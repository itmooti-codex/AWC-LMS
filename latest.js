!function(e) {
    function t(t) {
        for (var n, i, o = t[0], s = t[1], a = 0, u = []; a < o.length; a++)
            i = o[a],
            Object.prototype.hasOwnProperty.call(r, i) && r[i] && u.push(r[i][0]),
            r[i] = 0;
        for (n in s)
            Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n]);
        for (c && c(t); u.length; )
            u.shift()()
    }
    var n = {}
      , r = {
        0: 0
    };
    function i(t) {
        if (n[t])
            return n[t].exports;
        var r = n[t] = {
            i: t,
            l: !1,
            exports: {}
        };
        return e[t].call(r.exports, r, r.exports, i),
        r.l = !0,
        r.exports
    }
    i.e = function(e) {
        var t = []
          , n = r[e];
        if (0 !== n)
            if (n)
                t.push(n[2]);
            else {
                var o = new Promise((function(t, i) {
                    n = r[e] = [t, i]
                }
                ));
                t.push(n[2] = o);
                var s, a = document.createElement("script");
                a.charset = "utf-8",
                a.timeout = 120,
                i.nc && a.setAttribute("nonce", i.nc),
                a.src = function(e) {
                    return i.p + "" + ({
                        1: "clientSessionMgr",
                        2: "entitySchemaChunk",
                        3: "isomorix-bundle-dev",
                        4: "isomorix-router-props",
                        5: "prettier",
                        6: "vendors~entitySchemaChunk",
                        7: "vendors~prettier"
                    }[e] || e) + "." + {
                        1: "72c27b62",
                        2: "52ab8417",
                        3: "68682599",
                        4: "601f8624",
                        5: "468ffc1c",
                        6: "0ca31b42",
                        7: "94ebf63e"
                    }[e] + ".chunk.js"
                }(e),
                0 !== a.src.indexOf(window.location.origin + "/") && (a.crossOrigin = "anonymous");
                var c = new Error;
                s = function(t) {
                    a.onerror = a.onload = null,
                    clearTimeout(u);
                    var n = r[e];
                    if (0 !== n) {
                        if (n) {
                            var i = t && ("load" === t.type ? "missing" : t.type)
                              , o = t && t.target && t.target.src;
                            c.message = "Loading chunk " + e + " failed.\n(" + i + ": " + o + ")",
                            c.name = "ChunkLoadError",
                            c.type = i,
                            c.request = o,
                            n[1](c)
                        }
                        r[e] = void 0
                    }
                }
                ;
                var u = setTimeout((function() {
                    s({
                        type: "timeout",
                        target: a
                    })
                }
                ), 12e4);
                a.onerror = a.onload = s,
                document.head.appendChild(a)
            }
        return Promise.all(t)
    }
    ,
    i.m = e,
    i.c = n,
    i.d = function(e, t, n) {
        i.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: n
        })
    }
    ,
    i.r = function(e) {
        "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    i.t = function(e, t) {
        if (1 & t && (e = i(e)),
        8 & t)
            return e;
        if (4 & t && "object" === typeof e && e && e.__esModule)
            return e;
        var n = Object.create(null);
        if (i.r(n),
        Object.defineProperty(n, "default", {
            enumerable: !0,
            value: e
        }),
        2 & t && "string" != typeof e)
            for (var r in e)
                i.d(n, r, function(t) {
                    return e[t]
                }
                .bind(null, r));
        return n
    }
    ,
    i.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return i.d(t, "a", t),
        t
    }
    ,
    i.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    i.p = "https://static-au03.vitalstats.app/static/sdk/v1/1752353655/",
    i.oe = function(e) {
        throw console.error(e),
        e
    }
    ;
    var o = window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []
      , s = o.push.bind(o);
    o.push = t,
    o = o.slice();
    for (var a = 0; a < o.length; a++)
        t(o[a]);
    var c = s;
    i(i.s = 858)
}([function(e, t, n) {
    "use strict";
    n.d(t, "q", (function() {
        return r
    }
    )),
    n.d(t, "x", (function() {
        return o
    }
    )),
    n.d(t, "p", (function() {
        return s
    }
    )),
    n.d(t, "v", (function() {
        return a
    }
    )),
    n.d(t, "s", (function() {
        return c
    }
    )),
    n.d(t, "t", (function() {
        return u
    }
    )),
    n.d(t, "u", (function() {
        return l
    }
    )),
    n.d(t, "w", (function() {
        return d
    }
    )),
    n.d(t, "a", (function() {
        return h
    }
    )),
    n.d(t, "b", (function() {
        return f
    }
    )),
    n.d(t, "c", (function() {
        return p
    }
    )),
    n.d(t, "d", (function() {
        return g
    }
    )),
    n.d(t, "e", (function() {
        return m
    }
    )),
    n.d(t, "l", (function() {
        return y
    }
    )),
    n.d(t, "i", (function() {
        return v
    }
    )),
    n.d(t, "j", (function() {
        return b
    }
    )),
    n.d(t, "k", (function() {
        return _
    }
    )),
    n.d(t, "f", (function() {
        return S
    }
    )),
    n.d(t, "g", (function() {
        return O
    }
    )),
    n.d(t, "h", (function() {
        return T
    }
    )),
    n.d(t, "m", (function() {
        return I
    }
    )),
    n.d(t, "o", (function() {
        return x
    }
    )),
    n.d(t, "n", (function() {
        return w
    }
    )),
    n.d(t, "r", (function() {
        return M
    }
    )),
    n.d(t, "y", (function() {
        return A
    }
    )),
    n.d(t, "N", (function() {
        return E
    }
    )),
    n.d(t, "U", (function() {
        return C
    }
    )),
    n.d(t, "V", (function() {
        return N
    }
    )),
    n.d(t, "S", (function() {
        return R
    }
    )),
    n.d(t, "Z", (function() {
        return P
    }
    )),
    n.d(t, "P", (function() {
        return D
    }
    )),
    n.d(t, "O", (function() {
        return F
    }
    )),
    n.d(t, "Q", (function() {
        return k
    }
    )),
    n.d(t, "X", (function() {
        return j
    }
    )),
    n.d(t, "R", (function() {
        return L
    }
    )),
    n.d(t, "C", (function() {
        return V
    }
    )),
    n.d(t, "D", (function() {
        return U
    }
    )),
    n.d(t, "B", (function() {
        return q
    }
    )),
    n.d(t, "E", (function() {
        return Q
    }
    )),
    n.d(t, "T", (function() {
        return B
    }
    )),
    n.d(t, "W", (function() {
        return G
    }
    )),
    n.d(t, "L", (function() {
        return z
    }
    )),
    n.d(t, "K", (function() {
        return H
    }
    )),
    n.d(t, "Y", (function() {
        return K
    }
    )),
    n.d(t, "M", (function() {
        return Y
    }
    )),
    n.d(t, "I", (function() {
        return W
    }
    )),
    n.d(t, "F", (function() {
        return $
    }
    )),
    n.d(t, "G", (function() {
        return X
    }
    )),
    n.d(t, "H", (function() {
        return J
    }
    )),
    n.d(t, "J", (function() {
        return Z
    }
    )),
    n.d(t, "z", (function() {
        return ee
    }
    )),
    n.d(t, "A", (function() {
        return te
    }
    ));
    const r = "@__global-object-type__@"
      , i = "@__global-object-secondary-type__@"
      , o = "Store"
      , s = "Model"
      , a = "Record"
      , c = "Plugin"
      , u = "QUERY"
      , l = "QUERY_PAGINATION"
      , d = "QUERY_SELECT_FIELD"
      , h = "QUERY_ARGS"
      , f = "QUERY_ARG_GROUPED_QUERY"
      , p = "QUERY_ARG_KEY_VALUE"
      , g = "QUERY_ARG_VF_QUERY"
      , m = "QUERY_CALC"
      , y = m
      , v = "QUERY_HAVING"
      , b = "QUERY_HAVING_GROUP"
      , _ = "QUERY_CALC_METHOD"
      , S = "QUERY_CALC_CHILD_METHOD_ARG"
      , O = "QUERY_CALC_FIELD_ARG"
      , T = "QUERY_CALC_GROUP_ARG"
      , I = "QUERY_CALC_VALUE_ARG"
      , x = "QUERY_INCLUDE_VF"
      , w = "CHUNK_LOADER"
      , M = {
        ACTION_META: "ActionMeta",
        ARGS: h,
        ARG_GROUPED_QUERY: f,
        ARG_KEY_VALUE: p,
        ARG_VF_QUERY: g,
        CALC: m,
        CALC_SELECT: m,
        CALC_HAVING: v,
        CALC_HAVING_GROUP: b,
        CALC_CHILD_METHOD_ARG: S,
        CALC_FIELD_ARG: O,
        CALC_GROUP_ARG: T,
        CALC_METHOD: _,
        CALC_OPERATOR_ARG: "QUERY_CALC_OPERATOR_ARG",
        CALC_VALUE_ARG: I,
        CHUNK_LOADER: w,
        INCLUDE_VF: x,
        MODEL: s,
        MODEL_MUTATION: "ModelMutation",
        MAIN_ACTION_META: "MainActionMeta",
        MAIN_TRX: "MainTrx",
        MUTATION: "Mutation",
        MUTATION_CONTROLLER: "MutationController",
        PENDING_ACTION_META: "PendingActionMeta",
        PENDING_TRX: "PendingTrx",
        PLUGIN: c,
        PLUGIN_TYPES: "PluginTypes",
        QUERY: u,
        QUERY_PAGINATION: l,
        RECORD: a,
        RECORD_RESULT: "RecordResult",
        SELECT_FIELD: d,
        STATE_STORE: "StateStore",
        STORE: o,
        STORE_WRAPPER: "StoreWrapper",
        VIRTUAL_FIELD: "VirtualField"
    };
    function A(e, t) {
        return !!e && e[r] === t
    }
    const E = e => A(e, s)
      , C = e => A(e, a)
      , N = e => A(e, "RecordResult")
      , R = e => A(e, c)
      , P = e => A(e, "VirtualField")
      , D = e => {
        return "Mutation" === ((t = e) ? t[i] : void 0);
        var t
    }
      , F = e => A(e, "ModelMutation")
      , k = e => A(e, "MutationController")
      , j = e => A(e, o)
      , L = e => {
        if (!e || "object" !== typeof e)
            return e;
        const t = e[r];
        return !(!t || "RecordResult" === t) && (t === o ? !!e.mainDispatchId : !!e.__dispatchId)
    }
    ;
    function V(e) {
        if (!e || "object" !== typeof e)
            return e;
        const t = e[r];
        return t && "RecordResult" !== t ? t === o ? e.mainStore : e.getMainInstance() : e
    }
    function U(e) {
        if (!e)
            return e;
        for (let t in e)
            e[t] = V(e[t]);
        return e
    }
    function q(e) {
        if (e)
            return e[r]
    }
    const Q = (e, t) => !(!(e && "object" === typeof e && "string" === typeof e.type && A(e.meta, "ActionMeta") && e.payload && "object" === typeof e.payload) || t && e.meta[i] !== t)
      , B = e => A(e, u)
      , G = e => A(e, d)
      , z = e => A(e, x)
      , H = e => A(e, f)
      , K = e => A(e, g)
      , Y = e => A(e, p)
      , W = e => A(e, b)
      , $ = e => A(e, S)
      , X = e => A(e, O)
      , J = e => A(e, T)
      , Z = e => A(e, I)
      , ee = (e, t, n) => {
        n || (n = r);
        const i = {
            value: t,
            enumerable: !1,
            writable: !1,
            configurable: !1
        };
        Object.defineProperty(e, n, i),
        Object.defineProperty(e.prototype, n, i)
    }
      , te = (e, t) => ee(e, t, i)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "r", (function() {
        return r
    }
    )),
    n.d(t, "f", (function() {
        return i
    }
    )),
    n.d(t, "e", (function() {
        return o
    }
    )),
    n.d(t, "l", (function() {
        return s
    }
    )),
    n.d(t, "m", (function() {
        return a
    }
    )),
    n.d(t, "C", (function() {
        return c
    }
    )),
    n.d(t, "q", (function() {
        return u
    }
    )),
    n.d(t, "i", (function() {
        return l
    }
    )),
    n.d(t, "v", (function() {
        return d
    }
    )),
    n.d(t, "a", (function() {
        return h
    }
    )),
    n.d(t, "B", (function() {
        return f
    }
    )),
    n.d(t, "c", (function() {
        return p
    }
    )),
    n.d(t, "x", (function() {
        return g
    }
    )),
    n.d(t, "y", (function() {
        return m
    }
    )),
    n.d(t, "z", (function() {
        return y
    }
    )),
    n.d(t, "h", (function() {
        return v
    }
    )),
    n.d(t, "s", (function() {
        return b
    }
    )),
    n.d(t, "t", (function() {
        return _
    }
    )),
    n.d(t, "n", (function() {
        return S
    }
    )),
    n.d(t, "o", (function() {
        return O
    }
    )),
    n.d(t, "d", (function() {
        return T
    }
    )),
    n.d(t, "A", (function() {
        return I
    }
    )),
    n.d(t, "u", (function() {
        return x
    }
    )),
    n.d(t, "p", (function() {
        return w
    }
    )),
    n.d(t, "g", (function() {
        return M
    }
    )),
    n.d(t, "k", (function() {
        return A
    }
    )),
    n.d(t, "b", (function() {
        return E
    }
    )),
    n.d(t, "j", (function() {
        return C
    }
    )),
    n.d(t, "w", (function() {
        return N
    }
    ));
    const r = "next"
      , i = "complete"
      , o = "cancel"
      , s = "error"
      , a = "logicId"
      , c = "logicType"
      , u = "logicName"
      , l = "logicDescription"
      , d = "logicPriority"
      , h = "logicActionType"
      , f = "logicTrxSync"
      , p = "logicArgs"
      , g = "logicPure"
      , m = "logicRemoveReplace"
      , y = "logicRemoveReplaceInFlight"
      , v = "logicDefaults"
      , b = "logicOp"
      , _ = "logicOpsAliases"
      , S = "logicInit"
      , O = "logicInitArgs"
      , T = "logicCallInit"
      , I = "logicThisArg"
      , x = "logicPackageName"
      , w = "logicModuleName"
      , M = "logicContextType"
      , A = "logicEnumType"
      , E = "logicAlternates"
      , C = "logicDispatcher"
      , N = {
        NAME: u,
        TYPE: c,
        DESCRIPTION: l,
        PRIORITY: d,
        ID: a,
        ACTION_TYPE: h,
        TRX_SYNC: f,
        ARGS: p,
        PURE: g,
        REMOVE_REPLACE: m,
        REMOVE_REPLACE_IN_FLIGHT: y,
        DEFAULTS: v,
        INIT: S,
        INIT_ARGS: O,
        CALL_INIT: T,
        THIS_ARG: I,
        MODULE_NAME: w,
        PACKAGE_NAME: x,
        CONTEXT_TYPE: M,
        ENUM_TYPE: A,
        ALTERNATES: E,
        DISPATCHER: C,
        OP: b,
        OPS_ALIASES: _
    }
}
, , function(e, t, n) {
    "use strict";
    n.d(t, "f", (function() {
        return r
    }
    )),
    n.d(t, "c", (function() {
        return i
    }
    )),
    n.d(t, "d", (function() {
        return o
    }
    )),
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "b", (function() {
        return a
    }
    )),
    n.d(t, "g", (function() {
        return c
    }
    )),
    n.d(t, "h", (function() {
        return u
    }
    )),
    n.d(t, "e", (function() {
        return l
    }
    ));
    const r = "PRIMARY"
      , i = "||"
      , o = "||"
      , s = "||"
      , a = "Default Values"
      , c = 7650
      , u = 50
      , l = 1e4
}
, , , function(e, t, n) {
    "use strict";
    n.d(t, "k", (function() {
        return r
    }
    )),
    n.d(t, "h", (function() {
        return i
    }
    )),
    n.d(t, "f", (function() {
        return o
    }
    )),
    n.d(t, "j", (function() {
        return s
    }
    )),
    n.d(t, "i", (function() {
        return a
    }
    )),
    n.d(t, "g", (function() {
        return c
    }
    )),
    n.d(t, "d", (function() {
        return u
    }
    )),
    n.d(t, "a", (function() {
        return l
    }
    )),
    n.d(t, "l", (function() {
        return d
    }
    )),
    n.d(t, "e", (function() {
        return h
    }
    )),
    n.d(t, "b", (function() {
        return f
    }
    )),
    n.d(t, "m", (function() {
        return p
    }
    )),
    n.d(t, "c", (function() {
        return g
    }
    ));
    const r = "trxPrepare"
      , i = "trxOptimisticExecute"
      , o = "trxOptimisticCommit"
      , s = "trxOptimisticReducers"
      , a = "trxOptimisticNotify"
      , c = "trxOptimisticComplete"
      , u = "trxExecute"
      , l = "trxCommit"
      , d = "trxReducers"
      , h = "trxNotify"
      , f = "trxComplete"
      , p = "trxRollback"
      , g = "trxError"
}
, function(e, t, n) {
    "use strict";
    e.exports = n(849)
}
, , function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "d", (function() {
        return u
    }
    )),
    n.d(t, "e", (function() {
        return l
    }
    )),
    n.d(t, "c", (function() {
        return d
    }
    )),
    n.d(t, "g", (function() {
        return h
    }
    )),
    n.d(t, "k", (function() {
        return f
    }
    )),
    n.d(t, "j", (function() {
        return p
    }
    )),
    n.d(t, "a", (function() {
        return y
    }
    )),
    n.d(t, "h", (function() {
        return O
    }
    )),
    n.d(t, "f", (function() {
        return T
    }
    )),
    n.d(t, "i", (function() {
        return I
    }
    ));
    var r = n(17)
      , i = (n(866),
    n(865))
      , o = n(285);
    const s = Object.values(r.a)
      , a = e => ({
        kind: "Name",
        value: e
    })
      , c = e => {
        if ("undefined" === typeof e)
            return;
        if (e && e.kind && s.indexOf(e.kind) > -1)
            return e;
        let t;
        switch (typeof e) {
        case "boolean":
            t = r.a.BOOLEAN;
            break;
        case "string":
            t = r.a.STRING;
            break;
        case "number":
            t = Object(o.c)(e) ? r.a.FLOAT : r.a.INT;
            break;
        case "object":
            t = e ? Array.isArray(e) ? l(e) : Object(i.c)(e) ? e : h(e) : {
                kind: r.a.NULL
            };
            break;
        default:
            throw new Error("Unrecognized value type. Expected boolean, string, or integer. Got: " + typeof e)
        }
        return "string" === typeof t ? {
            block: !1,
            kind: t,
            value: e
        } : t
    }
      , u = e => ({
        kind: r.a.LIST_TYPE,
        type: "object" === typeof e ? e : p(e)
    })
      , l = (e, t) => {
        const n = [];
        for (let r of e)
            "object" === typeof r && r.kind && s.indexOf(r.kind) > -1 ? n.push(r) : t ? n.push(d(r)) : n.push(c(r));
        return {
            kind: r.a.LIST,
            values: n
        }
    }
      , d = e => ({
        kind: r.a.ENUM,
        value: e
    })
      , h = e => {
        let t;
        if (Array.isArray(e) && e[0].kind && e[0].kind === r.a.OBJECT_FIELD)
            t = e;
        else {
            let o;
            t = [];
            for (let s in e)
                o = e[s],
                o && o.kind && o.kind === r.a.OBJECT_FIELD ? t.push(o) : t.push((n = s,
                i = o,
                {
                    kind: r.a.OBJECT_FIELD,
                    name: a(n),
                    value: i && !Array.isArray(i) && "object" === typeof i && i.kind ? i : c(i)
                }))
        }
        var n, i;
        return {
            kind: r.a.OBJECT,
            fields: t
        }
    }
      , f = e => ({
        kind: r.a.VARIABLE,
        name: a(e)
    })
      , p = e => "object" === typeof e ? e : {
        kind: r.a.NAMED_TYPE,
        name: a(e)
    }
      , g = e => {
        const t = [];
        for (let o in e)
            t.push((n = o,
            i = e[o],
            {
                kind: r.a.ARGUMENT,
                name: a(n),
                value: c(i)
            }));
        var n, i;
        return t
    }
      , m = e => {
        let {args: t, name: n} = e;
        return {
            arguments: g(t),
            kind: r.a.DIRECTIVE,
            name: a(n)
        }
    }
      , y = e => ({
        kind: r.a.DOCUMENT,
        definitions: e
    })
      , v = e => {
        let {defaultValue: t, type: n, name: i} = e;
        return {
            defaultValue: c(t),
            kind: r.a.VARIABLE_DEFINITION,
            type: n,
            variable: f(i)
        }
    }
      , b = e => {
        let {name: t, value: n, variable: i} = e;
        const o = {
            kind: r.a.ARGUMENT,
            name: a(t)
        };
        return o.value = i ? f(i) : c(n),
        o
    }
      , _ = e => {
        let {alias: t, args: n, arguments: i, name: o, selections: s, selectionSet: c, directives: u} = e;
        const l = {
            alias: t ? {
                kind: r.a.NAME,
                value: t
            } : void 0,
            arguments: i || x(n, b, []),
            directives: x(u, m, []),
            kind: r.a.FIELD,
            name: a(o)
        };
        return c ? !c.kind && Array.isArray(c) ? l.selectionSet = {
            kind: r.a.SELECTION_SET,
            selections: c
        } : l.selectionSet = c : l.selectionSet = S(s),
        l
    }
      , S = e => "undefined" === typeof e ? void 0 : e.kind === r.a.SELECTION_SET ? e : {
        kind: r.a.SELECTION_SET,
        selections: x(e, _, [])
    }
      , O = e => {
        let {directives: t, name: n, selections: i, selectionSet: o, variables: s, variableDefinitions: c} = e;
        return {
            directives: x(t, m, []),
            kind: r.a.OPERATION_DEFINITION,
            name: a(n),
            operation: "query",
            selectionSet: o || S(i),
            variableDefinitions: c || x(s, v, [])
        }
    }
      , T = e => {
        let {directives: t, name: n, selections: i, selectionSet: o, variables: s, variableDefinitions: c} = e;
        return {
            directives: x(t, m, []),
            kind: r.a.OPERATION_DEFINITION,
            name: a(n),
            operation: "mutation",
            selectionSet: o || S(i),
            variableDefinitions: c || x(s, v, [])
        }
    }
      , I = e => {
        let {directives: t, name: n, selections: i, selectionSet: o, variables: s, variableDefinitions: c} = e;
        return {
            directives: x(t, m, []),
            kind: r.a.OPERATION_DEFINITION,
            name: a(n),
            operation: "subscription",
            selectionSet: o || S(i),
            variableDefinitions: c || x(s, v, [])
        }
    }
      , x = (e, t, n) => {
        if (!e)
            return n || void 0;
        const r = Array.isArray(n) ? n : [];
        let i;
        for (let o of e)
            i = t(o),
            i && r.push(i);
        return r.length > 0 ? r : void 0
    }
}
, function(e, t, n) {
    var r = n(39)
      , i = n(258).f
      , o = n(64)
      , s = n(94)
      , a = n(253)
      , c = n(454)
      , u = n(318);
    e.exports = function(e, t) {
        var n, l, d, h, f, p = e.target, g = e.global, m = e.stat;
        if (n = g ? r : m ? r[p] || a(p, {}) : (r[p] || {}).prototype)
            for (l in t) {
                if (h = t[l],
                d = e.noTargetGet ? (f = i(n, l)) && f.value : n[l],
                !u(g ? l : p + (m ? "." : "#") + l, e.forced) && void 0 !== d) {
                    if (typeof h === typeof d)
                        continue;
                    c(h, d)
                }
                (e.sham || d && d.sham) && o(h, "sham", !0),
                s(n, l, h, e)
            }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return u
    }
    )),
    n.d(t, "b", (function() {
        return f
    }
    ));
    var r = n(31)
      , i = (n(74),
    n(298))
      , o = n(52);
    const s = Object(r.a)(null);
    function a() {
        return s
    }
    let c;
    function u() {
        return c || (c = Object(i.a)(null, null))
    }
    const l = e => ({
        error: e.message,
        data: null,
        statusCode: 500,
        code: 500
    })
      , d = e => (e.code = 200,
    e.statusCode = 200,
    e)
      , h = Object(o.a)(e => e.ok ? e.json().then(d).catch(l) : e.json().then(t => (t.code = e.status,
    t.statusCode = e.status,
    t)).catch(t => (console.log("GOT ERROR PARSING JSON = ", t.message),
    {
        code: e.status,
        statusCode: e.status,
        ok: !1,
        data: null
    })))
      , f = () => h
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var r = Object.freeze({
        NAME: "Name",
        DOCUMENT: "Document",
        OPERATION_DEFINITION: "OperationDefinition",
        VARIABLE_DEFINITION: "VariableDefinition",
        SELECTION_SET: "SelectionSet",
        FIELD: "Field",
        ARGUMENT: "Argument",
        FRAGMENT_SPREAD: "FragmentSpread",
        INLINE_FRAGMENT: "InlineFragment",
        FRAGMENT_DEFINITION: "FragmentDefinition",
        VARIABLE: "Variable",
        INT: "IntValue",
        FLOAT: "FloatValue",
        STRING: "StringValue",
        BOOLEAN: "BooleanValue",
        NULL: "NullValue",
        ENUM: "EnumValue",
        LIST: "ListValue",
        OBJECT: "ObjectValue",
        OBJECT_FIELD: "ObjectField",
        DIRECTIVE: "Directive",
        NAMED_TYPE: "NamedType",
        LIST_TYPE: "ListType",
        NON_NULL_TYPE: "NonNullType",
        SCHEMA_DEFINITION: "SchemaDefinition",
        OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
        SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
        OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
        FIELD_DEFINITION: "FieldDefinition",
        INPUT_VALUE_DEFINITION: "InputValueDefinition",
        INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
        UNION_TYPE_DEFINITION: "UnionTypeDefinition",
        ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
        ENUM_VALUE_DEFINITION: "EnumValueDefinition",
        INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
        DIRECTIVE_DEFINITION: "DirectiveDefinition",
        SCHEMA_EXTENSION: "SchemaExtension",
        SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
        OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
        INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
        UNION_TYPE_EXTENSION: "UnionTypeExtension",
        ENUM_TYPE_EXTENSION: "EnumTypeExtension",
        INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
    })
}
, , function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = function(e, t) {
        return (r = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(e, t) {
            e.__proto__ = t
        }
        || function(e, t) {
            for (var n in t)
                t.hasOwnProperty(n) && (e[n] = t[n])
        }
        )(e, t)
    };
    function i(e, t) {
        function n() {
            this.constructor = e
        }
        r(e, t),
        e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
        new n)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "h", (function() {
        return r
    }
    )),
    n.d(t, "s", (function() {
        return i
    }
    )),
    n.d(t, "g", (function() {
        return o
    }
    )),
    n.d(t, "f", (function() {
        return s
    }
    )),
    n.d(t, "j", (function() {
        return a
    }
    )),
    n.d(t, "e", (function() {
        return c
    }
    )),
    n.d(t, "m", (function() {
        return u
    }
    )),
    n.d(t, "a", (function() {
        return l
    }
    )),
    n.d(t, "r", (function() {
        return d
    }
    )),
    n.d(t, "b", (function() {
        return h
    }
    )),
    n.d(t, "n", (function() {
        return f
    }
    )),
    n.d(t, "o", (function() {
        return p
    }
    )),
    n.d(t, "p", (function() {
        return g
    }
    )),
    n.d(t, "d", (function() {
        return m
    }
    )),
    n.d(t, "k", (function() {
        return y
    }
    )),
    n.d(t, "c", (function() {
        return v
    }
    )),
    n.d(t, "q", (function() {
        return b
    }
    )),
    n.d(t, "l", (function() {
        return _
    }
    )),
    n.d(t, "i", (function() {
        return S
    }
    ));
    const r = "logicId"
      , i = "logicType"
      , o = "logicEnumType"
      , s = "logicDispatcher"
      , a = "logicName"
      , c = "logicDescription"
      , u = "logicPriority"
      , l = "logicActionType"
      , d = "logicTrxSync"
      , h = "logicArgs"
      , f = "logicPure"
      , p = "logicRemoveReplace"
      , g = "logicRemoveReplaceInFlight"
      , m = "logicDefaults"
      , y = "logicOp"
      , v = "logicCallInit"
      , b = "logicThisArg"
      , _ = "logicPackageName"
      , S = "logicModuleName"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = "@isomorix/core-actions/DIRECT_QUERY"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = n(12).a
}
, function(e, t, n) {
    var r = n(51);
    e.exports = function(e) {
        if (!r(e))
            throw TypeError(String(e) + " is not an object");
        return e
    }
}
, , function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(42);
    function i(e, t) {
        return Object(r.a)(t || e, e)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(184);
    function i(e) {
        return (i = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    function o(e) {
        return s(e, [])
    }
    function s(e, t) {
        switch (i(e)) {
        case "string":
            return JSON.stringify(e);
        case "function":
            return e.name ? "[function ".concat(e.name, "]") : "[function]";
        case "object":
            return null === e ? "null" : function(e, t) {
                if (-1 !== t.indexOf(e))
                    return "[Circular]";
                var n = [].concat(t, [e])
                  , i = function(e) {
                    var t = e[String(r.a)];
                    if ("function" === typeof t)
                        return t;
                    if ("function" === typeof e.inspect)
                        return e.inspect
                }(e);
                if (void 0 !== i) {
                    var o = i.call(e);
                    if (o !== e)
                        return "string" === typeof o ? o : s(o, n)
                } else if (Array.isArray(e))
                    return function(e, t) {
                        if (0 === e.length)
                            return "[]";
                        if (t.length > 2)
                            return "[Array]";
                        for (var n = Math.min(10, e.length), r = e.length - n, i = [], o = 0; o < n; ++o)
                            i.push(s(e[o], t));
                        1 === r ? i.push("... 1 more item") : r > 1 && i.push("... ".concat(r, " more items"));
                        return "[" + i.join(", ") + "]"
                    }(e, n);
                return function(e, t) {
                    var n = Object.keys(e);
                    if (0 === n.length)
                        return "{}";
                    if (t.length > 2)
                        return "[" + function(e) {
                            var t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
                            if ("Object" === t && "function" === typeof e.constructor) {
                                var n = e.constructor.name;
                                if ("string" === typeof n && "" !== n)
                                    return n
                            }
                            return t
                        }(e) + "]";
                    return "{ " + n.map((function(n) {
                        return n + ": " + s(e[n], t)
                    }
                    )).join(", ") + " }"
                }(e, n)
            }(e, t);
        default:
            return String(e)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return l
    }
    ));
    var r = n(14)
      , i = n(180)
      , o = n(157)
      , s = n(38)
      , a = n(132)
      , c = n(66)
      , u = n(105)
      , l = function(e) {
        function t(n, r, i) {
            var s = e.call(this) || this;
            switch (s.syncErrorValue = null,
            s.syncErrorThrown = !1,
            s.syncErrorThrowable = !1,
            s.isStopped = !1,
            arguments.length) {
            case 0:
                s.destination = o.a;
                break;
            case 1:
                if (!n) {
                    s.destination = o.a;
                    break
                }
                if ("object" === typeof n) {
                    n instanceof t ? (s.syncErrorThrowable = n.syncErrorThrowable,
                    s.destination = n,
                    n.add(s)) : (s.syncErrorThrowable = !0,
                    s.destination = new d(s,n));
                    break
                }
            default:
                s.syncErrorThrowable = !0,
                s.destination = new d(s,n,r,i)
            }
            return s
        }
        return r.a(t, e),
        t.prototype[a.a] = function() {
            return this
        }
        ,
        t.create = function(e, n, r) {
            var i = new t(e,n,r);
            return i.syncErrorThrowable = !1,
            i
        }
        ,
        t.prototype.next = function(e) {
            this.isStopped || this._next(e)
        }
        ,
        t.prototype.error = function(e) {
            this.isStopped || (this.isStopped = !0,
            this._error(e))
        }
        ,
        t.prototype.complete = function() {
            this.isStopped || (this.isStopped = !0,
            this._complete())
        }
        ,
        t.prototype.unsubscribe = function() {
            this.closed || (this.isStopped = !0,
            e.prototype.unsubscribe.call(this))
        }
        ,
        t.prototype._next = function(e) {
            this.destination.next(e)
        }
        ,
        t.prototype._error = function(e) {
            this.destination.error(e),
            this.unsubscribe()
        }
        ,
        t.prototype._complete = function() {
            this.destination.complete(),
            this.unsubscribe()
        }
        ,
        t.prototype._unsubscribeAndRecycle = function() {
            var e = this._parentOrParents;
            return this._parentOrParents = null,
            this.unsubscribe(),
            this.closed = !1,
            this.isStopped = !1,
            this._parentOrParents = e,
            this
        }
        ,
        t
    }(s.a)
      , d = function(e) {
        function t(t, n, r, s) {
            var a, c = e.call(this) || this;
            c._parentSubscriber = t;
            var u = c;
            return Object(i.a)(n) ? a = n : n && (a = n.next,
            r = n.error,
            s = n.complete,
            n !== o.a && (u = Object.create(n),
            Object(i.a)(u.unsubscribe) && c.add(u.unsubscribe.bind(u)),
            u.unsubscribe = c.unsubscribe.bind(c))),
            c._context = u,
            c._next = a,
            c._error = r,
            c._complete = s,
            c
        }
        return r.a(t, e),
        t.prototype.next = function(e) {
            if (!this.isStopped && this._next) {
                var t = this._parentSubscriber;
                c.a.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? this.__tryOrSetError(t, this._next, e) && this.unsubscribe() : this.__tryOrUnsub(this._next, e)
            }
        }
        ,
        t.prototype.error = function(e) {
            if (!this.isStopped) {
                var t = this._parentSubscriber
                  , n = c.a.useDeprecatedSynchronousErrorHandling;
                if (this._error)
                    n && t.syncErrorThrowable ? (this.__tryOrSetError(t, this._error, e),
                    this.unsubscribe()) : (this.__tryOrUnsub(this._error, e),
                    this.unsubscribe());
                else if (t.syncErrorThrowable)
                    n ? (t.syncErrorValue = e,
                    t.syncErrorThrown = !0) : Object(u.a)(e),
                    this.unsubscribe();
                else {
                    if (this.unsubscribe(),
                    n)
                        throw e;
                    Object(u.a)(e)
                }
            }
        }
        ,
        t.prototype.complete = function() {
            var e = this;
            if (!this.isStopped) {
                var t = this._parentSubscriber;
                if (this._complete) {
                    var n = function() {
                        return e._complete.call(e._context)
                    };
                    c.a.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, n),
                    this.unsubscribe()) : (this.__tryOrUnsub(n),
                    this.unsubscribe())
                } else
                    this.unsubscribe()
            }
        }
        ,
        t.prototype.__tryOrUnsub = function(e, t) {
            try {
                e.call(this._context, t)
            } catch (n) {
                if (this.unsubscribe(),
                c.a.useDeprecatedSynchronousErrorHandling)
                    throw n;
                Object(u.a)(n)
            }
        }
        ,
        t.prototype.__tryOrSetError = function(e, t, n) {
            if (!c.a.useDeprecatedSynchronousErrorHandling)
                throw new Error("bad call");
            try {
                t.call(this._context, n)
            } catch (r) {
                return c.a.useDeprecatedSynchronousErrorHandling ? (e.syncErrorValue = r,
                e.syncErrorThrown = !0,
                !0) : (Object(u.a)(r),
                !0)
            }
            return !1
        }
        ,
        t.prototype._unsubscribe = function() {
            var e = this._parentSubscriber;
            this._context = null,
            this._parentSubscriber = null,
            e.unsubscribe()
        }
        ,
        t
    }(l)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "f", (function() {
        return r
    }
    )),
    n.d(t, "g", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "e", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return c
    }
    )),
    n.d(t, "d", (function() {
        return u
    }
    ));
    const r = "actionPrepare"
      , i = "actionTransform"
      , o = "actionCommit"
      , s = "actionFinalize"
      , a = "actionComplete"
      , c = "actionCancel"
      , u = "actionError"
}
, function(e, t) {
    e.exports = !1
}
, , function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return l
    }
    ));
    var r = n(22);
    var i = n(132)
      , o = n(157);
    var s = n(90)
      , a = n(153);
    function c(e) {
        return 0 === e.length ? a.a : 1 === e.length ? e[0] : function(t) {
            return e.reduce((function(e, t) {
                return t(e)
            }
            ), t)
        }
    }
    var u = n(66)
      , l = function() {
        function e(e) {
            this._isScalar = !1,
            e && (this._subscribe = e)
        }
        return e.prototype.lift = function(t) {
            var n = new e;
            return n.source = this,
            n.operator = t,
            n
        }
        ,
        e.prototype.subscribe = function(e, t, n) {
            var s = this.operator
              , a = function(e, t, n) {
                if (e) {
                    if (e instanceof r.a)
                        return e;
                    if (e[i.a])
                        return e[i.a]()
                }
                return e || t || n ? new r.a(e,t,n) : new r.a(o.a)
            }(e, t, n);
            if (s ? a.add(s.call(a, this.source)) : a.add(this.source || u.a.useDeprecatedSynchronousErrorHandling && !a.syncErrorThrowable ? this._subscribe(a) : this._trySubscribe(a)),
            u.a.useDeprecatedSynchronousErrorHandling && a.syncErrorThrowable && (a.syncErrorThrowable = !1,
            a.syncErrorThrown))
                throw a.syncErrorValue;
            return a
        }
        ,
        e.prototype._trySubscribe = function(e) {
            try {
                return this._subscribe(e)
            } catch (t) {
                u.a.useDeprecatedSynchronousErrorHandling && (e.syncErrorThrown = !0,
                e.syncErrorValue = t),
                !function(e) {
                    for (; e; ) {
                        var t = e
                          , n = t.closed
                          , i = t.destination
                          , o = t.isStopped;
                        if (n || o)
                            return !1;
                        e = i && i instanceof r.a ? i : null
                    }
                    return !0
                }(e) ? console.warn(t) : e.error(t)
            }
        }
        ,
        e.prototype.forEach = function(e, t) {
            var n = this;
            return new (t = d(t))((function(t, r) {
                var i;
                i = n.subscribe((function(t) {
                    try {
                        e(t)
                    } catch (n) {
                        r(n),
                        i && i.unsubscribe()
                    }
                }
                ), r, t)
            }
            ))
        }
        ,
        e.prototype._subscribe = function(e) {
            var t = this.source;
            return t && t.subscribe(e)
        }
        ,
        e.prototype[s.a] = function() {
            return this
        }
        ,
        e.prototype.pipe = function() {
            for (var e = [], t = 0; t < arguments.length; t++)
                e[t] = arguments[t];
            return 0 === e.length ? this : c(e)(this)
        }
        ,
        e.prototype.toPromise = function(e) {
            var t = this;
            return new (e = d(e))((function(e, n) {
                var r;
                t.subscribe((function(e) {
                    return r = e
                }
                ), (function(e) {
                    return n(e)
                }
                ), (function() {
                    return e(r)
                }
                ))
            }
            ))
        }
        ,
        e.create = function(t) {
            return new e(t)
        }
        ,
        e
    }();
    function d(e) {
        if (e || (e = u.a.Promise || Promise),
        !e)
            throw new Error("no Promise impl found");
        return e
    }
}
, function(e, t, n) {
    var r = n(18)
      , i = n(262)
      , o = n(65)
      , s = n(44)
      , a = n(172)
      , c = n(329)
      , u = function(e, t) {
        this.stopped = e,
        this.result = t
    };
    (e.exports = function(e, t, n, l, d) {
        var h, f, p, g, m, y, v, b = s(t, n, l ? 2 : 1);
        if (d)
            h = e;
        else {
            if ("function" != typeof (f = a(e)))
                throw TypeError("Target is not iterable");
            if (i(f)) {
                for (p = 0,
                g = o(e.length); g > p; p++)
                    if ((m = l ? b(r(v = e[p])[0], v[1]) : b(e[p])) && m instanceof u)
                        return m;
                return new u(!1)
            }
            h = f.call(e)
        }
        for (y = h.next; !(v = y.call(h)).done; )
            if ("object" == typeof (m = c(h, b, v.value, l)) && m && m instanceof u)
                return m;
        return new u(!1)
    }
    ).stop = function(e) {
        return new u(!0,e)
    }
}
, function(e, t, n) {
    e.exports = n(856)()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "f", (function() {
        return i
    }
    )),
    n.d(t, "h", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return s
    }
    )),
    n.d(t, "e", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return c
    }
    )),
    n.d(t, "d", (function() {
        return u
    }
    )),
    n.d(t, "g", (function() {
        return l
    }
    ));
    const r = "created"
      , i = "pkChange"
      , o = "updated"
      , s = "deleted"
      , a = "optimistic"
      , c = "commit"
      , u = "none"
      , l = "stale"
}
, function(e, t, n) {
    "use strict";
    function r(e, t) {
        if (!Boolean(e))
            throw new Error(t)
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(101)
      , i = n(222)
      , o = n(151);
    function s() {
        for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t];
        var n = e[e.length - 1];
        return Object(r.a)(n) ? (e.pop(),
        Object(o.a)(e, n)) : Object(i.a)(e)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return d
    }
    )),
    n.d(t, "b", (function() {
        return h
    }
    )),
    n.d(t, "e", (function() {
        return f
    }
    )),
    n.d(t, "d", (function() {
        return p
    }
    )),
    n.d(t, "c", (function() {
        return g
    }
    ));
    var r = n(134)
      , i = n(23)
      , o = n(6)
      , s = n(179)
      , a = n(131)
      , c = n(41)
      , u = n(100)
      , l = n(46);
    const d = {
        CREATE_PENDING_STORE: u.a,
        TRX_ACTION_STANDARD: u.d,
        TRX_ACTION_COMMIT_ONLY: u.c,
        MUTATION: u.b
    }
      , h = {
        ACTION_PREPARE: i.f,
        ACTION_TRANSFORM: i.g,
        ACTION_COMMIT: i.b,
        ACTION_FINALIZE: i.e,
        ACTION_COMPLETE: i.c,
        ACTION_CANCEL: i.a,
        ACTION_ERROR: i.d
    }
      , f = {
        TRX_PREPARE: o.k,
        TRX_OPTIMISTIC_EXECUTE: o.h,
        TRX_OPTIMISTIC_COMMIT: o.f,
        TRX_OPTIMISTIC_REDUCERS: o.j,
        TRX_OPTIMISTIC_NOTIFY: o.i,
        TRX_OPTIMISTIC_COMPLETE: o.g,
        TRX_EXECUTE: o.d,
        TRX_COMMIT: o.a,
        TRX_REDUCERS: o.l,
        TRX_NOTIFY: o.e,
        TRX_COMPLETE: o.b,
        TRX_ROLLBACK: o.m,
        TRX_ERROR: o.c
    }
      , p = (r.b,
    r.a,
    s.a,
    s.b,
    {
        CREATE: a.a,
        UPDATE: a.c,
        DELETE: a.b
    })
      , g = (l.d,
    l.e,
    l.a,
    l.b,
    l.c,
    c.c,
    c.b,
    c.e,
    c.f,
    c.d,
    c.a,
    c.j,
    c.g,
    c.h,
    c.i,
    500)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = function(e) {
        let t = []
          , n = []
          , r = []
          , i = 0
          , o = 0
          , s = 0;
        class a {
            static destroyPool() {
                t = void 0,
                n = void 0
            }
            checkoutMap() {
                return i ? (i--,
                t.pop()) : new Map
            }
            checkinMap(e) {
                e.clear(),
                t[i] = e,
                i++
            }
            cloneMap(e) {
                const t = this.checkoutMap();
                for (let[n,r] of e)
                    t.set(n, r);
                return t
            }
            checkoutSet() {
                return o ? (o--,
                n.pop()) : new Set
            }
            checkinSet(e) {
                e.clear(),
                n[o] = e,
                o++
            }
            cloneSet(e) {
                const t = this.checkoutSet();
                for (let n of e)
                    t.add(n);
                return t
            }
            checkoutArray() {
                return s ? (s--,
                r.pop()) : []
            }
            checkinArray(e) {
                0 !== e.length && e.splice(0),
                r.push(e),
                s++
            }
            cloneArray(e) {
                const t = this.checkoutArray();
                for (let n = 0, r = e.length; n < r; n++)
                    t[n] = e[n];
                return t
            }
        }
        if (e)
            return a;
        {
            const e = new a;
            return e.destroyPool = a.destroyPool,
            e
        }
    }()
}
, function(e, t) {
    e.exports = function(e) {
        if ("function" != typeof e)
            throw TypeError(String(e) + " is not a function");
        return e
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return s
    }
    ));
    var r = n(67)
      , i = function() {
        function e(e, t, n) {
            this.start = e.start,
            this.end = t.end,
            this.startToken = e,
            this.endToken = t,
            this.source = n
        }
        return e.prototype.toJSON = function() {
            return {
                start: this.start,
                end: this.end
            }
        }
        ,
        e
    }();
    Object(r.a)(i);
    var o = function() {
        function e(e, t, n, r, i, o, s) {
            this.kind = e,
            this.start = t,
            this.end = n,
            this.line = r,
            this.column = i,
            this.value = s,
            this.prev = o,
            this.next = null
        }
        return e.prototype.toJSON = function() {
            return {
                kind: this.kind,
                value: this.value,
                line: this.line,
                column: this.column
            }
        }
        ,
        e
    }();
    function s(e) {
        return null != e && "string" === typeof e.kind
    }
    Object(r.a)(o)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return b
    }
    ));
    var r = n(103)
      , i = n(61);
    function o(e, t) {
        for (var n, r = /\r\n|[\n\r]/g, i = 1, o = t + 1; (n = r.exec(e.body)) && n.index < t; )
            i += 1,
            o = t + 1 - (n.index + n[0].length);
        return {
            line: i,
            column: o
        }
    }
    function s(e) {
        return a(e.source, o(e.source, e.start))
    }
    function a(e, t) {
        var n = e.locationOffset.column - 1
          , r = u(n) + e.body
          , i = t.line - 1
          , o = e.locationOffset.line - 1
          , s = t.line + o
          , a = 1 === t.line ? n : 0
          , l = t.column + a
          , d = "".concat(e.name, ":").concat(s, ":").concat(l, "\n")
          , h = r.split(/\r\n|[\n\r]/g)
          , f = h[i];
        if (f.length > 120) {
            for (var p = Math.floor(l / 80), g = l % 80, m = [], y = 0; y < f.length; y += 80)
                m.push(f.slice(y, y + 80));
            return d + c([["".concat(s), m[0]]].concat(m.slice(1, p + 1).map((function(e) {
                return ["", e]
            }
            )), [[" ", u(g - 1) + "^"], ["", m[p + 1]]]))
        }
        return d + c([["".concat(s - 1), h[i - 1]], ["".concat(s), f], ["", u(l - 1) + "^"], ["".concat(s + 1), h[i + 1]]])
    }
    function c(e) {
        var t = e.filter((function(e) {
            e[0];
            return void 0 !== e[1]
        }
        ))
          , n = Math.max.apply(Math, t.map((function(e) {
            return e[0].length
        }
        )));
        return t.map((function(e) {
            var t, r = e[0], i = e[1];
            return u(n - (t = r).length) + t + (i ? " | " + i : " |")
        }
        )).join("\n")
    }
    function u(e) {
        return Array(e + 1).join(" ")
    }
    function l(e) {
        return (l = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    function d(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1,
            r.configurable = !0,
            "value"in r && (r.writable = !0),
            Object.defineProperty(e, r.key, r)
        }
    }
    function h(e, t) {
        return !t || "object" !== l(t) && "function" !== typeof t ? f(e) : t
    }
    function f(e) {
        if (void 0 === e)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }
    function p(e) {
        var t = "function" === typeof Map ? new Map : void 0;
        return (p = function(e) {
            if (null === e || (n = e,
            -1 === Function.toString.call(n).indexOf("[native code]")))
                return e;
            var n;
            if ("function" !== typeof e)
                throw new TypeError("Super expression must either be null or a function");
            if ("undefined" !== typeof t) {
                if (t.has(e))
                    return t.get(e);
                t.set(e, r)
            }
            function r() {
                return g(e, arguments, v(this).constructor)
            }
            return r.prototype = Object.create(e.prototype, {
                constructor: {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }),
            y(r, e)
        }
        )(e)
    }
    function g(e, t, n) {
        return (g = m() ? Reflect.construct : function(e, t, n) {
            var r = [null];
            r.push.apply(r, t);
            var i = new (Function.bind.apply(e, r));
            return n && y(i, n.prototype),
            i
        }
        ).apply(null, arguments)
    }
    function m() {
        if ("undefined" === typeof Reflect || !Reflect.construct)
            return !1;
        if (Reflect.construct.sham)
            return !1;
        if ("function" === typeof Proxy)
            return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
            ))),
            !0
        } catch (e) {
            return !1
        }
    }
    function y(e, t) {
        return (y = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t,
            e
        }
        )(e, t)
    }
    function v(e) {
        return (v = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }
        )(e)
    }
    var b = function(e) {
        !function(e, t) {
            if ("function" !== typeof t && null !== t)
                throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }),
            t && y(e, t)
        }(l, e);
        var t, n, c, u = function(e) {
            var t = m();
            return function() {
                var n, r = v(e);
                if (t) {
                    var i = v(this).constructor;
                    n = Reflect.construct(r, arguments, i)
                } else
                    n = r.apply(this, arguments);
                return h(this, n)
            }
        }(l);
        function l(e, t, n, i, s, a, c) {
            var d, p, g, m, y;
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, l),
            y = u.call(this, e);
            var v, b = Array.isArray(t) ? 0 !== t.length ? t : void 0 : t ? [t] : void 0, _ = n;
            !_ && b && (_ = null === (v = b[0].loc) || void 0 === v ? void 0 : v.source);
            var S, O = i;
            !O && b && (O = b.reduce((function(e, t) {
                return t.loc && e.push(t.loc.start),
                e
            }
            ), [])),
            O && 0 === O.length && (O = void 0),
            i && n ? S = i.map((function(e) {
                return o(n, e)
            }
            )) : b && (S = b.reduce((function(e, t) {
                return t.loc && e.push(o(t.loc.source, t.loc.start)),
                e
            }
            ), []));
            var T = c;
            if (null == T && null != a) {
                var I = a.extensions;
                Object(r.a)(I) && (T = I)
            }
            return Object.defineProperties(f(y), {
                name: {
                    value: "GraphQLError"
                },
                message: {
                    value: e,
                    enumerable: !0,
                    writable: !0
                },
                locations: {
                    value: null !== (d = S) && void 0 !== d ? d : void 0,
                    enumerable: null != S
                },
                path: {
                    value: null !== s && void 0 !== s ? s : void 0,
                    enumerable: null != s
                },
                nodes: {
                    value: null !== b && void 0 !== b ? b : void 0
                },
                source: {
                    value: null !== (p = _) && void 0 !== p ? p : void 0
                },
                positions: {
                    value: null !== (g = O) && void 0 !== g ? g : void 0
                },
                originalError: {
                    value: a
                },
                extensions: {
                    value: null !== (m = T) && void 0 !== m ? m : void 0,
                    enumerable: null != T
                }
            }),
            null !== a && void 0 !== a && a.stack ? (Object.defineProperty(f(y), "stack", {
                value: a.stack,
                writable: !0,
                configurable: !0
            }),
            h(y)) : (Error.captureStackTrace ? Error.captureStackTrace(f(y), l) : Object.defineProperty(f(y), "stack", {
                value: Error().stack,
                writable: !0,
                configurable: !0
            }),
            y)
        }
        return t = l,
        (n = [{
            key: "toString",
            value: function() {
                return function(e) {
                    var t = e.message;
                    if (e.nodes)
                        for (var n = 0, r = e.nodes; n < r.length; n++) {
                            var i = r[n];
                            i.loc && (t += "\n\n" + s(i.loc))
                        }
                    else if (e.source && e.locations)
                        for (var o = 0, c = e.locations; o < c.length; o++) {
                            var u = c[o];
                            t += "\n\n" + a(e.source, u)
                        }
                    return t
                }(this)
            }
        }, {
            key: i.a,
            get: function() {
                return "Object"
            }
        }]) && d(t.prototype, n),
        c && d(t, c),
        l
    }(p(Error))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "f", (function() {
        return T
    }
    )),
    n.d(t, "d", (function() {
        return I
    }
    )),
    n.d(t, "c", (function() {
        return x
    }
    )),
    n.d(t, "b", (function() {
        return w
    }
    )),
    n.d(t, "e", (function() {
        return g
    }
    )),
    n.d(t, "a", (function() {
        return m
    }
    ));
    var r = n(1010)
      , i = n(383)
      , o = n.n(i)
      , s = n(186)
      , a = n.n(s);
    const {stringify: c, parse: u} = a.a
      , l = {
        arrayFormat: "index"
    }
      , d = {
        arrayFormat: "index",
        parseNumbers: !0,
        parseBooleans: !0
    }
      , h = e => {
        for (let t of e)
            if (t && "object" === typeof t)
                return !0;
        return !1
    }
      , f = {
        string: !0,
        boolean: !0,
        number: !0,
        bigint: !0,
        undefined: !0,
        symbol: !1,
        function: !1,
        object: !0
    };
    function p(e, t) {
        if (e) {
            let n, r;
            t || (t = "index");
            for (let i in e)
                if (r = typeof e[i],
                "object" !== r) {
                    if (!f[r])
                        throw new Error('Unable to encode search param "'.concat(i, '" because it is a ').concat(r))
                } else
                    null !== e[i] && ("json" === t || !Array.isArray(e[i]) || h(e[i]) ? (n || (n = {
                        ...e
                    }),
                    n[i] = JSON.stringify(e[i])) : "csv" === t && (n || (n = {
                        ...e
                    }),
                    n[i] = e[i].join(",")));
            n && (e = n)
        }
        return c(e, l)
    }
    function g(e) {
        const t = u(e, d);
        if (t) {
            let e, i;
            for (let o in t)
                if ("string" === typeof (e = t[o]) && (i = e.charAt(0),
                "{" === i && "}" === e.charAt(e.length - 1) || "[" === i && "]" === e.charAt(e.length - 1)))
                    try {
                        t[o] = Object(r.a)(e)
                    } catch (n) {}
        }
        return t
    }
    class m extends o.a {
        constructor(e, t) {
            if (t) {
                const n = typeof t;
                "string" === n || "object" === n ? super(e, t, g) : super(e, g)
            } else
                super(e, g);
            this._updateSearch()
        }
        set(e, t) {
            switch (e) {
            case "search":
            case "searchParams":
            case "query":
                if (t)
                    if ("object" === typeof t) {
                        let e = !1;
                        for (let n in t)
                            if ("undefined" === typeof t[n]) {
                                t = p(t),
                                this.query = g(t),
                                this._updateSearch(),
                                e = !0;
                                break
                            }
                        e || (this.query = t,
                        this._updateSearch())
                    } else
                        this.query = g(t),
                        this._updateSearch();
                else
                    this.query = {},
                    this.search = "";
                break;
            default:
                super.set(e, t)
            }
            return this
        }
        _updateSearch() {
            const e = p(this.query);
            this.search = e ? "?".concat(e) : e
        }
        toString() {
            return super.toString(p)
        }
        get searchParams() {
            return this.query
        }
    }
    m.qs = a.a,
    m.parseSearch = g,
    m.stringifySearch = p;
    var y = n(234)
      , v = n(377);
    const b = /[_-]/g
      , _ = /\s/
      , S = /\//g
      , O = /\.\w{2,4}$/;
    function T(e) {
        const t = e.indexOf("/:");
        if (t > -1 && (e = e.substring(0, t)),
        "" === (e = Object(y.d)(Object(y.c)(e))))
            return "";
        if (e = e.replace(O, "").replace(b, " ").replace(S, " - "),
        b.lastIndex = 0,
        S.lastIndex = 0,
        _.test(e)) {
            const t = e.split(" ");
            e = Object(v.e)(t[0], !0);
            for (let n = 1; n < t.length; n++)
                t[n] && (e += " ".concat(Object(v.e)(t[n], !0)))
        } else
            e = Object(v.e)(e, !0);
        return e
    }
    function I(e, t) {
        return new m(e ? "string" === typeof e ? e : x(e) : void 0,t)
    }
    function x(e, t, n) {
        let r = e;
        if (r ? "object" === typeof e && (({pathname: r, search: t, hash: n} = e),
        "undefined" === typeof t && (t = e.searchParams),
        r || (r = "/")) : r = "/",
        !n && r.indexOf("#") > -1) {
            const e = r.split("#");
            r = e[0],
            n = e[1]
        }
        if (t) {
            if (r.indexOf("?") > -1) {
                const e = r.split("?");
                r = e[0];
                let n = e[1];
                if (n) {
                    "string" === typeof t && (t = g(t)),
                    n = g(n);
                    for (let e in t)
                        n[e] = t[e];
                    t = n
                }
            }
            "string" !== typeof t && (t = p(t)),
            "" === t ? t = "?" : "?" !== t && (t = "?" === t.charAt(0) ? t : "?".concat(t)),
            r += t
        }
        return n && "string" === typeof n && "#" !== n && (r += "#" === n.charAt(0) ? n : "#".concat(n)),
        r
    }
    function w(e, t, n, r) {
        let i, o = e.protocol;
        return e.slashes && (o += "//"),
        o += e.hostname,
        e.port && (o += ":".concat(e.port)),
        i = t ? "string" === typeof t || t.pathname ? x(t, n, r) : x({
            ...t,
            pathname: e.pathname
        }) : x(e),
        "/" !== i && (o += Object(y.a)(i)),
        o
    }
    a.a
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var r = n(133)
      , i = n(152)
      , o = n(180)
      , s = function() {
        function e(e) {
            return Error.call(this),
            this.message = e ? e.length + " errors occurred during unsubscription:\n" + e.map((function(e, t) {
                return t + 1 + ") " + e.toString()
            }
            )).join("\n  ") : "",
            this.name = "UnsubscriptionError",
            this.errors = e,
            this
        }
        return e.prototype = Object.create(Error.prototype),
        e
    }()
      , a = function() {
        function e(e) {
            this.closed = !1,
            this._parentOrParents = null,
            this._subscriptions = null,
            e && (this._ctorUnsubscribe = !0,
            this._unsubscribe = e)
        }
        var t;
        return e.prototype.unsubscribe = function() {
            var t;
            if (!this.closed) {
                var n = this._parentOrParents
                  , a = this._ctorUnsubscribe
                  , u = this._unsubscribe
                  , l = this._subscriptions;
                if (this.closed = !0,
                this._parentOrParents = null,
                this._subscriptions = null,
                n instanceof e)
                    n.remove(this);
                else if (null !== n)
                    for (var d = 0; d < n.length; ++d) {
                        n[d].remove(this)
                    }
                if (Object(o.a)(u)) {
                    a && (this._unsubscribe = void 0);
                    try {
                        u.call(this)
                    } catch (p) {
                        t = p instanceof s ? c(p.errors) : [p]
                    }
                }
                if (Object(r.a)(l)) {
                    d = -1;
                    for (var h = l.length; ++d < h; ) {
                        var f = l[d];
                        if (Object(i.a)(f))
                            try {
                                f.unsubscribe()
                            } catch (p) {
                                t = t || [],
                                p instanceof s ? t = t.concat(c(p.errors)) : t.push(p)
                            }
                    }
                }
                if (t)
                    throw new s(t)
            }
        }
        ,
        e.prototype.add = function(t) {
            var n = t;
            if (!t)
                return e.EMPTY;
            switch (typeof t) {
            case "function":
                n = new e(t);
            case "object":
                if (n === this || n.closed || "function" !== typeof n.unsubscribe)
                    return n;
                if (this.closed)
                    return n.unsubscribe(),
                    n;
                if (!(n instanceof e)) {
                    var r = n;
                    (n = new e)._subscriptions = [r]
                }
                break;
            default:
                throw new Error("unrecognized teardown " + t + " added to Subscription.")
            }
            var i = n._parentOrParents;
            if (null === i)
                n._parentOrParents = this;
            else if (i instanceof e) {
                if (i === this)
                    return n;
                n._parentOrParents = [i, this]
            } else {
                if (-1 !== i.indexOf(this))
                    return n;
                i.push(this)
            }
            var o = this._subscriptions;
            return null === o ? this._subscriptions = [n] : o.push(n),
            n
        }
        ,
        e.prototype.remove = function(e) {
            var t = this._subscriptions;
            if (t) {
                var n = t.indexOf(e);
                -1 !== n && t.splice(n, 1)
            }
        }
        ,
        e.EMPTY = ((t = new e).closed = !0,
        t),
        e
    }();
    function c(e) {
        return e.reduce((function(e, t) {
            return e.concat(t instanceof s ? t.errors : t)
        }
        ), [])
    }
}
, function(e, t, n) {
    (function(t) {
        var n = function(e) {
            return e && e.Math == Math && e
        };
        e.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof t && t) || Function("return this")()
    }
    ).call(this, n(167))
}
, function(e, t, n) {
    var r = n(39)
      , i = n(252)
      , o = n(56)
      , s = n(205)
      , a = n(307)
      , c = n(450)
      , u = i("wks")
      , l = r.Symbol
      , d = c ? l : l && l.withoutSetter || s;
    e.exports = function(e) {
        return o(u, e) || (a && o(l, e) ? u[e] = l[e] : u[e] = d("Symbol." + e)),
        u[e]
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "j", (function() {
        return r
    }
    )),
    n.d(t, "g", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "e", (function() {
        return a
    }
    )),
    n.d(t, "f", (function() {
        return c
    }
    )),
    n.d(t, "d", (function() {
        return u
    }
    )),
    n.d(t, "a", (function() {
        return l
    }
    )),
    n.d(t, "h", (function() {
        return d
    }
    )),
    n.d(t, "i", (function() {
        return h
    }
    ));
    const r = 100
      , i = 200
      , o = 300
      , s = -.5
      , a = 10
      , c = 4
      , u = 8
      , l = 600
      , d = 975
      , h = 25
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(71);
    function i(e, t) {
        return "function" === typeof e ? e(t) : e && "object" === typeof e && r.a in e ? e[r.a](t) : e instanceof Date ? new e.constructor(t) : new Date(t)
    }
}
, , function(e, t, n) {
    var r = n(34);
    e.exports = function(e, t, n) {
        if (r(e),
        void 0 === t)
            return e;
        switch (n) {
        case 0:
            return function() {
                return e.call(t)
            }
            ;
        case 1:
            return function(n) {
                return e.call(t, n)
            }
            ;
        case 2:
            return function(n, r) {
                return e.call(t, n, r)
            }
            ;
        case 3:
            return function(n, r, i) {
                return e.call(t, n, r, i)
            }
        }
        return function() {
            return e.apply(t, arguments)
        }
    }
}
, function(e, t, n) {
    var r = n(313)
      , i = n(39)
      , o = function(e) {
        return "function" == typeof e ? e : void 0
    };
    e.exports = function(e, t) {
        return arguments.length < 2 ? o(r[e]) || o(i[e]) : r[e] && r[e][t] || i[e] && i[e][t]
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "d", (function() {
        return r
    }
    )),
    n.d(t, "e", (function() {
        return i
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    ));
    const r = "TRX_OP_BEGIN_ID"
      , i = "TRX_OP_COMPLETE_ID"
      , o = "ISOLATION_OPTIMISTIC_STORE_LOGIC_ID"
      , s = "ISOLATION_STORE_LOGIC_ID"
      , a = "ISOLATION_TRX_LOGIC_ID"
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = i(n(598));
    function i(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var o = (0,
    i(n(606)).default)((function(e) {
        return null != e && "function" === typeof e.clone ? e.clone() : (0,
        r.default)(e, [], [], !0)
    }
    ));
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    (function(e) {
        n.d(t, "a", (function() {
            return s
        }
        )),
        n.d(t, "b", (function() {
            return a
        }
        ));
        var r = n(379)
          , i = Object.setPrototypeOf
          , o = void 0 === i ? function(e, t) {
            return e.__proto__ = t,
            e
        }
        : i
          , s = function(e) {
            function t(n) {
                void 0 === n && (n = "Invariant Violation");
                var r = e.call(this, "number" === typeof n ? "Invariant Violation: " + n + " (see https://github.com/apollographql/invariant-packages)" : n) || this;
                return r.framesToPop = 1,
                r.name = "Invariant Violation",
                o(r, t.prototype),
                r
            }
            return Object(r.a)(t, e),
            t
        }(Error);
        function a(e, t) {
            if (!e)
                throw new s(t)
        }
        function c(e) {
            return function() {
                return console[e].apply(console, arguments)
            }
        }
        !function(e) {
            e.warn = c("warn"),
            e.error = c("error")
        }(a || (a = {}));
        var u = {
            env: {}
        };
        if ("object" === typeof e)
            u = e;
        else
            try {
                Function("stub", "process = stub")(u)
            } catch (l) {}
    }
    ).call(this, n(359))
}
, function(e, t) {
    e.exports = function(e) {
        try {
            return !!e()
        } catch (t) {
            return !0
        }
    }
}
, function(e, t, n) {
    var r = n(53)
      , i = n(306)
      , o = n(18)
      , s = n(204)
      , a = Object.defineProperty;
    t.f = r ? a : function(e, t, n) {
        if (o(e),
        t = s(t, !0),
        o(n),
        i)
            try {
                return a(e, t, n)
            } catch (r) {}
        if ("get"in n || "set"in n)
            throw TypeError("Accessors not supported");
        return "value"in n && (e[t] = n.value),
        e
    }
}
, function(e, t) {
    e.exports = function(e) {
        return "object" === typeof e ? null !== e : "function" === typeof e
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var r = n(14)
      , i = n(72)
      , o = n(78)
      , s = n(57);
    function a(e, t, n) {
        return void 0 === n && (n = Number.POSITIVE_INFINITY),
        "function" === typeof t ? function(r) {
            return r.pipe(a((function(n, r) {
                return Object(o.a)(e(n, r)).pipe(Object(i.a)((function(e, i) {
                    return t(n, e, r, i)
                }
                )))
            }
            ), n))
        }
        : ("number" === typeof t && (n = t),
        function(t) {
            return t.lift(new c(e,n))
        }
        )
    }
    var c = function() {
        function e(e, t) {
            void 0 === t && (t = Number.POSITIVE_INFINITY),
            this.project = e,
            this.concurrent = t
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new u(e,this.project,this.concurrent))
        }
        ,
        e
    }()
      , u = function(e) {
        function t(t, n, r) {
            void 0 === r && (r = Number.POSITIVE_INFINITY);
            var i = e.call(this, t) || this;
            return i.project = n,
            i.concurrent = r,
            i.hasCompleted = !1,
            i.buffer = [],
            i.active = 0,
            i.index = 0,
            i
        }
        return r.a(t, e),
        t.prototype._next = function(e) {
            this.active < this.concurrent ? this._tryNext(e) : this.buffer.push(e)
        }
        ,
        t.prototype._tryNext = function(e) {
            var t, n = this.index++;
            try {
                t = this.project(e, n)
            } catch (r) {
                return void this.destination.error(r)
            }
            this.active++,
            this._innerSub(t)
        }
        ,
        t.prototype._innerSub = function(e) {
            var t = new s.a(this)
              , n = this.destination;
            n.add(t);
            var r = Object(s.c)(e, t);
            r !== t && n.add(r)
        }
        ,
        t.prototype._complete = function() {
            this.hasCompleted = !0,
            0 === this.active && 0 === this.buffer.length && this.destination.complete(),
            this.unsubscribe()
        }
        ,
        t.prototype.notifyNext = function(e) {
            this.destination.next(e)
        }
        ,
        t.prototype.notifyComplete = function() {
            var e = this.buffer;
            this.active--,
            e.length > 0 ? this._next(e.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete()
        }
        ,
        t
    }(s.b)
}
, function(e, t, n) {
    var r = n(49);
    e.exports = !r((function() {
        return 7 != Object.defineProperty({}, 1, {
            get: function() {
                return 7
            }
        })[1]
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return h
    }
    )),
    n.d(t, "b", (function() {
        return f
    }
    )),
    n.d(t, "i", (function() {
        return p
    }
    )),
    n.d(t, "d", (function() {
        return g
    }
    )),
    n.d(t, "k", (function() {
        return m
    }
    )),
    n.d(t, "h", (function() {
        return _
    }
    )),
    n.d(t, "c", (function() {
        return O
    }
    )),
    n.d(t, "e", (function() {
        return T
    }
    )),
    n.d(t, "j", (function() {
        return I
    }
    )),
    n.d(t, "g", (function() {
        return M
    }
    )),
    n.d(t, "f", (function() {
        return A
    }
    ));
    var r = n(1)
      , i = n(399)
      , o = n(15)
      , s = n(23)
      , a = n(6)
      , c = n(134)
      , u = n(32);
    const l = (e, t) => "function" !== typeof t[o.a] ? Object(i.h)(t[o.a], e.type) : t[o.a](e.type, e)
      , d = (e, t) => t.isMatch(e)
      , h = (e, t) => Object(i.h)(t.actionType, e.type)
      , f = () => [s.f, s.g, s.b, s.e, s.c]
      , p = (e, t, n) => {
        if (!e || !e.network)
            throw new Error('Invalid options provided to Store logic manager: "network" is a required options.');
        return e.Manager || (e.Manager = t),
        e.ManagerInner || (e.ManagerInner = n),
        e.ops || (e.ops = f(),
        e.opsAliases = {
            [s.f]: r.r,
            [s.g]: r.r,
            [s.b]: r.r,
            [s.e]: r.r,
            [s.c]: r.f,
            [s.d]: r.l,
            [s.a]: r.e
        }),
        e.logicFilter || (e.logicFilter = l),
        e
    }
      , g = e => e ? [a.k, a.d, a.a, a.l, a.e, a.b] : [a.k, a.h, a.f, a.j, a.i, a.g, a.d, a.a, a.l, a.e, a.b]
      , m = g()
      , y = m.length
      , v = g(!0)
      , b = v.length
      , _ = f()
      , S = _.length;
    function O() {
        const e = {};
        for (let t = 0; t < S; t++)
            e[_[t]] = t;
        return e
    }
    function T(e) {
        const t = {};
        if (e)
            for (let n = 0; n < b; n++)
                t[v[n]] = n;
        else
            for (let n = 0; n < y; n++)
                t[m[n]] = n;
        return t
    }
    const I = (e, t, n) => {
        if (!e || !e.network || !e.trxType)
            throw new Error('Invalid options provided to transaction logic manager: "network" and "trxType" are required options.');
        if (e.Manager || (e.Manager = t),
        e.ManagerInner || (e.ManagerInner = n),
        e.ops)
            e.isCommitOnly = e.trxType === c.a;
        else {
            const t = e.trxType === c.a;
            e.ops = g(t),
            e.opsAliases = (e => {
                const t = {
                    [a.k]: r.r,
                    [a.d]: r.r,
                    [a.a]: r.r,
                    [a.l]: r.r,
                    [a.e]: r.r,
                    [a.b]: r.f,
                    [a.m]: r.e,
                    [a.c]: r.l
                };
                return e || (t[a.h] = r.r,
                t[a.f] = r.r,
                t[a.j] = r.r,
                t[a.i] = r.r,
                t[a.g] = r.r),
                t
            }
            )(t),
            e.isCommitOnly = t
        }
        return e.logicFilter || (e.logicFilter = d),
        e
    }
      , x = {};
    for (let E in u.e)
        x[u.e[E]] = !0;
    const w = {};
    for (let E in u.b)
        w[u.b[E]] = !0;
    function M(e, t) {
        return !(!x[e] || t && e === a.c)
    }
    function A(e, t) {
        return !(!w[e] || t && e === s.d)
    }
}
, , function(e, t) {
    var n = {}.hasOwnProperty;
    e.exports = function(e, t) {
        return n.call(e, t)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "c", (function() {
        return u
    }
    ));
    var r = n(14)
      , i = n(22)
      , o = n(26)
      , s = n(233)
      , a = function(e) {
        function t(t) {
            var n = e.call(this) || this;
            return n.parent = t,
            n
        }
        return r.a(t, e),
        t.prototype._next = function(e) {
            this.parent.notifyNext(e)
        }
        ,
        t.prototype._error = function(e) {
            this.parent.notifyError(e),
            this.unsubscribe()
        }
        ,
        t.prototype._complete = function() {
            this.parent.notifyComplete(),
            this.unsubscribe()
        }
        ,
        t
    }(i.a)
      , c = (i.a,
    function(e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }
        return r.a(t, e),
        t.prototype.notifyNext = function(e) {
            this.destination.next(e)
        }
        ,
        t.prototype.notifyError = function(e) {
            this.destination.error(e)
        }
        ,
        t.prototype.notifyComplete = function() {
            this.destination.complete()
        }
        ,
        t
    }(i.a));
    i.a;
    function u(e, t) {
        if (!t.closed) {
            if (e instanceof o.a)
                return e.subscribe(t);
            var n;
            try {
                n = Object(s.a)(e)(t)
            } catch (r) {
                t.error(r)
            }
            return n
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "d", (function() {
        return s
    }
    )),
    n.d(t, "e", (function() {
        return a
    }
    )),
    n.d(t, "f", (function() {
        return c
    }
    )),
    n.d(t, "g", (function() {
        return u
    }
    )),
    n.d(t, "h", (function() {
        return l
    }
    )),
    n.d(t, "i", (function() {
        return d
    }
    )),
    n.d(t, "j", (function() {
        return h
    }
    )),
    n.d(t, "k", (function() {
        return f
    }
    )),
    n.d(t, "l", (function() {
        return p
    }
    )),
    n.d(t, "m", (function() {
        return g
    }
    )),
    n.d(t, "n", (function() {
        return m
    }
    )),
    n.d(t, "o", (function() {
        return y
    }
    )),
    n.d(t, "p", (function() {
        return v
    }
    )),
    n.d(t, "q", (function() {
        return b
    }
    )),
    n.d(t, "r", (function() {
        return _
    }
    )),
    n.d(t, "s", (function() {
        return S
    }
    )),
    n.d(t, "t", (function() {
        return O
    }
    ));
    const r = "@isomorix/core-actions/ADD_INDEX"
      , i = "@isomorix/core-actions/AI_CHAT_COMPLETION"
      , o = "@isomorix/core-actions/BUILD_MODELS"
      , s = "@isomorix/core-actions/BUILD_ROUTES"
      , a = "@isomorix/core-actions/EXECUTE_CREATES"
      , c = "@isomorix/core-actions/EXECUTE_DELETES"
      , u = "@isomorix/core-actions/EXECUTE_MUTATION"
      , l = "@isomorix/core-actions/EXECUTE_QUERY"
      , d = "@isomorix/core-actions/EXECUTE_SUBSCRIPTION"
      , h = "@isomorix/core-actions/EXECUTE_UPDATES"
      , f = "@isomorix/core-actions/GRAPHQL_REQUEST"
      , p = "init"
      , g = "logic_init"
      , m = "@isomorix/core-actions/MUTATION"
      , y = "@isomorix/core-actions/PLUGIN_INIT"
      , v = "@isomorix/core-actions/QUERY"
      , b = "@isomorix/core-actions/REMOVE_INDEX"
      , _ = "@isomorix/core-actions/REQUEST"
      , S = "@isomorix/core-actions/SUBSCRIPTION"
      , O = "@isomorix/core-actions/SYNC_SCHEMA"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return i
    }
    ));
    var r = function() {
        return (r = Object.assign || function(e) {
            for (var t, n = 1, r = arguments.length; n < r; n++)
                for (var i in t = arguments[n])
                    Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e
        }
        ).apply(this, arguments)
    };
    function i() {
        for (var e = 0, t = 0, n = arguments.length; t < n; t++)
            e += arguments[t].length;
        var r = Array(e)
          , i = 0;
        for (t = 0; t < n; t++)
            for (var o = arguments[t], s = 0, a = o.length; s < a; s++,
            i++)
                r[i] = o[s];
        return r
    }
}
, function(e, t, n) {
    var r, i, o, s = n(316), a = n(39), c = n(51), u = n(64), l = n(56), d = n(257), h = n(207), f = a.WeakMap;
    if (s) {
        var p = new f
          , g = p.get
          , m = p.has
          , y = p.set;
        r = function(e, t) {
            return y.call(p, e, t),
            t
        }
        ,
        i = function(e) {
            return g.call(p, e) || {}
        }
        ,
        o = function(e) {
            return m.call(p, e)
        }
    } else {
        var v = d("state");
        h[v] = !0,
        r = function(e, t) {
            return u(e, v, t),
            t
        }
        ,
        i = function(e) {
            return l(e, v) ? e[v] : {}
        }
        ,
        o = function(e) {
            return l(e, v)
        }
    }
    e.exports = {
        set: r,
        get: i,
        has: o,
        enforce: function(e) {
            return o(e) ? i(e) : r(e, {})
        },
        getterFor: function(e) {
            return function(t) {
                var n;
                if (!c(t) || (n = i(t)).type !== e)
                    throw TypeError("Incompatible receiver, " + e + " required");
                return n
            }
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    "function" === typeof Symbol && null != Symbol.iterator && Symbol.iterator,
    "function" === typeof Symbol && null != Symbol.asyncIterator && Symbol.asyncIterator;
    var r = "function" === typeof Symbol && null != Symbol.toStringTag ? Symbol.toStringTag : "@@toStringTag"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var r = Object.freeze({
        QUERY: "QUERY",
        MUTATION: "MUTATION",
        SUBSCRIPTION: "SUBSCRIPTION",
        FIELD: "FIELD",
        FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
        FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
        INLINE_FRAGMENT: "INLINE_FRAGMENT",
        VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
        SCHEMA: "SCHEMA",
        SCALAR: "SCALAR",
        OBJECT: "OBJECT",
        FIELD_DEFINITION: "FIELD_DEFINITION",
        ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
        INTERFACE: "INTERFACE",
        UNION: "UNION",
        ENUM: "ENUM",
        ENUM_VALUE: "ENUM_VALUE",
        INPUT_OBJECT: "INPUT_OBJECT",
        INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
    })
}
, , function(e, t, n) {
    var r = n(53)
      , i = n(50)
      , o = n(128);
    e.exports = r ? function(e, t, n) {
        return i.f(e, t, o(1, n))
    }
    : function(e, t, n) {
        return e[t] = n,
        e
    }
}
, function(e, t, n) {
    var r = n(114)
      , i = Math.min;
    e.exports = function(e) {
        return e > 0 ? i(r(e), 9007199254740991) : 0
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = !1
      , i = {
        Promise: void 0,
        set useDeprecatedSynchronousErrorHandling(e) {
            e && (new Error).stack;
            r = e
        },
        get useDeprecatedSynchronousErrorHandling() {
            return r
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(229)
      , i = n(184);
    function o(e) {
        var t = e.prototype.toJSON;
        "function" === typeof t || Object(r.a)(0),
        e.prototype.inspect = t,
        i.a && (e.prototype[i.a] = t)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(104);
    function i(e) {
        if (null === Object.getPrototypeOf(e))
            return e;
        for (var t = Object.create(null), n = 0, i = Object(r.a)(e); n < i.length; n++) {
            var o = i[n]
              , s = o[0]
              , a = o[1];
            t[s] = a
        }
        return t
    }
}
, , function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = "autoloadOnClient"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "e", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "d", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return s
    }
    )),
    n.d(t, "a", (function() {
        return a
    }
    ));
    Math.pow(10, 8);
    const r = 6048e5
      , i = 864e5
      , o = 6e4
      , s = 36e5
      , a = Symbol.for("constructDateFrom")
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(14)
      , i = n(22);
    function o(e, t) {
        return function(n) {
            if ("function" !== typeof e)
                throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
            return n.lift(new s(e,t))
        }
    }
    var s = function() {
        function e(e, t) {
            this.project = e,
            this.thisArg = t
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new a(e,this.project,this.thisArg))
        }
        ,
        e
    }()
      , a = function(e) {
        function t(t, n, r) {
            var i = e.call(this, t) || this;
            return i.project = n,
            i.count = 0,
            i.thisArg = r || i,
            i
        }
        return r.a(t, e),
        t.prototype._next = function(e) {
            var t;
            try {
                t = this.project.call(this.thisArg, e, this.count++)
            } catch (n) {
                return void this.destination.error(n)
            }
            this.destination.next(t)
        }
        ,
        t
    }(i.a)
}
, function(e, t, n) {
    "use strict";
    t.a = function(e, t) {
        return e instanceof t
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(14)
      , i = n(22);
    function o(e) {
        return function(t) {
            return t.lift(new s(e))
        }
    }
    var s = function() {
        function e(e) {
            this.value = e
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new a(e,this.value))
        }
        ,
        e
    }()
      , a = function(e) {
        function t(t, n) {
            var r = e.call(this, t) || this;
            return r.value = n,
            r
        }
        return r.a(t, e),
        t.prototype._next = function(e) {
            this.destination.next(this.value)
        }
        ,
        t
    }(i.a)
}
, , , function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return s
    }
    ));
    const r = {
        API_LOG: "ApiLog",
        CORE_LOGIC: "CoreLogic",
        DATA_SOURCE: "DataSource",
        DEVICE: "Device",
        DOMAIN: "Domain",
        ENTITY: "Entity",
        ENTITY_JOB: "EntityJob",
        LOCATION: "Location",
        PERMISSION: "Permission",
        PERSISTENT_QUERY: "PersistentQuery",
        PERSISTENT_QUERY_TAG: "PersistentQueryTag",
        PLUGIN: "Plugin",
        ROLE: "Role",
        ROLES_PERMISSIONS: "RolesPermissions",
        SESSION: "Session",
        SSL_CERT: "SslCert",
        SSL_CERT_DOMAIN: "SslCertDomain",
        TAG: "Tag",
        USER: "User",
        USER_META: "UserMeta",
        USER_ROLE: "UserRole",
        USER_TAG: "UserTag"
    }
      , i = {
        [r.DOMAIN]: null,
        [r.PLUGIN]: null,
        [r.ENTITY]: null
    };
    for (let a in i)
        i[a] = "".concat(a.charAt(0).toLowerCase()).concat(a.slice(1));
    r.DOMAIN,
    r.ENTITY,
    r.PLUGIN;
    const o = "Core";
    function s() {
        return [r.PERMISSION, r.ROLE, r.ROLES_PERMISSIONS, r.TAG, r.USER, r.USER_META, r.USER_ROLE, r.USER_TAG]
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(26)
      , i = n(233)
      , o = n(294);
    function s(e, t) {
        return t ? Object(o.a)(e, t) : e instanceof r.a ? e : new r.a(Object(i.a)(e))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "f", (function() {
        return a
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "g", (function() {
        return h
    }
    )),
    n.d(t, "e", (function() {
        return f
    }
    )),
    n.d(t, "d", (function() {
        return p
    }
    ));
    var r = n(1);
    const i = Object.values(r.w);
    i.splice(i.indexOf(r.h), 1);
    const o = [r.r, r.f]
      , s = e => {
        const t = e.name;
        if (t) {
            return {
                [t]: function() {
                    return e.call(this, ...arguments)
                }
            }[t]
        }
        return function() {
            return e.call(this, ...arguments)
        }
    }
    ;
    function a(e, t, n) {
        const {[r.h]: i} = e;
        let o;
        if (i)
            o = t ? {
                ...i,
                ...t
            } : {
                ...i
            };
        else {
            if (!t)
                throw new Error("There are no default options on the functional logic, nor were options provided as the 2nd argument. One (or both) must be available to create the logic.");
            o = {
                ...t
            }
        }
        const {[r.s]: a, [r.t]: c} = o;
        if (n) {
            const t = o;
            if (o = s(e),
            c && a) {
                if ("string" === typeof a)
                    t[r.s] = c[a] || a;
                else {
                    const e = [...a];
                    for (let t = 0; t < e.length; t++)
                        e[t] = c[e[t]] || e[t];
                    t[r.s] = e
                }
                t[r.t] = null
            }
            o[r.h] = t
        } else if ("string" === typeof a)
            c ? o[c[a]] = e : o[a] = e;
        else if (c)
            for (let r of a)
                o[c[r]] = e;
        else if (a)
            for (let r of a)
                o[r] = e;
        return o
    }
    function c(e, t) {
        const n = {};
        for (let r of i)
            n[r] = e[r];
        for (let r of t)
            n[r] = !1;
        return n
    }
    function u(e, t) {
        if (e) {
            if ("function" !== typeof e)
                return e;
            if (e[r.h])
                return e[r.h];
            if (t)
                return e[r.h] = {},
                e[r.h];
            throw new Error("No props found for functional logic. Unable to useLogicProps().")
        }
        if (t)
            return {};
        throw new Error("No target logic provided to useLogicProps().")
    }
    const l = [r.m, r.k, r.j, r.q, r.y, r.z, r.A]
      , d = [r.C, r.g, r.p, r.u, r.i];
    function h(e, t, n, i) {
        if (!e)
            throw new Error("No source logic provided. Unable to use props.");
        let o, s, a, c;
        "number" === typeof t ? (n = t,
        s = null,
        o = !0) : (s = t,
        o = "number" !== typeof n);
        const h = u(e, !1)
          , f = u(s, o);
        if ((c = h[r.s]) && "undefined" === typeof f[r.s] && (f[r.s] = Array.isArray(c) ? [...c] : c),
        (c = h[r.t]) && "undefined" === typeof f[r.t] && (f[r.t] = {
            ...c
        }),
        o)
            for (a of (f[r.v] = h[r.v],
            (c = h[r.b]) && "undefined" === typeof f[r.b] && (f[r.b] = Array.isArray(c) ? [...c] : c),
            (c = h[r.B]) && "undefined" === typeof f[r.B] && (f[r.B] = {
                ...c
            }),
            (c = h[r.c]) && "undefined" === typeof f[r.c] && (f[r.c] = [...c]),
            !0 === h[r.d] && !1 !== typeof f[r.d] && (f[r.d] = !0,
            "undefined" === typeof f[r.n] && (f[r.n] = h[r.n],
            "undefined" === typeof f[r.o] && (f[r.o] = h[r.o]))),
            l))
                "undefined" === typeof f[a] && "undefined" !== typeof (c = h[a]) && (f[a] = c);
        else if ("number" !== typeof f[r.v] && (f[r.v] = h[r.v] + n),
        i)
            return s || f;
        for (a of ((c = h[r.a]) && "undefined" === typeof f[r.a] && (f[r.a] = Array.isArray(c) ? [...c] : c),
        "boolean" === typeof (c = h[r.x]) && "boolean" !== typeof f[r.x] && (f[r.x] = c),
        d))
            "undefined" === typeof f[a] && "undefined" !== typeof (c = h[a]) && (f[a] = c);
        return s || f
    }
    function f(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          , n = arguments.length > 2 ? arguments[2] : void 0;
        if (n || (n = o),
        "function" === typeof e) {
            const i = e[r.h];
            let o = e[r.h];
            if (!i || !(o = i[r.s]))
                return null;
            const s = i[r.t];
            if ("string" === typeof o)
                return o = s && s[o] || o,
                n.indexOf(o) > -1 ? t ? o : [o] : null;
            {
                if (s) {
                    o = [...o];
                    for (let e = 0; e < o.length; e++)
                        o[e] = s[o[e]] || o[e]
                }
                let e;
                for (let r of o)
                    if (n.indexOf(r) > -1) {
                        if (t)
                            return r;
                        e ? e.push(r) : e = [r]
                    }
                return e || null
            }
        }
        {
            const i = e[r.t];
            let o, s;
            for (let r of n)
                if (s = i && i[r] || r,
                e[s]) {
                    if (t)
                        return r;
                    o ? o.push(r) : o = [r]
                }
            return o || null
        }
    }
    function p(e, t) {
        if (t || (t = o),
        "function" === typeof e)
            return e[r.h] ? e : null;
        let n, i;
        for (let o of t)
            if (i = e[o])
                if (n) {
                    if (i !== n)
                        return null
                } else {
                    if (!i[r.h])
                        return null;
                    n = i
                }
        return n || null
    }
}
, , function(e, t, n) {
    var r = n(18)
      , i = n(34)
      , o = n(40)("species");
    e.exports = function(e, t) {
        var n, s = r(e).constructor;
        return void 0 === s || void 0 == (n = r(s)[o]) ? t : i(n)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(156)
      , i = new (n(155).a)(r.a)
      , o = i
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return e.charAt(0).toUpperCase() + e.slice(1)
    }
    function i(e) {
        return e.charAt(0).toUpperCase() === e.charAt(0)
    }
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return i
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var r = n(21)
      , i = n(35)
      , o = {
        Name: [],
        Document: ["definitions"],
        OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
        VariableDefinition: ["variable", "type", "defaultValue", "directives"],
        Variable: ["name"],
        SelectionSet: ["selections"],
        Field: ["alias", "name", "arguments", "directives", "selectionSet"],
        Argument: ["name", "value"],
        FragmentSpread: ["name", "directives"],
        InlineFragment: ["typeCondition", "directives", "selectionSet"],
        FragmentDefinition: ["name", "variableDefinitions", "typeCondition", "directives", "selectionSet"],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ["values"],
        ObjectValue: ["fields"],
        ObjectField: ["name", "value"],
        Directive: ["name", "arguments"],
        NamedType: ["name"],
        ListType: ["type"],
        NonNullType: ["type"],
        SchemaDefinition: ["description", "directives", "operationTypes"],
        OperationTypeDefinition: ["type"],
        ScalarTypeDefinition: ["description", "name", "directives"],
        ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
        FieldDefinition: ["description", "name", "arguments", "type", "directives"],
        InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
        InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
        UnionTypeDefinition: ["description", "name", "directives", "types"],
        EnumTypeDefinition: ["description", "name", "directives", "values"],
        EnumValueDefinition: ["description", "name", "directives"],
        InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
        DirectiveDefinition: ["description", "name", "arguments", "locations"],
        SchemaExtension: ["directives", "operationTypes"],
        ScalarTypeExtension: ["name", "directives"],
        ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
        InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
        UnionTypeExtension: ["name", "directives", "types"],
        EnumTypeExtension: ["name", "directives", "values"],
        InputObjectTypeExtension: ["name", "directives", "fields"]
    }
      , s = Object.freeze({});
    function a(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : o
          , a = void 0
          , u = Array.isArray(e)
          , l = [e]
          , d = -1
          , h = []
          , f = void 0
          , p = void 0
          , g = void 0
          , m = []
          , y = []
          , v = e;
        do {
            var b = ++d === l.length
              , _ = b && 0 !== h.length;
            if (b) {
                if (p = 0 === y.length ? void 0 : m[m.length - 1],
                f = g,
                g = y.pop(),
                _) {
                    if (u)
                        f = f.slice();
                    else {
                        for (var S = {}, O = 0, T = Object.keys(f); O < T.length; O++) {
                            var I = T[O];
                            S[I] = f[I]
                        }
                        f = S
                    }
                    for (var x = 0, w = 0; w < h.length; w++) {
                        var M = h[w][0]
                          , A = h[w][1];
                        u && (M -= x),
                        u && null === A ? (f.splice(M, 1),
                        x++) : f[M] = A
                    }
                }
                d = a.index,
                l = a.keys,
                h = a.edits,
                u = a.inArray,
                a = a.prev
            } else {
                if (p = g ? u ? d : l[d] : void 0,
                null === (f = g ? g[p] : v) || void 0 === f)
                    continue;
                g && m.push(p)
            }
            var E, C = void 0;
            if (!Array.isArray(f)) {
                if (!Object(i.c)(f))
                    throw new Error("Invalid AST Node: ".concat(Object(r.a)(f), "."));
                var N = c(t, f.kind, b);
                if (N) {
                    if ((C = N.call(t, f, p, g, m, y)) === s)
                        break;
                    if (!1 === C) {
                        if (!b) {
                            m.pop();
                            continue
                        }
                    } else if (void 0 !== C && (h.push([p, C]),
                    !b)) {
                        if (!Object(i.c)(C)) {
                            m.pop();
                            continue
                        }
                        f = C
                    }
                }
            }
            if (void 0 === C && _ && h.push([p, f]),
            b)
                m.pop();
            else
                a = {
                    inArray: u,
                    index: d,
                    keys: l,
                    edits: h,
                    prev: a
                },
                l = (u = Array.isArray(f)) ? f : null !== (E = n[f.kind]) && void 0 !== E ? E : [],
                d = -1,
                h = [],
                g && y.push(g),
                g = f
        } while (void 0 !== a);
        return 0 !== h.length && (v = h[h.length - 1][1]),
        v
    }
    function c(e, t, n) {
        var r = e[t];
        if (r) {
            if (!n && "function" === typeof r)
                return r;
            var i = n ? r.leave : r.enter;
            if ("function" === typeof i)
                return i
        } else {
            var o = n ? e.leave : e.enter;
            if (o) {
                if ("function" === typeof o)
                    return o;
                var s = o[t];
                if ("function" === typeof s)
                    return s
            }
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return F
    }
    )),
    n.d(t, "c", (function() {
        return L
    }
    )),
    n.d(t, "d", (function() {
        return G
    }
    )),
    n.d(t, "a", (function() {
        return Y
    }
    ));
    var r = n(104)
      , i = n(61)
      , o = n(21);
    function s(e, t) {
        for (var n = Object.create(null), i = 0, o = Object(r.a)(e); i < o.length; i++) {
            var s = o[i]
              , a = s[0]
              , c = s[1];
            n[a] = t(c, a)
        }
        return n
    }
    var a = n(68)
      , c = n(30);
    function u(e, t, n) {
        return e.reduce((function(e, r) {
            return e[t(r)] = n(r),
            e
        }
        ), Object.create(null))
    }
    var l = n(73);
    var d = n(103);
    function h(e) {
        return e
    }
    var f = n(67);
    var p = 48;
    function g(e) {
        return !isNaN(e) && p <= e && e <= 57
    }
    function m(e, t) {
        for (var n = Object.create(null), r = new y(e), i = Math.floor(.4 * e.length) + 1, o = 0; o < t.length; o++) {
            var s = t[o]
              , a = r.measure(s, i);
            void 0 !== a && (n[s] = a)
        }
        return Object.keys(n).sort((function(e, t) {
            var r = n[e] - n[t];
            return 0 !== r ? r : function(e, t) {
                for (var n = 0, r = 0; n < e.length && r < t.length; ) {
                    var i = e.charCodeAt(n)
                      , o = t.charCodeAt(r);
                    if (g(i) && g(o)) {
                        var s = 0;
                        do {
                            ++n,
                            s = 10 * s + i - p,
                            i = e.charCodeAt(n)
                        } while (g(i) && s > 0);
                        var a = 0;
                        do {
                            ++r,
                            a = 10 * a + o - p,
                            o = t.charCodeAt(r)
                        } while (g(o) && a > 0);
                        if (s < a)
                            return -1;
                        if (s > a)
                            return 1
                    } else {
                        if (i < o)
                            return -1;
                        if (i > o)
                            return 1;
                        ++n,
                        ++r
                    }
                }
                return e.length - t.length
            }(e, t)
        }
        ))
    }
    var y = function() {
        function e(e) {
            this._input = e,
            this._inputLowerCase = e.toLowerCase(),
            this._inputArray = v(this._inputLowerCase),
            this._rows = [new Array(e.length + 1).fill(0), new Array(e.length + 1).fill(0), new Array(e.length + 1).fill(0)]
        }
        return e.prototype.measure = function(e, t) {
            if (this._input === e)
                return 0;
            var n = e.toLowerCase();
            if (this._inputLowerCase === n)
                return 1;
            var r = v(n)
              , i = this._inputArray;
            if (r.length < i.length) {
                var o = r;
                r = i,
                i = o
            }
            var s = r.length
              , a = i.length;
            if (!(s - a > t)) {
                for (var c = this._rows, u = 0; u <= a; u++)
                    c[0][u] = u;
                for (var l = 1; l <= s; l++) {
                    for (var d = c[(l - 1) % 3], h = c[l % 3], f = h[0] = l, p = 1; p <= a; p++) {
                        var g = r[l - 1] === i[p - 1] ? 0 : 1
                          , m = Math.min(d[p] + 1, h[p - 1] + 1, d[p - 1] + g);
                        if (l > 1 && p > 1 && r[l - 1] === i[p - 2] && r[l - 2] === i[p - 1]) {
                            var y = c[(l - 2) % 3][p - 2];
                            m = Math.min(m, y + 1)
                        }
                        m < f && (f = m),
                        h[p] = m
                    }
                    if (f > t)
                        return
                }
                var b = c[s % 3][a];
                return b <= t ? b : void 0
            }
        }
        ,
        e
    }();
    function v(e) {
        for (var t = e.length, n = new Array(t), r = 0; r < t; ++r)
            n[r] = e.charCodeAt(r);
        return n
    }
    var b = n(36)
      , _ = n(12)
      , S = n(107)
      , O = n(229);
    function T(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1,
            r.configurable = !0,
            "value"in r && (r.writable = !0),
            Object.defineProperty(e, r.key, r)
        }
    }
    function I(e, t, n) {
        return t && T(e.prototype, t),
        n && T(e, n),
        e
    }
    function x(e) {
        return w(e) || M(e) || A(e) || E(e) || C(e) || N(e) || R(e) || P(e)
    }
    function w(e) {
        return Object(l.a)(e, L)
    }
    function M(e) {
        return Object(l.a)(e, V)
    }
    function A(e) {
        return Object(l.a)(e, z)
    }
    function E(e) {
        return Object(l.a)(e, H)
    }
    function C(e) {
        return Object(l.a)(e, Y)
    }
    function N(e) {
        return Object(l.a)(e, $)
    }
    function R(e) {
        return Object(l.a)(e, D)
    }
    function P(e) {
        return Object(l.a)(e, F)
    }
    function D(e) {
        if (!(this instanceof D))
            return new D(e);
        this.ofType = function(e) {
            if (!x(e))
                throw new Error("Expected ".concat(Object(o.a)(e), " to be a GraphQL type."));
            return e
        }(e)
    }
    function F(e) {
        if (!(this instanceof F))
            return new F(e);
        this.ofType = function(e) {
            if (!function(e) {
                return x(e) && !P(e)
            }(e))
                throw new Error("Expected ".concat(Object(o.a)(e), " to be a GraphQL nullable type."));
            return e
        }(e)
    }
    function k(e) {
        return "function" === typeof e ? e() : e
    }
    function j(e) {
        return e && e.length > 0 ? e : void 0
    }
    D.prototype.toString = function() {
        return "[" + String(this.ofType) + "]"
    }
    ,
    D.prototype.toJSON = function() {
        return this.toString()
    }
    ,
    Object.defineProperty(D.prototype, i.a, {
        get: function() {
            return "GraphQLList"
        }
    }),
    Object(f.a)(D),
    F.prototype.toString = function() {
        return String(this.ofType) + "!"
    }
    ,
    F.prototype.toJSON = function() {
        return this.toString()
    }
    ,
    Object.defineProperty(F.prototype, i.a, {
        get: function() {
            return "GraphQLNonNull"
        }
    }),
    Object(f.a)(F);
    var L = function() {
        function e(e) {
            var t, n, r, i = null !== (t = e.parseValue) && void 0 !== t ? t : h;
            this.name = e.name,
            this.description = e.description,
            this.specifiedByUrl = e.specifiedByUrl,
            this.serialize = null !== (n = e.serialize) && void 0 !== n ? n : h,
            this.parseValue = i,
            this.parseLiteral = null !== (r = e.parseLiteral) && void 0 !== r ? r : function(e, t) {
                return i(function e(t, n) {
                    switch (t.kind) {
                    case _.a.NULL:
                        return null;
                    case _.a.INT:
                        return parseInt(t.value, 10);
                    case _.a.FLOAT:
                        return parseFloat(t.value);
                    case _.a.STRING:
                    case _.a.ENUM:
                    case _.a.BOOLEAN:
                        return t.value;
                    case _.a.LIST:
                        return t.values.map((function(t) {
                            return e(t, n)
                        }
                        ));
                    case _.a.OBJECT:
                        return u(t.fields, (function(e) {
                            return e.name.value
                        }
                        ), (function(t) {
                            return e(t.value, n)
                        }
                        ));
                    case _.a.VARIABLE:
                        return null === n || void 0 === n ? void 0 : n[t.name.value]
                    }
                    Object(O.a)(0, "Unexpected value node: " + Object(o.a)(t))
                }(e, t))
            }
            ,
            this.extensions = e.extensions && Object(a.a)(e.extensions),
            this.astNode = e.astNode,
            this.extensionASTNodes = j(e.extensionASTNodes),
            "string" === typeof e.name || Object(c.a)(0, "Must provide name."),
            null == e.specifiedByUrl || "string" === typeof e.specifiedByUrl || Object(c.a)(0, "".concat(this.name, ' must provide "specifiedByUrl" as a string, ') + "but got: ".concat(Object(o.a)(e.specifiedByUrl), ".")),
            null == e.serialize || "function" === typeof e.serialize || Object(c.a)(0, "".concat(this.name, ' must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.')),
            e.parseLiteral && ("function" === typeof e.parseValue && "function" === typeof e.parseLiteral || Object(c.a)(0, "".concat(this.name, ' must provide both "parseValue" and "parseLiteral" functions.')))
        }
        var t = e.prototype;
        return t.toConfig = function() {
            var e;
            return {
                name: this.name,
                description: this.description,
                specifiedByUrl: this.specifiedByUrl,
                serialize: this.serialize,
                parseValue: this.parseValue,
                parseLiteral: this.parseLiteral,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: null !== (e = this.extensionASTNodes) && void 0 !== e ? e : []
            }
        }
        ,
        t.toString = function() {
            return this.name
        }
        ,
        t.toJSON = function() {
            return this.toString()
        }
        ,
        I(e, [{
            key: i.a,
            get: function() {
                return "GraphQLScalarType"
            }
        }]),
        e
    }();
    Object(f.a)(L);
    var V = function() {
        function e(e) {
            this.name = e.name,
            this.description = e.description,
            this.isTypeOf = e.isTypeOf,
            this.extensions = e.extensions && Object(a.a)(e.extensions),
            this.astNode = e.astNode,
            this.extensionASTNodes = j(e.extensionASTNodes),
            this._fields = q.bind(void 0, e),
            this._interfaces = U.bind(void 0, e),
            "string" === typeof e.name || Object(c.a)(0, "Must provide name."),
            null == e.isTypeOf || "function" === typeof e.isTypeOf || Object(c.a)(0, "".concat(this.name, ' must provide "isTypeOf" as a function, ') + "but got: ".concat(Object(o.a)(e.isTypeOf), "."))
        }
        var t = e.prototype;
        return t.getFields = function() {
            return "function" === typeof this._fields && (this._fields = this._fields()),
            this._fields
        }
        ,
        t.getInterfaces = function() {
            return "function" === typeof this._interfaces && (this._interfaces = this._interfaces()),
            this._interfaces
        }
        ,
        t.toConfig = function() {
            return {
                name: this.name,
                description: this.description,
                interfaces: this.getInterfaces(),
                fields: B(this.getFields()),
                isTypeOf: this.isTypeOf,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: this.extensionASTNodes || []
            }
        }
        ,
        t.toString = function() {
            return this.name
        }
        ,
        t.toJSON = function() {
            return this.toString()
        }
        ,
        I(e, [{
            key: i.a,
            get: function() {
                return "GraphQLObjectType"
            }
        }]),
        e
    }();
    function U(e) {
        var t, n = null !== (t = k(e.interfaces)) && void 0 !== t ? t : [];
        return Array.isArray(n) || Object(c.a)(0, "".concat(e.name, " interfaces must be an Array or a function which returns an Array.")),
        n
    }
    function q(e) {
        var t = k(e.fields);
        return Q(t) || Object(c.a)(0, "".concat(e.name, " fields must be an object with field names as keys or a function which returns such an object.")),
        s(t, (function(t, n) {
            var i;
            Q(t) || Object(c.a)(0, "".concat(e.name, ".").concat(n, " field config must be an object.")),
            !("isDeprecated"in t) || Object(c.a)(0, "".concat(e.name, ".").concat(n, ' should provide "deprecationReason" instead of "isDeprecated".')),
            null == t.resolve || "function" === typeof t.resolve || Object(c.a)(0, "".concat(e.name, ".").concat(n, " field resolver must be a function if ") + "provided, but got: ".concat(Object(o.a)(t.resolve), "."));
            var s = null !== (i = t.args) && void 0 !== i ? i : {};
            Q(s) || Object(c.a)(0, "".concat(e.name, ".").concat(n, " args must be an object with argument names as keys."));
            var u = Object(r.a)(s).map((function(e) {
                var t = e[0]
                  , n = e[1];
                return {
                    name: t,
                    description: n.description,
                    type: n.type,
                    defaultValue: n.defaultValue,
                    deprecationReason: n.deprecationReason,
                    extensions: n.extensions && Object(a.a)(n.extensions),
                    astNode: n.astNode
                }
            }
            ));
            return {
                name: n,
                description: t.description,
                type: t.type,
                args: u,
                resolve: t.resolve,
                subscribe: t.subscribe,
                isDeprecated: null != t.deprecationReason,
                deprecationReason: t.deprecationReason,
                extensions: t.extensions && Object(a.a)(t.extensions),
                astNode: t.astNode
            }
        }
        ))
    }
    function Q(e) {
        return Object(d.a)(e) && !Array.isArray(e)
    }
    function B(e) {
        return s(e, (function(e) {
            return {
                description: e.description,
                type: e.type,
                args: G(e.args),
                resolve: e.resolve,
                subscribe: e.subscribe,
                deprecationReason: e.deprecationReason,
                extensions: e.extensions,
                astNode: e.astNode
            }
        }
        ))
    }
    function G(e) {
        return u(e, (function(e) {
            return e.name
        }
        ), (function(e) {
            return {
                description: e.description,
                type: e.type,
                defaultValue: e.defaultValue,
                deprecationReason: e.deprecationReason,
                extensions: e.extensions,
                astNode: e.astNode
            }
        }
        ))
    }
    Object(f.a)(V);
    var z = function() {
        function e(e) {
            this.name = e.name,
            this.description = e.description,
            this.resolveType = e.resolveType,
            this.extensions = e.extensions && Object(a.a)(e.extensions),
            this.astNode = e.astNode,
            this.extensionASTNodes = j(e.extensionASTNodes),
            this._fields = q.bind(void 0, e),
            this._interfaces = U.bind(void 0, e),
            "string" === typeof e.name || Object(c.a)(0, "Must provide name."),
            null == e.resolveType || "function" === typeof e.resolveType || Object(c.a)(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat(Object(o.a)(e.resolveType), "."))
        }
        var t = e.prototype;
        return t.getFields = function() {
            return "function" === typeof this._fields && (this._fields = this._fields()),
            this._fields
        }
        ,
        t.getInterfaces = function() {
            return "function" === typeof this._interfaces && (this._interfaces = this._interfaces()),
            this._interfaces
        }
        ,
        t.toConfig = function() {
            var e;
            return {
                name: this.name,
                description: this.description,
                interfaces: this.getInterfaces(),
                fields: B(this.getFields()),
                resolveType: this.resolveType,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: null !== (e = this.extensionASTNodes) && void 0 !== e ? e : []
            }
        }
        ,
        t.toString = function() {
            return this.name
        }
        ,
        t.toJSON = function() {
            return this.toString()
        }
        ,
        I(e, [{
            key: i.a,
            get: function() {
                return "GraphQLInterfaceType"
            }
        }]),
        e
    }();
    Object(f.a)(z);
    var H = function() {
        function e(e) {
            this.name = e.name,
            this.description = e.description,
            this.resolveType = e.resolveType,
            this.extensions = e.extensions && Object(a.a)(e.extensions),
            this.astNode = e.astNode,
            this.extensionASTNodes = j(e.extensionASTNodes),
            this._types = K.bind(void 0, e),
            "string" === typeof e.name || Object(c.a)(0, "Must provide name."),
            null == e.resolveType || "function" === typeof e.resolveType || Object(c.a)(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat(Object(o.a)(e.resolveType), "."))
        }
        var t = e.prototype;
        return t.getTypes = function() {
            return "function" === typeof this._types && (this._types = this._types()),
            this._types
        }
        ,
        t.toConfig = function() {
            var e;
            return {
                name: this.name,
                description: this.description,
                types: this.getTypes(),
                resolveType: this.resolveType,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: null !== (e = this.extensionASTNodes) && void 0 !== e ? e : []
            }
        }
        ,
        t.toString = function() {
            return this.name
        }
        ,
        t.toJSON = function() {
            return this.toString()
        }
        ,
        I(e, [{
            key: i.a,
            get: function() {
                return "GraphQLUnionType"
            }
        }]),
        e
    }();
    function K(e) {
        var t = k(e.types);
        return Array.isArray(t) || Object(c.a)(0, "Must provide Array of types or a function which returns such an array for Union ".concat(e.name, ".")),
        t
    }
    Object(f.a)(H);
    var Y = function() {
        function e(e) {
            var t, n, i, s;
            this.name = e.name,
            this.description = e.description,
            this.extensions = e.extensions && Object(a.a)(e.extensions),
            this.astNode = e.astNode,
            this.extensionASTNodes = j(e.extensionASTNodes),
            this._values = (t = this.name,
            Q(n = e.values) || Object(c.a)(0, "".concat(t, " values must be an object with value names as keys.")),
            Object(r.a)(n).map((function(e) {
                var n = e[0]
                  , r = e[1];
                return Q(r) || Object(c.a)(0, "".concat(t, ".").concat(n, ' must refer to an object with a "value" key ') + "representing an internal value but got: ".concat(Object(o.a)(r), ".")),
                !("isDeprecated"in r) || Object(c.a)(0, "".concat(t, ".").concat(n, ' should provide "deprecationReason" instead of "isDeprecated".')),
                {
                    name: n,
                    description: r.description,
                    value: void 0 !== r.value ? r.value : n,
                    isDeprecated: null != r.deprecationReason,
                    deprecationReason: r.deprecationReason,
                    extensions: r.extensions && Object(a.a)(r.extensions),
                    astNode: r.astNode
                }
            }
            ))),
            this._valueLookup = new Map(this._values.map((function(e) {
                return [e.value, e]
            }
            ))),
            this._nameLookup = (i = this._values,
            s = function(e) {
                return e.name
            }
            ,
            i.reduce((function(e, t) {
                return e[s(t)] = t,
                e
            }
            ), Object.create(null))),
            "string" === typeof e.name || Object(c.a)(0, "Must provide name.")
        }
        var t = e.prototype;
        return t.getValues = function() {
            return this._values
        }
        ,
        t.getValue = function(e) {
            return this._nameLookup[e]
        }
        ,
        t.serialize = function(e) {
            var t = this._valueLookup.get(e);
            if (void 0 === t)
                throw new b.a('Enum "'.concat(this.name, '" cannot represent value: ').concat(Object(o.a)(e)));
            return t.name
        }
        ,
        t.parseValue = function(e) {
            if ("string" !== typeof e) {
                var t = Object(o.a)(e);
                throw new b.a('Enum "'.concat(this.name, '" cannot represent non-string value: ').concat(t, ".") + W(this, t))
            }
            var n = this.getValue(e);
            if (null == n)
                throw new b.a('Value "'.concat(e, '" does not exist in "').concat(this.name, '" enum.') + W(this, e));
            return n.value
        }
        ,
        t.parseLiteral = function(e, t) {
            if (e.kind !== _.a.ENUM) {
                var n = Object(S.a)(e);
                throw new b.a('Enum "'.concat(this.name, '" cannot represent non-enum value: ').concat(n, ".") + W(this, n),e)
            }
            var r = this.getValue(e.value);
            if (null == r) {
                var i = Object(S.a)(e);
                throw new b.a('Value "'.concat(i, '" does not exist in "').concat(this.name, '" enum.') + W(this, i),e)
            }
            return r.value
        }
        ,
        t.toConfig = function() {
            var e, t = u(this.getValues(), (function(e) {
                return e.name
            }
            ), (function(e) {
                return {
                    description: e.description,
                    value: e.value,
                    deprecationReason: e.deprecationReason,
                    extensions: e.extensions,
                    astNode: e.astNode
                }
            }
            ));
            return {
                name: this.name,
                description: this.description,
                values: t,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: null !== (e = this.extensionASTNodes) && void 0 !== e ? e : []
            }
        }
        ,
        t.toString = function() {
            return this.name
        }
        ,
        t.toJSON = function() {
            return this.toString()
        }
        ,
        I(e, [{
            key: i.a,
            get: function() {
                return "GraphQLEnumType"
            }
        }]),
        e
    }();
    function W(e, t) {
        return function(e, t) {
            var n = "string" === typeof e ? [e, t] : [void 0, e]
              , r = n[0]
              , i = " Did you mean ";
            r && (i += r + " ");
            var o = n[1].map((function(e) {
                return '"'.concat(e, '"')
            }
            ));
            switch (o.length) {
            case 0:
                return "";
            case 1:
                return i + o[0] + "?";
            case 2:
                return i + o[0] + " or " + o[1] + "?"
            }
            var s = o.slice(0, 5)
              , a = s.pop();
            return i + s.join(", ") + ", or " + a + "?"
        }("the enum value", m(t, e.getValues().map((function(e) {
            return e.name
        }
        ))))
    }
    Object(f.a)(Y);
    var $ = function() {
        function e(e) {
            this.name = e.name,
            this.description = e.description,
            this.extensions = e.extensions && Object(a.a)(e.extensions),
            this.astNode = e.astNode,
            this.extensionASTNodes = j(e.extensionASTNodes),
            this._fields = X.bind(void 0, e),
            "string" === typeof e.name || Object(c.a)(0, "Must provide name.")
        }
        var t = e.prototype;
        return t.getFields = function() {
            return "function" === typeof this._fields && (this._fields = this._fields()),
            this._fields
        }
        ,
        t.toConfig = function() {
            var e, t = s(this.getFields(), (function(e) {
                return {
                    description: e.description,
                    type: e.type,
                    defaultValue: e.defaultValue,
                    extensions: e.extensions,
                    astNode: e.astNode
                }
            }
            ));
            return {
                name: this.name,
                description: this.description,
                fields: t,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: null !== (e = this.extensionASTNodes) && void 0 !== e ? e : []
            }
        }
        ,
        t.toString = function() {
            return this.name
        }
        ,
        t.toJSON = function() {
            return this.toString()
        }
        ,
        I(e, [{
            key: i.a,
            get: function() {
                return "GraphQLInputObjectType"
            }
        }]),
        e
    }();
    function X(e) {
        var t = k(e.fields);
        return Q(t) || Object(c.a)(0, "".concat(e.name, " fields must be an object with field names as keys or a function which returns such an object.")),
        s(t, (function(t, n) {
            return !("resolve"in t) || Object(c.a)(0, "".concat(e.name, ".").concat(n, " field has a resolve property, but Input Types cannot define resolvers.")),
            {
                name: n,
                description: t.description,
                type: t.type,
                defaultValue: t.defaultValue,
                deprecationReason: t.deprecationReason,
                extensions: t.extensions && Object(a.a)(t.extensions),
                astNode: t.astNode
            }
        }
        ))
    }
    Object(f.a)($)
}
, , function(e, t, n) {
    var r = n(113);
    e.exports = function(e) {
        return Object(r(e))
    }
}
, function(e, t, n) {
    var r = n(24)
      , i = n(175);
    e.exports = r ? i : function(e) {
        return Map.prototype.entries.call(e)
    }
}
, function(e, t, n) {
    "use strict";
    let r, i;
    function o() {
        return r
    }
    function s() {
        return i.now() + r
    }
    function a() {
        return i.now()
    }
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    i = window.performance,
    r = 25
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var r = function() {
        return "function" === typeof Symbol && Symbol.observable || "@@observable"
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    let r = {};
    function i() {
        return r
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(106);
    class i extends r.a {
        constructor(e, t, n, r) {
            super(e, n, r),
            this.managerInner = t,
            this.op = t.op,
            this.value = t.value
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(1)
      , i = n(92);
    class o extends i.a {
        constructor(e, t, n, i, s, a) {
            e || (e = "uncaught logic error");
            let c = e;
            c += " -- logic => id: ".concat(n.logicId, ", name: ").concat(n[r.q]),
            c += s ? ", method: ".concat(s, ", cycle op: ").concat(t.op) : ", method: ".concat(t.op);
            const u = t.logicArray[t.logicIdx];
            c += " -- currently executing logic => ",
            u ? u[r.m] === n[r.m] ? c += "(same)" : c += "id: ".concat(u[r.m], ", name: ").concat(n[r.q], ", method: ").concat(t.op) : c += "(none)",
            super(c, t, i, a),
            this.rawMessage = e,
            this.childError = i && i instanceof o ? i : void 0,
            this.logic = n,
            this.logicId = n[r.m],
            this.logicName = n[r.q],
            this.logicMethod = s || t.op,
            u && (this.currentLogicId = u[r.m],
            this.currentLogicName = u[r.q]),
            this.currentLogicMethod = t.op
        }
        getOriginalChildError() {
            let e = this;
            for (; e.childError; )
                e = e.childError;
            return e
        }
    }
}
, function(e, t, n) {
    var r = n(39)
      , i = n(64)
      , o = n(56)
      , s = n(253)
      , a = n(315)
      , c = n(60)
      , u = c.get
      , l = c.enforce
      , d = String(String).split("String");
    (e.exports = function(e, t, n, a) {
        var c = !!a && !!a.unsafe
          , u = !!a && !!a.enumerable
          , h = !!a && !!a.noTargetGet;
        "function" == typeof n && ("string" != typeof t || o(n, "name") || i(n, "name", t),
        l(n).source = d.join("string" == typeof t ? t : "")),
        e !== r ? (c ? !h && e[t] && (u = !0) : delete e[t],
        u ? e[t] = n : i(e, t, n)) : u ? e[t] = n : s(t, n)
    }
    )(Function.prototype, "toString", (function() {
        return "function" == typeof this && u(this).source || a(this)
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(39)
      , o = n(53)
      , s = n(261)
      , a = n(115)
      , c = n(467)
      , u = n(117)
      , l = n(128)
      , d = n(64)
      , h = n(65)
      , f = n(323)
      , p = n(325)
      , g = n(204)
      , m = n(56)
      , y = n(210)
      , v = n(51)
      , b = n(112)
      , _ = n(144)
      , S = n(259).f
      , O = n(326)
      , T = n(327).forEach
      , I = n(263)
      , x = n(50)
      , w = n(258)
      , M = n(60)
      , A = n(328)
      , E = M.get
      , C = M.set
      , N = x.f
      , R = w.f
      , P = Math.round
      , D = i.RangeError
      , F = c.ArrayBuffer
      , k = c.DataView
      , j = a.NATIVE_ARRAY_BUFFER_VIEWS
      , L = a.TYPED_ARRAY_TAG
      , V = a.TypedArray
      , U = a.TypedArrayPrototype
      , q = a.aTypedArrayConstructor
      , Q = a.isTypedArray
      , B = function(e, t) {
        for (var n = 0, r = t.length, i = new (q(e))(r); r > n; )
            i[n] = t[n++];
        return i
    }
      , G = function(e, t) {
        N(e, t, {
            get: function() {
                return E(this)[t]
            }
        })
    }
      , z = function(e) {
        var t;
        return e instanceof F || "ArrayBuffer" == (t = y(e)) || "SharedArrayBuffer" == t
    }
      , H = function(e, t) {
        return Q(e) && "symbol" != typeof t && t in e && String(+t) == String(t)
    }
      , K = function(e, t) {
        return H(e, t = g(t, !0)) ? l(2, e[t]) : R(e, t)
    }
      , Y = function(e, t, n) {
        return !(H(e, t = g(t, !0)) && v(n) && m(n, "value")) || m(n, "get") || m(n, "set") || n.configurable || m(n, "writable") && !n.writable || m(n, "enumerable") && !n.enumerable ? N(e, t, n) : (e[t] = n.value,
        e)
    };
    o ? (j || (w.f = K,
    x.f = Y,
    G(U, "buffer"),
    G(U, "byteOffset"),
    G(U, "byteLength"),
    G(U, "length")),
    r({
        target: "Object",
        stat: !0,
        forced: !j
    }, {
        getOwnPropertyDescriptor: K,
        defineProperty: Y
    }),
    e.exports = function(e, t, n) {
        var o = e.match(/\d+$/)[0] / 8
          , a = e + (n ? "Clamped" : "") + "Array"
          , c = "get" + e
          , l = "set" + e
          , g = i[a]
          , m = g
          , y = m && m.prototype
          , x = {}
          , w = function(e, t) {
            N(e, t, {
                get: function() {
                    return function(e, t) {
                        var n = E(e);
                        return n.view[c](t * o + n.byteOffset, !0)
                    }(this, t)
                },
                set: function(e) {
                    return function(e, t, r) {
                        var i = E(e);
                        n && (r = (r = P(r)) < 0 ? 0 : r > 255 ? 255 : 255 & r),
                        i.view[l](t * o + i.byteOffset, r, !0)
                    }(this, t, e)
                },
                enumerable: !0
            })
        };
        j ? s && (m = t((function(e, t, n, r) {
            return u(e, m, a),
            A(v(t) ? z(t) ? void 0 !== r ? new g(t,p(n, o),r) : void 0 !== n ? new g(t,p(n, o)) : new g(t) : Q(t) ? B(m, t) : O.call(m, t) : new g(f(t)), e, m)
        }
        )),
        _ && _(m, V),
        T(S(g), (function(e) {
            e in m || d(m, e, g[e])
        }
        )),
        m.prototype = y) : (m = t((function(e, t, n, r) {
            u(e, m, a);
            var i, s, c, l = 0, d = 0;
            if (v(t)) {
                if (!z(t))
                    return Q(t) ? B(m, t) : O.call(m, t);
                i = t,
                d = p(n, o);
                var g = t.byteLength;
                if (void 0 === r) {
                    if (g % o)
                        throw D("Wrong length");
                    if ((s = g - d) < 0)
                        throw D("Wrong length")
                } else if ((s = h(r) * o) + d > g)
                    throw D("Wrong length");
                c = s / o
            } else
                c = f(t),
                i = new F(s = c * o);
            for (C(e, {
                buffer: i,
                byteOffset: d,
                byteLength: s,
                length: c,
                view: new k(i)
            }); l < c; )
                w(e, l++)
        }
        )),
        _ && _(m, V),
        y = m.prototype = b(U)),
        y.constructor !== m && d(y, "constructor", m),
        L && d(y, L, a),
        x[a] = m,
        r({
            global: !0,
            forced: m != g,
            sham: !j
        }, x),
        "BYTES_PER_ELEMENT"in m || d(m, "BYTES_PER_ELEMENT", o),
        "BYTES_PER_ELEMENT"in y || d(y, "BYTES_PER_ELEMENT", o),
        I(a)
    }
    ) : e.exports = function() {}
}
, function(e, t, n) {
    var r = n(331)
      , i = n(334)
      , o = n(252)("metadata")
      , s = o.store || (o.store = new i)
      , a = function(e, t, n) {
        var i = s.get(e);
        if (!i) {
            if (!n)
                return;
            s.set(e, i = new r)
        }
        var o = i.get(t);
        if (!o) {
            if (!n)
                return;
            i.set(t, o = new r)
        }
        return o
    };
    e.exports = {
        store: s,
        getMap: a,
        has: function(e, t, n) {
            var r = a(t, n, !1);
            return void 0 !== r && r.has(e)
        },
        get: function(e, t, n) {
            var r = a(t, n, !1);
            return void 0 === r ? void 0 : r.get(e)
        },
        set: function(e, t, n, r) {
            a(n, r, !0).set(e, t)
        },
        keys: function(e, t) {
            var n = a(e, t, !1)
              , r = [];
            return n && n.forEach((function(e, t) {
                r.push(t)
            }
            )),
            r
        },
        toKey: function(e) {
            return void 0 === e || "symbol" == typeof e ? e : String(e)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "d", (function() {
        return r
    }
    )),
    n.d(t, "e", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "b", (function() {
        return a
    }
    )),
    n.d(t, "f", (function() {
        return u
    }
    ));
    const r = "_uid_"
      , i = "c_".concat(r)
      , o = "i_".concat("_ts_")
      , s = {
        TS_ACTION_FIELD: "_tsAction_",
        TS_FIELD: "_ts_",
        TS_CREATE_FIELD: "_tsCreate_",
        TS_SESSION_ID_FIELD: "_tsSessionId_",
        TS_UPDATE_COUNT_FIELD: "_tsUpdateCount_",
        PERM_REC_READ: "_perm_rec_read_",
        PERM_REC_UPDATE: "_perm_rec_update_",
        PERM_REC_DELETE: "_perm_rec_delete_",
        UID: r,
        PERM_READ_ID: "_permReadId_",
        PERM_UPDATE_ID: "_permUpdateId_",
        PERM_DELETE_ID: "_permDeleteId_",
        VALID_TO_TS: "_valid_to_"
    }
      , a = {
        PERM_READ_ROLES_DATA: "_permReadRolesData",
        PERM_UPDATE_ROLES_DATA: "_permUpdateRolesData",
        PERM_DELETE_ROLES_DATA: "_permDeleteRolesData"
    };
    const c = e => "The ID of the Permission that a User must have to ".concat(e, " the record.");
    function u(e) {
        switch (e) {
        case "_ts_":
            return "The timestamp of the latest change to the Record represented as the number of seconds since the Unix Epoch.";
        case "_tsAction_":
            return 'The type of mutation associated with the timestamp ("'.concat("_ts_", '") field.');
        case "_tsSessionId_":
            return "The ID of the Session that was last used to make a change to the Record, if any.";
        case "_tsCreate_":
            return "The timestamp of when the record was created, represented as the number of seconds since the Unix Epoch.";
        case "_tsUpdateCount_":
            return "The number of times the record has been updated after it was created.";
        case "_valid_to_":
            return 'The timestamp (number of seconds since the Unix Epoch) of when the entry ceased being the most recent representation of the record in the "standard" model that the entry is tracking. If it is currently the most recent representation, its value will be 2147483647.';
        case "_perm_rec_read_":
        case s.PERM_READ_ID:
            return c("read");
        case "_perm_rec_update_":
        case s.PERM_UPDATE_ID:
            return c("update");
        case "_perm_rec_delete_":
        case s.PERM_DELETE_ID:
            return c("delete");
        case r:
            return "An immutable, globally unique id for the record."
        }
    }
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    , o = n(649), s = (r = o) && r.__esModule ? r : {
        default: r
    };
    var a = "object" == ("undefined" === typeof self ? "undefined" : i(self)) && self && self.Object === Object && self
      , c = s.default || a || Function("return this")();
    t.default = c,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(607), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e, t) {
        return (0,
        o.default)(e, t)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "d", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    ));
    const r = "CREATE_PENDING_STORE"
      , i = "TRX_ACTION_STANDARD"
      , o = "TRX_ACTION_COMMIT_ONLY"
      , s = "@isomorix/core-actions/MUTATION"
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return e && "function" === typeof e.schedule
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(91)
      , i = n(20);
    function o(e, t) {
        var n, o, s, a, c, u, l, d;
        const h = Object(r.a)()
          , f = null !== (n = null !== (o = null !== (s = null !== (a = null === t || void 0 === t ? void 0 : t.weekStartsOn) && void 0 !== a ? a : null === t || void 0 === t || null === (c = t.locale) || void 0 === c || null === (u = c.options) || void 0 === u ? void 0 : u.weekStartsOn) && void 0 !== s ? s : h.weekStartsOn) && void 0 !== o ? o : null === (l = h.locale) || void 0 === l || null === (d = l.options) || void 0 === d ? void 0 : d.weekStartsOn) && void 0 !== n ? n : 0
          , p = Object(i.a)(e, null === t || void 0 === t ? void 0 : t.in)
          , g = p.getDay()
          , m = (g < f ? 7 : 0) + g - f;
        return p.setDate(p.getDate() - m),
        p.setHours(0, 0, 0, 0),
        p
    }
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return (r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    function i(e) {
        return "object" == r(e) && null !== e
    }
    n.d(t, "a", (function() {
        return i
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var r = Object.entries || function(e) {
        return Object.keys(e).map((function(t) {
            return [t, e[t]]
        }
        ))
    }
    ;
    t.a = r
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        setTimeout((function() {
            throw e
        }
        ), 0)
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    class r extends Error {
        constructor(e, t, n) {
            if (super(e),
            "function" === typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e).stack,
            this.name = this.constructor.name,
            t) {
                if (0 !== n) {
                    this.newStack = this.stack;
                    let e = (this.message.match(/\n/g) || []).length + 1;
                    this.stack = this.stack.split("\n").slice(0, e + (n || 1)).join("\n") + "\n" + t.stack
                }
                this.original = t
            } else
                this.original = void 0
        }
        getOriginalChildError() {
            return this
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(84)
      , i = n(230);
    function o(e) {
        return Object(r.a)(e, {
            leave: s
        })
    }
    var s = {
        Name: function(e) {
            return e.value
        },
        Variable: function(e) {
            return "$" + e.name
        },
        Document: function(e) {
            return c(e.definitions, "\n\n") + "\n"
        },
        OperationDefinition: function(e) {
            var t = e.operation
              , n = e.name
              , r = l("(", c(e.variableDefinitions, ", "), ")")
              , i = c(e.directives, " ")
              , o = e.selectionSet;
            return n || i || r || "query" !== t ? c([t, c([n, r]), i, o], " ") : o
        },
        VariableDefinition: function(e) {
            var t = e.variable
              , n = e.type
              , r = e.defaultValue
              , i = e.directives;
            return t + ": " + n + l(" = ", r) + l(" ", c(i, " "))
        },
        SelectionSet: function(e) {
            return u(e.selections)
        },
        Field: function(e) {
            var t = e.alias
              , n = e.name
              , r = e.arguments
              , i = e.directives
              , o = e.selectionSet
              , s = l("", t, ": ") + n
              , a = s + l("(", c(r, ", "), ")");
            return a.length > 80 && (a = s + l("(\n", d(c(r, "\n")), "\n)")),
            c([a, c(i, " "), o], " ")
        },
        Argument: function(e) {
            return e.name + ": " + e.value
        },
        FragmentSpread: function(e) {
            return "..." + e.name + l(" ", c(e.directives, " "))
        },
        InlineFragment: function(e) {
            var t = e.typeCondition
              , n = e.directives
              , r = e.selectionSet;
            return c(["...", l("on ", t), c(n, " "), r], " ")
        },
        FragmentDefinition: function(e) {
            var t = e.name
              , n = e.typeCondition
              , r = e.variableDefinitions
              , i = e.directives
              , o = e.selectionSet;
            return "fragment ".concat(t).concat(l("(", c(r, ", "), ")"), " ") + "on ".concat(n, " ").concat(l("", c(i, " "), " ")) + o
        },
        IntValue: function(e) {
            return e.value
        },
        FloatValue: function(e) {
            return e.value
        },
        StringValue: function(e, t) {
            var n = e.value;
            return e.block ? Object(i.b)(n, "description" === t ? "" : "  ") : JSON.stringify(n)
        },
        BooleanValue: function(e) {
            return e.value ? "true" : "false"
        },
        NullValue: function() {
            return "null"
        },
        EnumValue: function(e) {
            return e.value
        },
        ListValue: function(e) {
            return "[" + c(e.values, ", ") + "]"
        },
        ObjectValue: function(e) {
            return "{" + c(e.fields, ", ") + "}"
        },
        ObjectField: function(e) {
            return e.name + ": " + e.value
        },
        Directive: function(e) {
            return "@" + e.name + l("(", c(e.arguments, ", "), ")")
        },
        NamedType: function(e) {
            return e.name
        },
        ListType: function(e) {
            return "[" + e.type + "]"
        },
        NonNullType: function(e) {
            return e.type + "!"
        },
        SchemaDefinition: a((function(e) {
            var t = e.directives
              , n = e.operationTypes;
            return c(["schema", c(t, " "), u(n)], " ")
        }
        )),
        OperationTypeDefinition: function(e) {
            return e.operation + ": " + e.type
        },
        ScalarTypeDefinition: a((function(e) {
            return c(["scalar", e.name, c(e.directives, " ")], " ")
        }
        )),
        ObjectTypeDefinition: a((function(e) {
            var t = e.name
              , n = e.interfaces
              , r = e.directives
              , i = e.fields;
            return c(["type", t, l("implements ", c(n, " & ")), c(r, " "), u(i)], " ")
        }
        )),
        FieldDefinition: a((function(e) {
            var t = e.name
              , n = e.arguments
              , r = e.type
              , i = e.directives;
            return t + (f(n) ? l("(\n", d(c(n, "\n")), "\n)") : l("(", c(n, ", "), ")")) + ": " + r + l(" ", c(i, " "))
        }
        )),
        InputValueDefinition: a((function(e) {
            var t = e.name
              , n = e.type
              , r = e.defaultValue
              , i = e.directives;
            return c([t + ": " + n, l("= ", r), c(i, " ")], " ")
        }
        )),
        InterfaceTypeDefinition: a((function(e) {
            var t = e.name
              , n = e.interfaces
              , r = e.directives
              , i = e.fields;
            return c(["interface", t, l("implements ", c(n, " & ")), c(r, " "), u(i)], " ")
        }
        )),
        UnionTypeDefinition: a((function(e) {
            var t = e.name
              , n = e.directives
              , r = e.types;
            return c(["union", t, c(n, " "), r && 0 !== r.length ? "= " + c(r, " | ") : ""], " ")
        }
        )),
        EnumTypeDefinition: a((function(e) {
            var t = e.name
              , n = e.directives
              , r = e.values;
            return c(["enum", t, c(n, " "), u(r)], " ")
        }
        )),
        EnumValueDefinition: a((function(e) {
            return c([e.name, c(e.directives, " ")], " ")
        }
        )),
        InputObjectTypeDefinition: a((function(e) {
            var t = e.name
              , n = e.directives
              , r = e.fields;
            return c(["input", t, c(n, " "), u(r)], " ")
        }
        )),
        DirectiveDefinition: a((function(e) {
            var t = e.name
              , n = e.arguments
              , r = e.repeatable
              , i = e.locations;
            return "directive @" + t + (f(n) ? l("(\n", d(c(n, "\n")), "\n)") : l("(", c(n, ", "), ")")) + (r ? " repeatable" : "") + " on " + c(i, " | ")
        }
        )),
        SchemaExtension: function(e) {
            var t = e.directives
              , n = e.operationTypes;
            return c(["extend schema", c(t, " "), u(n)], " ")
        },
        ScalarTypeExtension: function(e) {
            return c(["extend scalar", e.name, c(e.directives, " ")], " ")
        },
        ObjectTypeExtension: function(e) {
            var t = e.name
              , n = e.interfaces
              , r = e.directives
              , i = e.fields;
            return c(["extend type", t, l("implements ", c(n, " & ")), c(r, " "), u(i)], " ")
        },
        InterfaceTypeExtension: function(e) {
            var t = e.name
              , n = e.interfaces
              , r = e.directives
              , i = e.fields;
            return c(["extend interface", t, l("implements ", c(n, " & ")), c(r, " "), u(i)], " ")
        },
        UnionTypeExtension: function(e) {
            var t = e.name
              , n = e.directives
              , r = e.types;
            return c(["extend union", t, c(n, " "), r && 0 !== r.length ? "= " + c(r, " | ") : ""], " ")
        },
        EnumTypeExtension: function(e) {
            var t = e.name
              , n = e.directives
              , r = e.values;
            return c(["extend enum", t, c(n, " "), u(r)], " ")
        },
        InputObjectTypeExtension: function(e) {
            var t = e.name
              , n = e.directives
              , r = e.fields;
            return c(["extend input", t, c(n, " "), u(r)], " ")
        }
    };
    function a(e) {
        return function(t) {
            return c([t.description, e(t)], "\n")
        }
    }
    function c(e) {
        var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        return null !== (t = null === e || void 0 === e ? void 0 : e.filter((function(e) {
            return e
        }
        )).join(n)) && void 0 !== t ? t : ""
    }
    function u(e) {
        return l("{\n", d(c(e, "\n")), "\n}")
    }
    function l(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
        return null != t && "" !== t ? e + t + n : ""
    }
    function d(e) {
        return l("  ", e.replace(/\n/g, "\n  "))
    }
    function h(e) {
        return -1 !== e.indexOf("\n")
    }
    function f(e) {
        return null != e && e.some(h)
    }
}
, , , , , function(e, t, n) {
    var r, i = n(18), o = n(308), s = n(256), a = n(207), c = n(312), u = n(254), l = n(257), d = l("IE_PROTO"), h = function() {}, f = function(e) {
        return "<script>" + e + "<\/script>"
    }, p = function() {
        try {
            r = document.domain && new ActiveXObject("htmlfile")
        } catch (t) {}
        p = r ? function(e) {
            e.write(f("")),
            e.close();
            var t = e.parentWindow.Object;
            return e = null,
            t
        }(r) : function() {
            var e, t = u("iframe");
            return t.style.display = "none",
            c.appendChild(t),
            t.src = String("javascript:"),
            (e = t.contentWindow.document).open(),
            e.write(f("document.F=Object")),
            e.close(),
            e.F
        }();
        for (var e = s.length; e--; )
            delete p.prototype[s[e]];
        return p()
    };
    a[d] = !0,
    e.exports = Object.create || function(e, t) {
        var n;
        return null !== e ? (h.prototype = i(e),
        n = new h,
        h.prototype = null,
        n[d] = e) : n = p(),
        void 0 === t ? n : o(n, t)
    }
}
, function(e, t) {
    e.exports = function(e) {
        if (void 0 == e)
            throw TypeError("Can't call method on " + e);
        return e
    }
}
, function(e, t) {
    var n = Math.ceil
      , r = Math.floor;
    e.exports = function(e) {
        return isNaN(e = +e) ? 0 : (e > 0 ? r : n)(e)
    }
}
, function(e, t, n) {
    "use strict";
    var r, i = n(322), o = n(53), s = n(39), a = n(51), c = n(56), u = n(210), l = n(64), d = n(94), h = n(50).f, f = n(116), p = n(144), g = n(40), m = n(205), y = s.Int8Array, v = y && y.prototype, b = s.Uint8ClampedArray, _ = b && b.prototype, S = y && f(y), O = v && f(v), T = Object.prototype, I = T.isPrototypeOf, x = g("toStringTag"), w = m("TYPED_ARRAY_TAG"), M = i && !!p && "Opera" !== u(s.opera), A = !1, E = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
    }, C = function(e) {
        return a(e) && c(E, u(e))
    };
    for (r in E)
        s[r] || (M = !1);
    if ((!M || "function" != typeof S || S === Function.prototype) && (S = function() {
        throw TypeError("Incorrect invocation")
    }
    ,
    M))
        for (r in E)
            s[r] && p(s[r], S);
    if ((!M || !O || O === T) && (O = S.prototype,
    M))
        for (r in E)
            s[r] && p(s[r].prototype, O);
    if (M && f(_) !== O && p(_, O),
    o && !c(O, x))
        for (r in A = !0,
        h(O, x, {
            get: function() {
                return a(this) ? this[w] : void 0
            }
        }),
        E)
            s[r] && l(s[r], w, r);
    e.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: M,
        TYPED_ARRAY_TAG: A && w,
        aTypedArray: function(e) {
            if (C(e))
                return e;
            throw TypeError("Target is not a typed array")
        },
        aTypedArrayConstructor: function(e) {
            if (p) {
                if (I.call(S, e))
                    return e
            } else
                for (var t in E)
                    if (c(E, r)) {
                        var n = s[t];
                        if (n && (e === n || I.call(n, e)))
                            return e
                    }
            throw TypeError("Target is not a typed array constructor")
        },
        exportTypedArrayMethod: function(e, t, n) {
            if (o) {
                if (n)
                    for (var r in E) {
                        var i = s[r];
                        i && c(i.prototype, e) && delete i.prototype[e]
                    }
                O[e] && !n || d(O, e, n ? t : M && v[e] || t)
            }
        },
        exportTypedArrayStaticMethod: function(e, t, n) {
            var r, i;
            if (o) {
                if (p) {
                    if (n)
                        for (r in E)
                            (i = s[r]) && c(i, e) && delete i[e];
                    if (S[e] && !n)
                        return;
                    try {
                        return d(S, e, n ? t : M && y[e] || t)
                    } catch (a) {}
                }
                for (r in E)
                    !(i = s[r]) || i[e] && !n || d(i, e, t)
            }
        },
        isView: function(e) {
            var t = u(e);
            return "DataView" === t || c(E, t)
        },
        isTypedArray: C,
        TypedArray: S,
        TypedArrayPrototype: O
    }
}
, function(e, t, n) {
    var r = n(56)
      , i = n(87)
      , o = n(257)
      , s = n(465)
      , a = o("IE_PROTO")
      , c = Object.prototype;
    e.exports = s ? Object.getPrototypeOf : function(e) {
        return e = i(e),
        r(e, a) ? e[a] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? c : null
    }
}
, function(e, t) {
    e.exports = function(e, t, n) {
        if (!(e instanceof t))
            throw TypeError("Incorrect " + (n ? n + " " : "") + "invocation");
        return e
    }
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return function t(n, o) {
            switch (arguments.length) {
            case 0:
                return t;
            case 1:
                return (0,
                i.default)(n) ? t : (0,
                r.default)((function(t) {
                    return e(n, t)
                }
                ));
            default:
                return (0,
                i.default)(n) && (0,
                i.default)(o) ? t : (0,
                i.default)(n) ? (0,
                r.default)((function(t) {
                    return e(t, o)
                }
                )) : (0,
                i.default)(o) ? (0,
                r.default)((function(t) {
                    return e(n, t)
                }
                )) : e(n, o)
            }
        }
    }
    ;
    var r = o(n(810))
      , i = o(n(811));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    function r() {
        return "function" === typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"
    }
    n.d(t, "a", (function() {
        return i
    }
    ));
    var i = r()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    ));
    var r = n(26)
      , i = new r.a((function(e) {
        return e.complete()
    }
    ));
    function o(e) {
        return e ? function(e) {
            return new r.a((function(t) {
                return e.schedule((function() {
                    return t.complete()
                }
                ))
            }
            ))
        }(e) : i
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return l
    }
    )),
    n.d(t, "a", (function() {
        return d
    }
    ));
    var r = n(14)
      , i = n(26)
      , o = n(22)
      , s = n(38)
      , a = n(122)
      , c = n(226)
      , u = n(132)
      , l = function(e) {
        function t(t) {
            var n = e.call(this, t) || this;
            return n.destination = t,
            n
        }
        return r.a(t, e),
        t
    }(o.a)
      , d = function(e) {
        function t() {
            var t = e.call(this) || this;
            return t.observers = [],
            t.closed = !1,
            t.isStopped = !1,
            t.hasError = !1,
            t.thrownError = null,
            t
        }
        return r.a(t, e),
        t.prototype[u.a] = function() {
            return new l(this)
        }
        ,
        t.prototype.lift = function(e) {
            var t = new h(this,this);
            return t.operator = e,
            t
        }
        ,
        t.prototype.next = function(e) {
            if (this.closed)
                throw new a.a;
            if (!this.isStopped)
                for (var t = this.observers, n = t.length, r = t.slice(), i = 0; i < n; i++)
                    r[i].next(e)
        }
        ,
        t.prototype.error = function(e) {
            if (this.closed)
                throw new a.a;
            this.hasError = !0,
            this.thrownError = e,
            this.isStopped = !0;
            for (var t = this.observers, n = t.length, r = t.slice(), i = 0; i < n; i++)
                r[i].error(e);
            this.observers.length = 0
        }
        ,
        t.prototype.complete = function() {
            if (this.closed)
                throw new a.a;
            this.isStopped = !0;
            for (var e = this.observers, t = e.length, n = e.slice(), r = 0; r < t; r++)
                n[r].complete();
            this.observers.length = 0
        }
        ,
        t.prototype.unsubscribe = function() {
            this.isStopped = !0,
            this.closed = !0,
            this.observers = null
        }
        ,
        t.prototype._trySubscribe = function(t) {
            if (this.closed)
                throw new a.a;
            return e.prototype._trySubscribe.call(this, t)
        }
        ,
        t.prototype._subscribe = function(e) {
            if (this.closed)
                throw new a.a;
            return this.hasError ? (e.error(this.thrownError),
            s.a.EMPTY) : this.isStopped ? (e.complete(),
            s.a.EMPTY) : (this.observers.push(e),
            new c.a(this,e))
        }
        ,
        t.prototype.asObservable = function() {
            var e = new i.a;
            return e.source = this,
            e
        }
        ,
        t.create = function(e, t) {
            return new h(e,t)
        }
        ,
        t
    }(i.a)
      , h = function(e) {
        function t(t, n) {
            var r = e.call(this) || this;
            return r.destination = t,
            r.source = n,
            r
        }
        return r.a(t, e),
        t.prototype.next = function(e) {
            var t = this.destination;
            t && t.next && t.next(e)
        }
        ,
        t.prototype.error = function(e) {
            var t = this.destination;
            t && t.error && this.destination.error(e)
        }
        ,
        t.prototype.complete = function() {
            var e = this.destination;
            e && e.complete && this.destination.complete()
        }
        ,
        t.prototype._subscribe = function(e) {
            return this.source ? this.source.subscribe(e) : s.a.EMPTY
        }
        ,
        t
    }(d)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var r = function() {
        function e() {
            return Error.call(this),
            this.message = "object unsubscribed",
            this.name = "ObjectUnsubscribedError",
            this
        }
        return e.prototype = Object.create(Error.prototype),
        e
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return c
    }
    ));
    var r = n(183);
    const {COMMIT: i, OPTIMISTIC: o, NONE: s} = r.a
      , a = {
        enumerable: !1
    };
    class c {
        constructor(e) {
            e && (this.state = {},
            this.changes = void 0,
            this.size = 0,
            this.hasDelete = !1,
            this.hasCreate = !1,
            this.store = void 0,
            this.mainDispatchId = void 0,
            this.dispatchId = void 0,
            this.event = s,
            this.isOptimistic = !0)
        }
        clone(e) {
            const t = e ? new e : new this.constructor;
            for (let n in this)
                t[n] = this[n];
            return t
        }
        cloneDeep() {
            const e = new this.constructor;
            let t;
            for (let n in this)
                t = this[n],
                e[n] = t && "object" === typeof t ? Array.isArray(t) ? [...t] : {
                    ...t
                } : t;
            return e
        }
        cloneNew() {
            const e = new this.constructor
              , {blacklistPropsCloneNew: t} = this.constructor;
            for (let n in this)
                t[n] || (e[n] = this[n]);
            return e
        }
        cloneState() {
            return {
                ...this.state
            }
        }
        createNewState() {
            return {}
        }
        getPrev(e) {
            const {prevState: t} = this;
            return t ? t[e] : void 0
        }
        getFromHistory(e) {
            let t = this.getPrev(e);
            if ("undefined" !== typeof t)
                return t;
            const n = this.history;
            if (n) {
                let r = n.length - 1;
                for (; r >= 0; ) {
                    if (t = n[r].state[e],
                    "undefined" !== typeof t)
                        return t;
                    r--
                }
            }
        }
        trxPrepare() {
            this.store.activeTrxCount++
        }
        optimisticCommit(e) {
            const t = this._prepareCommit(e, o);
            return t.isOptimistic = !0,
            t
        }
        runOptimisticReducers(e) {
            const {store: {reducers: t}} = this;
            if (t)
                for (let n of t)
                    n(this, e)
        }
        commit(e) {
            const t = this._prepareCommit(e, i);
            return t.isOptimistic = !1,
            t
        }
        runReducers(e) {
            const {store: {reducers: t}} = this;
            if (t)
                for (let n of t)
                    n(this, e)
        }
        getPrevState() {
            const {history: e} = this;
            let t;
            if (this.changes)
                t = e[e.length - 1];
            else {
                let n = e.length - 1;
                for (; n >= 0; ) {
                    if (e[n].changes) {
                        t = e[n - 1];
                        break
                    }
                    n--
                }
            }
            return t ? t.state : void 0
        }
        trxComplete() {
            const e = this.store;
            e && e.activeTrxCount--
        }
        deReference() {
            const {deReferenceProps: e} = this.constructor;
            for (let t of e)
                this[t] = void 0
        }
        complete() {
            this.destroy()
        }
        destroy() {
            this.deReference(),
            this.state = void 0,
            this.allChanges = void 0,
            this.changesToCommit = void 0,
            this.changes = void 0
        }
        _prepareCommit(e, t) {}
        get history() {
            return this.store.history
        }
        get prevState() {
            return this.getPrevState()
        }
    }
    c.deReferenceProps = ["store"],
    Object.defineProperties(c.prototype, {
        history: a,
        prevState: a
    })
}
, , , , , function(e, t) {
    e.exports = function(e, t) {
        return {
            enumerable: !(1 & e),
            configurable: !(2 & e),
            writable: !(4 & e),
            value: t
        }
    }
}
, function(e, t) {
    var n = {}.toString;
    e.exports = function(e) {
        return n.call(e).slice(8, -1)
    }
}
, function(e, t, n) {
    var r = n(24)
      , i = n(175);
    e.exports = r ? i : function(e) {
        return Set.prototype.values.call(e)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "c", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    ));
    const r = "create"
      , i = "update"
      , o = "delete"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var r = function() {
        return "function" === typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random()
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var r = function() {
        return Array.isArray || function(e) {
            return e && "number" === typeof e.length
        }
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return i
    }
    ));
    const r = "standardTrx"
      , i = "commitOnlyTrx"
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(809))
      , i = o(n(812));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = (0,
    r.default)((function(e, t) {
        return (0,
        i.default)((function(e, t, n) {
            return n
        }
        ), e, t)
    }
    ));
    t.default = s,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var r = n(58)
      , i = n(876)
      , o = n(193)
      , s = n(874);
    const a = i.a.initModule("@isomorix/logic/record/logic").addSource(o.b).add(o.c).add(o.d)
      , c = s.a.getByActionType(r.n);
    for (let u of c)
        a.add(u)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return k
    }
    )),
    n.d(t, "b", (function() {
        return j
    }
    )),
    n.d(t, "c", (function() {
        return F
    }
    ));
    var r = n(389);
    function i(e, t, n) {
        const r = function(e, t, n) {
            return new Intl.DateTimeFormat(n ? [n.code, "en-US"] : void 0,{
                timeZone: t,
                timeZoneName: e
            })
        }(e, n.timeZone, n.locale);
        return "formatToParts"in r ? function(e, t) {
            const n = e.formatToParts(t);
            for (let r = n.length - 1; r >= 0; --r)
                if ("timeZoneName" === n[r].type)
                    return n[r].value;
            return
        }(r, t) : function(e, t) {
            const n = e.format(t).replace(/\u200E/g, "")
              , r = / [\w-+ ]+$/.exec(n);
            return r ? r[0].substr(1) : ""
        }(r, t)
    }
    function o(e, t) {
        const n = function(e) {
            if (!a[e]) {
                const t = new Intl.DateTimeFormat("en-US",{
                    hourCycle: "h23",
                    timeZone: "America/New_York",
                    year: "numeric",
                    month: "2-digit",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit"
                }).format(new Date("2014-06-25T04:00:00.123Z"))
                  , n = "06/25/2014, 00:00:00" === t || "\u200e06\u200e/\u200e25\u200e/\u200e2014\u200e \u200e00\u200e:\u200e00\u200e:\u200e00" === t;
                a[e] = n ? new Intl.DateTimeFormat("en-US",{
                    hourCycle: "h23",
                    timeZone: e,
                    year: "numeric",
                    month: "numeric",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit"
                }) : new Intl.DateTimeFormat("en-US",{
                    hour12: !1,
                    timeZone: e,
                    year: "numeric",
                    month: "numeric",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit"
                })
            }
            return a[e]
        }(t);
        return "formatToParts"in n ? function(e, t) {
            try {
                const n = e.formatToParts(t)
                  , r = [];
                for (let e = 0; e < n.length; e++) {
                    const t = s[n[e].type];
                    void 0 !== t && (r[t] = parseInt(n[e].value, 10))
                }
                return r
            } catch (n) {
                if (n instanceof RangeError)
                    return [NaN];
                throw n
            }
        }(n, e) : function(e, t) {
            const n = e.format(t)
              , r = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(n);
            return [parseInt(r[3], 10), parseInt(r[1], 10), parseInt(r[2], 10), parseInt(r[4], 10), parseInt(r[5], 10), parseInt(r[6], 10)]
        }(n, e)
    }
    const s = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5
    };
    const a = {};
    function c(e, t, n, r, i, o, s) {
        const a = new Date(0);
        return a.setUTCFullYear(e, t, n),
        a.setUTCHours(r, i, o, s),
        a
    }
    const u = {
        timezone: /([Z+-].*)$/,
        timezoneZ: /^(Z)$/,
        timezoneHH: /^([+-]\d{2})$/,
        timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
    };
    function l(e, t, n) {
        if (!e)
            return 0;
        let r, i, o = u.timezoneZ.exec(e);
        if (o)
            return 0;
        if (o = u.timezoneHH.exec(e),
        o)
            return r = parseInt(o[1], 10),
            h(r) ? -36e5 * r : NaN;
        if (o = u.timezoneHHMM.exec(e),
        o) {
            r = parseInt(o[2], 10);
            const e = parseInt(o[3], 10);
            return h(r, e) ? (i = 36e5 * Math.abs(r) + 6e4 * e,
            "+" === o[1] ? -i : i) : NaN
        }
        if (function(e) {
            if (f[e])
                return !0;
            try {
                return new Intl.DateTimeFormat(void 0,{
                    timeZone: e
                }),
                f[e] = !0,
                !0
            } catch (t) {
                return !1
            }
        }(e)) {
            t = new Date(t || Date.now());
            const r = d(n ? t : function(e) {
                return c(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds())
            }(t), e);
            return -(n ? r : function(e, t, n) {
                let r = e.getTime() - t;
                const i = d(new Date(r), n);
                if (t === i)
                    return t;
                r -= i - t;
                const o = d(new Date(r), n);
                if (i === o)
                    return i;
                return Math.max(i, o)
            }(t, r, e))
        }
        return NaN
    }
    function d(e, t) {
        const n = o(e, t)
          , r = c(n[0], n[1] - 1, n[2], n[3] % 24, n[4], n[5], 0).getTime();
        let i = e.getTime();
        const s = i % 1e3;
        return i -= s >= 0 ? s : 1e3 + s,
        r - i
    }
    function h(e, t) {
        return -23 <= e && e <= 23 && (null == t || 0 <= t && t <= 59)
    }
    const f = {};
    const p = {
        X: function(e, t, n) {
            const r = g(n.timeZone, e);
            if (0 === r)
                return "Z";
            switch (t) {
            case "X":
                return v(r);
            case "XXXX":
            case "XX":
                return y(r);
            case "XXXXX":
            case "XXX":
            default:
                return y(r, ":")
            }
        },
        x: function(e, t, n) {
            const r = g(n.timeZone, e);
            switch (t) {
            case "x":
                return v(r);
            case "xxxx":
            case "xx":
                return y(r);
            case "xxxxx":
            case "xxx":
            default:
                return y(r, ":")
            }
        },
        O: function(e, t, n) {
            const r = g(n.timeZone, e);
            switch (t) {
            case "O":
            case "OO":
            case "OOO":
                return "GMT" + function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                    const n = e > 0 ? "-" : "+"
                      , r = Math.abs(e)
                      , i = Math.floor(r / 60)
                      , o = r % 60;
                    if (0 === o)
                        return n + String(i);
                    return n + String(i) + t + m(o, 2)
                }(r, ":");
            case "OOOO":
            default:
                return "GMT" + y(r, ":")
            }
        },
        z: function(e, t, n) {
            switch (t) {
            case "z":
            case "zz":
            case "zzz":
                return i("short", e, n);
            case "zzzz":
            default:
                return i("long", e, n)
            }
        }
    };
    function g(e, t) {
        var n;
        const r = e ? l(e, t, !0) / 6e4 : null !== (n = null === t || void 0 === t ? void 0 : t.getTimezoneOffset()) && void 0 !== n ? n : 0;
        if (Number.isNaN(r))
            throw new RangeError("Invalid time zone specified: " + e);
        return r
    }
    function m(e, t) {
        const n = e < 0 ? "-" : "";
        let r = Math.abs(e).toString();
        for (; r.length < t; )
            r = "0" + r;
        return n + r
    }
    function y(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        const n = e > 0 ? "-" : "+"
          , r = Math.abs(e)
          , i = m(Math.floor(r / 60), 2)
          , o = m(Math.floor(r % 60), 2);
        return n + i + t + o
    }
    function v(e, t) {
        if (e % 60 === 0) {
            return (e > 0 ? "-" : "+") + m(Math.abs(e) / 60, 2)
        }
        return y(e, t)
    }
    function b(e) {
        const t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
        return t.setUTCFullYear(e.getFullYear()),
        +e - +t
    }
    const _ = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/
      , S = {
        dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
        datePattern: /^([0-9W+-]+)(.*)/,
        plainTime: /:/,
        YY: /^(\d{2})$/,
        YYY: [/^([+-]\d{2})$/, /^([+-]\d{3})$/, /^([+-]\d{4})$/],
        YYYY: /^(\d{4})/,
        YYYYY: [/^([+-]\d{4})/, /^([+-]\d{5})/, /^([+-]\d{6})/],
        MM: /^-(\d{2})$/,
        DDD: /^-?(\d{3})$/,
        MMDD: /^-?(\d{2})-?(\d{2})$/,
        Www: /^-?W(\d{2})$/,
        WwwD: /^-?W(\d{2})-?(\d{1})$/,
        HH: /^(\d{2}([.,]\d*)?)$/,
        HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
        HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
        timeZone: _
    };
    function O(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (arguments.length < 1)
            throw new TypeError("1 argument required, but only " + arguments.length + " present");
        if (null === e)
            return new Date(NaN);
        const n = null == t.additionalDigits ? 2 : Number(t.additionalDigits);
        if (2 !== n && 1 !== n && 0 !== n)
            throw new RangeError("additionalDigits must be 0, 1 or 2");
        if (e instanceof Date || "object" === typeof e && "[object Date]" === Object.prototype.toString.call(e))
            return new Date(e.getTime());
        if ("number" === typeof e || "[object Number]" === Object.prototype.toString.call(e))
            return new Date(e);
        if ("[object String]" !== Object.prototype.toString.call(e))
            return new Date(NaN);
        const r = T(e)
          , {year: i, restDateString: o} = I(r.date, n)
          , s = x(o, i);
        if (null === s || isNaN(s.getTime()))
            return new Date(NaN);
        if (s) {
            const e = s.getTime();
            let n, i = 0;
            if (r.time && (i = w(r.time),
            null === i || isNaN(i)))
                return new Date(NaN);
            if (r.timeZone || t.timeZone) {
                if (n = l(r.timeZone || t.timeZone, new Date(e + i)),
                isNaN(n))
                    return new Date(NaN)
            } else
                n = b(new Date(e + i)),
                n = b(new Date(e + i + n));
            return new Date(e + i + n)
        }
        return new Date(NaN)
    }
    function T(e) {
        const t = {};
        let n, r = S.dateTimePattern.exec(e);
        if (r ? (t.date = r[1],
        n = r[3]) : (r = S.datePattern.exec(e),
        r ? (t.date = r[1],
        n = r[2]) : (t.date = null,
        n = e)),
        n) {
            const e = S.timeZone.exec(n);
            e ? (t.time = n.replace(e[1], ""),
            t.timeZone = e[1].trim()) : t.time = n
        }
        return t
    }
    function I(e, t) {
        if (e) {
            const n = S.YYY[t]
              , r = S.YYYYY[t];
            let i = S.YYYY.exec(e) || r.exec(e);
            if (i) {
                const t = i[1];
                return {
                    year: parseInt(t, 10),
                    restDateString: e.slice(t.length)
                }
            }
            if (i = S.YY.exec(e) || n.exec(e),
            i) {
                const t = i[1];
                return {
                    year: 100 * parseInt(t, 10),
                    restDateString: e.slice(t.length)
                }
            }
        }
        return {
            year: null
        }
    }
    function x(e, t) {
        if (null === t)
            return null;
        let n, r, i;
        if (!e || !e.length)
            return n = new Date(0),
            n.setUTCFullYear(t),
            n;
        let o = S.MM.exec(e);
        if (o)
            return n = new Date(0),
            r = parseInt(o[1], 10) - 1,
            N(t, r) ? (n.setUTCFullYear(t, r),
            n) : new Date(NaN);
        if (o = S.DDD.exec(e),
        o) {
            n = new Date(0);
            const e = parseInt(o[1], 10);
            return function(e, t) {
                if (t < 1)
                    return !1;
                const n = C(e);
                if (n && t > 366)
                    return !1;
                if (!n && t > 365)
                    return !1;
                return !0
            }(t, e) ? (n.setUTCFullYear(t, 0, e),
            n) : new Date(NaN)
        }
        if (o = S.MMDD.exec(e),
        o) {
            n = new Date(0),
            r = parseInt(o[1], 10) - 1;
            const e = parseInt(o[2], 10);
            return N(t, r, e) ? (n.setUTCFullYear(t, r, e),
            n) : new Date(NaN)
        }
        if (o = S.Www.exec(e),
        o)
            return i = parseInt(o[1], 10) - 1,
            R(i) ? M(t, i) : new Date(NaN);
        if (o = S.WwwD.exec(e),
        o) {
            i = parseInt(o[1], 10) - 1;
            const e = parseInt(o[2], 10) - 1;
            return R(i, e) ? M(t, i, e) : new Date(NaN)
        }
        return null
    }
    function w(e) {
        let t, n, r = S.HH.exec(e);
        if (r)
            return t = parseFloat(r[1].replace(",", ".")),
            P(t) ? t % 24 * 36e5 : NaN;
        if (r = S.HHMM.exec(e),
        r)
            return t = parseInt(r[1], 10),
            n = parseFloat(r[2].replace(",", ".")),
            P(t, n) ? t % 24 * 36e5 + 6e4 * n : NaN;
        if (r = S.HHMMSS.exec(e),
        r) {
            t = parseInt(r[1], 10),
            n = parseInt(r[2], 10);
            const e = parseFloat(r[3].replace(",", "."));
            return P(t, n, e) ? t % 24 * 36e5 + 6e4 * n + 1e3 * e : NaN
        }
        return null
    }
    function M(e, t, n) {
        t = t || 0,
        n = n || 0;
        const r = new Date(0);
        r.setUTCFullYear(e, 0, 4);
        const i = 7 * t + n + 1 - (r.getUTCDay() || 7);
        return r.setUTCDate(r.getUTCDate() + i),
        r
    }
    const A = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
      , E = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function C(e) {
        return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0
    }
    function N(e, t, n) {
        if (t < 0 || t > 11)
            return !1;
        if (null != n) {
            if (n < 1)
                return !1;
            const r = C(e);
            if (r && n > E[t])
                return !1;
            if (!r && n > A[t])
                return !1
        }
        return !0
    }
    function R(e, t) {
        return !(e < 0 || e > 52) && (null == t || !(t < 0 || t > 6))
    }
    function P(e, t, n) {
        return !(e < 0 || e >= 25) && ((null == t || !(t < 0 || t >= 60)) && (null == n || !(n < 0 || n >= 60)))
    }
    const D = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
    function F(e, t, n) {
        const r = l(t, e = O(e, n), !0)
          , i = new Date(e.getTime() - r)
          , o = new Date(0);
        return o.setFullYear(i.getUTCFullYear(), i.getUTCMonth(), i.getUTCDate()),
        o.setHours(i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds()),
        o
    }
    function k(e, t, n, i) {
        return function(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            const i = (t = String(t)).match(D);
            if (i) {
                const r = O(n.originalDate || e, n);
                t = i.reduce((function(e, t) {
                    if ("'" === t[0])
                        return e;
                    const i = e.indexOf(t)
                      , o = "'" === e[i - 1]
                      , s = e.replace(t, "'" + p[t[0]](r, t, n) + "'");
                    return o ? s.substring(0, i - 1) + s.substring(i + 1) : s
                }
                ), t)
            }
            return Object(r.a)(e, t, n)
        }(F(e, t, {
            timeZone: (i = {
                ...i,
                timeZone: t,
                originalDate: e
            }).timeZone
        }), n, i)
    }
    function j(e, t, n) {
        if ("string" === typeof e && !e.match(_))
            return O(e, {
                ...n,
                timeZone: t
            });
        const r = c((e = O(e, n)).getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()).getTime()
          , i = l(t, new Date(r));
        return new Date(r + i)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return c
    }
    ));
    var r, i = n(120), o = n(31), s = n(26);
    function a(e) {
        var t = e.error;
        e.subscriber.error(t)
    }
    r || (r = {});
    var c = function() {
        function e(e, t, n) {
            this.kind = e,
            this.value = t,
            this.error = n,
            this.hasValue = "N" === e
        }
        return e.prototype.observe = function(e) {
            switch (this.kind) {
            case "N":
                return e.next && e.next(this.value);
            case "E":
                return e.error && e.error(this.error);
            case "C":
                return e.complete && e.complete()
            }
        }
        ,
        e.prototype.do = function(e, t, n) {
            switch (this.kind) {
            case "N":
                return e && e(this.value);
            case "E":
                return t && t(this.error);
            case "C":
                return n && n()
            }
        }
        ,
        e.prototype.accept = function(e, t, n) {
            return e && "function" === typeof e.next ? this.observe(e) : this.do(e, t, n)
        }
        ,
        e.prototype.toObservable = function() {
            var e, t;
            switch (this.kind) {
            case "N":
                return Object(o.a)(this.value);
            case "E":
                return e = this.error,
                t ? new s.a((function(n) {
                    return t.schedule(a, 0, {
                        error: e,
                        subscriber: n
                    })
                }
                )) : new s.a((function(t) {
                    return t.error(e)
                }
                ));
            case "C":
                return Object(i.b)()
            }
            throw new Error("unexpected notification kind value")
        }
        ,
        e.createNext = function(t) {
            return "undefined" !== typeof t ? new e("N",t) : e.undefinedValueNotification
        }
        ,
        e.createError = function(t) {
            return new e("E",void 0,t)
        }
        ,
        e.createComplete = function() {
            return e.completeNotification
        }
        ,
        e.completeNotification = new e("C"),
        e.undefinedValueNotification = new e("N",void 0),
        e
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return l
    }
    )),
    n.d(t, "b", (function() {
        return d
    }
    ));
    var r = n(165)
      , i = n(396)
      , o = n(54)
      , s = n(15)
      , a = n(23)
      , c = n(32)
      , u = n(6);
    class l extends r.a {
        setDispatcher(e, t) {
            return t ? !0 === e && !0 === t ? this.setProp(s.f, i.c) : this.setProp(s.f, Object(i.b)(e, t)) : this.setProp(s.f, e || !1)
        }
        setPrepareOp(e, t) {
            return this.setOp(a.f, e, t)
        }
        setTransformOp(e, t) {
            return this.setOp(a.g, e, t)
        }
        setCommitOp(e, t) {
            return this.setOp(a.b, e, t)
        }
        setFinalizeOp(e, t) {
            return this.setOp(a.e, e, t)
        }
        setCompleteOp(e, t) {
            return this.setOp(a.c, e, t)
        }
        setErrorOp(e) {
            return this.setOp(a.d, e)
        }
        setCancelOp(e) {
            return this.setOp(a.a, e)
        }
    }
    l.DEFAULTS = {
        ...r.a.DEFAULTS,
        [s.k]: a.g,
        [s.m]: c.c
    },
    l.OPS = Object(o.b)(),
    l.ERROR_OP = a.d,
    l.CANCEL_OP = a.a;
    class d extends r.a {
        setPrepareOp(e, t) {
            return this.setOp(u.k, e, t)
        }
        setOptimisticExecuteOp(e, t) {
            return this.setOp(u.h, e, t)
        }
        setOptimisticCommitOp(e, t) {
            return this.setOp(u.f, e, t)
        }
        setOptimisticReducersOp(e, t) {
            return this.setOp(u.j, e, t)
        }
        setOptimisticNotifyOp(e, t) {
            return this.setOp(u.i, e, t)
        }
        setOptimisticCompleteOp(e, t) {
            return this.setOp(u.g, e, t)
        }
        setExecuteOp(e, t) {
            return this.setOp(u.d, e, t)
        }
        setCommitOp(e, t) {
            return this.setOp(u.a, e, t)
        }
        setReducersOp(e, t) {
            return this.setOp(u.l, e, t)
        }
        setNotifyOp(e, t) {
            return this.setOp(u.e, e, t)
        }
        setRollbackOp(e, t) {
            return this.setOp(u.m, e, t)
        }
        setErrorOp(e, t) {
            return this.setOp(u.c, e, t)
        }
        setCompleteOp(e, t) {
            return this.setOp(u.b, e, t)
        }
    }
    d.DEFAULTS = {
        ...r.a.DEFAULTS,
        [s.k]: u.k
    },
    d.OPS = Object(o.d)(),
    d.ERROR_OP = u.c,
    d.CANCEL_OP = u.m
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "d", (function() {
        return c
    }
    ));
    var r = n(188);
    function i(e, t, n) {
        const r = e[n];
        let i = t.length
          , o = t[i - 1];
        for (t.push(e); i > 0 && r < o[n]; )
            t[i] = o,
            i--,
            o = t[i - 1];
        return t[i] = e,
        i
    }
    function o(e, t, n) {
        n || (n = r.a);
        const i = n(e);
        let o = t.length
          , s = t[o - 1];
        for (t.push(e); o > 0 && i < n(s); )
            t[o] = s,
            o--,
            s = t[o - 1];
        return t[o] = e,
        o
    }
    function s(e, t, n) {
        const r = e[n];
        let i = t.length
          , o = t[i - 1];
        for (t.push(e); i > 0 && r >= o[n]; )
            t[i] = o,
            i--,
            o = t[i - 1];
        return t[i] = e,
        i
    }
    const a = (e, t, n, r, i) => {
        if (n && ("string" === typeof e && (e = e.toLowerCase()),
        "string" === typeof t && (t = t.toLowerCase())),
        r) {
            const n = "string" === typeof e && "_" === e.charAt(0)
              , r = "string" === typeof t && "_" === t.charAt(0);
            if (n && !r)
                return 1;
            if (!n && r)
                return -1
        }
        return e < t ? i ? 1 : -1 : e > t ? i ? -1 : 1 : 0
    }
    ;
    function c(e, t, n) {
        return e.sort( (e, r) => a(e, r, t, n, !1)),
        e
    }
}
, , , , function(e, t, n) {
    var r = n(18)
      , i = n(466);
    e.exports = Object.setPrototypeOf || ("__proto__"in {} ? function() {
        var e, t = !1, n = {};
        try {
            (e = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []),
            t = n instanceof Array
        } catch (o) {}
        return function(n, o) {
            return r(n),
            i(o),
            t ? e.call(n, o) : n.__proto__ = o,
            n
        }
    }() : void 0)
}
, function(e, t, n) {
    var r = n(94);
    e.exports = function(e, t, n) {
        for (var i in t)
            r(e, i, t[i], n);
        return e
    }
}
, function(e, t, n) {
    var r = n(50).f
      , i = n(56)
      , o = n(40)("toStringTag");
    e.exports = function(e, t, n) {
        e && !i(e = n ? e : e.prototype, o) && r(e, o, {
            configurable: !0,
            value: t
        })
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "a", (function() {
        return u
    }
    ));
    var r = n(294)
      , i = n(82)
      , o = n(862);
    n(74),
    n(52),
    n(72);
    const s = Object(r.a)([null], i.b)
      , a = Object(o.a)(s)
      , c = () => s
      , u = () => a
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(643))
      , i = o(n(663));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function(e, t) {
        var n = (0,
        i.default)(e, t);
        return (0,
        r.default)(n) ? n : void 0
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    )),
    n.d(t, "b", (function() {
        return l
    }
    ));
    var r = n(26)
      , i = n(22)
      , o = n(0);
    function s(e, t) {
        return new r.a(n => {
            let r = e.subscribe(Object(o.X)(e) ? Object(o.U)(e.instance) ? new u(n,t,e.parentInstance.primaryKey) : new a(n,t) : Object(o.U)(e) ? new c(n,t) : new a(n,t));
            return () => {
                r.unsubscribe(),
                r = void 0
            }
        }
        )
    }
    class a extends i.a {
        constructor(e, t) {
            super(),
            this.__observer = e,
            this.__emitValue = t
        }
        _complete() {
            const {__observer: e} = this;
            e.next(this.__emitValue),
            e.complete(),
            this.closed || super._complete()
        }
        unsubscribe() {
            this.closed || (super.unsubscribe(),
            this.__observer = void 0,
            this.__emitValue = void 0)
        }
    }
    class c extends a {
        _next(e) {
            e.__ID || this._complete()
        }
    }
    class u extends a {
        constructor(e, t, n) {
            super(e, t),
            this.__primaryKey = n
        }
        _next(e) {
            e.get(this.__primaryKey) || this._complete()
        }
    }
    function l(e, t) {
        return function(e, t, n) {
            if (!Object(o.R)(e))
                return t[n] = e,
                null;
            return e.subscribe(new d(Object(o.C)(e),t,n))
        }(e[t], e, t)
    }
    class d extends i.a {
        constructor(e, t, n) {
            super(),
            this.__main = e,
            this.__targetObj = t,
            this.__targetKey = n
        }
        _complete() {
            this.__targetObj[this.__targetKey] = this.__main,
            super._complete()
        }
        unsubscribe() {
            super.unsubscribe(),
            this.__targetObj = void 0,
            this.__main = void 0
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "a", (function() {
        return u
    }
    ));
    var r = n(52)
      , i = n(190)
      , o = n(188);
    const s = Object(r.a)(o.a)
      , a = Object(i.a)(o.a)
      , c = (Object(i.a)(e => !e),
    () => s)
      , u = () => a
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(26)
      , i = n(38);
    function o(e, t) {
        return new r.a((function(n) {
            var r = new i.a
              , o = 0;
            return r.add(t.schedule((function() {
                o !== e.length ? (n.next(e[o++]),
                n.closed || r.add(this.schedule())) : n.complete()
            }
            ))),
            r
        }
        ))
    }
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return null !== e && "object" === typeof e
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return e
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return m
    }
    ));
    var r = n(22)
      , i = n(998)
      , o = n(1)
      , s = n(33)
      , a = n(79);
    function c(e, t) {
        if ("function" !== typeof e)
            return "function" === typeof e[t];
        const n = e[o.h];
        return !(!n || !n[o.s]) && ("string" === typeof n[o.s] ? n[o.s] === t : Array.isArray(n[o.s]) && n[o.s].indexOf(t) > -1)
    }
    var u = n(296)
      , l = n(92);
    const d = Object.values(o.w)
      , h = "@@__withLogic_tracking-internal-use-only-do-not-modify__@@"
      , f = Object(i.c)(Math.floor(1e5 + 9e5 * Math.random()))
      , p = {
        enumerable: !1,
        writable: !0,
        configurable: !1
    }
      , g = () => !1;
    class m extends r.a {
        constructor(e, t, n, r) {
            super(),
            this.dispatchId = r,
            this.ops = e.ops,
            this.opsIdxMap = e.opsIdxMap;
            const {opsAliases: i} = e;
            this.opsAliases = i,
            this.logicObservers = n || s.a.checkoutMap(),
            this.logicArray = t || [],
            this.opIdx = -1,
            i ? (this.errorOp = i[o.l],
            this.completeOp = i[o.f],
            this.cancelOp = i[o.e]) : (this.errorOp = o.l,
            this.completeOp = o.f,
            this.cancelOp = o.e),
            this.options = e,
            this.network = e.network,
            this.closed = !1,
            this.pendingUnsubscribe = !1,
            this.isReadyForUnsubscribe = !1,
            this.isOuter = !1,
            this.isInner = !1
        }
        static createStandaloneLogicValidator(e) {
            return e || (e = {}),
            e.ops || (e.ops = [o.r, o.f]),
            e.streamName || (e.streamName = "standalone_logic_validator"),
            e.streamId || (e.streamId = "n/a"),
            e.validateLogic || (e.validateLogic = e.useDefaultMethods ? m.prototype.validateLogic : this.prototype.validateLogic),
            e.validateSingleLogic || (e.validateSingleLogic = e.useDefaultMethods ? m.prototype.validateSingleLogic : this.prototype.validateSingleLogic),
            function(t, n) {
                return e.validateLogic(t, n)
            }
        }
        get streamId() {
            return this.options.streamId
        }
        get streamName() {
            return this.options.streamName
        }
        setDestination(e) {
            e instanceof r.a || (e = new r.a(e)),
            this.syncErrorThrowable = e.syncErrorThrowable,
            this.destination = e,
            e.add(this)
        }
        callLogicInit(e, t) {
            const n = e;
            return !!(e = e[o.o] ? e[o.n](t, this, ...e[o.o]) : e[o.n](t, this)) && (!0 === e ? n : e !== n ? (e[o.A] && !0 !== e[o.A] || (e[o.A] = e),
            e[o.m] = n[o.m],
            e[o.q] = n[o.q],
            e[o.v] = n[o.v],
            e[o.a] = n[o.a],
            "boolean" !== typeof e[o.x] && (e[o.x] = n[o.x]),
            e) : e)
        }
        getLogic(e) {
            const {logicArray: t} = this;
            if (!e)
                return [...t];
            {
                const n = this.determineLogicId(e);
                if (n)
                    for (let e of t)
                        if (e[o.m] === n)
                            return e
            }
        }
        extractFunctionalLogic(e) {
            return Object(a.d)(e, this.ops)
        }
        getCurrentLogic() {
            return this.logicArray[this.logicIdx] || null
        }
        getNextLogic() {
            let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0])
                return function e(t, n, r, i, o) {
                    const s = r[i];
                    let a, u = n + 1;
                    for (; u < t.length; ) {
                        if (a = t[u],
                        c(a, s))
                            return o ? u : a;
                        u++
                    }
                    return r[i += 1] ? e(t, -1, r, i, o) : o ? -1 : null
                }(this.logicArray, this.logicIdx, this.ops, this.opIdx, e);
            {
                const t = this.logicArray[this.logicIdx + 1];
                return e ? t ? this.logicIdx + 1 : -1 : t || null
            }
        }
        getPrevLogic() {
            let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0])
                return function e(t, n, r, i, o) {
                    const s = r[i];
                    let a, u = n - 1;
                    for (; u > -1; ) {
                        if (a = t[u],
                        c(a, s))
                            return o ? u : a;
                        u--
                    }
                    return r[i -= 1] ? e(t, t.length, r, i, o) : o ? -1 : null
                }(this.logicArray, this.logicIdx, this.ops, this.opIdx, e);
            {
                const t = this.logicArray[this.logicIdx - 1];
                return e ? t ? this.logicIdx - 1 : -1 : t || null
            }
        }
        getLogicId(e) {
            return function(e, t) {
                if ("function" === typeof e) {
                    const n = e[o.h];
                    return n ? n[t] : void 0
                }
                return e[t]
            }(e || this.getCurrentLogic(), o.m)
        }
        getLogicIdx(e, t) {
            let n = -1;
            if (!t) {
                if (!this.logicObservers.has(e))
                    return n;
                ({logicArray: t} = this)
            }
            for (let r = 0, i = t.length; r < i; r++)
                if (t[r][o.m] === e) {
                    n = r;
                    break
                }
            return n
        }
        determineLogicId(e, t) {
            if (!t && Array.isArray(e)) {
                let t = 0
                  , {length: n} = e;
                for (; t < n; )
                    e[t] = this.determineLogicId(e[t], !0),
                    t++;
                return e
            }
            {
                let t;
                switch (typeof e) {
                case "object":
                    t = e[o.m],
                    "undefined" === typeof t && (t = Object(u.b)(e)[o.m]);
                    break;
                case "function":
                    t = e[o.h][o.m],
                    "undefined" === typeof t && (t = Object(u.b)(e)[o.h][o.m]);
                    break;
                default:
                    t = e
                }
                return t
            }
        }
        getOps() {
            return this.ops
        }
        getOpIndex(e) {
            return e ? this.opsIdxMap[e] : this.opIdx
        }
        getNextOp(e) {
            if (e) {
                const {ops: t} = this
                  , n = t.indexOf(e);
                return n > -1 ? t[n + 1] : void 0
            }
            return this.ops[this.opIdx + 1]
        }
        getCompleteOp() {
            return this.completeOp
        }
        getCancelOp() {
            return this.cancelOp
        }
        getErrorOp() {
            return this.errorOp
        }
        isNextOp(e) {
            e || (e = this.op);
            const {opsAliases: t} = this;
            return !!(e === o.r || t && t[e] === o.r)
        }
        isCompleteOp(e) {
            return e ? e === this.completeOp : this.op === this.completeOp
        }
        isCancelOp(e) {
            return e ? e === this.cancelOp : this.op === this.cancelOp
        }
        isErrorOp(e) {
            return e ? e === this.errorOp : this.op === this.errorOp
        }
        isCancelOrErrorOp(e) {
            return e || (e = this.op),
            e === this.errorOp || e === this.cancelOp
        }
        isCompleteOrCancelOp(e) {
            return e || (e = this.op),
            e === this.completeOp || e === this.cancelOp
        }
        hasLogic(e, t) {
            return t ? this.getLogicIdx(this.determineLogicId(e)) > -1 : this.logicObservers.has(this.determineLogicId(e))
        }
        validateLogic(e, t, n) {
            if (e) {
                if (Array.isArray(e)) {
                    let r = !1;
                    n || (n = [],
                    r = !0);
                    for (let o of e)
                        this.validateLogic(o, t, n);
                    let {length: i} = n;
                    if (0 === i)
                        return !1;
                    if (r && t) {
                        let e, t = 0;
                        const r = {};
                        for (; t < i; )
                            e = n[t][o.m],
                            r[e] ? (n.splice(t, 1),
                            i--) : (r[e] = !0,
                            t++)
                    }
                    return n
                }
                {
                    const t = this.validateSingleLogic(e);
                    return n && n.push(t),
                    t
                }
            }
            return !1
        }
        validateSingleLogic(e, t) {
            if (e[h] === f)
                return e;
            let n;
            n = "function" === typeof e && e[o.h] ? Object(a.f)(e) : e;
            let r = n[o.m];
            if (r)
                n[o.q] || (n[o.q] = r);
            else if (t)
                n[o.m] = t,
                n[o.q] || (n[o.q] = t);
            else {
                if (!n[o.q]) {
                    if ("function" === typeof n)
                        throw new l.a('Invalid functional logic "'.concat(n.name, '" provided to stream ').concat(this.streamName, " (streamId: ").concat(this.streamId, '). The provided logic does not have a "').concat(o.h, '" property on its prototype from which to build out the logic.'),this);
                    {
                        let t;
                        if (n[o.a]) {
                            const e = Array.isArray(n[o.a]) ? n[o.a].join(", ") : n[o.a];
                            t = 'The logic is associated with the following action type(s): "'.concat(e, '". ')
                        } else
                            t = "The logic does not have any action types associated with it. ";
                        throw "function" === typeof e && (t += 'It was provided as functional logic, the function name is: "'.concat(e.name, '".')),
                        new l.a("Invalid logic provided to stream ".concat(this.streamName, " (streamId: ").concat(this.streamId, "). No logicId and no logicName was given. At least one or the other must be provided. ").concat(t),this)
                    }
                }
                Object(u.b)(n)
            }
            n[o.v] || 0 === n[o.v] || (n[o.v] = 10),
            "undefined" === typeof n[o.A] && (n[o.A] = null),
            n[o.d] || (n[o.d] = !1),
            n[o.x] || (n[o.x] = !1);
            let i = n[o.y];
            i ? !0 === i && (n[o.y] = null) : n[o.y] = !1 === i ? g : null,
            (i = n[o.z]) ? !0 === i && (n[o.z] = null) : n[o.z] = !1 === i ? g : null;
            const {ops: s} = this;
            for (let o of s)
                n[o] || (n[o] = !1);
            return n[h] = f,
            Object.defineProperty(n, h, p),
            n
        }
        cloneLogicProps(e, t) {
            t || (t = {});
            for (let n of d)
                t[n] = e[n];
            return t[h] = e[h],
            t
        }
        getSyncObserver(e) {
            let t = this.logicObservers.get(e);
            return "number" === typeof t && (t = this.network.createLogicObserver(this, this.logicArray[this.getLogicIdx(e)], t, this.parent ? this.parent.logicObservers.get(e) : void 0, !0),
            this.logicObservers.set(e, t)),
            t
        }
        _addDependency(e, t) {
            if (t || (t = {}),
            this.closed || e.closed || this.isInner && t.depFilter && !t.depFilter(this.value, t, this))
                return !1;
            let n = this
              , r = e;
            if (t[h]) {
                if (t.logic && !(n = this.getSyncObserver(t.logic)) || t.otherLogic && !(r = e.getSyncObserver(t.otherLogic)))
                    return !1
            } else {
                const {ops: i} = this;
                let o, {logic: s, otherLogic: a, opsMap: c} = t;
                if (c) {
                    const {opsIdxMap: t} = e;
                    let n;
                    for (let e of i)
                        o = c[e],
                        o && "number" === typeof t[o] ? n = o : c[e] = n || null
                } else {
                    t.opsMap = c = {};
                    const {ops: n} = e;
                    for (let e = 0; e < i.length && (o = n[e],
                    o); e++)
                        c[i[e]] = o
                }
                if (s) {
                    const e = this.determineLogicId(s);
                    if (!e || !(n = this.getSyncObserver(e)))
                        return !1;
                    t.logic = e
                }
                if (a) {
                    const n = this.determineLogicId(a);
                    if (!n || !(r = e.getSyncObserver(n)))
                        return !1;
                    t.otherLogic = n
                }
                t[h] = f,
                Object.defineProperty(t, h, p)
            }
            return this._addDeps(e, t, n, r)
        }
        checkoutOpsDeps() {
            if (this.parent)
                return this.parent.checkoutOpsDeps();
            {
                let e;
                if (this.opsDepsPool ? e = this.opsDepsPool.pop() : this.opsDepsPool = [],
                !e) {
                    e = {};
                    const {ops: t} = this;
                    for (let n of t)
                        e[n] = void 0
                }
                return e
            }
        }
        checkinOpsDeps(e) {
            if (this.parent)
                this.parent.checkinOpsDeps(e);
            else {
                const {ops: t} = this;
                for (let n of t)
                    e[n] && (e[n].complete(),
                    e[n] = void 0);
                this.opsDepsPool && this.opsDepsPool.push(e)
            }
        }
        _doUnsubscribe() {
            const {logicObservers: e} = this;
            for (let[,t] of e)
                "number" !== typeof t && t.unsubscribe();
            super.unsubscribe(),
            this.logicArray = null,
            s.a.checkinMap(this.logicObservers),
            this.logicObservers = null,
            this.ops = null,
            this.opsAliases = null,
            this.options = void 0,
            this.network = void 0
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(14)
      , i = function() {
        function e(t, n) {
            void 0 === n && (n = e.now),
            this.SchedulerAction = t,
            this.now = n
        }
        return e.prototype.schedule = function(e, t, n) {
            return void 0 === t && (t = 0),
            new this.SchedulerAction(this,e).schedule(n, t)
        }
        ,
        e.now = function() {
            return Date.now()
        }
        ,
        e
    }()
      , o = function(e) {
        function t(n, r) {
            void 0 === r && (r = i.now);
            var o = e.call(this, n, (function() {
                return t.delegate && t.delegate !== o ? t.delegate.now() : r()
            }
            )) || this;
            return o.actions = [],
            o.active = !1,
            o.scheduled = void 0,
            o
        }
        return r.a(t, e),
        t.prototype.schedule = function(n, r, i) {
            return void 0 === r && (r = 0),
            t.delegate && t.delegate !== this ? t.delegate.schedule(n, r, i) : e.prototype.schedule.call(this, n, r, i)
        }
        ,
        t.prototype.flush = function(e) {
            var t = this.actions;
            if (this.active)
                t.push(e);
            else {
                var n;
                this.active = !0;
                do {
                    if (n = e.execute(e.state, e.delay))
                        break
                } while (e = t.shift());
                if (this.active = !1,
                n) {
                    for (; e = t.shift(); )
                        e.unsubscribe();
                    throw n
                }
            }
        }
        ,
        t
    }(i)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(14)
      , i = function(e) {
        function t(t, n) {
            var r = e.call(this, t, n) || this;
            return r.scheduler = t,
            r.work = n,
            r.pending = !1,
            r
        }
        return r.a(t, e),
        t.prototype.schedule = function(e, t) {
            if (void 0 === t && (t = 0),
            this.closed)
                return this;
            this.state = e;
            var n = this.id
              , r = this.scheduler;
            return null != n && (this.id = this.recycleAsyncId(r, n, t)),
            this.pending = !0,
            this.delay = t,
            this.id = this.id || this.requestAsyncId(r, this.id, t),
            this
        }
        ,
        t.prototype.requestAsyncId = function(e, t, n) {
            return void 0 === n && (n = 0),
            setInterval(e.flush.bind(e, this), n)
        }
        ,
        t.prototype.recycleAsyncId = function(e, t, n) {
            if (void 0 === n && (n = 0),
            null !== n && this.delay === n && !1 === this.pending)
                return t;
            clearInterval(t)
        }
        ,
        t.prototype.execute = function(e, t) {
            if (this.closed)
                return new Error("executing a cancelled action");
            this.pending = !1;
            var n = this._execute(e, t);
            if (n)
                return n;
            !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
        }
        ,
        t.prototype._execute = function(e, t) {
            var n = !1
              , r = void 0;
            try {
                this.work(e)
            } catch (i) {
                n = !0,
                r = !!i && i || new Error(i)
            }
            if (n)
                return this.unsubscribe(),
                r
        }
        ,
        t.prototype._unsubscribe = function() {
            var e = this.id
              , t = this.scheduler
              , n = t.actions
              , r = n.indexOf(this);
            this.work = null,
            this.state = null,
            this.pending = !1,
            this.scheduler = null,
            -1 !== r && n.splice(r, 1),
            null != e && (this.id = this.recycleAsyncId(t, e, null)),
            this.delay = null
        }
        ,
        t
    }(function(e) {
        function t(t, n) {
            return e.call(this) || this
        }
        return r.a(t, e),
        t.prototype.schedule = function(e, t) {
            return void 0 === t && (t = 0),
            this
        }
        ,
        t
    }(n(38).a))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(66)
      , i = n(105)
      , o = {
        closed: !0,
        next: function(e) {},
        error: function(e) {
            if (r.a.useDeprecatedSynchronousErrorHandling)
                throw e;
            Object(i.a)(e)
        },
        complete: function() {}
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(1)
      , i = n(33);
    class o {
        constructor(e, t, n) {
            this.manager = e,
            this.op = t,
            this.opIdx = e.opsIdxMap[t],
            this.isComplete = !1,
            this.hasReady = !1,
            this.isReady = !1,
            this.isWaiting = !1,
            this.logicId = n ? n.logic[r.m] : void 0,
            this.waitingFor = i.a.checkoutSet(),
            this.readyNeededBy = i.a.checkoutSet(),
            this.readyNeededByInherit = i.a.checkoutSet(),
            this.completeNeededBy = i.a.checkoutSet()
        }
        get observer() {
            return this.logicId ? this.manager.logicObservers.get(this.logicId) : void 0
        }
        ensureOpReady(e) {
            if (this.hasReady || this.isReady) {
                const {observer: t} = this;
                return t ? t._opReady(e, this.op) : this.manager._opReady(e)
            }
            const {readyNeededBy: t} = this;
            if (this.readyNeededBy = void 0,
            this.hasReady = !0,
            this.value = e,
            t.size > 0)
                for (let n of t)
                    n.deleteWaitingFor(this);
            if (i.a.checkinSet(t),
            !this.isComplete) {
                if (0 === this.waitingFor.size)
                    return this.ready();
                {
                    this.isWaiting = !0;
                    const {observer: e} = this;
                    e && (e.waitingFor = this)
                }
            }
        }
        deleteWaitingFor(e) {
            if (this.isReady)
                return;
            const {waitingFor: t} = this;
            t.delete(e),
            0 === t.size && this.isWaiting && this.ready()
        }
        addToReadyNeededBy(e, t) {
            this.isReady || e.isReady || (t ? (this.readyNeededByInherit.add(e),
            e.waitingFor.add(this)) : this.hasReady || (this.readyNeededBy.add(e),
            e.waitingFor.add(this)))
        }
        addToCompleteNeededBy(e) {
            this.isComplete || e.isReady || (this.completeNeededBy.add(e),
            e.waitingFor.add(this))
        }
        ready() {
            if (this.isReady)
                return;
            this.isReady = !0;
            const {isComplete: e, value: t, readyNeededByInherit: n, manager: r} = this;
            if (this.isWaiting = !1,
            this.readyNeededByInherit = void 0,
            !this.hasReady) {
                const {readyNeededBy: e} = this;
                this.readyNeededBy = void 0;
                for (let t of e)
                    t.deleteWaitingFor(this);
                i.a.checkinSet(e)
            }
            if (n.size > 0)
                for (let i of n)
                    i.deleteWaitingFor(this);
            if (i.a.checkinSet(n),
            i.a.checkinSet(this.waitingFor),
            this.waitingFor = void 0,
            this.value = void 0,
            !e) {
                const {observer: e} = this;
                return e ? e._opReady(t, this.op) : r._opReady(t)
            }
        }
        complete() {
            if (this.isComplete)
                return;
            this.isComplete = !0;
            const {completeNeededBy: e} = this;
            if (this.isReady || this.ready(),
            e.size > 0)
                for (let t of e)
                    t.deleteWaitingFor(this);
            i.a.checkinSet(e),
            this.completeNeededBy = void 0,
            this.manager = void 0,
            this.value = void 0
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(29);
    const i = {
        CREATED: r.b,
        UPDATED: r.h,
        DELETED: r.c,
        PK_CHANGE: r.f
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        BELONGS_TO: "belongsTo",
        BELONGS_TO_MANY: "belongsToMany",
        BELONGS_TO_MANY_REF: "belongsToManyRef",
        HAS_MANY: "hasMany",
        HAS_ONE: "hasOne"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        CASCADE: "cascade",
        NO_ACTION: "noAction",
        RESTRICT: "restrict",
        SET_NULL: "setNull"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        ENDPOINT: "Endpoint",
        POD: "Pod",
        POD_CONTAINER: "PodContainer",
        ROUTE: "Route",
        ROUTER: "Router",
        APP_STORAGE: "AppStorage",
        SERVICE: "Service"
    }
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return !(!e || "function" !== typeof e.lift || "function" !== typeof e.subscribe)
    }
    let i;
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return i
    }
    )),
    i = "symbol" === typeof Symbol.observable ? e => !!e && ("function" === typeof e[Symbol.observable] ? e === e[Symbol.observable]() : "function" === typeof e["@@observable"] && e === e["@@observable"]()) : e => !(!e || "function" !== typeof e["@@observable"]) && e === e["@@observable"]()
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return !(!e || "function" !== typeof e.then || "function" === typeof e.subscribe)
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return c
    }
    ));
    var r = n(1)
      , i = n(395)
      , o = n(296)
      , s = n(79)
      , a = n(235);
    class c {
        constructor(e, t) {
            this.DEFAULTS = e,
            this.logicMgr = t,
            this._current = null
        }
        static init(e, t) {
            if (e) {
                const t = this.DEFAULTS;
                for (let n in t)
                    "undefined" === typeof e[n] && (e[n] = t[n])
            } else
                e = {
                    ...this.DEFAULTS
                };
            return new this(e,t)
        }
        static createCustomBuilder(e) {
            if (!e.DEFAULTS)
                throw new Error("Unable to create custom LogicBuilder because no DEFAULTS were provided.");
            class t extends (this) {
            }
            return t.DEFAULTS = e.DEFAULTS,
            e.OPS && (t.OPS = e.OPS),
            e.ERROR_OP && (t.ERROR_OP = e.ERROR_OP),
            e.COMPLETE_OP && (t.COMPLETE_OP = e.COMPLETE_OP),
            t
        }
        getLogic(e, t, n) {
            const i = this._currentLogicMgr || this.logicMgr;
            if (!i)
                throw new Error("Unable to getLogic with ".concat(r.q, " or ").concat(r.m, ' of "').concat(e, '" because there is no LogicMgr instance associated with this LogicBuilder.'));
            let o = i.findByName(e, this.DEFAULTS[r.a], t);
            if (!o && !(o = i.findById(e, t)) && n) {
                const t = this.DEFAULTS;
                throw new Error("The logic with ".concat(r.q, ' "').concat(e, '", ').concat(r.a, ' "').concat(t[r.a], '" was not found by the logicMgr associated with this LogicBuilder, nor was a logic whose ').concat(r.m, ' property is "').concat(e, "\". The logicMgr's packageName = ").concat(i.packageName, ", and the logicMgr's moduleName = ").concat(i.moduleName, "."))
            }
            return o
        }
        setLogicMgr(e, t) {
            let n = this._current;
            return n ? this._currentLogicMgr = e : (n = this.DEFAULTS,
            this.logicMgr = e),
            e && (n[r.u] = e.packageName,
            n[r.p] = Object(i.a)(n, t, e.moduleName, e.packageName),
            n[r.k] = e.enumType),
            this
        }
        createNewInstance(e) {
            return new this.constructor(this._merge(this.DEFAULTS, e),this.logicMgr)
        }
        createId(e, t) {
            if ("string" === typeof e)
                return Object(o.a)(e, t || this.DEFAULTS[r.a]);
            if ("function" === typeof e) {
                const n = e[r.h];
                if (!n)
                    throw new Error('Unable to create id for functional logic because it does not define a DEFAULTS property on its prototype. The name of the function is: "'.concat(e.name, '"'));
                return n[r.m] || (n[r.m] = Object(o.a)(n[r.q] || e.name, t || n[r.a] || this.DEFAULTS[r.a])),
                n[r.m]
            }
            return e[r.m] || (e[r.m] = Object(o.a)(e[r.q], t || e[r.a] || this.DEFAULTS[r.a])),
            e[r.m]
        }
        setDefaults(e, t, n) {
            return "function" === typeof e ? (t = this._merge(this.DEFAULTS, t),
            e[r.h] = t,
            n ? this.getId(e) : e) : (this.DEFAULTS = e,
            this)
        }
        use(e, t) {
            if (!e)
                return this._current = {
                    ...this.DEFAULTS
                },
                this;
            "string" === typeof e && (e = this.getLogic(e, !1, !0));
            let n = this.DEFAULTS;
            const i = Object(s.g)(e, {
                [r.u]: n[r.u],
                [r.p]: n[r.p]
            });
            this._merge(this.DEFAULTS, i),
            this._current = i;
            const {OPS: o, ERROR_OP: a, CANCEL_OP: c} = this.constructor;
            let u = Object(s.d)(e, o);
            if (u) {
                n = u[r.h],
                u = Object(s.a)(u),
                "function" === typeof n[a] && (i[a] = n[a]),
                "function" === typeof n[c] && (i[c] = n[c]);
                const e = n[r.s];
                if (e)
                    if (Array.isArray(e))
                        for (let t of e)
                            i[t] = u;
                    else
                        i[e] = u;
                u[r.h] = i
            } else {
                for (let t of o)
                    "function" === typeof e[t] && (i[t] = e[t]);
                "function" === typeof e[a] && (i[a] = e[a]),
                "function" === typeof e[c] && (i[c] = e[c])
            }
            return t ? u || null : this
        }
        useProps(e, t, n) {
            if (e) {
                "string" === typeof e && (e = this.getLogic(e, !1, !0));
                const i = this.DEFAULTS;
                this._current = Object(s.g)(e, {
                    [r.u]: i[r.u],
                    [r.p]: i[r.p]
                }, t, n),
                this._merge(this.DEFAULTS, this._current)
            } else
                this._current = {
                    ...this.DEFAULTS
                };
            return this
        }
        usePrevProps(e, t) {
            return this.useProps(this._prev, e, t)
        }
        useRelative(e, t) {
            let n = e;
            return "number" === typeof e && (t = e,
            n = this._prev),
            this.useProps(n, t || 0, !0)
        }
        _merge(e, t) {
            return e ? t ? Object(s.g)(e, t, 0) : {
                ...e
            } : t
        }
        getCurrent() {
            return this._current
        }
        getPrev() {
            return this._prev
        }
        getPrevId(e) {
            const t = this._prev;
            if (t)
                return e ? this.createId(t) : "function" === typeof t ? t[r.h][r.m] : t[r.m]
        }
        getProp(e) {
            return (this._current || this.DEFAULTS)[e]
        }
        setProp(e, t) {
            let n = this._current;
            return n ? ("undefined" === typeof t && (t = this.DEFAULTS[e]),
            n[e] = t) : this.DEFAULTS[e] = t,
            this
        }
        setPropKey(e, t, n) {
            const r = this._current || this.DEFAULTS;
            let i = r[e];
            return i || (i = {},
            r[e] = i),
            i[t] = n,
            this
        }
        merge(e) {
            const t = this._current || this.DEFAULTS;
            return this._merge("function" === typeof e ? e[r.h] : e, t),
            this
        }
        setName(e) {
            return this.setProp(r.q, e)
        }
        setType(e) {
            return this.setProp(r.C, e)
        }
        setDescription(e, t) {
            if ("undefined" === typeof t)
                return this.setProp(r.i, e);
            {
                const n = this._current || this.DEFAULTS;
                return "string" === typeof n[r.i] && (n[r.i] = {
                    logic: n[r.i]
                }),
                n[r.i][e] = t,
                this
            }
        }
        setPriority(e) {
            return this.setProp(r.v, e),
            this
        }
        setActionType(e, t) {
            if (t) {
                const t = this._current || this.DEFAULTS;
                let n = t[r.a];
                return n ? Array.isArray(n) ? n.indexOf(e) < 0 && n.push(e) : n = n === e ? e : [n, e] : (n = this.DEFAULTS[r.a],
                n ? Array.isArray(n) ? (n = [...n],
                n.indexOf(e) < 0 && n.push(e)) : n !== e && (n = [n, e]) : n = e),
                t[r.a] = n,
                this
            }
            return this.setProp(r.a, e)
        }
        setTrxSync(e, t) {
            if ("string" !== typeof e)
                return this.setProp(r.B, e);
            if (t || (t = this.getProp(r.s)))
                return this.setPropKey(r.B, e, t);
            throw new Error("Unable to setTrxSync(): The op to associate with the provided trxOp could not be determined automatically because the current logic's ".concat(r.s, " property has not been set yet."))
        }
        setArgs(e) {
            return this.setProp(r.c, e)
        }
        setPure(e) {
            return this.setProp(r.x, e)
        }
        setRemoveReplace(e) {
            return this.setProp(r.y, e)
        }
        setRemoveReplaceInFlight(e) {
            return this.setProp(r.z, e)
        }
        setInit(e) {
            return this.setProp(r.n, e),
            this.setProp(r.d, !!e)
        }
        setCallInit(e) {
            return this.setProp(r.d, !!e)
        }
        setInitArgs(e) {
            return this.setProp(r.o, e)
        }
        setThisArg(e) {
            return this.setProp(r.A, e)
        }
        setContextType(e) {
            return this.setProp(r.g, e)
        }
        setEnumType(e) {
            return this.setProp(r.k, e)
        }
        setAlternates(e) {
            return this.setProp(r.b, e)
        }
        setOp(e, t, n) {
            return t ? (this.setProp(e, t),
            n && (this.setProp(r.s, e),
            t[r.h] = this._current || this.DEFAULTS),
            this) : this.setProp(r.s, e)
        }
        setOpMethod(e, t) {
            const n = this._current || this.DEFAULTS
              , i = n[r.s];
            if (!i)
                throw new Error('Cannot set opMethod for logic "'.concat(n[r.q], '" with ').concat(r.a, ' "').concat(n[r.a], '", ').concat(r.u, ' "').concat(n[r.u], '", and ').concat(r.p, ' "').concat(n[r.p], '" because the OP property has not been defined.'));
            if ("string" === typeof i)
                n[i] = e;
            else
                for (let r of i)
                    n[r] = e;
            return t && (e[r.h] = n),
            this
        }
        setOpsAliases(e) {
            return this.setProp(r.t, e)
        }
        setDispatcher(e, t) {
            return this.setProp(r.j, e)
        }
        setModuleName(e) {
            if (!e)
                return this.setProp(r.p, e);
            const t = this.DEFAULTS
              , n = this._current || t;
            return n[r.p] = Object(i.a)(n, e, t[r.p], "@" === e.charAt(0) ? void 0 : "undefined" === typeof n[r.u] ? t[r.u] : n[r.u], r.u),
            this
        }
        setPackageName(e) {
            return this.setProp(r.u, e)
        }
        add(e, t) {
            const n = this._currentLogicMgr || this.logicMgr;
            if (!n)
                throw new Error("Unable to add to a LogicMgr because the LogicMgr was not provided. Use the done() method instead, or call addTo() and provide a LogicMgr that the logic should be added to. The defaults associated with this builder are: \n".concat(JSON.stringify(this.DEFAULTS, void 0, 4)));
            return this.addTo(n, e, t)
        }
        addTo(e, t, n) {
            if (!Array.isArray(e))
                throw new Error("Unable to add to a LogicMgr because the LogicMgr was not provided. Use the add() method to add the logic to the LogicMgr currently associated with this builder, or call done() to not add logic to a LogicMgr. The defaults associated with this builder are: \n".concat(JSON.stringify(this.DEFAULTS, void 0, 4)));
            const i = this.done(t, n);
            if (i)
                n ? e.addOrReplaceSingle(i[r.h]) : e.addOrReplaceSingle(i);
            else {
                if (t)
                    throw new Error("A function was provided to add/addTo(), but no logic is currently being created. Did you forget to call one of the use() methods? The defaults associated with the builder are: \n".concat(JSON.stringify(this.DEFAULTS, void 0, 4)));
                e.addBuilder(this)
            }
            return this
        }
        done(e, t) {
            const n = this._current;
            return n ? (e && (t ? this.setOpMethod(e, !0) : e[r.h] = n),
            this._prev = n,
            this._current = null,
            this._currentLogicMgr = null,
            e || n) : null
        }
        setID(e) {
            return this.setId(e)
        }
        setId(e) {
            const t = this._current;
            return !0 === e ? (e = t ? this.createId(t[r.q], t[r.a]) : this.createId(this.DEFAULTS[r.q]),
            this.setProp(r.m, e)) : t && "undefined" === typeof e ? this.createId(t) : this.setProp(r.m, e),
            this
        }
        getID(e) {
            return this.getId(e)
        }
        getId(e) {
            if ("function" === typeof e) {
                let t = e[r.h];
                if (!t)
                    throw new Error("Unable to getId for logic " + Object(a.a)(e) + " because it does not define a DEFAULTS Object from which to get the ID.");
                e = t
            }
            let t = e[r.m];
            return t || (t = this.createId(e),
            e[r.m] = t),
            t
        }
    }
    c.DEFAULTS = {
        [r.s]: r.r,
        [r.v]: 10,
        [r.x]: !1,
        [r.A]: null,
        [r.d]: !1,
        [r.y]: null,
        [r.z]: null
    },
    c.OPS = [r.r, r.f],
    c.CANCEL_OP = r.e,
    c.ERROR_OP = r.l
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(139)
      , i = n(136);
    const o = r.a.init(null, i.a)
}
, function(e, t) {
    var n;
    n = function() {
        return this
    }();
    try {
        n = n || new Function("return this")()
    } catch (r) {
        "object" === typeof window && (n = window)
    }
    e.exports = n
}
, , , function(e, t, n) {
    var r = n(40)
      , i = n(112)
      , o = n(50)
      , s = r("unscopables")
      , a = Array.prototype;
    void 0 == a[s] && o.f(a, s, {
        configurable: !0,
        value: i(null)
    }),
    e.exports = function(e) {
        a[s][e] = !0
    }
}
, function(e, t, n) {
    var r = n(114)
      , i = n(113)
      , o = function(e) {
        return function(t, n) {
            var o, s, a = String(i(t)), c = r(n), u = a.length;
            return c < 0 || c >= u ? e ? "" : void 0 : (o = a.charCodeAt(c)) < 55296 || o > 56319 || c + 1 === u || (s = a.charCodeAt(c + 1)) < 56320 || s > 57343 ? e ? a.charAt(c) : o : e ? a.slice(c, c + 2) : s - 56320 + (o - 55296 << 10) + 65536
        }
    };
    e.exports = {
        codeAt: o(!1),
        charAt: o(!0)
    }
}
, function(e, t, n) {
    var r = n(210)
      , i = n(173)
      , o = n(40)("iterator");
    e.exports = function(e) {
        if (void 0 != e)
            return e[o] || e["@@iterator"] || i[r(e)]
    }
}
, function(e, t) {
    e.exports = {}
}
, function(e, t, n) {
    "use strict";
    var r = n(333).IteratorPrototype
      , i = n(112)
      , o = n(128)
      , s = n(146)
      , a = n(173)
      , c = function() {
        return this
    };
    e.exports = function(e, t, n) {
        var u = t + " Iterator";
        return e.prototype = i(r, {
            next: o(1, n)
        }),
        s(e, u, !1, !0),
        a[u] = c,
        e
    }
}
, function(e, t, n) {
    var r = n(18)
      , i = n(172);
    e.exports = function(e) {
        var t = i(e);
        if ("function" != typeof t)
            throw TypeError(String(e) + " is not iterable");
        return r(t.call(e))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "d", (function() {
        return a
    }
    )),
    n.d(t, "c", (function() {
        return c
    }
    ));
    const r = /^.{2,}History$/
      , i = /History$/
      , o = e => "".concat(e, "History")
      , s = e => "".concat(e, "Histories")
      , a = e => r.test(e)
      , c = e => e.replace(i, "")
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return function t(n) {
            return 0 === arguments.length || (0,
            o.default)(n) ? t : e.apply(this, arguments)
        }
    }
    ;
    var r, i = n(605), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    ));
    const [r,i] = function() {
        const e = {}
          , t = {
            X_MONTH_WEEK_1_BEGIN: "X_MONTH_WEEK_1_BEGIN",
            X_MONTH_WEEK_1_END: "X_MONTH_WEEK_1_END",
            X_MONTH_WEEK_2_BEGIN: "X_MONTH_WEEK_2_BEGIN",
            X_MONTH_WEEK_2_END: "X_MONTH_WEEK_2_END",
            X_MONTH_WEEK_3_BEGIN: "X_MONTH_WEEK_3_BEGIN",
            X_MONTH_WEEK_3_END: "X_MONTH_WEEK_3_END",
            X_MONTH_WEEK_4_BEGIN: "X_MONTH_WEEK_4_BEGIN",
            X_MONTH_WEEK_4_END: "X_MONTH_WEEK_4_END",
            X_SECOND: "X_SECOND"
        };
        for (const s in t)
            e[s] = !0;
        e.X_SECOND = !1;
        const n = ["YEAR", "MONTH", "WEEK", "DAY", "HOUR", "MINUTE", "SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY"];
        let r, i, o;
        for (const s of n)
            r = "X_".concat(s),
            t[r] = r,
            e[r] = !1,
            r = "X_".concat(s, "_BEGIN"),
            i = "X_".concat(s, "_END"),
            t[r] = r,
            t[i] = i,
            o = "MINUTE" !== s,
            e[r] = o,
            e[i] = o;
        return [t, e]
    }()
      , o = r
      , s = r
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return i
    }
    ));
    const r = "NONE"
      , i = "SERIALIZABLE"
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return "function" === typeof e
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return h
    }
    ));
    var r = n(861)
      , i = n(140)
      , o = n(154)
      , s = n(92)
      , a = n(106)
      , c = n(93)
      , u = n(1)
      , l = n(158)
      , d = n(79);
    class h extends o.a {
        constructor(e, t, n, r, i, o) {
            super(e.options, t, n, r),
            this.value = i,
            this.parent = e,
            this.isInner = !0,
            this.logicIdx = -1,
            this.savedLogicIdx = -1,
            this.cancelLogicId = void 0,
            this.isPendingOp = !0,
            this._queuedEvents = void 0,
            this.hasQueuedEvents = !1,
            this.isQueuedEvent = !1,
            this.waitingFor = void 0,
            o ? (this.op = o,
            this.opIdx = this.opsIdxMap[o],
            this.prevOp = this.ops[this.opIdx - 1]) : (this.prevOp = void 0,
            this.op = this.ops[0],
            this.opIdx = -1)
        }
        init() {
            return this
        }
        begin(e) {
            this.next(e)
        }
        get isComplete() {
            return this.closed
        }
        next(e) {
            let {op: t} = this;
            if ("undefined" === typeof e ? ({value: e} = this) : (this.value = e,
            e = this.value),
            t === this.errorOp) {
                if (e instanceof a.a || !this.doesValueResolveError(e))
                    return this.logicIdx--,
                    void this._errorLoop(e);
                this.op = t = this.ops[this.opIdx],
                this.isQueuedEvent && (this.logicIdx = this.savedLogicIdx)
            }
            const n = t === this.cancelOp;
            if (!n && this.hasQueuedEvents)
                return void this.processQueuedEvents();
            this.logicIdx++;
            let {logicArray: r, logicIdx: i} = this;
            if (r.length - i < 1)
                return void this.opComplete(e);
            const {logicObservers: o, opIdx: s} = this;
            let l, d, h, f, p, g, m, {isPendingOp: y} = this;
            for (; l = r[i]; ) {
                if (y && l[u.v] >= 0) {
                    if (this.logicIdx = --i,
                    "undefined" === typeof this._ensureOpReady(e, !0))
                        break;
                    y = !1,
                    this.logicIdx = ++i
                } else
                    this.logicIdx = i;
                if (({[u.m]: d, [t]: p} = l),
                h = o.get(d),
                "number" !== typeof h) {
                    if (h.opIdx = s,
                    p || h.opsDeps && h.opsDeps[t]) {
                        if (f = h.callOp(e, t),
                        "undefined" === typeof f)
                            break;
                        if (this.value = f,
                        e = this.value,
                        this.hasQueuedEvents) {
                            this.processQueuedEvents();
                            break
                        }
                        if (t !== this.op)
                            break;
                        ({logicIdx: i} = this)
                    }
                } else if (o.set(d, s) && p) {
                    ({[u.A]: g, [u.c]: m} = l);
                    try {
                        if (f = m ? p.call(g || l, e, ...m) : p.call(g || l, e),
                        "undefined" !== typeof f && (this.value = f,
                        e = this.value),
                        this.hasQueuedEvents) {
                            this.processQueuedEvents();
                            break
                        }
                        if (t !== this.op)
                            break;
                        ({logicIdx: i} = this)
                    } catch (v) {
                        if (!n) {
                            let e = v;
                            v instanceof c.a || (e = new c.a("uncaught logic error",this,l,v)),
                            this.error(e);
                            break
                        }
                        ({logicIdx: i} = this)
                    }
                }
                i++
            }
            l || (this.logicIdx = i,
            this.opComplete(e))
        }
        doesValueResolveError(e) {
            return !0
        }
        _errorLoop(e) {
            const {op: t, opIdx: n, logicArray: i, logicObservers: o} = this;
            let s;
            this.value = e,
            e = this.value;
            let l, d, h, f, p, g, {logicIdx: m} = this;
            for (; s = i[m]; ) {
                if (({[u.m]: h, [t]: d} = s),
                this.logicIdx = m,
                l = o.get(h),
                "number" !== typeof l) {
                    if (l.opIdx = n - 1,
                    d) {
                        if (f = l.callOp(e, t),
                        t !== this.op || "undefined" === typeof f)
                            break;
                        if (f instanceof a.a)
                            this.value = f;
                        else if (this.doesValueResolveError(f)) {
                            this.next(f);
                            break
                        }
                        e = this.value
                    }
                } else if (o.set(h, n - 1) && d) {
                    ({[u.A]: p, [u.c]: g} = s);
                    try {
                        if (f = g ? d.call(p || s, e, ...g) : d.call(p || s, e),
                        t !== this.op)
                            break;
                        if ("undefined" !== typeof f) {
                            if (f instanceof a.a)
                                this.value = f;
                            else if (this.doesValueResolveError(f)) {
                                this.next(f);
                                break
                            }
                            e = this.value
                        }
                    } catch (y) {
                        let t;
                        y instanceof c.a || (t = new c.a("uncaught logic error",this,s,y)),
                        this.value = t,
                        e = this.value
                    }
                }
                m--
            }
            if (!s) {
                if (this.logicIdx = m,
                Object(r.a)())
                    console.warn("UNRESOLVED ERROR, value = ", e);
                else {
                    let t = "UNRESOLVED ERROR: ".concat(e.message);
                    e.original && (t += "\n\nORIGINAL:\n".concat(e.original.message, "\n\n").concat(e.original.stack)),
                    console.warn(t)
                }
                this.cancel(e)
            }
        }
        error(e) {
            if (this.op === this.cancelOp)
                return void this.next(this.value);
            e instanceof a.a || (e = e ? "string" === typeof e ? new s.a(e,this) : e instanceof Error ? new s.a(e.message,this,e) : new s.a("Unknown error.",this) : new s.a("Unknown error.",this));
            const {errorOp: t} = this;
            this.op === t ? (e.childError = this.value,
            this.logicIdx--,
            this._errorLoop(e)) : (this.op = t,
            this._errorLoop(e))
        }
        queueEvent(e) {
            this._queuedEvents ? this._queuedEvents.push(e) : this._queuedEvents = [e],
            this.hasQueuedEvents = !0
        }
        processQueuedEvents() {
            if (this.hasQueuedEvents) {
                const {_queuedEvents: e} = this;
                if (0 === e.length)
                    this.isQueuedEvent = !1,
                    this.hasQueuedEvents = !1,
                    this.next(this.value);
                else {
                    this.isQueuedEvent = !0;
                    const t = e.shift();
                    "function" === typeof t ? t() : this.error(t)
                }
            } else
                this.next(this.value)
        }
        cancel(e, t) {
            const {cancelOp: n} = this;
            if (this.op === n || this.isReadyForUnsubscribe)
                return;
            const {logicArray: r, logicIdx: i} = this
              , o = r[i];
            if (o) {
                const e = this.logicObservers.get(o[u.m]);
                "number" !== typeof e && this.logicObservers.set(o[u.m], e.forceAbandonOp()),
                t && (this.savedLogicId = t[u.m])
            }
            this.logicIdx = -1,
            this.op = n,
            this.isPendingOp = !1,
            this.next(e)
        }
        unsubscribe(e) {
            if (!this.closed && e === this.parent) {
                if (this.pendingUnsubscribe) {
                    if (!this.isReadyForUnsubscribe)
                        return
                } else if (this.pendingUnsubscribe = !0,
                !this.isReadyForUnsubscribe)
                    return void (this.isCancelOp() || this.cancel(this.value));
                this._doUnsubscribe()
            }
        }
        _doUnsubscribe() {
            const {parent: e} = this
              , {network: t} = this;
            super._doUnsubscribe(),
            this.parent = void 0,
            this._queuedEvents = void 0,
            this.value = void 0,
            this.waitingFor = void 0,
            this.opsDeps && (e.checkinOpsDeps(this.opsDeps),
            this.opsDeps = void 0),
            e.childManagerComplete(this, t)
        }
        opComplete(e, t) {
            const {opsAliases: n, op: r} = this
              , i = n && n[r] ? n[r] : r;
            i === u.e ? (this.isReadyForUnsubscribe = !0,
            e instanceof a.a ? (this.destination.error(e),
            this.parent.notifyError(e, this)) : (this.destination.next(e),
            this.destination.complete(),
            this.parent.notifyComplete(this))) : this.isPendingOp ? this._ensureOpReady(e) : (this.opsDeps && this.opsDeps[r] && this.opsDeps[r].complete(),
            i === u.f ? (this.isReadyForUnsubscribe = !0,
            this.destination.complete(),
            this.parent.notifyComplete(this)) : (this.destination.next(e),
            i === u.r && this.parent.notifyNext(e),
            t || this.setOp(this.getNextOp(), e)))
        }
        getLogicObserver(e, t) {
            return t && t !== this.dispatchId ? this.parent.getLogicObserver(e, t) : this.logicObservers.get(e)
        }
        addLogic(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            const r = this.validateLogic(e);
            if (!r)
                return !1;
            let i = !1;
            return n && "all" !== n && (i = this._addLogic(r, t, n, !1)),
            (t || "all" === n) && this.parent.addLogic(r, t, n, !0) && (i = !0),
            i
        }
        removeLogic(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            const r = this.determineLogicId(e);
            if (!r)
                return !1;
            let i = !1;
            return n && "all" !== n && (i = this._removeLogic(r, t, n)),
            (t || "all" === n) && this.parent.removeLogic(r, t, n, !0) && (i = !0),
            i
        }
        replaceLogic(e, t) {
            let n, r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
            if (n = this.validateLogic(t),
            !n)
                return !1;
            const o = this.determineLogicId(e);
            if (!o || n[u.m] !== o)
                return !1;
            let s = !1;
            return i && "all" !== i && (s = this._replaceLogic(o, n, r, i, !1)),
            (r || "all" === i) && this.parent.replaceLogic(o, n, r, i, !0) && (s = !0),
            s
        }
        addOrReplaceLogic(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            const r = this.validateLogic(e, !0);
            if (!r)
                return !1;
            let i = !1;
            return n && "all" !== n && (i = this._addLogic(r, t, n, !0)),
            (t || "all" === n) && this.parent.addOrReplaceLogic(r, t, n, !0) && (i = !0),
            i
        }
        _addLogic(e, t, n, r, o, s) {
            if ("boolean" !== typeof o && (o = this.isCompleteOrCancelOp(),
            s = this.logicArray[this.logicIdx],
            Array.isArray(e))) {
                let i = !1;
                for (let a of e)
                    this._addLogic(a, t, n, r, o, s) && (i = !0);
                return i
            }
            if (o && s && s[u.v] > e[u.v])
                return !1;
            const {logicObservers: a} = this
              , {[u.m]: c} = e;
            if (!this.options.logicFilter(this.value, e))
                return !1;
            if (a.has(c))
                return !!r && this._replaceLogic(c, e, t, n, !0);
            {
                if (e[u.d] && !(e = this.callLogicInit(e, this.value)))
                    return !1;
                const t = Object(i.a)(e, this.logicArray, u.v)
                  , n = this.parent.logicObservers.get(c);
                let r;
                return t <= this.logicIdx ? (this.logicIdx++,
                r = this.opIdx) : r = this.opIdx - 1,
                t < this.savedLogicIdx && this.savedLogicIdx++,
                a.set(c, this.network.createLogicObserver(this, e, r, n)),
                !0
            }
        }
        _removeLogic(e, t, n, r, i) {
            if (!e)
                return !1;
            if (!r && (({value: i} = this),
            Array.isArray(e))) {
                let r = !1;
                for (let o of e)
                    !0 === this._removeLogic(o, t, n, !0, i) && (r = !0);
                return r
            }
            const o = e
              , {logicObservers: s} = this;
            if (!s.has(o))
                return !1;
            let a = this.getLogicIdx(o);
            if (a !== this.logicIdx || this.isQueuedEvent) {
                const {logicArray: e} = this
                  , t = e[a]
                  , n = s.get(o)
                  , r = this.callLogicRemoveReplace(t, n, i);
                return !0 === r && s.has(o) && (e[a] && e[a][u.m] === o || (a = this.getLogicIdx(o)),
                s.delete(o),
                e.splice(a, 1),
                a <= this.savedLogicIdx && this.savedLogicIdx--,
                a <= this.logicIdx && this.logicIdx--,
                "number" !== typeof n && n.unsubscribe()),
                r
            }
            {
                const e = () => {
                    "boolean" === typeof this._removeLogic(o, !0, this.value) && this.processQueuedEvents()
                }
                ;
                return e.type = "removeLogic",
                this.queueEvent(e),
                !0
            }
        }
        _replaceLogic(e, t, n, r, o) {
            const {value: s, logicObservers: a} = this;
            if (!o) {
                if (this.isCompleteOrCancelOp()) {
                    const e = this.logicArray[this.logicIdx];
                    if (e && e[u.v] > t[u.v])
                        return !1
                }
                if (!a.has(e) || !this.options.logicFilter(s, t))
                    return !1
            }
            let c = this.getLogicIdx(e);
            const {logicArray: l} = this;
            let h = a.get(e);
            const f = l[c];
            if (c === this.logicIdx && !this.isQueuedEvent && t[u.v] !== f[u.v]) {
                const i = () => {
                    "boolean" === typeof this._replaceLogic(e, t, n, r, o) && this.processQueuedEvents()
                }
                ;
                return i.type = "replaceLogic",
                this.queueEvent(i),
                !0
            }
            if (!0 !== this.callLogicRemoveReplace(f, h, s, t))
                return !1;
            if (t[u.d]) {
                let e = this.callLogicInit(t, s);
                t = e || Object(d.b)(t, this.ops)
            }
            if (!a.has(e))
                return !!o && this._addLogic(t, n, r, o);
            h = a.get(e),
            l[c] && l[c][u.m] === e || (c = this.getLogicIdx(e));
            let p, g, m = t[u.x];
            "number" === typeof h ? (p = !0,
            g = h) : (p = !1,
            g = h.opIdx);
            const y = this.parent.logicObservers.get(e);
            if (m && y && "number" !== typeof y && (m = !1),
            t[u.v] === f[u.v])
                l[c] = t,
                c === this.logicIdx && this.logicIdx--;
            else {
                let {savedLogicIdx: e, logicIdx: n} = this;
                c <= e && e--,
                c <= n && n--,
                l.splice(c, 1);
                const r = Object(i.a)(t, l, u.v);
                r < n && (n++,
                g = this.opIdx),
                r < e && e++,
                this.savedLogicIdx = e,
                this.logicIdx = n
            }
            return p && m ? (a.set(e, g),
            !0) : p ? (a.set(e, this.network.createLogicObserver(this, t, g, y)),
            !0) : (h.logic = t,
            h.opIdx = g,
            g === this.opIdx && this.logicIdx > c && h.opsDeps && h.opsDeps[this.ops[g]] && h.opsDeps[this.ops[g]].complete(),
            !0)
        }
        callLogicRemoveReplace(e, t, n, r) {
            const i = e[u.z];
            if (!i)
                return !0;
            const {[u.A]: o} = e;
            let s;
            try {
                s = e[u.x] ? !!i.call(o || e, n, r) : !!i.call(o || e, n, t, r)
            } catch (a) {
                let t = a;
                a instanceof c.a || (t = new c.a(u.z,this,e,a,u.z)),
                this.isQueuedEvent ? (this.error(t),
                s = t) : (this.queueEvent(t),
                s = !1)
            }
            return s
        }
        getOpDep(e, t) {
            const {opIdx: n} = this
              , r = this.opsIdxMap[e];
            if (!(n > r || n === r && !this.isPendingOp)) {
                let n, {opsDeps: r} = this;
                return r ? (({[e]: n} = r),
                n || t || (r[e] = n = new l.a(this,e))) : t || (this.opsDeps = r = this.parent.checkoutOpsDeps(),
                r[e] = n = new l.a(this,e)),
                n
            }
        }
        addDependency(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]
              , i = !1;
            return !0 === r ? (i = this._addDependency(e, t),
            r = !1) : "all" === r && (r = !0),
            (n || r) && this.parent.addDependency(e.parent, t, n, r) && (i = !0),
            i
        }
        _addDeps(e, t, n, r) {
            const {ops: i} = this
              , {opsMap: o, asPeer: s, inheritPeerDeps: a} = t;
            let c, u, l, d = null, h = !1;
            for (let f of i)
                (c = o[f]) && c !== d && (u = n.getOpDep(f)) && (l = r.getOpDep(c)) && (h = !0,
                d = c,
                s ? l.addToReadyNeededBy(u, a) : l.addToCompleteNeededBy(u));
            return h
        }
        _ensureOpReady(e, t) {
            if (this.opsDeps) {
                const {[this.op]: t} = this.opsDeps;
                if (t)
                    return this.waitingFor = t,
                    void t.ensureOpReady(e)
            }
            return this._opReady(e, !!t)
        }
        _opReady(e, t) {
            return this.destination.next(e),
            this.waitingFor = void 0,
            this.isPendingOp = !1,
            t ? e : void this.next(e)
        }
        getStatus() {
            if (this.closed)
                return;
            let e = this._status;
            e || (this._status = e = {}),
            e.logicIdx = this.logicIdx,
            e.logicCount = this.logicArray.length,
            e.op = this.op,
            e.opIdx = this.opIdx,
            e.opCount = this.ops.length;
            let t = this.logicArray[this.logicIdx]
              , n = this.waitingFor;
            if (t) {
                if (e.logic = t[u.q],
                !n) {
                    const e = this.logicObservers.get(t[u.m]);
                    n = e && "number" !== typeof e ? e.waitingFor : void 0
                }
            } else
                e.logic = void 0;
            return n ? (e.waiting = !0,
            (t = n.observer) ? e.waitingLogic = t.logic[u.q] : e.waitingLogic = void 0) : (e.waiting = !1,
            e.waitingLogic = void 0),
            e
        }
        setOp(e, t) {
            this.prevOp = this.op,
            this.op = e,
            this.opIdx = this.opsIdxMap[e],
            this.logicIdx = -1,
            this.nextLogicIdx = 0,
            this.isPendingOp = !0,
            this.next(t)
        }
        getGlobalLogic(e) {
            return this.parent.getLogic(e)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return p
    }
    )),
    n.d(t, "a", (function() {
        return g
    }
    )),
    n.d(t, "b", (function() {
        return m
    }
    ));
    var r = n(121)
      , i = n(74)
      , o = n(0)
      , s = n(181)
      , a = n(106)
      , c = n(6)
      , u = n(46);
    const l = {
        opsMap: {
            [c.k]: c.k,
            [c.h]: c.h,
            [c.f]: c.g,
            [c.d]: c.d
        },
        logic: u.d,
        otherLogic: u.e,
        asPeer: !0
    }
      , d = {
        opsMap: {
            [c.k]: c.k,
            [c.h]: c.h,
            [c.g]: c.g,
            [c.d]: c.d
        },
        logic: u.e,
        otherLogic: u.e
    }
      , h = {
        opsMap: {
            [c.k]: c.k,
            [c.h]: c.d,
            [c.f]: c.l
        },
        logic: u.d,
        otherLogic: u.e,
        asPeer: !0
    }
      , f = {
        opsMap: {
            [c.k]: c.k,
            [c.d]: c.h
        },
        logic: u.e,
        otherLogic: u.e
    };
    class p extends s.a {
        get value() {
            return this._value
        }
        set value(e) {
            e instanceof a.a ? this._value = e : this._value = this
        }
        get mainDispatchId() {
            return this.closed ? void 0 : this.isMain ? this.dispatchId : this.network.mainDispatchId
        }
        get pendingDispatchId() {
            return this.isMain ? this._pendingDispatchId : this.dispatchId
        }
        get streamName() {
            return this.isMain ? "MainTrx" : "PendingTrx"
        }
        doesValueResolveError(e) {
            return !1
        }
        setDestination(e) {
            e === this._observers$ && super.setDestination(e)
        }
        subscribe(e, t) {
            this._observers$ || (this._observers$ = new r.a,
            this.setDestination(this._observers$));
            const n = this._observers$.pipe(Object(i.a)(e));
            return t ? n.subscribe(t) : n
        }
        getTrxOpsStream(e) {
            return this._observers$ || (this._observers$ = new r.a,
            this.setDestination(this._observers$)),
            this._observers$.pipe(Object(i.a)(e))
        }
    }
    class g extends p {
        init() {
            return this.activeCount = 0,
            this.isCommitReady = !1,
            super.init()
        }
        addPendingTrx(e, t, n) {
            this.activeCount++,
            e.mainTrx = this,
            n && (e.isCommitOnly ? (this._addDependency(e, h),
            e._addDependency(this, f)) : (this._addDependency(e, l),
            e._addDependency(this, d)))
        }
        pendingTrxComplete(e) {
            this.activeCount--
        }
        complete() {
            !this.closed && this.isCommitReady && this.op === c.d && this.setOp(c.a, this.value)
        }
        setOp(e, t) {
            e !== c.a || this.isCommitReady ? super.setOp(e, t) : this.isCommitReady = !0
        }
        _doUnsubscribe() {
            this.network.mainTrxComplete(this),
            super._doUnsubscribe()
        }
    }
    g.prototype.isMain = !0,
    g.prototype.isCommitOnly = !1,
    Object(o.z)(g, o.r.MAIN_TRX);
    class m extends p {
        init() {
            return this.value = this,
            this.mainTrx = void 0,
            super.init()
        }
        get isCommitOnly() {
            return this.closed ? void 0 : this.parent.isCommitOnly
        }
        _doUnsubscribe() {
            this.mainTrx && (this.mainTrx.pendingTrxComplete(this),
            this.mainTrx = void 0),
            super._doUnsubscribe()
        }
    }
    m.prototype.isMain = !1,
    Object(o.z)(m, o.r.PENDING_TRX)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(29);
    const i = {
        OPTIMISTIC: r.e,
        COMMIT: r.a,
        NONE: r.d,
        STALE: r.g
    }
}
, function(e, t, n) {
    "use strict";
    var r = "function" === typeof Symbol && "function" === typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : void 0;
    t.a = r
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(133);
    function i(e) {
        return !Object(r.a)(e) && e - parseFloat(e) + 1 >= 0
    }
}
, function(e, t, n) {
    "use strict";
    const r = n(845)
      , i = n(846)
      , o = n(847)
      , s = n(848)
      , a = Symbol("encodeFragmentIdentifier");
    function c(e) {
        if ("string" !== typeof e || 1 !== e.length)
            throw new TypeError("arrayFormatSeparator must be single character string")
    }
    function u(e, t) {
        return t.encode ? t.strict ? r(e) : encodeURIComponent(e) : e
    }
    function l(e, t) {
        return t.decode ? i(e) : e
    }
    function d(e) {
        const t = e.indexOf("#");
        return -1 !== t && (e = e.slice(0, t)),
        e
    }
    function h(e) {
        const t = (e = d(e)).indexOf("?");
        return -1 === t ? "" : e.slice(t + 1)
    }
    function f(e, t) {
        return t.parseNumbers && !Number.isNaN(Number(e)) && "string" === typeof e && "" !== e.trim() ? e = Number(e) : !t.parseBooleans || null === e || "true" !== e.toLowerCase() && "false" !== e.toLowerCase() || (e = "true" === e.toLowerCase()),
        e
    }
    function p(e, t) {
        c((t = Object.assign({
            decode: !0,
            sort: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            parseNumbers: !1,
            parseBooleans: !1
        }, t)).arrayFormatSeparator);
        const n = function(e) {
            let t;
            switch (e.arrayFormat) {
            case "index":
                return (e, n, r) => {
                    t = /\[(\d*)\]$/.exec(e),
                    e = e.replace(/\[\d*\]$/, ""),
                    t ? (void 0 === r[e] && (r[e] = {}),
                    r[e][t[1]] = n) : r[e] = n
                }
                ;
            case "bracket":
                return (e, n, r) => {
                    t = /(\[\])$/.exec(e),
                    e = e.replace(/\[\]$/, ""),
                    t ? void 0 !== r[e] ? r[e] = [].concat(r[e], n) : r[e] = [n] : r[e] = n
                }
                ;
            case "colon-list-separator":
                return (e, n, r) => {
                    t = /(:list)$/.exec(e),
                    e = e.replace(/:list$/, ""),
                    t ? void 0 !== r[e] ? r[e] = [].concat(r[e], n) : r[e] = [n] : r[e] = n
                }
                ;
            case "comma":
            case "separator":
                return (t, n, r) => {
                    const i = "string" === typeof n && n.includes(e.arrayFormatSeparator)
                      , o = "string" === typeof n && !i && l(n, e).includes(e.arrayFormatSeparator);
                    n = o ? l(n, e) : n;
                    const s = i || o ? n.split(e.arrayFormatSeparator).map(t => l(t, e)) : null === n ? n : l(n, e);
                    r[t] = s
                }
                ;
            case "bracket-separator":
                return (t, n, r) => {
                    const i = /(\[\])$/.test(t);
                    if (t = t.replace(/\[\]$/, ""),
                    !i)
                        return void (r[t] = n ? l(n, e) : n);
                    const o = null === n ? [] : n.split(e.arrayFormatSeparator).map(t => l(t, e));
                    void 0 !== r[t] ? r[t] = [].concat(r[t], o) : r[t] = o
                }
                ;
            default:
                return (e, t, n) => {
                    void 0 !== n[e] ? n[e] = [].concat(n[e], t) : n[e] = t
                }
            }
        }(t)
          , r = Object.create(null);
        if ("string" !== typeof e)
            return r;
        if (!(e = e.trim().replace(/^[?#&]/, "")))
            return r;
        for (const i of e.split("&")) {
            if ("" === i)
                continue;
            let[e,s] = o(t.decode ? i.replace(/\+/g, " ") : i, "=");
            s = void 0 === s ? null : ["comma", "separator", "bracket-separator"].includes(t.arrayFormat) ? s : l(s, t),
            n(l(e, t), s, r)
        }
        for (const i of Object.keys(r)) {
            const e = r[i];
            if ("object" === typeof e && null !== e)
                for (const n of Object.keys(e))
                    e[n] = f(e[n], t);
            else
                r[i] = f(e, t)
        }
        return !1 === t.sort ? r : (!0 === t.sort ? Object.keys(r).sort() : Object.keys(r).sort(t.sort)).reduce( (e, t) => {
            const n = r[t];
            return Boolean(n) && "object" === typeof n && !Array.isArray(n) ? e[t] = function e(t) {
                return Array.isArray(t) ? t.sort() : "object" === typeof t ? e(Object.keys(t)).sort( (e, t) => Number(e) - Number(t)).map(e => t[e]) : t
            }(n) : e[t] = n,
            e
        }
        , Object.create(null))
    }
    t.extract = h,
    t.parse = p,
    t.stringify = (e, t) => {
        if (!e)
            return "";
        c((t = Object.assign({
            encode: !0,
            strict: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ","
        }, t)).arrayFormatSeparator);
        const n = n => {
            return t.skipNull && (null === (r = e[n]) || void 0 === r) || t.skipEmptyString && "" === e[n];
            var r
        }
          , r = function(e) {
            switch (e.arrayFormat) {
            case "index":
                return t => (n, r) => {
                    const i = n.length;
                    return void 0 === r || e.skipNull && null === r || e.skipEmptyString && "" === r ? n : null === r ? [...n, [u(t, e), "[", i, "]"].join("")] : [...n, [u(t, e), "[", u(i, e), "]=", u(r, e)].join("")]
                }
                ;
            case "bracket":
                return t => (n, r) => void 0 === r || e.skipNull && null === r || e.skipEmptyString && "" === r ? n : null === r ? [...n, [u(t, e), "[]"].join("")] : [...n, [u(t, e), "[]=", u(r, e)].join("")];
            case "colon-list-separator":
                return t => (n, r) => void 0 === r || e.skipNull && null === r || e.skipEmptyString && "" === r ? n : null === r ? [...n, [u(t, e), ":list="].join("")] : [...n, [u(t, e), ":list=", u(r, e)].join("")];
            case "comma":
            case "separator":
            case "bracket-separator":
                {
                    const t = "bracket-separator" === e.arrayFormat ? "[]=" : "=";
                    return n => (r, i) => void 0 === i || e.skipNull && null === i || e.skipEmptyString && "" === i ? r : (i = null === i ? "" : i,
                    0 === r.length ? [[u(n, e), t, u(i, e)].join("")] : [[r, u(i, e)].join(e.arrayFormatSeparator)])
                }
            default:
                return t => (n, r) => void 0 === r || e.skipNull && null === r || e.skipEmptyString && "" === r ? n : null === r ? [...n, u(t, e)] : [...n, [u(t, e), "=", u(r, e)].join("")]
            }
        }(t)
          , i = {};
        for (const s of Object.keys(e))
            n(s) || (i[s] = e[s]);
        const o = Object.keys(i);
        return !1 !== t.sort && o.sort(t.sort),
        o.map(n => {
            const i = e[n];
            return void 0 === i ? "" : null === i ? u(n, t) : Array.isArray(i) ? 0 === i.length && "bracket-separator" === t.arrayFormat ? u(n, t) + "[]" : i.reduce(r(n), []).join("&") : u(n, t) + "=" + u(i, t)
        }
        ).filter(e => e.length > 0).join("&")
    }
    ,
    t.parseUrl = (e, t) => {
        t = Object.assign({
            decode: !0
        }, t);
        const [n,r] = o(e, "#");
        return Object.assign({
            url: n.split("?")[0] || "",
            query: p(h(e), t)
        }, t && t.parseFragmentIdentifier && r ? {
            fragmentIdentifier: l(r, t)
        } : {})
    }
    ,
    t.stringifyUrl = (e, n) => {
        n = Object.assign({
            encode: !0,
            strict: !0,
            [a]: !0
        }, n);
        const r = d(e.url).split("?")[0] || ""
          , i = t.extract(e.url)
          , o = t.parse(i, {
            sort: !1
        })
          , s = Object.assign(o, e.query);
        let c = t.stringify(s, n);
        c && (c = "?" + c);
        let l = function(e) {
            let t = "";
            const n = e.indexOf("#");
            return -1 !== n && (t = e.slice(n)),
            t
        }(e.url);
        return e.fragmentIdentifier && (l = "#" + (n[a] ? u(e.fragmentIdentifier, n) : e.fragmentIdentifier)),
        `${r}${c}${l}`
    }
    ,
    t.pick = (e, n, r) => {
        r = Object.assign({
            parseFragmentIdentifier: !0,
            [a]: !1
        }, r);
        const {url: i, query: o, fragmentIdentifier: c} = t.parseUrl(e, r);
        return t.stringifyUrl({
            url: i,
            query: s(o, n),
            fragmentIdentifier: c
        }, r)
    }
    ,
    t.exclude = (e, n, r) => {
        const i = Array.isArray(n) ? e => !n.includes(e) : (e, t) => !n(e, t);
        return t.pick(e, i, r)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return O
    }
    )),
    n.d(t, "a", (function() {
        return T
    }
    )),
    n.d(t, "b", (function() {
        return I
    }
    ));
    var r = n(54)
      , i = n(999)
      , o = n(120)
      , s = n(872)
      , a = n(0)
      , c = n(181)
      , u = n(121)
      , l = n(31)
      , d = n(22);
    class h extends u.a {
        constructor(e) {
            super(),
            this.meta = e
        }
        complete() {
            super.complete(),
            this.unsubscribe()
        }
        subscribe(e) {
            const t = super.subscribe(e)
              , {meta: n} = this;
            return n.isStarted || e instanceof f || n._gotSubscription(),
            t
        }
        unsubscribe() {
            super.unsubscribe(),
            this.meta = void 0
        }
    }
    class f extends u.a {
        constructor(e) {
            super(),
            this.meta = e
        }
        next(e) {
            e.meta.isCompleteOrCancelOp() && super.next(e)
        }
        complete() {
            super.complete(),
            this.unsubscribe()
        }
        subscribe(e) {
            if (this.closed)
                return Object(l.a)(void 0).subscribe(e);
            const t = super.subscribe(e);
            return this.meta.isStarted || this.meta._gotSubscription(),
            t
        }
        unsubscribe() {
            this.closed || (super.unsubscribe(),
            this.meta = void 0)
        }
    }
    class p extends d.a {
        constructor(e) {
            super(),
            this.mainActionMeta = e
        }
        _next(e) {
            this.mainActionMeta.isTrx ? this.mainActionMeta.subscribe() : this.mainActionMeta.cancel(),
            this.unsubscribe()
        }
        unsubscribe() {
            super.unsubscribe(),
            this.mainActionMeta = void 0
        }
    }
    var g = n(15)
      , m = n(23);
    const y = Object(r.e)()
      , v = Object(r.e)(!0);
    class b extends c.a {
        get isStarted() {
            return this.logicIdx > -1 || this.opIdx > 0
        }
        get isTrx() {
            return !this.closed && this.network.isTrx
        }
        get isCommitOnlyTrx() {
            return !(this.closed || !this.network.isTrx) && this.network.isCommitOnly
        }
        get trxOp() {
            return this.closed ? void 0 : this.network.trxOp
        }
        get trxOpIdx() {
            return this.closed ? void 0 : this.network.trxOpIdx
        }
        get isPendingTrxOp() {
            return this.closed ? void 0 : this.network.isPendingTrxOp
        }
        get streamName() {
            return this.isMain ? "mainAction_" + this.store.storeName : "pendingAction_" + this.store.storeName
        }
        get streamId() {
            return this.store.storeId
        }
        get mainAction() {
            return this.closed ? void 0 : this.isMain ? this.value : this.parent.mainActionMeta.action
        }
        get pendingAction() {
            return this.closed ? void 0 : this.isMain ? this._pendingActionMeta.action : this.value
        }
        get action() {
            return this.value
        }
        get store() {
            return this.closed ? void 0 : this.parent.store
        }
        get storeId() {
            return this.closed ? void 0 : this.parent.store.storeId
        }
        get mainStore() {
            return this.closed ? void 0 : this.parent.store.mainStore
        }
        get pendingStore() {
            return this.closed ? void 0 : this.isMain ? this._pendingStore : this.parent.store
        }
        get pendingDispatchId() {
            return this.isMain ? this._pendingDispatchId : this.dispatchId
        }
        get mainActionMeta() {
            return this.closed ? void 0 : this.isMain ? this : this.parent.mainActionMeta
        }
        get pendingActionMeta() {
            if (!this.closed)
                return this.isMain ? this._pendingActionMeta : this
        }
        get instance() {
            return this.closed ? void 0 : this.parent.store.instance
        }
        get mainInstance() {
            return this.closed ? void 0 : this.parent.store.mainInstance
        }
        get pendingInstance() {
            if (!this.closed)
                return this.isMain ? this._pendingStore ? this._pendingStore.instance : void 0 : this.parent.store.instance
        }
        get parentInstance() {
            return this.closed ? void 0 : this.parent.store.parentInstance
        }
        get pendingParentInstance() {
            if (!this.closed)
                return this.isMain ? this._pendingStore ? this._pendingStore.parentInstance : void 0 : this.parent.store.parentInstance
        }
        get mainParentInstance() {
            return this.closed ? void 0 : this.isMain ? this.parent.store.parentInstance : this.mainActionMeta.store.parentInstance
        }
        get publicAction() {
            return this.publicActionMeta ? this.publicActionMeta.action : void 0
        }
        get isServer() {
            return this.network.isServer
        }
        getAssetsMgr() {
            return this.network.getAssetsMgr()
        }
        setAssetsMgr(e) {
            this.network.setAssetsMgr(e)
        }
        undoable() {
            return this.network.undoable()
        }
        createTs() {
            return this.network.createTs()
        }
        getTs() {
            return this.network.getTs()
        }
        setTs(e) {
            return this.network.setTs(e)
        }
        getTsOffset(e) {
            return this.network.getTsOffset(e)
        }
        updateTs(e) {
            return this.network.updateTs(e)
        }
        getSession() {
            return this.network.getSession()
        }
        setSession(e) {
            this.network.setSession(e)
        }
        get isUndoable() {
            return this.network.isUndoable
        }
        getPublicAction() {
            if (!this.closed)
                return this.action
        }
        setDestination() {}
        addChildTrx(e) {
            return this.network.addChildTrx(e)
        }
        addParentTrx(e) {
            return this.network.addParentTrx(e)
        }
        addSiblingTrx(e) {
            return this.network.addSiblingTrx(e)
        }
        willEmitOp(e, t) {
            if (this.closed)
                return !1;
            let n, i, o;
            if (Object(r.f)(e, !0))
                n = this.opsIdxMap,
                i = this.isPendingOp,
                o = this.opIdx;
            else {
                if (!Object(r.g)(e, !0))
                    return !1;
                if (!this.isTrx)
                    return !1;
                n = this.isCommitOnlyTrx ? v : y,
                i = this.isPendingTrxOp,
                o = n[this.trxOp]
            }
            const s = n[e];
            return !(o > s || "number" !== typeof s) && (o !== s || (!t || i))
        }
        willExecuteOp(e, t) {
            if (this.closed)
                return !1;
            if (Object(r.f)(e, !0)) {
                const n = this.opsIdxMap[e];
                if ("number" !== typeof n)
                    return !1;
                const r = this.opsIdxMap[this.op];
                if (r > n)
                    return !1;
                if (n === r) {
                    if (this.logicIdx < 0)
                        return !0;
                    if ("number" !== typeof t)
                        return !1;
                    const e = this.logicArray[this.logicIdx];
                    return e && e[g.m] <= t
                }
                return !0
            }
            return this.willEmitOp(e, !0)
        }
        pipeOps() {
            return this.closed ? o.a.pipe(...arguments) : 0 === arguments.length ? this._getOpsObservers$().asObservable() : this._getOpsObservers$().pipe(...arguments)
        }
        pipe() {
            return this.closed ? o.a.pipe(...arguments) : 0 === arguments.length ? this._getResultObservers$().asObservable() : this._getResultObservers$().pipe(...arguments)
        }
        publicSubscribe(e) {
            if (this.closed)
                throw new Error("The action is already complete.");
            return this.getPublicAction().meta.subscribe(e)
        }
        publicSubscribeToOps(e) {
            if (this.closed)
                throw new Error("The action is already complete.");
            return this.getPublicAction().meta.subscribeToOps(e)
        }
        subscribeToOps(e) {
            if (this.closed)
                throw new Error("Action is closed.");
            return e ? this._getOpsObservers$().subscribe(e) : (this._gotSubscription(),
            this)
        }
        subscribe(e) {
            if (this.closed)
                throw new Error("Action is closed.");
            return e ? this._getResultObservers$().subscribe(e) : (this._gotSubscription(),
            this)
        }
        _getOpsObservers$() {
            return this._opsObservers$ || (this._opsObservers$ = this.destination = new h(this)),
            this._opsObservers$
        }
        _getResultObservers$() {
            return this._resultObservers$ || (this._resultObservers$ = new f(this),
            this.subscribeToOps(this._resultObservers$)),
            this._resultObservers$
        }
        _getTrxOpsObservers$() {
            return this._trxOpsObservers$ || (this._trxOpsObservers$ = this.network.getTrxOpsStream(this.value).pipe(Object(s.a)())),
            this._trxOpsObservers$
        }
        pipeTrxOps() {
            return this.closed ? o.a.pipe(...arguments) : 0 === arguments.length ? this._getTrxOpsObservers$().asObservable() : this._getTrxOpsObservers$().pipe(...arguments)
        }
        subscribeToTrxOps(e) {
            if (this.closed)
                throw new Error("Action is closed.");
            if (e)
                return this._getTrxOpsObservers$().subscribe(e);
            throw new Error("An observer or function is required to subscribe to transaction ops. To get an observable of the trx ops, use pipeTrxOps(...operators).")
        }
        asObservable() {
            return this._getResultObservers$().asObservable()
        }
        asObservableOps() {
            return this._getOpsObservers$().asObservable()
        }
        toPromise() {
            return this.asObservable().toPromise()
        }
        _gotSubscription() {
            this._hasSubscription = !0,
            this.isStarted || this.begin(this.value)
        }
        _doUnsubscribe() {
            this.closed || (super._doUnsubscribe(),
            this.publicActionMeta = void 0,
            this._resultObservers$ ? (this._opsObservers$ = void 0,
            this._resultObservers$ = void 0) : this._opsObservers$ && (this._opsObservers$ = void 0))
        }
    }
    Object(a.z)(b, a.r.ACTION_META);
    class _ extends b {
        get mainDispatchId() {
            return this.dispatchId
        }
        cancel(e, t) {
            if (this.op === this.cancelOp)
                return;
            console.warn("IT IS NOT SAFE TO CALL CANCEL() ON MAIN ACTION.");
            const n = this.pendingStore;
            if (n && n.complete(),
            this._notifiedNetwork)
                return super.cancel(e, t);
            {
                const {network: n} = this
                  , r = super.cancel(e, t);
                return n.mainActionMetaComplete(this),
                r
            }
        }
        begin(e) {
            this.isStarted || this.next("undefined" === typeof e ? this.value : e)
        }
        pendingStoreComplete() {
            !this.closed && this._notifiedNetwork && this._opReady(this.value, !1)
        }
        _opReady(e, t) {
            return this.op !== m.c || this._notifiedNetwork ? super._opReady(e, t) : ("undefined" !== typeof e && (this.value = e),
            this._notifiedNetwork = !0,
            void this.network.mainActionMetaComplete(this))
        }
        _doUnsubscribe() {
            this.closed || (this._pendingStore = void 0,
            this._pendingActionMeta = void 0,
            super._doUnsubscribe())
        }
    }
    Object(a.A)(_, a.r.MAIN_ACTION_META),
    _.prototype.isMain = !0;
    class S extends b {
        cancel(e, t) {
            if (this.op !== this.cancelOp) {
                if (this.isStarted || this.parent.canStart)
                    return super.cancel(e, t);
                {
                    const {mainActionMeta: n} = this;
                    this.subscribe(new p(n)),
                    super.cancel(e, t)
                }
            }
        }
        begin(e) {
            if (!this.isStarted)
                if (this.parent.canStart)
                    if (this._hasSubscription)
                        this.next(e || this.value);
                    else {
                        const t = this.mainActionMeta;
                        t.pendingDispatchId === this.dispatchId && t._hasSubscription && this.next(e || this.value)
                    }
                else
                    this.mainActionMeta.begin()
        }
        init() {
            return this.parent.pendingDispatchId === this.dispatchId && (this.parent.mainActionMeta._pendingActionMeta = this),
            this.mainDispatchId = this.parent.store.mainDispatchId,
            super.init()
        }
    }
    Object(a.A)(S, a.r.PENDING_ACTION_META),
    S.prototype.isMain = !1;
    class O extends i.a {
        clone(e, t, n, r, i) {
            const o = super.clone(e, t, n, r, i);
            return r && this.store && (o.store = this.store),
            o
        }
        notifyError(e, t) {
            this.notifyComplete(t)
        }
        _doUnsubscribe() {
            this.closed || (super._doUnsubscribe(),
            this.store = void 0)
        }
        get streamName() {
            if (this.store)
                return this.isMain ? "mainStoreMgr_" + this.store.storeName : "pendingStoreMgr_" + this.store.storeName
        }
        get streamId() {
            return this.store ? this.store.storeId : void 0
        }
    }
    class T extends O {
        static parseOptions(e, t) {
            return super.parseOptions(Object(r.i)(e, this, _), t)
        }
        static create(e) {
            return new this(this.parseOptions(e)).init()
        }
        next(e) {
            throw new Error("This should not happen.")
        }
        setStore(e) {
            this.store = e
        }
        _doUnsubscribe() {
            if (this.closed)
                return;
            const {store: e} = this;
            super._doUnsubscribe(),
            e && e.complete()
        }
    }
    T.prototype.isMain = !0;
    class I extends O {
        static parseOptions(e, t) {
            return super.parseOptions(Object(r.i)(e, this, S), t)
        }
        static create(e) {
            return new this(this.parseOptions(e)).init()
        }
        mainActionReady() {
            if (!this.canStart) {
                this.canStart = !0;
                const {children: e} = this;
                for (let[,t] of e)
                    t.begin()
            }
        }
        createPendingStoreMgr(e, t, n) {
            const {mainDispatchId: r} = e
              , i = super.clone(t, void 0, !1, !0, r);
            return i.init(),
            n._pendingStore = e,
            i.setStore(e, n),
            this.children.set(r, i),
            this.network.registerChildManager(i, n.value),
            i
        }
        setStore(e, t) {
            this.store = e,
            t && (this.mainDispatchId = e.mainDispatchId,
            this.pendingDispatchId = t.pendingDispatchId,
            this.mainActionMeta = t,
            this.canStart = !1,
            this.setAsOuterManager())
        }
        _doUnsubscribe() {
            if (!this.closed)
                if (this.mainActionMeta) {
                    const {store: e} = this;
                    super._doUnsubscribe(),
                    this.mainActionMeta.pendingStoreComplete(),
                    this.mainActionMeta = void 0,
                    e.complete()
                } else
                    super._doUnsubscribe()
        }
    }
    I.prototype.isMain = !1
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return e
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return f
    }
    ));
    var r = n(159)
      , i = n(183)
      , o = n(123);
    const s = Object.prototype.propertyIsEnumerable
      , {CREATED: a, UPDATED: c, DELETED: u, PK_CHANGE: l} = r.a
      , {OPTIMISTIC: d, STALE: h} = i.a;
    class f extends o.a {
        constructor(e) {
            super(e),
            e && (this.allChanges = void 0,
            this.isUndo = !1,
            this.isRedo = !1)
        }
        static init(e, t) {
            const n = new this(!0);
            return n.store = e,
            n
        }
        static updateStoreConfig(e, t, n, r) {
            if ("string" !== typeof t) {
                let n = !1
                  , r = this;
                for (let i in t)
                    r.updateStoreConfig(e, i, t[i], t) && (n = !0,
                    "MainValue" === i && (r = e.value.constructor));
                return n
            }
            switch (t) {
            case "MainValue":
                if (this !== n) {
                    const t = e.value;
                    e.value = t.clone(n),
                    t.destroy()
                }
                return !0;
            case "PendingValue":
                return e.PendingValue = n,
                !0;
            default:
                let {storeConfig: r} = e;
                r || (e.storeConfig = r = {}),
                r[t] = n
            }
        }
        cloneCommit(e) {
            const t = this.cloneNew()
              , {blacklistPropsCommitPendingState: n} = this.constructor;
            for (let r in e)
                n[r] || (t[r] = e[r]);
            return t
        }
        get(e) {
            return this.state[e]
        }
        has(e) {
            return s.call(this.state, e)
        }
        cancel(e) {}
        _prepareCommitChanges(e, t, n, r) {
            const {changesToCommit: i} = n
              , {state: o} = this;
            let l, d, h = null, f = !1, p = !1;
            for (d in i) {
                switch (l = i[d],
                l) {
                case c:
                    break;
                case a:
                    s.call(o, d) ? l = c : p = !0;
                    break;
                case u:
                    if (!s.call(o, d))
                        continue;
                    f = !0;
                    break;
                default:
                    continue
                }
                h || (h = {}),
                h[d] = l,
                i[d] = null
            }
            return t.hasDelete = f,
            t.hasCreate = p,
            t.changes = h,
            t
        }
        _prepareCommitState(e, t, n, r) {
            const {changes: i} = t
              , {state: o} = n;
            let s, c;
            if (t.hasDelete) {
                const e = this.state;
                let n;
                c = 0,
                s = this.createNewState();
                for (let t in e)
                    (n = i[t]) ? n !== u && (s[t] = o[t],
                    c++) : (s[t] = e[t],
                    c++);
                if (t.hasCreate)
                    for (let t in i)
                        i[t] === a && (s[t] = o[t],
                        c++)
            } else if (c = this.size,
            s = this.cloneState(),
            t.hasCreate)
                for (let u in i)
                    s[u] = o[u],
                    i[u] === a && c++;
            else
                for (let a in i)
                    s[a] = o[a];
            return t.state = s,
            t.size = c,
            t
        }
        _prepareCommit(e, t) {
            const n = e.meta.pendingStore.value;
            let r = this.cloneCommit(n);
            r.event = t;
            const i = this.store.history;
            return 4 === i.length ? (i[0].destroy(),
            i[0] = i[1],
            i[1] = i[2],
            i[2] = i[3],
            i[3] = this) : i.push(this),
            n.changesToCommit ? (r = this._prepareCommitChanges(e, r, n, t === d),
            r.changes && (r = this._prepareCommitState(e, r, n, t === d))) : r.changes = null,
            r.isUndo = e.meta.network.isUndo,
            r.isRedo = e.meta.network.isRedo,
            this.store.value = r,
            this.deReference(),
            r
        }
        getState() {
            return this.state
        }
        optimisticNotify() {
            this.changes && (this.store.next(this),
            this.callMergeMainStateInFlight())
        }
        notify() {
            this.changes ? (this.store.next(this),
            this.callMergeMainStateInFlight()) : this.allChanges && this.store.next(this)
        }
        callMergeMainStateInFlight() {
            const e = this.store.pendingStoreMgr.children;
            if (e.size > 0)
                for (let[,t] of e)
                    t.store.value.mergeMainStateInFlight(this)
        }
        get isUndoRedo() {
            return this.isUndo || this.isRedo || !1
        }
    }
    Object.defineProperty(f.prototype, "isUndoRedo", o.b),
    f.blacklistPropsCloneNew = {
        ts: !0,
        changes: !0,
        allChanges: !0,
        hasDelete: !0,
        hasCreate: !0,
        event: !0,
        isUndo: !0,
        isRedo: !0
    },
    f.blacklistPropsCommitPendingState = {
        changesToCommit: !0,
        changes: !0,
        state: !0,
        size: !0,
        pState: !0,
        pChanges: !0,
        pSize: !0,
        hasPendingDelete: !0,
        hasCreate: !0,
        hasDelete: !0,
        store: !0
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(14)
      , i = n(22);
    function o(e, t) {
        return function(n) {
            return n.lift(new s(e,t))
        }
    }
    var s = function() {
        function e(e, t) {
            this.predicate = e,
            this.thisArg = t
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new a(e,this.predicate,this.thisArg))
        }
        ,
        e
    }()
      , a = function(e) {
        function t(t, n, r) {
            var i = e.call(this, t) || this;
            return i.predicate = n,
            i.thisArg = r,
            i.count = 0,
            i
        }
        return r.a(t, e),
        t.prototype._next = function(e) {
            var t;
            try {
                t = this.predicate.call(this.thisArg, e, this.count++)
            } catch (n) {
                return void this.destination.error(n)
            }
            t && this.destination.next(e)
        }
        ,
        t
    }(i.a)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return i
    }
    ));
    const r = (e, t, n, r) => {
        let i = !0;
        if (e && e[n]) {
            if (e[n] === t[n])
                return t[n] = r ? [...t[n]] : {
                    ...t[n]
                },
                !0
        } else
            i = !1;
        return t[n] || (t[n] = r ? [] : {}),
        i
    }
    ;
    function i(e, t, n, i) {
        if (!n)
            return t ? e === t ? i ? [...t] : {
                ...t
            } : t : i ? [] : {};
        if (t ? e === t && (t = {
            ...t
        }) : t = {},
        "string" === typeof n)
            r(e, t, n, i);
        else {
            let o = e
              , s = t
              , a = 0;
            const c = n.length - 1;
            for (; a < c; )
                o = r(o, s, n[a]) ? o[n[a]] : null,
                s = s[n[a]],
                a++;
            r(o, s, n[c], i)
        }
        return t
    }
}
, function(e, t, n) {
    "use strict";
    !function e() {
        if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) {
            0;
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
            } catch (t) {
                console.error(t)
            }
        }
    }(),
    e.exports = n(852)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "a", (function() {
        return b
    }
    )),
    n.d(t, "c", (function() {
        return g
    }
    )),
    n.d(t, "d", (function() {
        return m
    }
    ));
    var r = n(876)
      , i = n(874);
    const o = r.a.initModule("@isomorix/record/logic").add(i.a.findByName("trxPrepare")).add(i.a.findByName("trxComplete")).addSource(i.a);
    var s = n(32)
      , a = n(23)
      , c = n(15)
      , u = n(1006)
      , l = n(196);
    const d = o.parseModuleName("./recursiveVFs")
      , h = o.packageName
      , f = Object.values(s.b)
      , p = {};
    for (let _ of f)
        _ !== a.d && (p[_] = _);
    function g(e) {
        return e
    }
    function m(e) {
        return e
    }
    g[c.d] = {
        [c.h]: u.a,
        [c.j]: "recursiveChildAnchorLogic",
        [c.m]: l.a,
        [c.n]: !0,
        [c.a]: "*",
        [c.l]: h,
        [c.i]: d,
        [c.e]: "Anchor logic for children in a recursive relationship. The children will wait at this logic during each op until the parent reaches its `recursiveParentAnchorLogic` before continuing."
    },
    m[c.d] = {
        [c.h]: u.b,
        [c.j]: "recursiveParentAnchorLogic",
        [c.m]: l.b,
        [c.n]: !0,
        [c.a]: "*",
        [c.l]: h,
        [c.i]: d,
        [c.e]: "Anchor logic for the parent in a recursive relationship. The parent will not proceed past this logic until its children reach this logic, and children will not pass the `recursiveChildAnchorLogic` until the parent reaches this logic during each op. Meaning, a child will wait at the `recursiveChildAnchorLogic` until its parent reaches this logic, and the parent will wait at this logic until its children catch up. They will then both proceed."
    };
    const y = e => ({
        logic: e.isRefModel ? u.b : u.a,
        otherLogic: u.b,
        opsMap: p,
        asPeer: !0
    });
    function v(e, t, n, r) {
        e._addDependency(t, n),
        r && t._addDependency(e, r)
    }
    function b(e, t) {
        const n = {};
        let r;
        function i(e, t) {
            let r = n[e.bestVFName];
            return r ? t ? y(e) : r : null
        }
        function o(i, o) {
            o || (o = n);
            const {meta: s} = i
              , a = s.store
              , c = s.instance
              , {dispatchId: u} = s;
            let l, d, h, f, p, g, m;
            r = e.virtualFields;
            for (let e in o)
                if (l = r[e],
                f = l.getter(c, a))
                    if (g = o[e],
                    m = o[l.ownRefModelVF.bestVFName],
                    l.isMany)
                        for (d in h = f,
                        h)
                            f = h[d],
                            (p = t.get(f).getAction(u)) && v(s, p.meta, g, m);
                    else
                        (p = t.get(f).getAction(u)) && v(s, p.meta, g, m);
            return i
        }
        return o[c.d] = {
            [c.h]: u.c,
            [c.j]: "syncRecursiveVFs",
            [c.k]: a.f,
            [c.m]: -1500,
            [c.a]: "*",
            [c.n]: !0,
            [c.l]: h,
            [c.i]: d,
            [c.e]: "Checks for recursive relationships and syncs parent and child records accordingly."
        },
        o.registerVF = function(e) {
            const t = e.bestVFName;
            return !n[t] && (n[t] = y(e),
            !0)
        }
        ,
        o.getOwnOptions = i,
        o.getOwnRefOptions = function(e, t) {
            return i(e.ownRefModelVF, t)
        }
        ,
        o.getOwnRefAction = function(e, n, r) {
            return t.get(n).getAction(r || e.meta.dispatchId)
        }
        ,
        o
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return p
    }
    )),
    n.d(t, "a", (function() {
        return g
    }
    ));
    var r = Number.isFinite || function(e) {
        return "number" === typeof e && isFinite(e)
    }
      , i = Number.isInteger || function(e) {
        return "number" === typeof e && isFinite(e) && Math.floor(e) === e
    }
      , o = n(21)
      , s = n(103)
      , a = n(12)
      , c = n(107)
      , u = n(36)
      , l = n(85);
    var d = new l.c({
        name: "Int",
        description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
        serialize: function(e) {
            var t = f(e);
            if ("boolean" === typeof t)
                return t ? 1 : 0;
            var n = t;
            if ("string" === typeof t && "" !== t && (n = Number(t)),
            !i(n))
                throw new u.a("Int cannot represent non-integer value: ".concat(Object(o.a)(t)));
            if (n > 2147483647 || n < -2147483648)
                throw new u.a("Int cannot represent non 32-bit signed integer value: " + Object(o.a)(t));
            return n
        },
        parseValue: function(e) {
            if (!i(e))
                throw new u.a("Int cannot represent non-integer value: ".concat(Object(o.a)(e)));
            if (e > 2147483647 || e < -2147483648)
                throw new u.a("Int cannot represent non 32-bit signed integer value: ".concat(e));
            return e
        },
        parseLiteral: function(e) {
            if (e.kind !== a.a.INT)
                throw new u.a("Int cannot represent non-integer value: ".concat(Object(c.a)(e)),e);
            var t = parseInt(e.value, 10);
            if (t > 2147483647 || t < -2147483648)
                throw new u.a("Int cannot represent non 32-bit signed integer value: ".concat(e.value),e);
            return t
        }
    });
    var h = new l.c({
        name: "Float",
        description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
        serialize: function(e) {
            var t = f(e);
            if ("boolean" === typeof t)
                return t ? 1 : 0;
            var n = t;
            if ("string" === typeof t && "" !== t && (n = Number(t)),
            !r(n))
                throw new u.a("Float cannot represent non numeric value: ".concat(Object(o.a)(t)));
            return n
        },
        parseValue: function(e) {
            if (!r(e))
                throw new u.a("Float cannot represent non numeric value: ".concat(Object(o.a)(e)));
            return e
        },
        parseLiteral: function(e) {
            if (e.kind !== a.a.FLOAT && e.kind !== a.a.INT)
                throw new u.a("Float cannot represent non numeric value: ".concat(Object(c.a)(e)),e);
            return parseFloat(e.value)
        }
    });
    function f(e) {
        if (Object(s.a)(e)) {
            if ("function" === typeof e.valueOf) {
                var t = e.valueOf();
                if (!Object(s.a)(t))
                    return t
            }
            if ("function" === typeof e.toJSON)
                return e.toJSON()
        }
        return e
    }
    var p = new l.c({
        name: "String",
        description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
        serialize: function(e) {
            var t = f(e);
            if ("string" === typeof t)
                return t;
            if ("boolean" === typeof t)
                return t ? "true" : "false";
            if (r(t))
                return t.toString();
            throw new u.a("String cannot represent value: ".concat(Object(o.a)(e)))
        },
        parseValue: function(e) {
            if ("string" !== typeof e)
                throw new u.a("String cannot represent a non string value: ".concat(Object(o.a)(e)));
            return e
        },
        parseLiteral: function(e) {
            if (e.kind !== a.a.STRING)
                throw new u.a("String cannot represent a non string value: ".concat(Object(c.a)(e)),e);
            return e.value
        }
    });
    var g = new l.c({
        name: "Boolean",
        description: "The `Boolean` scalar type represents `true` or `false`.",
        serialize: function(e) {
            var t = f(e);
            if ("boolean" === typeof t)
                return t;
            if (r(t))
                return 0 !== t;
            throw new u.a("Boolean cannot represent a non boolean value: ".concat(Object(o.a)(t)))
        },
        parseValue: function(e) {
            if ("boolean" !== typeof e)
                throw new u.a("Boolean cannot represent a non boolean value: ".concat(Object(o.a)(e)));
            return e
        },
        parseLiteral: function(e) {
            if (e.kind !== a.a.BOOLEAN)
                throw new u.a("Boolean cannot represent a non boolean value: ".concat(Object(c.a)(e)),e);
            return e.value
        }
    });
    var m = new l.c({
        name: "ID",
        description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
        serialize: function(e) {
            var t = f(e);
            if ("string" === typeof t)
                return t;
            if (i(t))
                return String(t);
            throw new u.a("ID cannot represent value: ".concat(Object(o.a)(e)))
        },
        parseValue: function(e) {
            if ("string" === typeof e)
                return e;
            if (i(e))
                return e.toString();
            throw new u.a("ID cannot represent value: ".concat(Object(o.a)(e)))
        },
        parseLiteral: function(e) {
            if (e.kind !== a.a.STRING && e.kind !== a.a.INT)
                throw new u.a("ID cannot represent a non-string and non-integer value: " + Object(c.a)(e),e);
            return e.value
        }
    });
    Object.freeze([p, d, h, g, m])
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return m
    }
    )),
    n.d(t, "a", (function() {
        return g
    }
    ));
    var r = n(0)
      , i = n(163)
      , o = n(164)
      , s = n(31)
      , a = n(394)
      , c = n(78)
      , u = n(72)
      , l = n(859)
      , d = n(52)
      , h = n(15)
      , f = n(54);
    const p = function() {};
    let g = p;
    function m(e, t, n) {
        e = (e => "function" !== typeof e ? e : {
            resolve() {},
            chunkName() {},
            requireAsync: e
        })(e);
        let p, m, y = null, v = !0;
        if (t) {
            if (n || (n = t[h.d]))
                if (y = n[h.b],
                n[h.n])
                    n[h.n] = !1;
                else {
                    const e = n[h.k];
                    v = "string" === typeof e ? f.k.indexOf(e) > -1 : f.k.indexOf(e[0]) > -1
                }
        } else
            t = () => Object(s.a)(p);
        function b(n, r) {
            if (g(n, e.chunkName()),
            !p)
                return m || (m = Object(a.a)( () => e.requireAsync()).pipe(Object(u.a)(e => (p = e,
                m = void 0,
                e)), Object(l.a)(1))),
                v || !r ? m.pipe(Object(d.a)( () => b.call(this, n, r))) : void m.subscribe( () => {
                    const e = b.call(this, n, r);
                    "undefined" !== typeof e && r.next(e)
                }
                );
            if (v) {
                let e;
                return e = n ? y ? t.call(this, n, p, ...y) : t.call(this, n, p) : y ? t.call(this, p, ...y) : t.call(this, p),
                Object(i.a)(e) ? e : Object(o.a)(e) ? Object(c.a)(e) : Object(s.a)(e || p)
            }
            return y ? t.call(this, n, r, p, ...y) : t.call(this, n, r, p)
        }
        if (b[r.q] = r.n,
        n && t[h.d]) {
            b[h.d] = n;
            const e = n[h.k];
            if (!e)
                return b;
            if ("string" !== typeof e)
                for (let t of e)
                    n[t] && (n[t] = b);
            else
                n[e] && (n[e] = b)
        }
        return b.chunkName = e.chunkName(),
        b
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    ));
    var r = n(32);
    const i = r.c - 100
      , o = r.c + 100
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return l
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    ));
    var r = n(297)
      , i = n(11)
      , o = n(83)
      , s = n(1003);
    const a = (e, t) => e && e.customHooks && e.customHooks[t] || null;
    function c(e, t, n) {
        let r;
        if (t) {
            let i = t.props;
            if ("string" === typeof i && (i = JSON.parse(t.props),
            t.props = i),
            !(r = a(i, "init")))
                return null;
            n || (n = e.payload.types) || (n = e.payload.pluginBuilder.types)
        } else {
            if (!(r = a(e.meta.store.get("props"), "init")))
                return null;
            n = e.meta.instance.types,
            t = e.meta.instance
        }
        return e.payload.schemaPrefix = Object(o.b)(t.slug),
        l(r, e, n, !0)
    }
    const u = Object(s.a)(e => (console.error("Entity call hooks error: ".concat(e.message, "\n\n").concat(e.stack)),
    Object(i.c)()));
    function l(e, t, n, o) {
        return e ? o ? Object(r.a)(n.LogicItemEnum.getByModelName().initItems(e, t, !0, !0)).pipe(u) : n.LogicItemEnum.getByModelName().initItems(e, t, !1, !1) : o ? Object(i.c)() : null
    }
}
, , , , , , , function(e, t, n) {
    var r = n(51);
    e.exports = function(e, t) {
        if (!r(e))
            return e;
        var n, i;
        if (t && "function" == typeof (n = e.toString) && !r(i = n.call(e)))
            return i;
        if ("function" == typeof (n = e.valueOf) && !r(i = n.call(e)))
            return i;
        if (!t && "function" == typeof (n = e.toString) && !r(i = n.call(e)))
            return i;
        throw TypeError("Can't convert object to primitive value")
    }
}
, function(e, t) {
    var n = 0
      , r = Math.random();
    e.exports = function(e) {
        return "Symbol(" + String(void 0 === e ? "" : e) + ")_" + (++n + r).toString(36)
    }
}
, function(e, t, n) {
    var r = n(255)
      , i = n(113);
    e.exports = function(e) {
        return r(i(e))
    }
}
, function(e, t) {
    e.exports = {}
}
, function(e, t, n) {
    "use strict";
    var r = n(34)
      , i = function(e) {
        var t, n;
        this.promise = new e((function(e, r) {
            if (void 0 !== t || void 0 !== n)
                throw TypeError("Bad Promise constructor");
            t = e,
            n = r
        }
        )),
        this.resolve = r(t),
        this.reject = r(n)
    };
    e.exports.f = function(e) {
        return new i(e)
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(18);
    e.exports = function() {
        var e = r(this)
          , t = "";
        return e.global && (t += "g"),
        e.ignoreCase && (t += "i"),
        e.multiline && (t += "m"),
        e.dotAll && (t += "s"),
        e.unicode && (t += "u"),
        e.sticky && (t += "y"),
        t
    }
}
, function(e, t, n) {
    var r = n(464)
      , i = n(129)
      , o = n(40)("toStringTag")
      , s = "Arguments" == i(function() {
        return arguments
    }());
    e.exports = r ? i : function(e) {
        var t, n, r;
        return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
            try {
                return e[t]
            } catch (n) {}
        }(t = Object(e), o)) ? n : s ? i(t) : "Object" == (r = i(t)) && "function" == typeof t.callee ? "Arguments" : r
    }
}
, function(e, t, n) {
    var r = n(207)
      , i = n(51)
      , o = n(56)
      , s = n(50).f
      , a = n(205)
      , c = n(489)
      , u = a("meta")
      , l = 0
      , d = Object.isExtensible || function() {
        return !0
    }
      , h = function(e) {
        s(e, u, {
            value: {
                objectID: "O" + ++l,
                weakData: {}
            }
        })
    }
      , f = e.exports = {
        REQUIRED: !1,
        fastKey: function(e, t) {
            if (!i(e))
                return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
            if (!o(e, u)) {
                if (!d(e))
                    return "F";
                if (!t)
                    return "E";
                h(e)
            }
            return e[u].objectID
        },
        getWeakData: function(e, t) {
            if (!o(e, u)) {
                if (!d(e))
                    return !0;
                if (!t)
                    return !1;
                h(e)
            }
            return e[u].weakData
        },
        onFreeze: function(e) {
            return c && f.REQUIRED && d(e) && !o(e, u) && h(e),
            e
        }
    };
    r[u] = !0
}
, function(e, t, n) {
    "use strict";
    var r = n(18)
      , i = n(34);
    e.exports = function() {
        for (var e, t = r(this), n = i(t.delete), o = !0, s = 0, a = arguments.length; s < a; s++)
            e = n.call(t, arguments[s]),
            o = o && e;
        return !!o
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(34)
      , i = n(44)
      , o = n(27);
    e.exports = function(e) {
        var t, n, s, a, c = arguments.length, u = c > 1 ? arguments[1] : void 0;
        return r(this),
        (t = void 0 !== u) && r(u),
        void 0 == e ? new this : (n = [],
        t ? (s = 0,
        a = i(u, c > 2 ? arguments[2] : void 0, 2),
        o(e, (function(e) {
            n.push(a(e, s++))
        }
        ))) : o(e, n.push, n),
        new this(n))
    }
}
, function(e, t, n) {
    "use strict";
    e.exports = function() {
        for (var e = arguments.length, t = new Array(e); e--; )
            t[e] = arguments[e];
        return new this(t)
    }
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = c(n(614))
      , i = c(n(616))
      , o = c(n(620))
      , s = c(n(623))
      , a = c(n(626));
    function c(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    function u(e) {
        var t = -1
          , n = null == e ? 0 : e.length;
        for (this.clear(); ++t < n; ) {
            var r = e[t];
            this.set(r[0], r[1])
        }
    }
    u.prototype.clear = r.default,
    u.prototype.delete = i.default,
    u.prototype.get = o.default,
    u.prototype.has = s.default,
    u.prototype.set = a.default,
    t.default = u,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(619), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e, t) {
        for (var n = e.length; n--; )
            if ((0,
            o.default)(e[n][0], t))
                return n;
        return -1
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(647))
      , i = s(n(650))
      , o = s(n(653));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var a = r.default ? r.default.toStringTag : void 0;
    t.default = function(e) {
        return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : a && a in Object(e) ? (0,
        i.default)(e) : (0,
        o.default)(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(674);
    var o = (0,
    ((r = i) && r.__esModule ? r : {
        default: r
    }).default)(Object, "create");
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(691), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e, t) {
        var n = e.__data__;
        return (0,
        o.default)(t) ? n["string" == typeof t ? "string" : "hash"] : n.map
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    t.default = function(e) {
        return null != e && "object" == ("undefined" === typeof e ? "undefined" : r(e))
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "a", (function() {
        return c
    }
    )),
    n.d(t, "b", (function() {
        return u
    }
    ));
    const r = "vitalstats"
      , i = r.toUpperCase()
      , o = Object({
        APP_VERSION: "1752353655",
        CORE_PLUGIN_SLUG: "vitalstats",
        VITALSTATS_PLUGIN_NAME: "vitalstats",
        VITALSTATS_PLUGIN_DESCRIPTION: "Vital Stats empowers businesses with the tools and technology they need to thrive in today's modern world.",
        ISOMX_VAPID_PUBLIC_KEY: "BCmOoIWa_fzacAgaNAIeOmFgziu5BzV0Kza0rl-rM2MBC7rAC6b0GP9rqvTQqjUqkf30mVSFjRdfjb0v4fgLF3Q",
        ISOMX_GOOGLE_MAPS_API_KEY: "AIzaSyANWBuLTP6NrpERQGnIemNmpgvozqezx14",
        QUERY_UI_ADMIN_USER_IDS: "dml0YWxzdGF0c3x8VXNlcnx8MQ==,dml0YWxzdGF0c3x8VXNlcnx8Mw==",
        APP_ASSETS_BASE_URL: "https://static-au03.vitalstats.app",
        APP_ASSETS_HOST: "static-au03.vitalstats.app",
        APP_ASSETS_DIR: "static",
        APP_ASSETS_VOLUMES_PATH: "",
        ISOMX_IS_SDK: "1",
        NODE_ENV: "production",
        BROWSER: 1,
        PUBLIC_URL: "C:/dev/isomorix/ui/volumes/public/vitalstats"
    })["".concat(i, "_PLUGIN_NAME")] || "core"
      , s = Object({
        APP_VERSION: "1752353655",
        CORE_PLUGIN_SLUG: "vitalstats",
        VITALSTATS_PLUGIN_NAME: "vitalstats",
        VITALSTATS_PLUGIN_DESCRIPTION: "Vital Stats empowers businesses with the tools and technology they need to thrive in today's modern world.",
        ISOMX_VAPID_PUBLIC_KEY: "BCmOoIWa_fzacAgaNAIeOmFgziu5BzV0Kza0rl-rM2MBC7rAC6b0GP9rqvTQqjUqkf30mVSFjRdfjb0v4fgLF3Q",
        ISOMX_GOOGLE_MAPS_API_KEY: "AIzaSyANWBuLTP6NrpERQGnIemNmpgvozqezx14",
        QUERY_UI_ADMIN_USER_IDS: "dml0YWxzdGF0c3x8VXNlcnx8MQ==,dml0YWxzdGF0c3x8VXNlcnx8Mw==",
        APP_ASSETS_BASE_URL: "https://static-au03.vitalstats.app",
        APP_ASSETS_HOST: "static-au03.vitalstats.app",
        APP_ASSETS_DIR: "static",
        APP_ASSETS_VOLUMES_PATH: "",
        ISOMX_IS_SDK: "1",
        NODE_ENV: "production",
        BROWSER: 1,
        PUBLIC_URL: "C:/dev/isomorix/ui/volumes/public/vitalstats"
    })["".concat(i, "_PLUGIN_DESCRIPTION")] || "The Core Plugin"
      , a = r
      , c = "4.3.14"
      , u = {
        NAME: o,
        DESCRIPTION: s,
        SLUG: r,
        MULTISITE_TYPE: null
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(26)
      , i = n(223)
      , o = n(151);
    function s(e, t) {
        return t ? Object(o.a)(e, t) : new r.a(Object(i.a)(e))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var r = function(e) {
        return function(t) {
            for (var n = 0, r = e.length; n < r && !t.closed; n++)
                t.next(e[n]);
            t.complete()
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var r = function(e) {
        return e && "number" === typeof e.length && "function" !== typeof e
    }
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return !!e && "function" !== typeof e.subscribe && "function" === typeof e.then
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(14)
      , i = function(e) {
        function t(t, n) {
            var r = e.call(this) || this;
            return r.subject = t,
            r.subscriber = n,
            r.closed = !1,
            r
        }
        return r.a(t, e),
        t.prototype.unsubscribe = function() {
            if (!this.closed) {
                this.closed = !0;
                var e = this.subject
                  , t = e.observers;
                if (this.subject = null,
                t && 0 !== t.length && !e.isStopped && !e.closed) {
                    var n = t.indexOf(this.subscriber);
                    -1 !== n && t.splice(n, 1)
                }
            }
        }
        ,
        t
    }(n(38).a)
}
, function(e, t, n) {
    "use strict";
    (function(e) {
        n.d(t, "a", (function() {
            return r
        }
        ));
        class r {
            constructor(e, t) {
                this.options = e,
                this.isServer = t,
                this.hasCustomizedPlugin = !1,
                this.init = () => this.doInit(),
                this.getPlugin = () => this.mainStore ? this.mainStore.instance : void 0,
                this.getState = () => this.mainStore,
                this.CoreBuilder = e.CoreBuilder,
                this.devLoader = e.devLoader,
                this.enableDevMode = () => {
                    if (this.bundleDevModule)
                        this.storeConfig && this.bundleDevModule.enableDevMode(this.storeConfig),
                        this.isPendingReload && (this.isPendingReload = !1,
                        this.reloadApp());
                    else {
                        if (!this.devLoader)
                            return;
                        this.devLoader().subscribe(e => {
                            this.bundleDevModule || (this.bundleDevModule = e,
                            this.getDestroyApp = e.getDestroyApp,
                            this.enableDevMode())
                        }
                        )
                    }
                }
                ,
                this.reloadApp = () => {
                    this.bundleDevModule ? (this.isLoading = !1,
                    this.init()) : (this.isPendingReload = !0,
                    this.enableDevMode())
                }
            }
            setHot() {
                return this
            }
            initBegin() {
                this.isLoading = !0;
                const t = this.isServer ? e : window;
                return this.mainStore ? (t.isReload = !0,
                this.prevStore = this.mainStore,
                this.mainStore = void 0,
                this.builder = void 0,
                this.storeConfig = void 0,
                this.hasCustomizedPlugin = !1) : t.isReload = !1,
                this
            }
            createStoreConfig() {
                return this.storeConfig = this.CoreBuilder.createStoreConfig(this.isServer),
                this.bundleDevModule && this.bundleDevModule.enableDevMode(this.storeConfig),
                this
            }
            initBuilder() {
                return this.builder = this.CoreBuilder.init(this.storeConfig),
                this
            }
            customizePlugin() {
                return this.hasCustomizedPlugin = !0,
                this.options.customizePlugin(this),
                this
            }
            createStore() {
                return this.mainStore = this.options.createStore ? this.options.createStore(this) : this.builder.createStore(),
                this
            }
            dispatchInit() {
                (this.isServer ? e : window).isReload = !!this.prevStore;
                const t = this.options.dispatchInit ? this.options.dispatchInit(this) : this.builder.dispatchInit();
                return t && this.subscribeToAction(t),
                this
            }
            initComplete() {
                if (this.isLoading = !1,
                this.getDestroyApp && this.prevStore) {
                    const {prevStore: e} = this;
                    this.prevStore = void 0,
                    setTimeout(this.getDestroyApp(e), this.isServer ? 1e3 : 1e4)
                }
                this.hasQueuedReload && (this.hasQueuedReload = !1,
                setTimeout(this.init, 50))
            }
        }
    }
    ).call(this, n(167))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    var r = function() {
        function e() {
            return Error.call(this),
            this.message = "argument out of range",
            this.name = "ArgumentOutOfRangeError",
            this
        }
        return e.prototype = Object.create(Error.prototype),
        e
    }()
}
, function(e, t, n) {
    "use strict";
    function r(e, t) {
        if (!Boolean(e))
            throw new Error(null != t ? t : "Unexpected invariant triggered.")
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        var t = e.split(/\r\n|[\n\r]/g)
          , n = function(e) {
            for (var t, n = !0, r = !0, i = 0, o = null, s = 0; s < e.length; ++s)
                switch (e.charCodeAt(s)) {
                case 13:
                    10 === e.charCodeAt(s + 1) && ++s;
                case 10:
                    n = !1,
                    r = !0,
                    i = 0;
                    break;
                case 9:
                case 32:
                    ++i;
                    break;
                default:
                    r && !n && (null === o || i < o) && (o = i),
                    r = !1
                }
            return null !== (t = o) && void 0 !== t ? t : 0
        }(e);
        if (0 !== n)
            for (var r = 1; r < t.length; r++)
                t[r] = t[r].slice(n);
        for (var o = 0; o < t.length && i(t[o]); )
            ++o;
        for (var s = t.length; s > o && i(t[s - 1]); )
            --s;
        return t.slice(o, s).join("\n")
    }
    function i(e) {
        for (var t = 0; t < e.length; ++t)
            if (" " !== e[t] && "\t" !== e[t])
                return !1;
        return !0
    }
    function o(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ""
          , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
          , r = -1 === e.indexOf("\n")
          , i = " " === e[0] || "\t" === e[0]
          , o = '"' === e[e.length - 1]
          , s = "\\" === e[e.length - 1]
          , a = !r || o || s || n
          , c = "";
        return !a || r && i || (c += "\n" + t),
        c += t ? e.replace(/\n/g, "\n" + t) : e,
        a && (c += "\n"),
        '"""' + c.replace(/"""/g, '\\"""') + '"""'
    }
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(52)
      , i = n(153);
    function o(e) {
        return void 0 === e && (e = Number.POSITIVE_INFINITY),
        Object(r.a)(i.a, e)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = void 0
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return l
    }
    ));
    var r = n(223)
      , i = n(105)
      , o = n(119)
      , s = n(90)
      , a = n(224)
      , c = n(225)
      , u = n(152)
      , l = function(e) {
        if (e && "function" === typeof e[s.a])
            return l = e,
            function(e) {
                var t = l[s.a]();
                if ("function" !== typeof t.subscribe)
                    throw new TypeError("Provided object does not correctly implement Symbol.observable");
                return t.subscribe(e)
            }
            ;
        if (Object(a.a)(e))
            return Object(r.a)(e);
        if (Object(c.a)(e))
            return n = e,
            function(e) {
                return n.then((function(t) {
                    e.closed || (e.next(t),
                    e.complete())
                }
                ), (function(t) {
                    return e.error(t)
                }
                )).then(null, i.a),
                e
            }
            ;
        if (e && "function" === typeof e[o.a])
            return t = e,
            function(e) {
                for (var n = t[o.a](); ; ) {
                    var r = void 0;
                    try {
                        r = n.next()
                    } catch (i) {
                        return e.error(i),
                        e
                    }
                    if (r.done) {
                        e.complete();
                        break
                    }
                    if (e.next(r.value),
                    e.closed)
                        break
                }
                return "function" === typeof n.return && e.add((function() {
                    n.return && n.return()
                }
                )),
                e
            }
            ;
        var t, n, l, d = Object(u.a)(e) ? "an invalid object" : "'" + e + "'";
        throw new TypeError("You provided " + d + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.")
    }
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return "/" === e.charAt(e.length - 1) ? e : "".concat(e, "/")
    }
    function i(e) {
        return "/" === e[0] ? e : "/".concat(e)
    }
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "d", (function() {
        return c
    }
    ));
    const o = /^\/+/
      , s = /(?<=.)\/+$/;
    function a(e) {
        return e.replace(o, "")
    }
    function c(e) {
        return e.replace(s, "")
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    const r = "function" === typeof Symbol ? Symbol.for("nodejs.util.inspect.custom") : void 0;
    function i(e) {
        return o(e)
    }
    function o(e, t) {
        switch (typeof e) {
        case "string":
            return JSON.stringify(e);
        case "function":
            return e.name ? "[function ".concat(e.name, "]") : "[function]";
        case "object":
            return function(e, t) {
                if (-1 !== t.indexOf(e))
                    return "[Circular]";
                const n = [...t, e];
                if (e) {
                    const t = function(e) {
                        const t = e[String(r)];
                        if ("function" === typeof t)
                            return t;
                        if ("function" === typeof e.inspect)
                            return e.inspect
                    }(e);
                    if (t) {
                        const r = t.call(e);
                        if (r !== e)
                            return "string" === typeof r ? r : o(r, n)
                    } else if (Array.isArray(e))
                        return function(e, t) {
                            if (0 === e.length)
                                return "[]";
                            if (t.length > 2)
                                return "[Array]";
                            const n = Math.min(10, e.length)
                              , r = e.length - n
                              , i = [];
                            for (let s = 0; s < n; ++s)
                                i.push(o(e[s], t));
                            1 === r ? i.push("... 1 more item") : r > 1 && i.push("... ".concat(r, " more items"));
                            return "[" + i.join(", ") + "]"
                        }(e, n);
                    return function(e, t) {
                        const n = Object.keys(e);
                        if (0 === n.length)
                            return "{}";
                        if (t.length > 2)
                            return "[" + function(e) {
                                const t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
                                if ("Object" === t && "function" === typeof e.constructor) {
                                    const t = e.constructor.name;
                                    if ("string" === typeof t)
                                        return t
                                }
                                return t
                            }(e) + "]";
                        return "{ " + n.map(n => n + ": " + o(e[n], t)).join(", ") + " }"
                    }(e, n)
                }
                return String(e)
            }(e, t || []);
        default:
            return String(e)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return g
    }
    ));
    var r = n(123)
      , i = n(159)
      , o = n(183);
    const {CREATED: s, UPDATED: a, DELETED: c, PK_CHANGE: u} = i.a
      , {STALE: l} = o.a
      , d = Object.prototype.propertyIsEnumerable
      , h = {
        enumerable: !1,
        configurable: !0,
        writable: !0
    }
      , f = {
        enumerable: !0,
        configurable: !0,
        writable: !0
    }
      , p = (e, t) => {
        const {store: n} = e;
        if (!e.pState && !n.history.length)
            return !1;
        if (!t) {
            const e = n.getAction(n.mainDispatchId).meta.network;
            return e.isUndo || e.isRedo || !1
        }
        return n.getAction(n.mainDispatchId).meta.network[t]
    }
    ;
    class g extends r.a {
        constructor(e) {
            super(e),
            e && (this.allChanges = void 0,
            this.changesToCommit = void 0,
            this.pState = void 0,
            this.pChanges = void 0,
            this.pSize = void 0,
            this.hasPendingDelete = !1)
        }
        static init(e, t) {
            const n = new this;
            n.store = e;
            const r = e.getAction(e.mainDispatchId);
            return n.mainDispatchId = r.meta.mainDispatchId,
            n.dispatchId = r.meta.pendingDispatchId,
            n.cloneMainState(e.mainStore.value, n),
            n
        }
        cloneMainState(e, t) {
            t || (t = this.cloneNew());
            const {blacklistPropsCloneMainState: n} = this.constructor;
            for (let r in e)
                n[r] || (t[r] = e[r]);
            return t
        }
        registerChildStore(e) {
            const t = this.store.mainStore;
            if (t._savePendingChildByKey) {
                let n;
                t._savePendingChildInstance ? (n = e.instance[t._savePendingChildByKey],
                this.pChanges && this.pChanges[n] || this.set(n, e.instance)) : (n = e.get(t._savePendingChildByKey),
                this.pChanges && this.pChanges[n] || this.set(n, e.instance))
            }
        }
        get(e) {
            return this.pChanges ? this.pChanges[e] === c ? void 0 : this.pState[e] : this.state[e]
        }
        has(e) {
            return this.pChanges ? this.pChanges[e] !== c && d.call(this.pState, e) : d.call(this.state, e)
        }
        set(e, t) {
            let {pState: n, pChanges: r} = this;
            if (n) {
                if (r[e] === c)
                    return r[e] = a,
                    n[e] = t,
                    Object.defineProperty(n, e, f),
                    this.pSize++,
                    t
            } else
                this.pState = n = this.cloneState(),
                this.pChanges = r = {},
                this.pSize = this.size;
            return d.call(n, e) ? r[e] !== s && (r[e] = a) : (this.pSize++,
            r[e] = s),
            n[e] = t,
            t
        }
        setImmediate(e, t, n) {
            const r = e.meta
              , {changes: i, allChanges: o} = this;
            if (!i || !r.isTrx || r.dispatchId !== this.dispatchId || this.pChanges)
                return !1;
            const {state: u} = this;
            let h = i[t];
            d.call(u, t) ? h || (h = a) : (this.size++,
            h = h === c ? a : s),
            u[t] = n,
            i[t] = h;
            const {changesToCommit: f} = this;
            return h === a ? (o[t] || (o[t] = a),
            f[t] || (f[t] = a)) : (o[t] = h,
            f[t] !== l && (f[t] = h,
            h === s ? this.hasCreate = !0 : this.hasDelete = !0)),
            !0
        }
        delete(e) {
            let {pChanges: t} = this;
            if (t) {
                if (t[e] === c || !d.call(this.pState, e))
                    return !1
            } else {
                if (!d.call(this.state, e))
                    return !1;
                this.pState = this.cloneState(),
                this.pChanges = t = {},
                this.pSize = this.size
            }
            return this.pSize--,
            this.hasPendingDelete = !0,
            this.pState[e] = void 0,
            t[e] = c,
            Object.defineProperty(this.pState, e, h),
            !0
        }
        deleteAll() {
            let e, {pState: t} = this;
            t ? ({pChanges: e} = this) : (t = this.state,
            e = {});
            let n = !1;
            for (let r in t)
                e[r] = c,
                n = !0;
            return this.pState = {},
            this.pSize = 0,
            this.pChanges = e,
            n
        }
        cancel(e) {
            this.pState && (this.pState = void 0,
            this.pSize = void 0,
            this.pChanges = void 0),
            e.meta.cancel()
        }
        _prepareCommitChanges(e, t) {
            const {pChanges: n} = this;
            let r, {changesToCommit: i, allChanges: o} = this;
            o || (t.allChanges = o = {}),
            i || (t.changesToCommit = i = {});
            for (let d in n)
                switch (r = n[d],
                r) {
                case a:
                    o[d] || (o[d] = a),
                    i[d] || (i[d] = a);
                    break;
                case s:
                    o[d] = r,
                    i[d] !== l && (i[d] = r,
                    t.hasCreate = !0);
                    break;
                case u:
                    break;
                case c:
                    o[d] = r,
                    i[d] !== l && (i[d] = r,
                    t.hasDelete = !0);
                    break;
                default:
                    o[d] = r
                }
            return t.changes = n,
            t.state = this.hasPendingDelete ? {
                ...this.pState
            } : this.pState,
            t.size = this.pSize,
            t
        }
        _prepareCommit(e, t) {
            const {pState: n} = this;
            if (!n)
                return e && (this.dispatchId = e.meta.dispatchId),
                this.changes = null,
                this;
            let r = this.cloneNew();
            return e && (r.dispatchId = e.meta.dispatchId),
            r.event = t,
            r = this._prepareCommitChanges(e, r),
            this.pSize = void 0,
            this.pState = void 0,
            this.pChanges = void 0,
            this.store.history.push(this),
            this.store.value = r,
            this.deReference(),
            r
        }
        optimisticNotify() {
            this.changes && this.store.next(this)
        }
        notify() {
            this.changes && this.store.next(this)
        }
        mergeMainStateInFlight(e) {
            const {mainDispatchId: t, changes: n} = e;
            if (this.mainDispatchId === t || !n)
                return;
            let r;
            if (this.mainDispatchId < t) {
                if (({changesToCommit: r} = this),
                r || (this.changesToCommit = r = {}),
                !e.hasCreate) {
                    for (let e in n)
                        r[e] = l;
                    return
                }
            } else if (!e.hasCreate)
                return;
            const {allChanges: i, pChanges: o, pState: a, state: c} = this
              , {state: h} = e;
            let f, p = 0;
            for (let g in n)
                f = n[g],
                f !== u && (n[g] !== s || i && i[g] || o && o[g] || d.call(c, g) || (c[g] = h[g],
                a && (a[g] = h[g]),
                p++),
                r && (r[g] = l));
            p && (this.size += p,
            o && (this.pSize += p))
        }
        getPrevState() {
            return this.pChanges ? this.state : super.getPrevState()
        }
        getState() {
            return this.pState ? this.hasPendingDelete ? (this.pState = {
                ...this.pState
            },
            this.hasPendingDelete = !1,
            this.pState) : this.pState : this.state
        }
        get isUndo() {
            return p(this, "isUndo")
        }
        get isRedo() {
            return p(this, "isRedo")
        }
        get isUndoRedo() {
            return p(this)
        }
    }
    Object.defineProperties(g.prototype, {
        isUndo: r.b,
        isRedo: r.b,
        isUndoRedo: r.b
    }),
    g.blacklistPropsCloneNew = {
        changes: !0,
        hasPendingDelete: !0,
        pState: !0,
        pChanges: !0,
        pSize: !0
    },
    g.blacklistPropsCloneMainState = {
        hasCreate: !0,
        hasDelete: !0,
        changesToCommit: !0,
        dispatchId: !0,
        mainDispatchId: !0,
        changes: !0,
        event: !0,
        allChanges: !0,
        store: !0,
        isUndo: !0,
        isRedo: !0
    }
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return e.charAt(0).toLowerCase() + e.slice(1)
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    var r, i;
    !function(o) {
        if (void 0 === (i = "function" === typeof (r = o) ? r.call(t, n, t, e) : r) || (e.exports = i),
        !0,
        e.exports = o(),
        !!0) {
            var s = window.Cookies
              , a = window.Cookies = o();
            a.noConflict = function() {
                return window.Cookies = s,
                a
            }
        }
    }((function() {
        function e() {
            for (var e = 0, t = {}; e < arguments.length; e++) {
                var n = arguments[e];
                for (var r in n)
                    t[r] = n[r]
            }
            return t
        }
        function t(e) {
            return e.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
        }
        return function n(r) {
            function i() {}
            function o(t, n, o) {
                if ("undefined" !== typeof document) {
                    "number" === typeof (o = e({
                        path: "/"
                    }, i.defaults, o)).expires && (o.expires = new Date(1 * new Date + 864e5 * o.expires)),
                    o.expires = o.expires ? o.expires.toUTCString() : "";
                    try {
                        var s = JSON.stringify(n);
                        /^[\{\[]/.test(s) && (n = s)
                    } catch (u) {}
                    n = r.write ? r.write(n, t) : encodeURIComponent(String(n)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent),
                    t = encodeURIComponent(String(t)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
                    var a = "";
                    for (var c in o)
                        o[c] && (a += "; " + c,
                        !0 !== o[c] && (a += "=" + o[c].split(";")[0]));
                    return document.cookie = t + "=" + n + a
                }
            }
            function s(e, n) {
                if ("undefined" !== typeof document) {
                    for (var i = {}, o = document.cookie ? document.cookie.split("; ") : [], s = 0; s < o.length; s++) {
                        var a = o[s].split("=")
                          , c = a.slice(1).join("=");
                        n || '"' !== c.charAt(0) || (c = c.slice(1, -1));
                        try {
                            var u = t(a[0]);
                            if (c = (r.read || r)(c, u) || t(c),
                            n)
                                try {
                                    c = JSON.parse(c)
                                } catch (l) {}
                            if (i[u] = c,
                            e === u)
                                break
                        } catch (l) {}
                    }
                    return e ? i[e] : i
                }
            }
            return i.set = o,
            i.get = function(e) {
                return s(e, !1)
            }
            ,
            i.getJSON = function(e) {
                return s(e, !0)
            }
            ,
            i.remove = function(t, n) {
                o(t, "", e(n, {
                    expires: -1
                }))
            }
            ,
            i.defaults = {},
            i.withConverter = n,
            i
        }((function() {}
        ))
    }
    ))
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(828))
      , i = s(n(829))
      , o = s(n(831));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var a = (0,
    r.default)((function(e, t) {
        for (var n, r = t, s = 0; s < e.length; ) {
            if (null == r)
                return;
            n = e[s],
            r = (0,
            i.default)(n) ? (0,
            o.default)(n, r) : r[n],
            s += 1
        }
        return r
    }
    ));
    t.default = a,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "e", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "c", (function() {
        return s
    }
    )),
    n.d(t, "a", (function() {
        return a
    }
    )),
    n.d(t, "d", (function() {
        return c
    }
    ));
    var r = n(140);
    const i = ["pathname", "search", "hash", "hostname", "port", "protocol", "slashes", "key", "title", "state", "historyIdx"];
    function o(e) {
        const t = {
            __historyIdx: e.historyIdx
        };
        for (let n of i)
            t[n] = e[n];
        return t
    }
    function s(e) {
        const t = document.location;
        let n = e.historyIdx - 1;
        const r = e.historyArray;
        n < 0 && (n = 0);
        let i = n;
        for (; i < r.length; )
            r[i].historyIdx++,
            r[i].__historyIdx++,
            i++;
        return {
            pathname: t.pathname,
            search: t.search,
            hash: t.hash,
            key: e.createKey(),
            title: document.title || "",
            state: null,
            historyIdx: n,
            __historyIdx: n
        }
    }
    function a(e, t) {
        let n = Object(r.a)(e, t, "__historyIdx");
        const i = t.length;
        for (; n < i; )
            t[n].historyIdx = n,
            n++
    }
    function c(e, t) {
        for (let n of e)
            if (n.key === t)
                return n
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        DEFAULT: "DEFAULT",
        VF_ONE: "VIRTUAL_FIELD_ONE",
        VF_MANY: "VIRTUAL_FIELD_MANY",
        VF_M2M: "VIRTUAL_FIELD_M2M",
        FIELD: "field",
        QUERY_ONE: "queryOne",
        QUERY_MANY: "queryMany",
        QUERY_CALC: "queryCalc",
        CREATE_ONE: "createOne",
        CREATE_MANY: "createMany",
        UPDATE_ONE: "updateOne",
        UPDATE_MANY: "updateMany",
        DELETE_ONE: "deleteOne",
        DELETE_MANY: "deleteMany",
        SUBSCRIBE_ONE: "subscribeOne",
        SUBSCRIBE_MANY: "subscribeMany",
        SUBSCRIBE_CALC: "subscribeCalc"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        APP: "app",
        APP_ENDPOINT: "podAppContainerEndpoint",
        API: "appApi",
        API_AWS_S3_ROUTE: "appApiAwsS3Route",
        API_DATA_SOURCE_ROUTE: "appApiDataSourceRoute",
        API_GRAPHQL_ROUTER: "appApiGraphqlRouter",
        API_REST_ROUTER: "appApiRestRouter",
        API_REST_ROUTE: "appApiRestRoute",
        API_REST_TYPES_ROUTE: "appApiRestTypesRoute",
        API_SEARCH_ROUTER: "appApiSearchRouter",
        API_SESSION_ROUTE: "appApiSessionRoute",
        DATABASE_STORAGE: "appDatabaseStorage",
        DISK_STORAGE: "appDiskStorage",
        DOCUMENT_STORAGE: "appDocumentStorage",
        MULTISITE: "appMultisite",
        UI: "appUi"
    }
}
, , , , , , , , , , function(e, t, n) {
    var r = n(24)
      , i = n(305);
    (e.exports = function(e, t) {
        return i[e] || (i[e] = void 0 !== t ? t : {})
    }
    )("versions", []).push({
        version: "3.6.5",
        mode: r ? "pure" : "global",
        copyright: "\xa9 2020 Denis Pushkarev (zloirock.ru)"
    })
}
, function(e, t, n) {
    var r = n(39)
      , i = n(64);
    e.exports = function(e, t) {
        try {
            i(r, e, t)
        } catch (n) {
            r[e] = t
        }
        return t
    }
}
, function(e, t, n) {
    var r = n(39)
      , i = n(51)
      , o = r.document
      , s = i(o) && i(o.createElement);
    e.exports = function(e) {
        return s ? o.createElement(e) : {}
    }
}
, function(e, t, n) {
    var r = n(49)
      , i = n(129)
      , o = "".split;
    e.exports = r((function() {
        return !Object("z").propertyIsEnumerable(0)
    }
    )) ? function(e) {
        return "String" == i(e) ? o.call(e, "") : Object(e)
    }
    : Object
}
, function(e, t) {
    e.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
}
, function(e, t, n) {
    var r = n(252)
      , i = n(205)
      , o = r("keys");
    e.exports = function(e) {
        return o[e] || (o[e] = i(e))
    }
}
, function(e, t, n) {
    var r = n(53)
      , i = n(314)
      , o = n(128)
      , s = n(206)
      , a = n(204)
      , c = n(56)
      , u = n(306)
      , l = Object.getOwnPropertyDescriptor;
    t.f = r ? l : function(e, t) {
        if (e = s(e),
        t = a(t, !0),
        u)
            try {
                return l(e, t)
            } catch (n) {}
        if (c(e, t))
            return o(!i.f.call(e, t), e[t])
    }
}
, function(e, t, n) {
    var r = n(310)
      , i = n(256).concat("length", "prototype");
    t.f = Object.getOwnPropertyNames || function(e) {
        return r(e, i)
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(209)
      , i = n(319)
      , o = RegExp.prototype.exec
      , s = String.prototype.replace
      , a = o
      , c = function() {
        var e = /a/
          , t = /b*/g;
        return o.call(e, "a"),
        o.call(t, "a"),
        0 !== e.lastIndex || 0 !== t.lastIndex
    }()
      , u = i.UNSUPPORTED_Y || i.BROKEN_CARET
      , l = void 0 !== /()??/.exec("")[1];
    (c || l || u) && (a = function(e) {
        var t, n, i, a, d = this, h = u && d.sticky, f = r.call(d), p = d.source, g = 0, m = e;
        return h && (-1 === (f = f.replace("y", "")).indexOf("g") && (f += "g"),
        m = String(e).slice(d.lastIndex),
        d.lastIndex > 0 && (!d.multiline || d.multiline && "\n" !== e[d.lastIndex - 1]) && (p = "(?: " + p + ")",
        m = " " + m,
        g++),
        n = new RegExp("^(?:" + p + ")",f)),
        l && (n = new RegExp("^" + p + "$(?!\\s)",f)),
        c && (t = d.lastIndex),
        i = o.call(h ? n : d, m),
        h ? i ? (i.input = i.input.slice(g),
        i[0] = i[0].slice(g),
        i.index = d.lastIndex,
        d.lastIndex += i[0].length) : d.lastIndex = 0 : c && i && (d.lastIndex = d.global ? i.index + i[0].length : t),
        l && i && i.length > 1 && s.call(i[0], n, (function() {
            for (a = 1; a < arguments.length - 2; a++)
                void 0 === arguments[a] && (i[a] = void 0)
        }
        )),
        i
    }
    ),
    e.exports = a
}
, function(e, t, n) {
    var r = n(39)
      , i = n(49)
      , o = n(321)
      , s = n(115).NATIVE_ARRAY_BUFFER_VIEWS
      , a = r.ArrayBuffer
      , c = r.Int8Array;
    e.exports = !s || !i((function() {
        c(1)
    }
    )) || !i((function() {
        new c(-1)
    }
    )) || !o((function(e) {
        new c,
        new c(null),
        new c(1.5),
        new c(e)
    }
    ), !0) || i((function() {
        return 1 !== new c(new a(2),1,void 0).length
    }
    ))
}
, function(e, t, n) {
    var r = n(40)
      , i = n(173)
      , o = r("iterator")
      , s = Array.prototype;
    e.exports = function(e) {
        return void 0 !== e && (i.Array === e || s[o] === e)
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(45)
      , i = n(50)
      , o = n(40)
      , s = n(53)
      , a = o("species");
    e.exports = function(e) {
        var t = r(e)
          , n = i.f;
        s && t && !t[a] && n(t, a, {
            configurable: !0,
            get: function() {
                return this
            }
        })
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(39)
      , o = n(318)
      , s = n(94)
      , a = n(211)
      , c = n(27)
      , u = n(117)
      , l = n(51)
      , d = n(49)
      , h = n(321)
      , f = n(146)
      , p = n(328);
    e.exports = function(e, t, n) {
        var g = -1 !== e.indexOf("Map")
          , m = -1 !== e.indexOf("Weak")
          , y = g ? "set" : "add"
          , v = i[e]
          , b = v && v.prototype
          , _ = v
          , S = {}
          , O = function(e) {
            var t = b[e];
            s(b, e, "add" == e ? function(e) {
                return t.call(this, 0 === e ? 0 : e),
                this
            }
            : "delete" == e ? function(e) {
                return !(m && !l(e)) && t.call(this, 0 === e ? 0 : e)
            }
            : "get" == e ? function(e) {
                return m && !l(e) ? void 0 : t.call(this, 0 === e ? 0 : e)
            }
            : "has" == e ? function(e) {
                return !(m && !l(e)) && t.call(this, 0 === e ? 0 : e)
            }
            : function(e, n) {
                return t.call(this, 0 === e ? 0 : e, n),
                this
            }
            )
        };
        if (o(e, "function" != typeof v || !(m || b.forEach && !d((function() {
            (new v).entries().next()
        }
        )))))
            _ = n.getConstructor(t, e, g, y),
            a.REQUIRED = !0;
        else if (o(e, !0)) {
            var T = new _
              , I = T[y](m ? {} : -0, 1) != T
              , x = d((function() {
                T.has(1)
            }
            ))
              , w = h((function(e) {
                new v(e)
            }
            ))
              , M = !m && d((function() {
                for (var e = new v, t = 5; t--; )
                    e[y](t, t);
                return !e.has(-0)
            }
            ));
            w || ((_ = t((function(t, n) {
                u(t, _, e);
                var r = p(new v, t, _);
                return void 0 != n && c(n, r[y], r, g),
                r
            }
            ))).prototype = b,
            b.constructor = _),
            (x || M) && (O("delete"),
            O("has"),
            g && O("get")),
            (M || I) && O(y),
            m && b.clear && delete b.clear
        }
        return S[e] = _,
        r({
            global: !0,
            forced: _ != v
        }, S),
        f(_, e),
        m || n.setStrong(_, e, g),
        _
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(174)
      , o = n(116)
      , s = n(144)
      , a = n(146)
      , c = n(64)
      , u = n(94)
      , l = n(40)
      , d = n(24)
      , h = n(173)
      , f = n(333)
      , p = f.IteratorPrototype
      , g = f.BUGGY_SAFARI_ITERATORS
      , m = l("iterator")
      , y = function() {
        return this
    };
    e.exports = function(e, t, n, l, f, v, b) {
        i(n, t, l);
        var _, S, O, T = function(e) {
            if (e === f && A)
                return A;
            if (!g && e in w)
                return w[e];
            switch (e) {
            case "keys":
            case "values":
            case "entries":
                return function() {
                    return new n(this,e)
                }
            }
            return function() {
                return new n(this)
            }
        }, I = t + " Iterator", x = !1, w = e.prototype, M = w[m] || w["@@iterator"] || f && w[f], A = !g && M || T(f), E = "Array" == t && w.entries || M;
        if (E && (_ = o(E.call(new e)),
        p !== Object.prototype && _.next && (d || o(_) === p || (s ? s(_, p) : "function" != typeof _[m] && c(_, m, y)),
        a(_, I, !0, !0),
        d && (h[I] = y))),
        "values" == f && M && "values" !== M.name && (x = !0,
        A = function() {
            return M.call(this)
        }
        ),
        d && !b || w[m] === A || c(w, m, A),
        h[t] = A,
        f)
            if (S = {
                values: T("values"),
                keys: v ? A : T("keys"),
                entries: T("entries")
            },
            b)
                for (O in S)
                    (g || x || !(O in w)) && u(w, O, S[O]);
            else
                r({
                    target: t,
                    proto: !0,
                    forced: g || x
                }, S);
        return S
    }
}
, function(e, t) {
    e.exports = function(e) {
        try {
            return {
                error: !1,
                value: e()
            }
        } catch (t) {
            return {
                error: !0,
                value: t
            }
        }
    }
}
, function(e, t, n) {
    var r = n(313)
      , i = n(56)
      , o = n(569)
      , s = n(50).f;
    e.exports = function(e) {
        var t = r.Symbol || (r.Symbol = {});
        i(t, e) || s(t, e, {
            value: o.f(e)
        })
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(77);
    const i = {}
      , o = {};
    for (let s in r.b)
        i[s] = "id",
        o[r.b[s]] = "id"
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    t.default = function(e) {
        return null != e && "object" === ("undefined" === typeof e ? "undefined" : r(e)) && !0 === e["@@functional/placeholder"]
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(642))
      , i = o(n(665));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = (0,
    r.default)(i.default, "Map");
    t.default = s,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(648);
    var o = ((r = i) && r.__esModule ? r : {
        default: r
    }).default.Symbol;
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = Array.isArray;
    t.default = r,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e, t) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return i
    }
    ));
    const r = {
        PENDING_SETUP: "pending_setup",
        PENDING_DELETE: "pending_delete",
        ACTIVE: "active",
        PAUSED: "paused",
        INACTIVE: "inactive",
        ERROR: "error",
        EXTERNAL_ERROR_FATAL: "external_error_fatal",
        EXTERNAL_ERROR_TEMPORARY: "external_error_temporary",
        SCHEMA_SYNCING: "schema_syncing",
        SCHEMA_SYNC_ERROR: "schema_sync_error",
        SYNC_INITIAL: "sync_initial"
    }
      , i = {
        PENDING_FETCH: "pending_fetch",
        OK: "ok",
        HAS_ERRORS: "has_errors",
        HAS_UNRESOLVED_ERRORS: "has_unresolved_errors",
        HAS_RESOLVED_ERRORS: "has_resolved_errors",
        DOES_NOT_EXIST: "does_not_exist"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return l
    }
    ));
    var r = n(31)
      , i = n(22)
      , o = n(298)
      , s = n(74)
      , a = n(867)
      , c = n(0)
      , u = n(150);
    function l(e) {
        return e ? t => t.lift(new d(e)).pipe(Object(u.b)()) : t => t.lift(new d(e))
    }
    class d {
        constructor(e) {
            this.onPendingComplete = e
        }
        call(e, t) {
            return t.subscribe(new m(e,this.onPendingComplete))
        }
    }
    const h = (e, t) => Object(c.B)(e) === c.x ? e.pipe(Object(o.a)(), Object(s.a)(t)) : e.subscribe().pipe(Object(a.a)(null), Object(o.a)(), Object(s.a)(t))
      , f = e => e.__dispatchId || Object(c.B)(e) === c.x && e.mainDispatchId ? e : void 0
      , p = (e, t, n) => e ? h(e, t) : n ? Object(r.a)(t) : t;
    function g(e, t) {
        if (!e || "object" !== typeof e)
            return t ? Object(r.a)(e) : e;
        let n;
        if (Array.isArray(e)) {
            let i, o;
            for (let s = 0; s < e.length; s++)
                if (o = e[s],
                o) {
                    if (!n && !(n = Object(c.B)(o)))
                        return t ? Object(r.a)(e) : e;
                    !i && t && (i = f(o)),
                    e[s] = Object(c.C)(o)
                }
            return p(i, e, t)
        }
        if (n = Object(c.B)(e))
            return Object(c.R)(e) ? p(e, Object(c.C)(e), t) : t ? Object(r.a)(e) : e;
        {
            let i, o, a = e, u = e;
            if (e.__didPrepare && "undefined" !== typeof e.records) {
                if (!(a = e.records))
                    return t ? e.mutation ? e.mutation.ofComplete(!0).pipe(Object(s.a)(null)) : e.model && e.model.__dispatchId ? h(e.model, null) : Object(r.a)(null) : a;
                u = {}
            }
            for (let s in a)
                if (o = a[s]) {
                    if (!n && !(n = Object(c.B)(o)))
                        return t ? Object(r.a)(e) : e;
                    !i && t && (i = f(o)),
                    u[s] = Object(c.C)(o)
                } else
                    u[s] = o;
            return p(i, u, t)
        }
    }
    class m extends i.a {
        constructor(e, t) {
            super(e),
            this.onPendingComplete = t
        }
        _next(e) {
            super._next(g(e, this.onPendingComplete))
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return i
    }
    ));
    const r = {
        CONNECTION_ACK: "CONNECTION_ACK",
        CONNECTION_INIT: "CONNECTION_INIT",
        CONNECTION_ERROR: "CONNECTION_ERROR",
        CONNECTION_TERMINATE: "CONNECTION_TERMINATE",
        KEEP_ALIVE: "KEEP_ALIVE",
        KEEP_ALIVE_ACK: "KEEP_ALIVE_ACK",
        GQL_COMPLETE: "GQL_COMPLETE",
        GQL_DATA: "GQL_DATA",
        GQL_ERROR: "GQL_ERROR",
        GQL_START: "GQL_START",
        GQL_STOP: "GQL_STOP",
        AI_COMPLETE: "AI_COMPLETE",
        AI_DATA: "AI_DATA",
        AI_ERROR: "AI_ERROR",
        AI_START: "AI_START",
        AI_STOP: "AI_STOP"
    }
      , i = 9e4
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        CORE_LOGIC_TYPE: "CoreLogicTypeEnum",
        CORE_LOGIC_METHOD: "CoreLogicMethodEnum",
        CORE_LOGIC_COMPONENT: "CoreLogicComponentEnum",
        DATA_SOURCE_COMPONENT: "DataSourceComponentEnum",
        DATA_SOURCE_EXTERNAL_RECORD_STATUS: "DataSourceExternalRecordStatusEnum",
        DATA_SOURCE_MANAGER: "DataSourceManagerEnum",
        DATA_SOURCE_STATUS: "DataSourceStatusEnum",
        DATA_SOURCE_TYPE: "DataSourceTypeEnum",
        GRAPHQL_RESOLVER: "GraphqlResolverEnum",
        LOCATION_CHANGE_TYPE: "LocationChangeTypeEnum",
        PERMISSION_USER_CAN: "PermissionUserCanEnum",
        QUERY_ARG_OPERATOR: "QueryArgOperatorEnum",
        QUERY_ORDER_BY: "QueryOrderByEnum",
        QUERY_ORDER_BY_NULLS: "QueryOrderByNullsEnum",
        QUERY_PAYLOAD_TYPES_INT: "QueryPayloadTypesIntEnum",
        QUERY_PAYLOAD_TYPES_JSON: "QueryPayloadTypesJsonEnum",
        RESOURCE_SHARE_STATUS: "CrmResourceShareStatusEnum",
        SESSION_STATUS: "SessionStatusEnum",
        SSL_CERT_STATUS: "SslCertStatusEnum",
        TS_ACTION_TYPE: "TimestampActionTypeEnum",
        VF_RELATIONSHIP_TYPE: "VFRelationshipTypeEnum",
        WINDOW_STATUS: "WindowStatusEnum"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(863);
    const i = Object(r.a)(1)
      , o = () => i
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        DATE_FORMAT: "dateFormat",
        DISABLE_EXTERNAL_PROPAGATION: "disableExternalPropagation",
        DISABLE_HISTORY_UPDATE: "disableHistoryUpdate",
        LOGIN_LOCAL_STRATEGY: "login_local_strategy",
        LOGOUT_LOCAL_STRATEGY: "logout_local_strategy",
        REGISTER_USER_LOCAL_STRATEGY: "register_user_local_strategy",
        TIME_ZONE: "time_zone",
        USER_CREATE: "user_create",
        USER_UPDATE_PASSWORD: "user_update_password"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return d
    }
    ));
    var r = n(191)
      , i = n(877);
    function o(e, t, n) {
        return e = this.mergeProps(e),
        n ? this.setLocalState({
            props: e
        }, t) : this.setState({
            props: e
        }, t)
    }
    function s(e, t, n, r) {
        const i = this.mergeProps(e, t);
        return r ? this.setLocalState({
            props: i
        }, n) : this.setState({
            props: i
        }, n)
    }
    function a(e, t) {
        return this.getMutableProps(e, t, !0)
    }
    function c(e, t) {
        return this.mergeProps(e, t, !0)
    }
    function u(e, t) {
        return this.setLocalState({
            localProps: this.mergeLocalProps(e)
        }, t)
    }
    function l(e, t, n) {
        return this.setLocalState({
            localProps: this.mergeLocalProps(e, t)
        }, n)
    }
    function d(e, t) {
        const n = e.storesMap;
        t || (t = e.getRecordBuilder().Class.prototype),
        t.getMutableProps = function(e, t, i) {
            const o = n.get(this).value;
            if (!o.mutation)
                throw new Error("Only call getMutableProps() after ensuring the record is already mutable by calling getMutableRecord().");
            const s = !0 === i ? "localProps" : "props";
            let a = o.get(s);
            if (a) {
                if (o.pChanges && o.pChanges[s] && (!0 === i || o.pState.props !== o.persistedState.props))
                    return e ? (Object(r.a)(o.state[s], a, e, t),
                    a) : a;
                a = e ? Object(r.a)(o.state[s], a, e, t) : {
                    ...a
                }
            } else
                a = e ? Object(r.a)(void 0, {}, e, t) : {};
            return o.mutation.update(this, s, null, a, !0 === i),
            a
        }
        ,
        t.mergeProps = function(e, t, r) {
            const o = n.get(this).value
              , s = !0 === r ? "localProps" : "props";
            return Object(i.b)(e, t, o.get(s), o.state[s])
        }
        ,
        t.getMutableLocalProps = a,
        t.mergeLocalProps = c,
        t.setProps = o,
        t.setPropsAtPath = s,
        t.setLocalProps = u,
        t.setLocalPropsAtPath = l
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        READY: 100,
        NOT_READY: 0,
        SUCCESS: 200,
        NO_DATA_SOURCES: 110,
        NO_SELECTED_OBJECTS: 120,
        DATA_SOURCE_HAS_UNSAVED_CHANGES: 510,
        DATA_SOURCE_PENDING_DELETE: 130,
        SCHEMA_ISSUES: 500
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return W
    }
    ));
    var r = n(368)
      , i = n(0)
      , o = n(240);
    const {REPLACE: s} = r.a;
    function a(e) {
        class t extends e.Mutation {
        }
        return t.Create = function(e) {
            const t = e.storesMap;
            class n extends e.Mutation.Create {
                setAddRecord() {
                    const e = this.mutation;
                    if (e.isUndoRedo)
                        return super.setAddRecord();
                    const n = e.Record
                      , r = super.setAddRecord().addRecord;
                    return this.addRecord = function(e, a, c) {
                        if (Object(i.U)(e))
                            return r.call(this, e, a, c);
                        e.changeType = s,
                        e.historyIdx = 0,
                        e.key || (e.key = n.prototype.createKey());
                        const u = r.call(this, e, a, c);
                        if (!u)
                            return u;
                        const l = t.get(u);
                        return l.storeConfig.historyArray[0] = Object(o.b)(l.value.pState),
                        u
                    }
                    ,
                    this
                }
            }
            return n
        }(e),
        t
    }
    var c = n(37)
      , u = n(875);
    const l = !("undefined" === typeof window || !window.document || !window.document.createElement);
    var d = n(393)
      , h = n(291)
      , f = n(268);
    const p = ["pathname", "search", "hash", "hostname", "port", "protocol", "slashes"]
      , g = {
        [f.a.LOCATION]: !1,
        changeType: !1,
        historyIdx: !1,
        key: !1,
        state: !1,
        title: !1,
        pathname: !0,
        search: !0,
        hash: !0,
        hostname: !0,
        port: !0,
        protocol: !0,
        slashes: !0
    };
    let m;
    {
        const e = (e, t) => "window" === e ? document.documentElement : t ? document.querySelector("".concat(t, " ").concat(e)) : document.querySelector(e);
        m = function(t) {
            const n = t.storesMap
              , i = t.getRecordBuilder().Class.prototype;
            i.registerScrollElem = function(t, i) {
                let o = n.get(this);
                i && (o = o.getBestStore(i));
                const {scrollMap: s} = o.storeConfig
                  , a = o.get("key")
                  , c = o.get("changeType");
                let u = s.get(a);
                if (u || (u = {},
                s.set(a, u)),
                "html" === t && (t = "window"),
                u[t]) {
                    if (c === r.a.POP) {
                        const n = e(t);
                        n && (n.scrollTop = u[t].top,
                        n.scrollLeft = u[t].left)
                    }
                } else
                    u[t] = {}
            }
            ,
            i.saveScrollPositions = function(t, r) {
                const i = n.get(this)
                  , o = i.storeConfig.scrollMap;
                r || (r = i.get("key"));
                const s = o.get(r);
                if (s) {
                    let n;
                    for (let r in s)
                        (n = e(r, t)) && (s[r].top = n.scrollTop,
                        s[r].left = n.scrollLeft)
                }
            }
            ,
            i.getScrollPosition = function(e, t) {
                const r = n.get(this);
                t || (t = r.get("key"));
                const i = r.storeConfig.scrollMap.get(t);
                if (!i)
                    return null;
                if (!e)
                    return i;
                "html" === e && (e = "window");
                const o = i[e];
                return o && "number" === typeof o.top ? o : null
            }
            ,
            i.setScrollPosition = function(e, t, r) {
                const i = n.get(this)
                  , {scrollMap: o} = i.storeConfig;
                "html" === e && (e = "window"),
                r || (r = i.get("key"));
                let s = o.get(r);
                s || (s = {},
                o.set(r, s)),
                s[e] = t
            }
            ,
            i.restoreScrollPositions = function(t, r) {
                const i = n.get(this)
                  , {scrollMap: o} = i.storeConfig;
                r || (r = i.get("key"));
                const s = o.get(r);
                if (!s)
                    return;
                let a;
                for (let n in s)
                    (a = e(n, t)) && (a.scrollTop = s[n].top,
                    a.scrollLeft = s[n].left)
            }
        }
    }
    var y = n(72)
      , v = n(150)
      , b = n(159);
    const _ = (e, t, n) => n[t] !== e[t] && (e[t] = n[t],
    !0)
      , S = () => !0
      , O = (e, t, n) => {
        let r = !1;
        for (let i of t)
            n[i] !== e[i] && (e[i] = n[i],
            r = !0);
        return r
    }
      , T = (e, t, n) => {
        let r = !1;
        for (let i in t)
            n[i] !== e[i] && (n[i] !== t[i] && e[i] !== t[i] || (r = !0),
            e[i] = n[i]);
        return r
    }
    ;
    const I = ["pathname", "search", "hash", "protocol", "hostname", "port"];
    function x(e) {
        let t;
        t = "string" === typeof e ? Object(c.d)(e, this) : e instanceof c.a ? e : Object(i.U)(e) ? e.getState() : Object(c.d)(e, this);
        const n = this.getState();
        for (let r of I)
            if (n[r] !== t[r])
                return !0;
        return !1
    }
    function w(e) {
        return t => {
            if (t && (0 !== t.button || !0 === t.shiftKey || !0 === t.altKey || !0 === t.ctrlKey || !0 === t.metaKey))
                return;
            let n = e.to;
            if (e.onClick) {
                const r = e.onClick(t || null, this);
                "undefined" !== typeof r && (n = r)
            }
            n && (t && t.preventDefault(),
            e.replace ? e.searchOnly ? this.replaceSearch(n, e.state) : this.replace(n, e.state) : e.searchOnly ? this.pushSearch(n, e.state) : this.push(n, e.state))
        }
    }
    function M(e) {
        return Object(c.f)("string" === typeof e ? e : this.pathname)
    }
    var A = n(6)
      , E = n(74);
    function C(e, t, n) {
        return e.key !== t && (n || (n = {})) && (n.key = t),
        n
    }
    function N(e, t, n) {
        return t ? "#" !== t.charAt(0) && (t = "#".concat(t)) : t = "",
        e.hash !== t && (n || (n = {})) && (n.hash = t),
        n
    }
    function R(e, t, n) {
        return t || (t = null),
        e.state !== t && (n || (n = {})) && (n.state = t),
        n
    }
    function P(e, t, n) {
        return e.historyIdx !== t && (n || (n = {})) && (n.historyIdx = t),
        n
    }
    function D(e, t, n) {
        return t || (t = ""),
        e.title !== t && (n || (n = {})) && (n.title = t),
        n
    }
    const F = p.length;
    function k(e, t, n) {
        let r;
        for (let i = 0; i < F; i++)
            r = p[i],
            e[r] !== t[r] && (n || (n = {})) && (n[r] = t[r]);
        return n
    }
    const j = {
        changeType: function(e, t, n) {
            return e.changeType !== t && (n || (n = {})) && (n.changeType = t),
            n
        },
        key: C,
        state: R,
        historyIdx: P,
        fromHistory: function(e, t, n) {
            return n = C(e, t.key, n),
            n = P(e, t.historyIdx, n),
            n = R(e, t.state, n),
            n = k(e, t, n = D(e, t.title, n)),
            n = N(e, t.hash, n)
        },
        title: D,
        url: k,
        hash: N
    }
      , {PUSH: L, POP: V, REPLACE: U} = r.a;
    Object(E.a)(null);
    function q(e, t) {
        if (!t)
            return null;
        const n = e.value;
        let r = n.mutation;
        return r && r.action.meta.willEmitOp(A.k) && n.pChanges && n.pChanges.key ? (t.key = n.pState.key,
        t.changeType = n.pState.changeType,
        r.update(e.instance, t),
        r.ofComplete().pipe(Object(E.a)(t.key))) : (r = e.parentInstance.mutation(),
        r.update(e.instance, t),
        1 === r.controller.executeCount ? r.controller.executeNow() : r.execute(),
        r.ofComplete(!e.mainDispatchId).pipe(Object(E.a)(t.key)))
    }
    function Q(e, t, n, r, i) {
        let o = void 0;
        const s = e.getState();
        if ("object" === typeof r)
            "undefined" !== typeof r.state && (t = r.state),
            "undefined" !== typeof r.title && (n = r.title),
            s.search && "undefined" === typeof r.search && "undefined" === typeof r.searchParams && (!r.pathname || r.pathname.indexOf("?") < 0) && (r = {
                ...r,
                search: s.search
            });
        else if (s.search && r && r.indexOf("?") < 0)
            if (r.indexOf("#") > -1) {
                const e = r.split("#");
                r = "".concat(e[0]).concat(s.search, "#").concat(e[1])
            } else
                r += s.search;
        if (r)
            o = j.url(s, Object(c.d)(r, s), o);
        else if (!i)
            return null;
        return o = j.state(s, t, o),
        o = j.title(s, n, o),
        o ? (o = j.changeType(s, i ? U : L, o),
        o.key = e.instance.createKey(),
        q(e, o)) : null
    }
    function B(e, t, n, r) {
        "object" !== typeof t && (t = Object(c.e)(t));
        const i = e.value.urlParse
          , o = i.search;
        let s;
        if (i.set("searchParams", {
            ...i.searchParams,
            ...t
        }),
        o !== i.search && (s = {
            search: i.search,
            key: e.instance.createKey(),
            changeType: r ? U : L
        }),
        n && "object" === typeof n) {
            const t = e.value.get("state");
            t !== n && (s || (s = {
                key: e.instance.createKey(),
                changeType: r ? U : L
            }),
            s.state = t ? {
                ...t,
                ...n
            } : n)
        }
        return q(e, s)
    }
    function G(e, t, n) {
        const r = e.storeConfig
          , i = r.historyArray;
        return console.log("\n\n----------------------------\nUnable to find historyIdx or key in historyArray. HistoryIdx = ".concat(n, ", key = ").concat(t, ", historyArray = "), [...i]),
        console.log({
            record: e.instance,
            mainRecord: e.instance.getMainInstance(),
            currState: e.getState(),
            currWindowLocation: r.windowHistory && r.windowHistory.location,
            documentLocation: l ? document.location : void 0
        }),
        null
    }
    function z(e, t) {
        const n = typeof t
          , r = e.storeConfig.historyArray;
        let i, s;
        switch (n) {
        case "number":
            if (s = t,
            s < 0 && (s = 0),
            !(i = r[s]))
                return G(e, void 0, s);
            break;
        case "string":
            if (i = Object(o.d)(r, t),
            !i)
                return G(e, t);
            break;
        case "object":
            if (i = Object(o.d)(r, t.key),
            !i) {
                if (i = t,
                "number" !== typeof i.__historyIdx)
                    throw new Error("State was provided to popsState() that does not include the required `__historyIdx` property. If the call to popState() came in response to a window `popstate` event, it means that state pushed or replaced on window.history without properly including a `__historyIdx` property. This means the change was done independently of the Location record and therefore has compromised the integrity of the internal history stack. Always use push/replace/pushState/replaceState, etc. on the Location record to modify the location rather than doing so directly on the window.history api and this error will not occur. Or make sure to include the proper tracking information by using the `createHistoryItem()` utility when pushing/replacing to the window history api.");
                Object(o.a)(i, r)
            }
            break;
        default:
            return null
        }
        const a = e.getState();
        if (a.key === i.key)
            return null;
        if (i.isInvalid) {
            let t, n = i.historyIdx, o = !1;
            if (a.historyIdx > i.historyIdx)
                for (t = i.historyIdx - a.historyIdx,
                n--,
                console.log("ORIG DELTA BACKWARDS = ", t); n >= 0; ) {
                    if (!r[n].isInvalid) {
                        o = !0;
                        break
                    }
                    t--,
                    n--
                }
            else {
                t = i.historyIdx - a.historyIdx,
                console.log("ORIG DELTA FORWARDS = ", t),
                n++;
                const e = r.length;
                for (; n < e; ) {
                    if (!r[n].isInvalid) {
                        o = !0;
                        break
                    }
                    t++,
                    n++
                }
            }
            if (o)
                return console.log("FOUND OK STATE, delta = ", t),
                H(e, t),
                null
        }
        let c = j.fromHistory(a, i);
        return c = j.changeType(a, V, c),
        q(e, c)
    }
    function H(e, t) {
        const n = e.storeConfig;
        n.windowHistory ? n.windowHistory.go(t) : z(e, e.instance.historyIdx + t)
    }
    const K = {
        pushState: Q,
        replaceState: (e, t, n, r) => Q(e, t, n, r, !0),
        popState: z,
        pushSearch: B,
        replaceSearch: (e, t, n) => B(e, t, n, !0),
        back: function(e) {
            const t = e.storeConfig;
            return t.windowHistory ? t.windowHistory.back() : z(e, e.instance.historyIdx - 1)
        },
        forward: function(e) {
            const t = e.storeConfig;
            t.windowHistory ? t.windowHistory.forward() : z(e, e.instance.historyIdx + 1)
        },
        go: H
    };
    function Y(e) {
        const t = e.storesMap
          , n = e.getRecordBuilder()
          , r = n.registerExtension("../RecordMixin").addPendingLogic(d.a).setPendingValue(function(e) {
            e || (e = h.b);
            class t extends e {
                set(e, t) {
                    if (!g[e])
                        return super.set(e, t);
                    const n = super.set(e, t);
                    return this.urlParse[e] !== n && this.urlParse.set(e, n),
                    n
                }
            }
            return t.deReferenceProps = [...t.deReferenceProps, "urlParse"],
            t
        }(n.PendingValue)).setMainValue(function(e) {
            e || (e = h.a);
            class t extends e {
            }
            return t.deReferenceProps = [...t.deReferenceProps, "urlParse"],
            t
        }(n.MainValue)).Class.prototype;
        r.syncWithWindowHistory = function() {
            let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            if (!l)
                return !e;
            let n = t.get(this);
            const r = n.storeConfig;
            if (!1 === e)
                return r.windowHistory = null,
                r.popstateListener && (window.removeEventListener("popstate", r.popstateListener),
                r.popstateListener = null),
                r.beforeunloadListener && (window.removeEventListener("beforeunload", r.beforeunloadListener),
                r.beforeunloadListener = null),
                !0;
            if (r.windowHistory)
                return !0;
            if (!(r.windowHistory = window.history))
                return !1;
            r.windowHistory.scrollRestoration = "manual";
            let i = r.windowHistory.state;
            return !i || i.key !== this.key || r.historyArray.length > 1 ? (i = Object(o.b)(n.getState()),
            window.location.hash && (i.hash = window.location.hash),
            r.windowHistory.replaceState(i, n.get("title"), this.path)) : r.historyArray.length ? r.historyArray[0].__historyIdx = i.__historyIdx : r.historyArray[0] = i,
            window.location.hash && n.get("hash") !== window.location.hash && this.setState({
                hash: window.location.hash
            }),
            n = n.mainStore,
            r.popstateListener = e => {
                const t = e.state;
                n.instance.saveScrollPositions(null, n.get("key")),
                K.popState(n, t && "number" === typeof t.__historyIdx ? t : Object(o.c)(n.instance))
            }
            ,
            window.addEventListener("popstate", r.popstateListener),
            !0
        }
        ,
        r.createHistoryItem = function(e) {
            return e || (e = this.getState()),
            Object(o.b)(e)
        }
        ,
        r.push = function(e, n) {
            const r = t.get(this).value;
            return K.pushState(r.store, n, r.get("title"), e)
        }
        ,
        r.pushSearch = function(e, n) {
            return K.pushSearch(t.get(this), e, n)
        }
        ,
        r.pushState = function(e, n, r) {
            return K.pushState(t.get(this), e, n, r)
        }
        ,
        r.replace = function(e, n) {
            const r = t.get(this).value;
            return K.replaceState(r.store, n, r.get("title"), e)
        }
        ,
        r.replaceState = function(e, n, r) {
            return K.replaceState(t.get(this), e, n, r)
        }
        ,
        r.replaceSearch = function(e, n) {
            return K.replaceSearch(t.get(this), e, n)
        }
        ,
        r.back = function() {
            K.back(t.get(this))
        }
        ,
        r.forward = function() {
            K.forward(t.get(this))
        }
        ,
        r.go = function(e) {
            K.go(t.get(this), e)
        }
        ,
        r.createHref = function(e, n, r) {
            const i = t.get(this).value.urlParse;
            return Object(c.b)(i, e, n, r)
        }
        ,
        function(e) {
            const t = e.getRecordBuilder().Class
              , n = e.storesMap
              , r = t.build;
            t.build = function(e) {
                const t = r.call(this, e)
                  , i = n.get(t);
                let o = i.storeConfig;
                return o ? (o.urlParse || (o.urlParse = new c.a("/")),
                o.historyArray || (o.historyArray = [])) : (o = {
                    historyArray: [],
                    urlParse: new c.a("/")
                },
                i.storeConfig = o),
                o.scrollMap || (o.scrollMap = new Map),
                i.value.urlParse = o.urlParse,
                t
            }
        }(e),
        m(e),
        function(e, t) {
            const n = e.storesMap
              , {DELETED: r} = b.a;
            t.subscribeToSearch = function(e) {
                let t = T;
                e ? "string" === typeof e ? t = _ : Array.isArray(e) && (t = O) : t = S;
                const i = n.get(this)
                  , o = {
                    ...i.value.urlParse.query
                };
                return i.subscribeAndPersist().pipe(Object(y.a)(n => {
                    const i = n.changes && n.changes.search;
                    if (i && (i === r || t(o, e, n.urlParse.query)))
                        return n.store.instance
                }
                ), Object(v.a)())
            }
        }(e, r),
        r.isDifferentThan = x,
        r.createOnClick = w,
        r.createPath = function(e, t, n) {
            return e ? "string" === typeof e || e.pathname || (t = e.search || e.searchParams,
            n = e.hash,
            e = this.pathname) : e = this.pathname,
            Object(c.c)(e, t, n)
        }
        ,
        r.parseSearch = c.e,
        r.pathToTitle = M,
        r.createKey = u.b;
        const i = n.accessors;
        i.host = {
            get() {
                const e = this.getState();
                return e.port ? "".concat(e.hostname, ":").concat(e.port) : e.hostname
            },
            set: void 0,
            enumerable: !1,
            configurable: !0
        },
        i.href = {
            get() {
                return t.get(this).value.urlParse.href
            },
            set: void 0,
            enumerable: !1,
            configurable: !0
        },
        i.historyArray = {
            get() {
                return t.get(this).storeConfig.historyArray
            },
            set: void 0,
            enumerable: !1,
            configurable: !1
        },
        i.historyItem = {
            get() {
                const e = t.get(this);
                return e.storeConfig.historyArray[e.get("historyIdx")]
            },
            set: void 0,
            enumerable: !1,
            configurable: !1
        },
        i.path = {
            get() {
                return Object(c.c)(this.getState())
            },
            set: void 0,
            enumerable: !1,
            configurable: !1
        },
        i.searchParams = {
            get() {
                return t.get(this).value.urlParse.query
            },
            set: void 0,
            enumerable: !1,
            configurable: !0
        }
    }
    function W(e) {
        e.setPackageName("@isomorix/core-location").setDefaultModuleNames("@isomorix/core/location").setMutation(a(e), "../Mutation"),
        Y(e)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "a", (function() {
        return c
    }
    ));
    var r = n(14)
      , i = n(22)
      , o = n(138);
    function s(e, t) {
        return void 0 === t && (t = 0),
        function(n) {
            return n.lift(new a(e,t))
        }
    }
    var a = function() {
        function e(e, t) {
            void 0 === t && (t = 0),
            this.scheduler = e,
            this.delay = t
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new c(e,this.scheduler,this.delay))
        }
        ,
        e
    }()
      , c = function(e) {
        function t(t, n, r) {
            void 0 === r && (r = 0);
            var i = e.call(this, t) || this;
            return i.scheduler = n,
            i.delay = r,
            i
        }
        return r.a(t, e),
        t.dispatch = function(e) {
            var t = e.notification
              , n = e.destination;
            t.observe(n),
            this.unsubscribe()
        }
        ,
        t.prototype.scheduleMessage = function(e) {
            this.destination.add(this.scheduler.schedule(t.dispatch, this.delay, new u(e,this.destination)))
        }
        ,
        t.prototype._next = function(e) {
            this.scheduleMessage(o.a.createNext(e))
        }
        ,
        t.prototype._error = function(e) {
            this.scheduleMessage(o.a.createError(e)),
            this.unsubscribe()
        }
        ,
        t.prototype._complete = function() {
            this.scheduleMessage(o.a.createComplete()),
            this.unsubscribe()
        }
        ,
        t
    }(i.a)
      , u = function() {
        return function(e, t) {
            this.notification = e,
            this.destination = t
        }
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return c
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    ));
    var r = n(187)
      , i = n(182)
      , o = n(54);
    const s = {
        ops: Object(o.b)()
    };
    r.c.createStandaloneLogicValidator(s);
    const a = {
        ops: Object(o.d)()
    };
    function c(e, t) {
        return s.validateLogic(e, t)
    }
    i.c.createStandaloneLogicValidator(a)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "e", (function() {
        return s
    }
    )),
    n.d(t, "f", (function() {
        return a
    }
    )),
    n.d(t, "d", (function() {
        return c
    }
    )),
    n.d(t, "b", (function() {
        return u
    }
    )),
    n.d(t, "i", (function() {
        return l
    }
    )),
    n.d(t, "h", (function() {
        return d
    }
    )),
    n.d(t, "a", (function() {
        return h
    }
    )),
    n.d(t, "g", (function() {
        return f
    }
    ));
    const r = /^-?\d+$/
      , i = /^-?\d+(?:\.\d+)?$/
      , o = e => e === +e && e !== (0 | e);
    function s(e) {
        return "string" === typeof e && r.test(e) ? parseInt(e, 10) : e
    }
    function a(e) {
        return "string" === typeof e && i.test(e) ? parseFloat(e) : e
    }
    const c = Number.isInteger ? Number.isInteger : e => u(e) && Math.floor(e) === e
      , u = Number.isFinite ? Number.isFinite : e => "number" === typeof e && isFinite(e);
    function l(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
          , n = !1;
        e < 0 && (n = !0,
        e *= -1);
        const r = Math.pow(10, t);
        return e = parseFloat((e * r).toFixed(11)),
        e = (Math.round(e) / r).toFixed(t),
        n ? +(-1 * e).toFixed(t) : +e
    }
    function d(e) {
        return 1 + (Math.log((e ^ e >> 31) - (e >> 31)) * Math.LOG10E | 0)
    }
    function h(e, t, n) {
        const r = e + "";
        return n && r.indexOf(".") < 0 ? r : l(e, t).toFixed(t)
    }
    function f(e) {
        return (e + "").replace(".", "").replace("-", "").length
    }
}
, function(e, t, n) {
    "use strict";
    (function(e) {
        n.d(t, "a", (function() {
            return c
        }
        )),
        n.d(t, "b", (function() {
            return l
        }
        )),
        n.d(t, "c", (function() {
            return o
        }
        )),
        n.d(t, "d", (function() {
            return a
        }
        )),
        n.d(t, "e", (function() {
            return i
        }
        ));
        n(84);
        var r = n(48);
        n(59),
        n(380),
        n(360);
        function i(e, t, n, o) {
            if (function(e) {
                return "IntValue" === e.kind
            }(n) || function(e) {
                return "FloatValue" === e.kind
            }(n))
                e[t.value] = Number(n.value);
            else if (function(e) {
                return "BooleanValue" === e.kind
            }(n) || function(e) {
                return "StringValue" === e.kind
            }(n))
                e[t.value] = n.value;
            else if (function(e) {
                return "ObjectValue" === e.kind
            }(n)) {
                var s = {};
                n.fields.map((function(e) {
                    return i(s, e.name, e.value, o)
                }
                )),
                e[t.value] = s
            } else if (function(e) {
                return "Variable" === e.kind
            }(n)) {
                var a = (o || {})[n.name.value];
                e[t.value] = a
            } else if (function(e) {
                return "ListValue" === e.kind
            }(n))
                e[t.value] = n.values.map((function(e) {
                    var n = {};
                    return i(n, t, e, o),
                    n[t.value]
                }
                ));
            else if (function(e) {
                return "EnumValue" === e.kind
            }(n))
                e[t.value] = n.value;
            else {
                if (!function(e) {
                    return "NullValue" === e.kind
                }(n))
                    throw new r.a(17);
                e[t.value] = null
            }
        }
        function o(e) {
            return "Field" === e.kind
        }
        function s(e) {
            throw new r.a(18)
        }
        function a(e, t) {
            switch (void 0 === t && (t = s),
            e.kind) {
            case "Variable":
                return t(e);
            case "NullValue":
                return null;
            case "IntValue":
                return parseInt(e.value, 10);
            case "FloatValue":
                return parseFloat(e.value);
            case "ListValue":
                return e.values.map((function(e) {
                    return a(e, t)
                }
                ));
            case "ObjectValue":
                for (var n = {}, r = 0, i = e.fields; r < i.length; r++) {
                    var o = i[r];
                    n[o.name.value] = a(o.value, t)
                }
                return n;
            default:
                return e.value
            }
        }
        function c(e, t) {
            if (e.directives && e.directives.length) {
                var n = {};
                return e.directives.forEach((function(e) {
                    n[e.name.value] = function(e, t) {
                        if (e.arguments && e.arguments.length) {
                            var n = {};
                            return e.arguments.forEach((function(e) {
                                var r = e.name
                                  , o = e.value;
                                return i(n, r, o, t)
                            }
                            )),
                            n
                        }
                        return null
                    }(e, t)
                }
                )),
                n
            }
            return null
        }
        function u(e) {
            Object(r.b)(e && "Document" === e.kind, 2);
            var t = e.definitions.filter((function(e) {
                return "FragmentDefinition" !== e.kind
            }
            )).map((function(e) {
                if ("OperationDefinition" !== e.kind)
                    throw new r.a(3);
                return e
            }
            ));
            return Object(r.b)(t.length <= 1, 4),
            e
        }
        function l(e) {
            var t;
            u(e);
            for (var n = 0, i = e.definitions; n < i.length; n++) {
                var o = i[n];
                if ("OperationDefinition" === o.kind) {
                    var s = o.operation;
                    if ("query" === s || "mutation" === s || "subscription" === s)
                        return o
                }
                "FragmentDefinition" !== o.kind || t || (t = o)
            }
            if (t)
                return t;
            throw new r.a(10)
        }
        "function" === typeof WeakMap && "object" === typeof navigator && navigator.product,
        Object.prototype.toString;
        Object.prototype.hasOwnProperty;
        Object.create({})
    }
    ).call(this, n(359))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(20);
    function i(e, t) {
        const n = Object(r.a)(e, null === t || void 0 === t ? void 0 : t.in);
        return n.setHours(0, 0, 0, 0),
        n
    }
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = i(n(836));
    function i(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var o = (0,
    i(n(838)).default)((function(e, t) {
        return (0,
        r.default)({}, t, e)
    }
    ));
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(839))
      , i = o(n(840));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = (0,
    r.default)((function(e, t) {
        return (0,
        i.default)((function(e, t, n) {
            return t
        }
        ), e, t)
    }
    ));
    t.default = s,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = i(n(841));
    function i(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var o = (0,
    i(n(842)).default)((function(e, t) {
        return (0,
        r.default)({}, e, t)
    }
    ));
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return l
    }
    )),
    n.d(t, "b", (function() {
        return d
    }
    ));
    var r = n(159)
      , i = n(189)
      , o = n(236);
    const s = Object.prototype.propertyIsEnumerable
      , {CREATED: a, DELETED: c, UPDATED: u} = r.a;
    const l = function(e) {
        class t extends e {
            changePkValue(e, t, n, r) {
                if (r)
                    this.state[e] === t && (this.state[e] = n);
                else {
                    if (this.persistedState[e] === t && (this.persistedState[e] = n),
                    this.state[e] !== t)
                        return this;
                    this.state[e] = n;
                    const i = (r = this.store).history;
                    for (let o of i)
                        o.changePkValue(e, t, n, r)
                }
                return this
            }
            optimisticNotify() {
                this.changes && (0 === this.size ? this.store.emitComplete() : this.store.next(this),
                this.callMergeMainStateInFlight())
            }
            notify() {
                this.changes ? this.optimisticNotify() : this.allChanges && this.store.next(this)
            }
        }
        return t.blacklistPropsCommitPendingState = {
            ...e.blacklistPropsCommitPendingState,
            mutation: !0,
            mutationType: !0
        },
        t
    }(i.a);
    const d = function(e) {
        class t extends e {
            markAsUpdated(e) {
                const {pChanges: t} = this;
                t ? t[e] || (t[e] = u) : (this.pState = this.cloneState(),
                this.pChanges = {
                    [e]: u
                },
                this.pSize = this.size)
            }
            set(e, t) {
                if (!e)
                    return !1;
                let {pState: n} = this;
                const r = n || this.state;
                if (r[e] !== t) {
                    let {pChanges: i} = this;
                    return n || (this.pState = n = this.cloneState(),
                    this.pChanges = i = {},
                    this.pSize = this.size),
                    s.call(r, e) ? i[e] !== a && (i[e] = u) : (this.pSize++,
                    i[e] = i[e] === c ? u : a),
                    n[e] = t,
                    t
                }
                return r[e]
            }
            changePkValue(e, t, n, r) {
                if (r)
                    this.state[e] === t && (this.state[e] = n);
                else {
                    if (this.pState && this.pState[e] === t && (this.pState[e] = n),
                    this.state[e] !== t)
                        return this;
                    this.state[e] = n;
                    const i = (r = this.store).history;
                    for (let o of i)
                        o.changePkValue(e, t, n, r)
                }
                return this
            }
            commit(e) {
                return this.mutation && this.mutation.dispatchId === e.meta.dispatchId && (this.mutation = void 0,
                this.mutationType = void 0),
                super.commit(e)
            }
        }
        return t.deReferenceProps = [...e.deReferenceProps, "mutation", "mutationType"],
        t
    }(o.a)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    ));
    const r = (e, t) => (t._mutation || (t.mutation ? t._mutation = t.mutation.switchTo(e.__typename) : (t.mutation = e.getModel().mutation(t.dispatchId),
    t._mutation = t.mutation,
    t.dispatchId = t.mutation.mainDispatchId,
    t.mutation.execute())),
    t._mutation)
      , i = (e, t) => (t.dispatchId ? e = e.getBestInstance(t.dispatchId) : t.mutation ? (t.dispatchId = t.mutation.mainDispatchId,
    e = e.getBestInstance(t.dispatchId)) : t.dispatchId = e.__dispatchId,
    e)
      , o = {
        getMutation: r,
        setBestDispatchId: i
    }
}
, function(e, t, n) {
    "use strict";
    e.exports = function(e, t, n, r, i, o, s, a) {
        if (!e) {
            var c;
            if (void 0 === t)
                c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
            else {
                var u = [n, r, i, o, s, a]
                  , l = 0;
                (c = new Error(t.replace(/%s/g, (function() {
                    return u[l++]
                }
                )))).name = "Invariant Violation"
            }
            throw c.framesToPop = 1,
            c
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return l
    }
    ));
    var r = n(26)
      , i = n(38)
      , o = n(90);
    var s = n(151)
      , a = n(119);
    var c = n(225)
      , u = n(224);
    function l(e, t) {
        if (null != e) {
            if (function(e) {
                return e && "function" === typeof e[o.a]
            }(e))
                return function(e, t) {
                    return new r.a((function(n) {
                        var r = new i.a;
                        return r.add(t.schedule((function() {
                            var i = e[o.a]();
                            r.add(i.subscribe({
                                next: function(e) {
                                    r.add(t.schedule((function() {
                                        return n.next(e)
                                    }
                                    )))
                                },
                                error: function(e) {
                                    r.add(t.schedule((function() {
                                        return n.error(e)
                                    }
                                    )))
                                },
                                complete: function() {
                                    r.add(t.schedule((function() {
                                        return n.complete()
                                    }
                                    )))
                                }
                            }))
                        }
                        ))),
                        r
                    }
                    ))
                }(e, t);
            if (Object(c.a)(e))
                return function(e, t) {
                    return new r.a((function(n) {
                        var r = new i.a;
                        return r.add(t.schedule((function() {
                            return e.then((function(e) {
                                r.add(t.schedule((function() {
                                    n.next(e),
                                    r.add(t.schedule((function() {
                                        return n.complete()
                                    }
                                    )))
                                }
                                )))
                            }
                            ), (function(e) {
                                r.add(t.schedule((function() {
                                    return n.error(e)
                                }
                                )))
                            }
                            ))
                        }
                        ))),
                        r
                    }
                    ))
                }(e, t);
            if (Object(u.a)(e))
                return Object(s.a)(e, t);
            if (function(e) {
                return e && "function" === typeof e[a.a]
            }(e) || "string" === typeof e)
                return function(e, t) {
                    if (!e)
                        throw new Error("Iterable cannot be null");
                    return new r.a((function(n) {
                        var r, o = new i.a;
                        return o.add((function() {
                            r && "function" === typeof r.return && r.return()
                        }
                        )),
                        o.add(t.schedule((function() {
                            r = e[a.a](),
                            o.add(t.schedule((function() {
                                if (!n.closed) {
                                    var e, t;
                                    try {
                                        var i = r.next();
                                        e = i.value,
                                        t = i.done
                                    } catch (o) {
                                        return void n.error(o)
                                    }
                                    t ? n.complete() : (n.next(e),
                                    this.schedule())
                                }
                            }
                            )))
                        }
                        ))),
                        o
                    }
                    ))
                }(e, t)
        }
        throw new TypeError((null !== e && typeof e || e) + " is not observable")
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(31)
      , i = n(231);
    function o() {
        return Object(i.a)(1)
    }
    function s() {
        for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t];
        return o()(r.a.apply(void 0, e))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return o
    }
    )),
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(875)
      , i = n(1);
    function o(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        const n = "function" === typeof e ? e[i.h] : e;
        if (!n)
            throw new Error("No defaults provided for functional logic. Place defaults on the functional logic's prototype key \"" + i.h + '". Logic: ' + e);
        const {[i.a]: o} = n;
        let s;
        return s = "string" === typeof o ? o : Array.isArray(o) ? o.join("-") : Object(r.b)(),
        n[i.m] = "".concat(n[i.q], "__").concat(s).concat(t),
        e
    }
    function s(e, t) {
        return Array.isArray(t) ? "".concat(e, "__").concat(t.join("-")) : "".concat(e, "__").concat(t)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return c
    }
    ));
    var r = n(26)
      , i = n(133)
      , o = n(72)
      , s = n(152)
      , a = n(78);
    function c() {
        for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t];
        if (1 === e.length) {
            var n = e[0];
            if (Object(i.a)(n))
                return u(n, null);
            if (Object(s.a)(n) && Object.getPrototypeOf(n) === Object.prototype) {
                var r = Object.keys(n);
                return u(r.map((function(e) {
                    return n[e]
                }
                )), r)
            }
        }
        if ("function" === typeof e[e.length - 1]) {
            var a = e.pop();
            return u(e = 1 === e.length && Object(i.a)(e[0]) ? e[0] : e, null).pipe(Object(o.a)((function(e) {
                return a.apply(void 0, e)
            }
            )))
        }
        return u(e, null)
    }
    function u(e, t) {
        return new r.a((function(n) {
            var r = e.length;
            if (0 !== r)
                for (var i = new Array(r), o = 0, s = 0, c = function(c) {
                    var u = Object(a.a)(e[c])
                      , l = !1;
                    n.add(u.subscribe({
                        next: function(e) {
                            l || (l = !0,
                            s++),
                            i[c] = e
                        },
                        error: function(e) {
                            return n.error(e)
                        },
                        complete: function() {
                            ++o !== r && l || (s === r && n.next(t ? t.reduce((function(e, t, n) {
                                return e[t] = i[n],
                                e
                            }
                            ), {}) : i),
                            n.complete())
                        }
                    }))
                }, u = 0; u < r; u++)
                    c(u);
            else
                n.complete()
        }
        ))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return _
    }
    ));
    var r = function() {
        function e() {
            return Error.call(this),
            this.message = "no elements in sequence",
            this.name = "EmptyError",
            this
        }
        return e.prototype = Object.create(Error.prototype),
        e
    }()
      , i = n(190)
      , o = n(14)
      , s = n(22)
      , a = n(228)
      , c = n(120);
    function u(e) {
        return function(t) {
            return 0 === e ? Object(c.b)() : t.lift(new l(e))
        }
    }
    var l = function() {
        function e(e) {
            if (this.total = e,
            this.total < 0)
                throw new a.a
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new d(e,this.total))
        }
        ,
        e
    }()
      , d = function(e) {
        function t(t, n) {
            var r = e.call(this, t) || this;
            return r.total = n,
            r.ring = new Array,
            r.count = 0,
            r
        }
        return o.a(t, e),
        t.prototype._next = function(e) {
            var t = this.ring
              , n = this.total
              , r = this.count++;
            t.length < n ? t.push(e) : t[r % n] = e
        }
        ,
        t.prototype._complete = function() {
            var e = this.destination
              , t = this.count;
            if (t > 0)
                for (var n = this.count >= this.total ? this.total : this.count, r = this.ring, i = 0; i < n; i++) {
                    var o = t++ % n;
                    e.next(r[o])
                }
            e.complete()
        }
        ,
        t
    }(s.a);
    function h(e) {
        return void 0 === e && (e = g),
        function(t) {
            return t.lift(new f(e))
        }
    }
    var f = function() {
        function e(e) {
            this.errorFactory = e
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new p(e,this.errorFactory))
        }
        ,
        e
    }()
      , p = function(e) {
        function t(t, n) {
            var r = e.call(this, t) || this;
            return r.errorFactory = n,
            r.hasValue = !1,
            r
        }
        return o.a(t, e),
        t.prototype._next = function(e) {
            this.hasValue = !0,
            this.destination.next(e)
        }
        ,
        t.prototype._complete = function() {
            if (this.hasValue)
                return this.destination.complete();
            var e = void 0;
            try {
                e = this.errorFactory()
            } catch (t) {
                e = t
            }
            this.destination.error(e)
        }
        ,
        t
    }(s.a);
    function g() {
        return new r
    }
    function m(e) {
        return void 0 === e && (e = null),
        function(t) {
            return t.lift(new y(e))
        }
    }
    var y = function() {
        function e(e) {
            this.defaultValue = e
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new v(e,this.defaultValue))
        }
        ,
        e
    }()
      , v = function(e) {
        function t(t, n) {
            var r = e.call(this, t) || this;
            return r.defaultValue = n,
            r.isEmpty = !0,
            r
        }
        return o.a(t, e),
        t.prototype._next = function(e) {
            this.isEmpty = !1,
            this.destination.next(e)
        }
        ,
        t.prototype._complete = function() {
            this.isEmpty && this.destination.next(this.defaultValue),
            this.destination.complete()
        }
        ,
        t
    }(s.a)
      , b = n(153);
    function _(e, t) {
        var n = arguments.length >= 2;
        return function(o) {
            return o.pipe(e ? Object(i.a)((function(t, n) {
                return e(t, n, o)
            }
            )) : b.a, u(1), n ? m(t) : h((function() {
                return new r
            }
            )))
        }
    }
}
, , , , , , , function(e, t, n) {
    var r = n(39)
      , i = n(253)
      , o = r["__core-js_shared__"] || i("__core-js_shared__", {});
    e.exports = o
}
, function(e, t, n) {
    var r = n(53)
      , i = n(49)
      , o = n(254);
    e.exports = !r && !i((function() {
        return 7 != Object.defineProperty(o("div"), "a", {
            get: function() {
                return 7
            }
        }).a
    }
    ))
}
, function(e, t, n) {
    var r = n(49);
    e.exports = !!Object.getOwnPropertySymbols && !r((function() {
        return !String(Symbol())
    }
    ))
}
, function(e, t, n) {
    var r = n(53)
      , i = n(50)
      , o = n(18)
      , s = n(309);
    e.exports = r ? Object.defineProperties : function(e, t) {
        o(e);
        for (var n, r = s(t), a = r.length, c = 0; a > c; )
            i.f(e, n = r[c++], t[n]);
        return e
    }
}
, function(e, t, n) {
    var r = n(310)
      , i = n(256);
    e.exports = Object.keys || function(e) {
        return r(e, i)
    }
}
, function(e, t, n) {
    var r = n(56)
      , i = n(206)
      , o = n(451).indexOf
      , s = n(207);
    e.exports = function(e, t) {
        var n, a = i(e), c = 0, u = [];
        for (n in a)
            !r(s, n) && r(a, n) && u.push(n);
        for (; t.length > c; )
            r(a, n = t[c++]) && (~o(u, n) || u.push(n));
        return u
    }
}
, function(e, t, n) {
    var r = n(114)
      , i = Math.max
      , o = Math.min;
    e.exports = function(e, t) {
        var n = r(e);
        return n < 0 ? i(n + t, 0) : o(n, t)
    }
}
, function(e, t, n) {
    var r = n(45);
    e.exports = r("document", "documentElement")
}
, function(e, t, n) {
    var r = n(39);
    e.exports = r
}
, function(e, t, n) {
    "use strict";
    var r = {}.propertyIsEnumerable
      , i = Object.getOwnPropertyDescriptor
      , o = i && !r.call({
        1: 2
    }, 1);
    t.f = o ? function(e) {
        var t = i(this, e);
        return !!t && t.enumerable
    }
    : r
}
, function(e, t, n) {
    var r = n(305)
      , i = Function.toString;
    "function" != typeof r.inspectSource && (r.inspectSource = function(e) {
        return i.call(e)
    }
    ),
    e.exports = r.inspectSource
}
, function(e, t, n) {
    var r = n(39)
      , i = n(315)
      , o = r.WeakMap;
    e.exports = "function" === typeof o && /native code/.test(i(o))
}
, function(e, t) {
    t.f = Object.getOwnPropertySymbols
}
, function(e, t, n) {
    var r = n(49)
      , i = /#|\.prototype\./
      , o = function(e, t) {
        var n = a[s(e)];
        return n == u || n != c && ("function" == typeof t ? r(t) : !!t)
    }
      , s = o.normalize = function(e) {
        return String(e).replace(i, ".").toLowerCase()
    }
      , a = o.data = {}
      , c = o.NATIVE = "N"
      , u = o.POLYFILL = "P";
    e.exports = o
}
, function(e, t, n) {
    "use strict";
    var r = n(49);
    function i(e, t) {
        return RegExp(e, t)
    }
    t.UNSUPPORTED_Y = r((function() {
        var e = i("a", "y");
        return e.lastIndex = 2,
        null != e.exec("abcd")
    }
    )),
    t.BROKEN_CARET = r((function() {
        var e = i("^r", "gy");
        return e.lastIndex = 2,
        null != e.exec("str")
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var r = n(171).charAt;
    e.exports = function(e, t, n) {
        return t + (n ? r(e, t).length : 1)
    }
}
, function(e, t, n) {
    var r = n(40)("iterator")
      , i = !1;
    try {
        var o = 0
          , s = {
            next: function() {
                return {
                    done: !!o++
                }
            },
            return: function() {
                i = !0
            }
        };
        s[r] = function() {
            return this
        }
        ,
        Array.from(s, (function() {
            throw 2
        }
        ))
    } catch (a) {}
    e.exports = function(e, t) {
        if (!t && !i)
            return !1;
        var n = !1;
        try {
            var o = {};
            o[r] = function() {
                return {
                    next: function() {
                        return {
                            done: n = !0
                        }
                    }
                }
            }
            ,
            e(o)
        } catch (a) {}
        return n
    }
}
, function(e, t) {
    e.exports = "undefined" !== typeof ArrayBuffer && "undefined" !== typeof DataView
}
, function(e, t, n) {
    var r = n(114)
      , i = n(65);
    e.exports = function(e) {
        if (void 0 === e)
            return 0;
        var t = r(e)
          , n = i(t);
        if (t !== n)
            throw RangeError("Wrong length or index");
        return n
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(87)
      , i = n(311)
      , o = n(65);
    e.exports = function(e) {
        for (var t = r(this), n = o(t.length), s = arguments.length, a = i(s > 1 ? arguments[1] : void 0, n), c = s > 2 ? arguments[2] : void 0, u = void 0 === c ? n : i(c, n); u > a; )
            t[a++] = e;
        return t
    }
}
, function(e, t, n) {
    var r = n(469);
    e.exports = function(e, t) {
        var n = r(e);
        if (n % t)
            throw RangeError("Wrong offset");
        return n
    }
}
, function(e, t, n) {
    var r = n(87)
      , i = n(65)
      , o = n(172)
      , s = n(262)
      , a = n(44)
      , c = n(115).aTypedArrayConstructor;
    e.exports = function(e) {
        var t, n, u, l, d, h, f = r(e), p = arguments.length, g = p > 1 ? arguments[1] : void 0, m = void 0 !== g, y = o(f);
        if (void 0 != y && !s(y))
            for (h = (d = y.call(f)).next,
            f = []; !(l = h.call(d)).done; )
                f.push(l.value);
        for (m && p > 2 && (g = a(g, arguments[2], 2)),
        n = i(f.length),
        u = new (c(this))(n),
        t = 0; n > t; t++)
            u[t] = m ? g(f[t], t) : f[t];
        return u
    }
}
, function(e, t, n) {
    var r = n(44)
      , i = n(255)
      , o = n(87)
      , s = n(65)
      , a = n(470)
      , c = [].push
      , u = function(e) {
        var t = 1 == e
          , n = 2 == e
          , u = 3 == e
          , l = 4 == e
          , d = 6 == e
          , h = 5 == e || d;
        return function(f, p, g, m) {
            for (var y, v, b = o(f), _ = i(b), S = r(p, g, 3), O = s(_.length), T = 0, I = m || a, x = t ? I(f, O) : n ? I(f, 0) : void 0; O > T; T++)
                if ((h || T in _) && (v = S(y = _[T], T, b),
                e))
                    if (t)
                        x[T] = v;
                    else if (v)
                        switch (e) {
                        case 3:
                            return !0;
                        case 5:
                            return y;
                        case 6:
                            return T;
                        case 2:
                            c.call(x, y)
                        }
                    else if (l)
                        return !1;
            return d ? -1 : u || l ? l : x
        }
    };
    e.exports = {
        forEach: u(0),
        map: u(1),
        filter: u(2),
        some: u(3),
        every: u(4),
        find: u(5),
        findIndex: u(6)
    }
}
, function(e, t, n) {
    var r = n(51)
      , i = n(144);
    e.exports = function(e, t, n) {
        var o, s;
        return i && "function" == typeof (o = t.constructor) && o !== n && r(s = o.prototype) && s !== n.prototype && i(e, s),
        e
    }
}
, function(e, t, n) {
    var r = n(18);
    e.exports = function(e, t, n, i) {
        try {
            return i ? t(r(n)[0], n[1]) : t(n)
        } catch (s) {
            var o = e.return;
            throw void 0 !== o && r(o.call(e)),
            s
        }
    }
}
, function(e, t, n) {
    var r = n(331)
      , i = n(334)
      , o = n(112)
      , s = n(51)
      , a = function() {
        this.object = null,
        this.symbol = null,
        this.primitives = null,
        this.objectsByIndex = o(null)
    };
    a.prototype.get = function(e, t) {
        return this[e] || (this[e] = t())
    }
    ,
    a.prototype.next = function(e, t, n) {
        var o = n ? this.objectsByIndex[e] || (this.objectsByIndex[e] = new i) : this.primitives || (this.primitives = new r)
          , s = o.get(t);
        return s || o.set(t, s = new a),
        s
    }
    ;
    var c = new a;
    e.exports = function() {
        var e, t, n = c, r = arguments.length;
        for (e = 0; e < r; e++)
            s(t = arguments[e]) && (n = n.next(e, t, !0));
        if (this === Object && n === c)
            throw TypeError("Composite keys must contain a non-primitive component");
        for (e = 0; e < r; e++)
            s(t = arguments[e]) || (n = n.next(e, t, !1));
        return n
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(264)
      , i = n(332);
    e.exports = r("Map", (function(e) {
        return function() {
            return e(this, arguments.length ? arguments[0] : void 0)
        }
    }
    ), i)
}
, function(e, t, n) {
    "use strict";
    var r = n(50).f
      , i = n(112)
      , o = n(145)
      , s = n(44)
      , a = n(117)
      , c = n(27)
      , u = n(265)
      , l = n(263)
      , d = n(53)
      , h = n(211).fastKey
      , f = n(60)
      , p = f.set
      , g = f.getterFor;
    e.exports = {
        getConstructor: function(e, t, n, u) {
            var l = e((function(e, r) {
                a(e, l, t),
                p(e, {
                    type: t,
                    index: i(null),
                    first: void 0,
                    last: void 0,
                    size: 0
                }),
                d || (e.size = 0),
                void 0 != r && c(r, e[u], e, n)
            }
            ))
              , f = g(t)
              , m = function(e, t, n) {
                var r, i, o = f(e), s = y(e, t);
                return s ? s.value = n : (o.last = s = {
                    index: i = h(t, !0),
                    key: t,
                    value: n,
                    previous: r = o.last,
                    next: void 0,
                    removed: !1
                },
                o.first || (o.first = s),
                r && (r.next = s),
                d ? o.size++ : e.size++,
                "F" !== i && (o.index[i] = s)),
                e
            }
              , y = function(e, t) {
                var n, r = f(e), i = h(t);
                if ("F" !== i)
                    return r.index[i];
                for (n = r.first; n; n = n.next)
                    if (n.key == t)
                        return n
            };
            return o(l.prototype, {
                clear: function() {
                    for (var e = f(this), t = e.index, n = e.first; n; )
                        n.removed = !0,
                        n.previous && (n.previous = n.previous.next = void 0),
                        delete t[n.index],
                        n = n.next;
                    e.first = e.last = void 0,
                    d ? e.size = 0 : this.size = 0
                },
                delete: function(e) {
                    var t = f(this)
                      , n = y(this, e);
                    if (n) {
                        var r = n.next
                          , i = n.previous;
                        delete t.index[n.index],
                        n.removed = !0,
                        i && (i.next = r),
                        r && (r.previous = i),
                        t.first == n && (t.first = r),
                        t.last == n && (t.last = i),
                        d ? t.size-- : this.size--
                    }
                    return !!n
                },
                forEach: function(e) {
                    for (var t, n = f(this), r = s(e, arguments.length > 1 ? arguments[1] : void 0, 3); t = t ? t.next : n.first; )
                        for (r(t.value, t.key, this); t && t.removed; )
                            t = t.previous
                },
                has: function(e) {
                    return !!y(this, e)
                }
            }),
            o(l.prototype, n ? {
                get: function(e) {
                    var t = y(this, e);
                    return t && t.value
                },
                set: function(e, t) {
                    return m(this, 0 === e ? 0 : e, t)
                }
            } : {
                add: function(e) {
                    return m(this, e = 0 === e ? 0 : e, e)
                }
            }),
            d && r(l.prototype, "size", {
                get: function() {
                    return f(this).size
                }
            }),
            l
        },
        setStrong: function(e, t, n) {
            var r = t + " Iterator"
              , i = g(t)
              , o = g(r);
            u(e, t, (function(e, t) {
                p(this, {
                    type: r,
                    target: e,
                    state: i(e),
                    kind: t,
                    last: void 0
                })
            }
            ), (function() {
                for (var e = o(this), t = e.kind, n = e.last; n && n.removed; )
                    n = n.previous;
                return e.target && (e.last = n = n ? n.next : e.state.first) ? "keys" == t ? {
                    value: n.key,
                    done: !1
                } : "values" == t ? {
                    value: n.value,
                    done: !1
                } : {
                    value: [n.key, n.value],
                    done: !1
                } : (e.target = void 0,
                {
                    value: void 0,
                    done: !0
                })
            }
            ), n ? "entries" : "values", !n, !0),
            l(t)
        }
    }
}
, function(e, t, n) {
    "use strict";
    var r, i, o, s = n(116), a = n(64), c = n(56), u = n(40), l = n(24), d = u("iterator"), h = !1;
    [].keys && ("next"in (o = [].keys()) ? (i = s(s(o))) !== Object.prototype && (r = i) : h = !0),
    void 0 == r && (r = {}),
    l || c(r, d) || a(r, d, (function() {
        return this
    }
    )),
    e.exports = {
        IteratorPrototype: r,
        BUGGY_SAFARI_ITERATORS: h
    }
}
, function(e, t, n) {
    "use strict";
    var r, i = n(39), o = n(145), s = n(211), a = n(264), c = n(490), u = n(51), l = n(60).enforce, d = n(316), h = !i.ActiveXObject && "ActiveXObject"in i, f = Object.isExtensible, p = function(e) {
        return function() {
            return e(this, arguments.length ? arguments[0] : void 0)
        }
    }, g = e.exports = a("WeakMap", p, c);
    if (d && h) {
        r = c.getConstructor(p, "WeakMap", !0),
        s.REQUIRED = !0;
        var m = g.prototype
          , y = m.delete
          , v = m.has
          , b = m.get
          , _ = m.set;
        o(m, {
            delete: function(e) {
                if (u(e) && !f(e)) {
                    var t = l(this);
                    return t.frozen || (t.frozen = new r),
                    y.call(this, e) || t.frozen.delete(e)
                }
                return y.call(this, e)
            },
            has: function(e) {
                if (u(e) && !f(e)) {
                    var t = l(this);
                    return t.frozen || (t.frozen = new r),
                    v.call(this, e) || t.frozen.has(e)
                }
                return v.call(this, e)
            },
            get: function(e) {
                if (u(e) && !f(e)) {
                    var t = l(this);
                    return t.frozen || (t.frozen = new r),
                    v.call(this, e) ? b.call(this, e) : t.frozen.get(e)
                }
                return b.call(this, e)
            },
            set: function(e, t) {
                if (u(e) && !f(e)) {
                    var n = l(this);
                    n.frozen || (n.frozen = new r),
                    v.call(this, e) ? _.call(this, e, t) : n.frozen.set(e, t)
                } else
                    _.call(this, e, t);
                return this
            }
        })
    }
}
, function(e, t) {
    e.exports = Math.scale || function(e, t, n, r, i) {
        return 0 === arguments.length || e != e || t != t || n != n || r != r || i != i ? NaN : e === 1 / 0 || e === -1 / 0 ? e : (e - t) * (i - r) / (n - t) + r
    }
}
, function(e, t) {
    e.exports = "\t\n\v\f\r \xa0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029\ufeff"
}
, function(e, t, n) {
    "use strict";
    var r = n(18)
      , i = n(34);
    e.exports = function() {
        for (var e = r(this), t = i(e.add), n = 0, o = arguments.length; n < o; n++)
            t.call(e, arguments[n]);
        return e
    }
}
, function(e, t, n) {
    var r = n(51)
      , i = n(129)
      , o = n(40)("match");
    e.exports = function(e) {
        var t;
        return r(e) && (void 0 !== (t = e[o]) ? !!t : "RegExp" == i(e))
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(206)
      , i = n(170)
      , o = n(173)
      , s = n(60)
      , a = n(265)
      , c = s.set
      , u = s.getterFor("Array Iterator");
    e.exports = a(Array, "Array", (function(e, t) {
        c(this, {
            type: "Array Iterator",
            target: r(e),
            index: 0,
            kind: t
        })
    }
    ), (function() {
        var e = u(this)
          , t = e.target
          , n = e.kind
          , r = e.index++;
        return !t || r >= t.length ? (e.target = void 0,
        {
            value: void 0,
            done: !0
        }) : "keys" == n ? {
            value: r,
            done: !1
        } : "values" == n ? {
            value: t[r],
            done: !1
        } : {
            value: [r, t[r]],
            done: !1
        }
    }
    ), "values"),
    o.Arguments = o.Array,
    i("keys"),
    i("values"),
    i("entries")
}
, function(e, t, n) {
    var r = n(49)
      , i = n(40)
      , o = n(24)
      , s = i("iterator");
    e.exports = !r((function() {
        var e = new URL("b?a=1&b=2&c=3","http://a")
          , t = e.searchParams
          , n = "";
        return e.pathname = "c%20d",
        t.forEach((function(e, r) {
            t.delete("b"),
            n += r + e
        }
        )),
        o && !e.toJSON || !t.sort || "http://a/c%20d?a=1&c=3" !== e.href || "3" !== t.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t[s] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://\u0442\u0435\u0441\u0442").host || "#%D0%B1" !== new URL("http://a#\u0431").hash || "a1c3" !== n || "x" !== new URL("http://x",void 0).host
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n(339);
    var r = n(10)
      , i = n(45)
      , o = n(340)
      , s = n(94)
      , a = n(145)
      , c = n(146)
      , u = n(174)
      , l = n(60)
      , d = n(117)
      , h = n(56)
      , f = n(44)
      , p = n(210)
      , g = n(18)
      , m = n(51)
      , y = n(112)
      , v = n(128)
      , b = n(175)
      , _ = n(172)
      , S = n(40)
      , O = i("fetch")
      , T = i("Headers")
      , I = S("iterator")
      , x = l.set
      , w = l.getterFor("URLSearchParams")
      , M = l.getterFor("URLSearchParamsIterator")
      , A = /\+/g
      , E = Array(4)
      , C = function(e) {
        return E[e - 1] || (E[e - 1] = RegExp("((?:%[\\da-f]{2}){" + e + "})", "gi"))
    }
      , N = function(e) {
        try {
            return decodeURIComponent(e)
        } catch (t) {
            return e
        }
    }
      , R = function(e) {
        var t = e.replace(A, " ")
          , n = 4;
        try {
            return decodeURIComponent(t)
        } catch (r) {
            for (; n; )
                t = t.replace(C(n--), N);
            return t
        }
    }
      , P = /[!'()~]|%20/g
      , D = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+"
    }
      , F = function(e) {
        return D[e]
    }
      , k = function(e) {
        return encodeURIComponent(e).replace(P, F)
    }
      , j = function(e, t) {
        if (t)
            for (var n, r, i = t.split("&"), o = 0; o < i.length; )
                (n = i[o++]).length && (r = n.split("="),
                e.push({
                    key: R(r.shift()),
                    value: R(r.join("="))
                }))
    }
      , L = function(e) {
        this.entries.length = 0,
        j(this.entries, e)
    }
      , V = function(e, t) {
        if (e < t)
            throw TypeError("Not enough arguments")
    }
      , U = u((function(e, t) {
        x(this, {
            type: "URLSearchParamsIterator",
            iterator: b(w(e).entries),
            kind: t
        })
    }
    ), "Iterator", (function() {
        var e = M(this)
          , t = e.kind
          , n = e.iterator.next()
          , r = n.value;
        return n.done || (n.value = "keys" === t ? r.key : "values" === t ? r.value : [r.key, r.value]),
        n
    }
    ))
      , q = function() {
        d(this, q, "URLSearchParams");
        var e, t, n, r, i, o, s, a, c, u = arguments.length > 0 ? arguments[0] : void 0, l = this, f = [];
        if (x(l, {
            type: "URLSearchParams",
            entries: f,
            updateURL: function() {},
            updateSearchParams: L
        }),
        void 0 !== u)
            if (m(u))
                if ("function" === typeof (e = _(u)))
                    for (n = (t = e.call(u)).next; !(r = n.call(t)).done; ) {
                        if ((s = (o = (i = b(g(r.value))).next).call(i)).done || (a = o.call(i)).done || !o.call(i).done)
                            throw TypeError("Expected sequence with length 2");
                        f.push({
                            key: s.value + "",
                            value: a.value + ""
                        })
                    }
                else
                    for (c in u)
                        h(u, c) && f.push({
                            key: c,
                            value: u[c] + ""
                        });
            else
                j(f, "string" === typeof u ? "?" === u.charAt(0) ? u.slice(1) : u : u + "")
    }
      , Q = q.prototype;
    a(Q, {
        append: function(e, t) {
            V(arguments.length, 2);
            var n = w(this);
            n.entries.push({
                key: e + "",
                value: t + ""
            }),
            n.updateURL()
        },
        delete: function(e) {
            V(arguments.length, 1);
            for (var t = w(this), n = t.entries, r = e + "", i = 0; i < n.length; )
                n[i].key === r ? n.splice(i, 1) : i++;
            t.updateURL()
        },
        get: function(e) {
            V(arguments.length, 1);
            for (var t = w(this).entries, n = e + "", r = 0; r < t.length; r++)
                if (t[r].key === n)
                    return t[r].value;
            return null
        },
        getAll: function(e) {
            V(arguments.length, 1);
            for (var t = w(this).entries, n = e + "", r = [], i = 0; i < t.length; i++)
                t[i].key === n && r.push(t[i].value);
            return r
        },
        has: function(e) {
            V(arguments.length, 1);
            for (var t = w(this).entries, n = e + "", r = 0; r < t.length; )
                if (t[r++].key === n)
                    return !0;
            return !1
        },
        set: function(e, t) {
            V(arguments.length, 1);
            for (var n, r = w(this), i = r.entries, o = !1, s = e + "", a = t + "", c = 0; c < i.length; c++)
                (n = i[c]).key === s && (o ? i.splice(c--, 1) : (o = !0,
                n.value = a));
            o || i.push({
                key: s,
                value: a
            }),
            r.updateURL()
        },
        sort: function() {
            var e, t, n, r = w(this), i = r.entries, o = i.slice();
            for (i.length = 0,
            n = 0; n < o.length; n++) {
                for (e = o[n],
                t = 0; t < n; t++)
                    if (i[t].key > e.key) {
                        i.splice(t, 0, e);
                        break
                    }
                t === n && i.push(e)
            }
            r.updateURL()
        },
        forEach: function(e) {
            for (var t, n = w(this).entries, r = f(e, arguments.length > 1 ? arguments[1] : void 0, 3), i = 0; i < n.length; )
                r((t = n[i++]).value, t.key, this)
        },
        keys: function() {
            return new U(this,"keys")
        },
        values: function() {
            return new U(this,"values")
        },
        entries: function() {
            return new U(this,"entries")
        }
    }, {
        enumerable: !0
    }),
    s(Q, I, Q.entries),
    s(Q, "toString", (function() {
        for (var e, t = w(this).entries, n = [], r = 0; r < t.length; )
            e = t[r++],
            n.push(k(e.key) + "=" + k(e.value));
        return n.join("&")
    }
    ), {
        enumerable: !0
    }),
    c(q, "URLSearchParams"),
    r({
        global: !0,
        forced: !o
    }, {
        URLSearchParams: q
    }),
    o || "function" != typeof O || "function" != typeof T || r({
        global: !0,
        enumerable: !0,
        forced: !0
    }, {
        fetch: function(e) {
            var t, n, r, i = [e];
            return arguments.length > 1 && (m(t = arguments[1]) && (n = t.body,
            "URLSearchParams" === p(n) && ((r = t.headers ? new T(t.headers) : new T).has("content-type") || r.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"),
            t = y(t, {
                body: v(0, String(n)),
                headers: v(0, r)
            }))),
            i.push(t)),
            O.apply(this, i)
        }
    }),
    e.exports = {
        URLSearchParams: q,
        getState: w
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(195);
    const i = Object(r.b)({
        resolved: {},
        chunkName: () => "isomorix-bundle-dev",
        isReady(e) {
            const t = this.resolve(e);
            return !0 === this.resolved[t] && !!n.m[t]
        },
        importAsync: () => n.e(3).then(n.bind(null, 407)),
        requireAsync(e) {
            const t = this.resolve(e);
            return this.resolved[t] = !1,
            this.importAsync(e).then(e => (this.resolved[t] = !0,
            e))
        },
        requireSync(e) {
            const t = this.resolve(e);
            return n(t)
        },
        resolve() {
            return 407
        }
    })
}
, function(e, t, n) {
    "use strict";
    function r(e) {
        return "isomx_core_".concat(e)
    }
    n.d(t, "a", (function() {
        return o
    }
    ));
    r("introspection_query"),
    r("create_user_meta"),
    r("delete_user_record");
    const i = r("manage_plugins")
      , o = (r("manage_roles_permissions"),
    r("manage_logic_record"),
    r("manage_schema"),
    r("read_location_record"),
    r("read_session_record"),
    r("read_user_record"),
    r("update_field_perm"),
    r("update_location_record"),
    r("update_rec_perm_field"),
    r("update_session_record"),
    r("update_user_record"),
    {
        ANY: "any",
        ANY_USER: "any_user",
        READ_QUERIES: "read_queries",
        CREATE_QUERIES: "create_queries",
        MANAGE_QUERIES: "manage_queries",
        READ_DOMAINS: "read_domains",
        MANAGE_DOMAINS: "manage_domains",
        READ_SESSIONS: "read_sessions",
        MANAGE_SESSIONS: "manage_sessions",
        READ_PERMISSIONS: "read_permissions",
        MANAGE_PERMISSIONS: "manage_permissions",
        READ_TAGS: "read_tags",
        MANAGE_TAGS: "manage_tags",
        READ_USERS: "read_users",
        MANAGE_USERS: "manage_users",
        READ_ENTITIES: "read_entities",
        MANAGE_ENTITIES: "manage_entities",
        CREATE_APPS: "create_apps",
        CURRENT_ENTITY: "current_entity",
        CURRENT_USER: "current_user",
        READ_LOGIC: "read_logic",
        READ_DATA_SOURCES: "read_data_sources",
        MANAGE_DATA_SOURCES: "manage_data_sources",
        READ_DEPLOYMENTS: "read_deployments",
        MANAGE_APPS: "manage_apps",
        MANAGE_LOGIC: "manage_logic",
        MANAGE_DEPLOYMENTS: "manage_deployments",
        MANAGE_ENTITY: "manage_entity",
        MANAGE_PLUGINS: i,
        NEVER: "never",
        READ_DEV_RESOURCES: "read_dev_resources"
    })
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        NESTED_PATCH: "patch",
        FLAT_PATCH: "flatPatch",
        SKIP: "skip",
        INCLUDE: "include",
        DEPRECATED: "deprecated",
        SPECIFIED_BY: "specifiedBy"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(26)
      , i = n(82)
      , o = n(89);
    function s(e, t, n) {
        return new r.a(r => {
            const s = e.length;
            let a, c = 0, u = !1, l = !1, d = 0;
            const h = () => {
                if (!u) {
                    if (c === s)
                        return r.next(n),
                        void r.complete();
                    a = Object(o.b)();
                    try {
                        for (; c < s && (t(e[c]),
                        c++,
                        !(c % 2 === 0 && Object(o.c)() > a)); )
                            ;
                    } catch (f) {
                        return void r.error(f)
                    }
                    d = c,
                    !l || c !== s || Object(o.b)() - a > Object(o.a)() / 3 ? (l = !0,
                    i.b.schedule(h, 0)) : (r.next(n),
                    r.complete())
                }
            }
            ;
            return h(),
            () => {
                u = !0
            }
        }
        )
    }
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e, t) {
        return e === t || e !== e && t !== t
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(646))
      , i = o(n(655));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function(e) {
        if (!(0,
        i.default)(e))
            return !1;
        var t = (0,
        r.default)(e);
        return "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    (function(n) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        var r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
          , i = "object" == ("undefined" === typeof n ? "undefined" : r(n)) && n && n.Object === Object && n;
        t.default = i,
        e.exports = t.default
    }
    ).call(this, n(167))
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    t.default = function(e) {
        var t = "undefined" === typeof e ? "undefined" : r(e);
        return null != e && ("object" == t || "function" == t)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = Function.prototype.toString;
    t.default = function(e) {
        if (null != e) {
            try {
                return r.call(e)
            } catch (t) {}
            try {
                return e + ""
            } catch (t) {}
        }
        return ""
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = c(n(667))
      , i = c(n(688))
      , o = c(n(693))
      , s = c(n(696))
      , a = c(n(699));
    function c(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    function u(e) {
        var t = -1
          , n = null == e ? 0 : e.length;
        for (this.clear(); ++t < n; ) {
            var r = e[t];
            this.set(r[0], r[1])
        }
    }
    u.prototype.clear = r.default,
    u.prototype.delete = i.default,
    u.prototype.get = o.default,
    u.prototype.has = s.default,
    u.prototype.set = a.default,
    t.default = u,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(703))
      , i = s(n(710))
      , o = s(n(712));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function(e, t, n, s, a, c) {
        var u = 1 & n
          , l = e.length
          , d = t.length;
        if (l != d && !(u && d > l))
            return !1;
        var h = c.get(e);
        if (h && c.get(t))
            return h == t;
        var f = -1
          , p = !0
          , g = 2 & n ? new r.default : void 0;
        for (c.set(e, t),
        c.set(t, e); ++f < l; ) {
            var m = e[f]
              , y = t[f];
            if (s)
                var v = u ? s(y, m, f, t, e, c) : s(m, y, f, e, t, c);
            if (void 0 !== v) {
                if (v)
                    continue;
                p = !1;
                break
            }
            if (g) {
                if (!(0,
                i.default)(t, (function(e, t) {
                    if (!(0,
                    o.default)(g, t) && (m === e || a(m, e, n, s, c)))
                        return g.push(t)
                }
                ))) {
                    p = !1;
                    break
                }
            } else if (m !== y && !a(m, y, n, s, c)) {
                p = !1;
                break
            }
        }
        return c.delete(e),
        c.delete(t),
        p
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    (function(e) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        var r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
          , i = s(n(756))
          , o = s(n(757));
        function s(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }
        var a = "object" == r(t) && t && !t.nodeType && t
          , c = a && "object" == r(e) && e && !e.nodeType && e
          , u = c && c.exports === a ? i.default.Buffer : void 0
          , l = (u ? u.isBuffer : void 0) || o.default;
        t.default = l,
        e.exports = t.default
    }
    ).call(this, n(354)(e))
}
, function(e, t) {
    e.exports = function(e) {
        return e.webpackPolyfill || (e.deprecate = function() {}
        ,
        e.paths = [],
        e.children || (e.children = []),
        Object.defineProperty(e, "loaded", {
            enumerable: !0,
            get: function() {
                return e.l
            }
        }),
        Object.defineProperty(e, "id", {
            enumerable: !0,
            get: function() {
                return e.i
            }
        }),
        e.webpackPolyfill = 1),
        e
    }
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(762))
      , i = s(n(767))
      , o = s(n(769));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var a = o.default && o.default.isTypedArray
      , c = a ? (0,
    i.default)(a) : r.default;
    t.default = c,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    t.default = function(e) {
        return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(813))
      , i = s(n(817))
      , o = s(n(819));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var a = (0,
    r.default)((function e(t, n, r) {
        return (0,
        o.default)((function(n, r, o) {
            return (0,
            i.default)(r) && (0,
            i.default)(o) ? e(t, r, o) : t(n, r, o)
        }
        ), n, r)
    }
    ));
    t.default = a,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return function t(n, s, a) {
            switch (arguments.length) {
            case 0:
                return t;
            case 1:
                return (0,
                o.default)(n) ? t : (0,
                i.default)((function(t, r) {
                    return e(n, t, r)
                }
                ));
            case 2:
                return (0,
                o.default)(n) && (0,
                o.default)(s) ? t : (0,
                o.default)(n) ? (0,
                i.default)((function(t, n) {
                    return e(t, s, n)
                }
                )) : (0,
                o.default)(s) ? (0,
                i.default)((function(t, r) {
                    return e(n, t, r)
                }
                )) : (0,
                r.default)((function(t) {
                    return e(n, s, t)
                }
                ));
            default:
                return (0,
                o.default)(n) && (0,
                o.default)(s) && (0,
                o.default)(a) ? t : (0,
                o.default)(n) && (0,
                o.default)(s) ? (0,
                i.default)((function(t, n) {
                    return e(t, n, a)
                }
                )) : (0,
                o.default)(n) && (0,
                o.default)(a) ? (0,
                i.default)((function(t, n) {
                    return e(t, s, n)
                }
                )) : (0,
                o.default)(s) && (0,
                o.default)(a) ? (0,
                i.default)((function(t, r) {
                    return e(n, t, r)
                }
                )) : (0,
                o.default)(n) ? (0,
                r.default)((function(t) {
                    return e(t, s, a)
                }
                )) : (0,
                o.default)(s) ? (0,
                r.default)((function(t) {
                    return e(n, t, a)
                }
                )) : (0,
                o.default)(a) ? (0,
                r.default)((function(t) {
                    return e(n, s, t)
                }
                )) : e(n, s, a)
            }
        }
    }
    ;
    var r = s(n(814))
      , i = s(n(815))
      , o = s(n(816));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    e.exports = t.default
}
, function(e, t) {
    var n, r, i = e.exports = {};
    function o() {
        throw new Error("setTimeout has not been defined")
    }
    function s() {
        throw new Error("clearTimeout has not been defined")
    }
    function a(e) {
        if (n === setTimeout)
            return setTimeout(e, 0);
        if ((n === o || !n) && setTimeout)
            return n = setTimeout,
            setTimeout(e, 0);
        try {
            return n(e, 0)
        } catch (t) {
            try {
                return n.call(null, e, 0)
            } catch (t) {
                return n.call(this, e, 0)
            }
        }
    }
    !function() {
        try {
            n = "function" === typeof setTimeout ? setTimeout : o
        } catch (e) {
            n = o
        }
        try {
            r = "function" === typeof clearTimeout ? clearTimeout : s
        } catch (e) {
            r = s
        }
    }();
    var c, u = [], l = !1, d = -1;
    function h() {
        l && c && (l = !1,
        c.length ? u = c.concat(u) : d = -1,
        u.length && f())
    }
    function f() {
        if (!l) {
            var e = a(h);
            l = !0;
            for (var t = u.length; t; ) {
                for (c = u,
                u = []; ++d < t; )
                    c && c[d].run();
                d = -1,
                t = u.length
            }
            c = null,
            l = !1,
            function(e) {
                if (r === clearTimeout)
                    return clearTimeout(e);
                if ((r === s || !r) && clearTimeout)
                    return r = clearTimeout,
                    clearTimeout(e);
                try {
                    r(e)
                } catch (t) {
                    try {
                        return r.call(null, e)
                    } catch (t) {
                        return r.call(this, e)
                    }
                }
            }(e)
        }
    }
    function p(e, t) {
        this.fun = e,
        this.array = t
    }
    function g() {}
    i.nextTick = function(e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var n = 1; n < arguments.length; n++)
                t[n - 1] = arguments[n];
        u.push(new p(e,t)),
        1 !== u.length || l || a(f)
    }
    ,
    p.prototype.run = function() {
        this.fun.apply(null, this.array)
    }
    ,
    i.title = "browser",
    i.browser = !0,
    i.env = {},
    i.argv = [],
    i.version = "",
    i.versions = {},
    i.on = g,
    i.addListener = g,
    i.once = g,
    i.off = g,
    i.removeListener = g,
    i.removeAllListeners = g,
    i.emit = g,
    i.prependListener = g,
    i.prependOnceListener = g,
    i.listeners = function(e) {
        return []
    }
    ,
    i.binding = function(e) {
        throw new Error("process.binding is not supported")
    }
    ,
    i.cwd = function() {
        return "/"
    }
    ,
    i.chdir = function(e) {
        throw new Error("process.chdir is not supported")
    }
    ,
    i.umask = function() {
        return 0
    }
}
, function(e, t, n) {
    "use strict";
    var r = Object.prototype;
    r.toString,
    r.hasOwnProperty,
    new Map
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        DATE_FORMAT_DIRECTIVE_VALUE: "DateFormatDirectiveValueScalar",
        ENCRYPTED_JSON: "EncryptedJsonScalar",
        LOCATION_HISTORY: "LocationHistoryScalar",
        LOCATION_MATCH: "LocationMatchScalar",
        PERMISSION: "PermissionScalar",
        PLUGIN_INSTANCE: "PluginInstanceScalar",
        PLUGIN_TYPES: "PluginTypesInstanceScalar",
        QUERY_CALC_VALUE: "QueryCalcValueScalar",
        QUERY_SELECT_ALIAS_OR_VARIABLE_NAME: "QuerySelectAliasOrVariableNameScalar",
        SCHEMA_NAME: "SchemaNameScalar",
        TAG: "TagScalar",
        TIMEZONE_UTC_OFFSET: "TimezoneUTCOffsetScalar",
        USER_PASSWORD: "UserPasswordScalar"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(868)
      , i = n(149);
    function o(e) {
        return Object(r.a)(Object(i.a)(e))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(22);
    function i(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "execute";
        return n => n.lift(new o(e,t))
    }
    class o {
        constructor(e, t) {
            this.action = e,
            this.event = t
        }
        call(e, t) {
            return t.subscribe(new s(e,this.action,this.event))
        }
    }
    class s extends r.a {
        constructor(e, t, n) {
            super(e),
            this._action = t,
            this._event = n
        }
        _next(e) {
            e === this._event && (super._next(this._action),
            this.unsubscribe())
        }
        unsubscribe() {
            super.unsubscribe(),
            this._action = void 0
        }
    }
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(837), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = "function" === typeof Object.assign ? Object.assign : function(e) {
        if (null == e)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), n = 1, r = arguments.length; n < r; ) {
            var i = arguments[n];
            if (null != i)
                for (var s in i)
                    (0,
                    o.default)(s, i) && (t[s] = i[s]);
            n += 1
        }
        return t
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        GRAPHQL: "graphql_http",
        INSTANT_MEILISEARCH: "instant_meilisearch",
        MEILISEARCH: "meilisearch",
        REDIS: "redis",
        REST: "rest",
        SQL: "sql",
        AI_ROUTER: "ai_router",
        OPEN_AI: "openai",
        GOOGLE_MAPS: "google_maps",
        GOOGLE_TEXT_TO_SPEECH: "google_text_to_speech",
        TRANSACTIONAL_EMAIL: "transactional_email",
        AWS_S3: "aws_s3",
        APP_ASSETS: "app_assets",
        OPTIZMO_ACCESS: "optizmo_access"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return f
    }
    ));
    var r = n(390)
      , i = n(72)
      , o = n(52)
      , s = n(74)
      , a = n(31)
      , c = n(195)
      , u = n(281)
      , l = n(77)
      , d = n(871);
    const h = Object(c.b)({
        resolved: {},
        chunkName: () => "entitySchemaChunk",
        isReady(e) {
            const t = this.resolve(e);
            return !0 === this.resolved[t] && !!n.m[t]
        },
        importAsync: () => Promise.all([n.e(6), n.e(2)]).then(n.bind(null, 404)),
        requireAsync(e) {
            const t = this.resolve(e);
            return this.resolved[t] = !1,
            this.importAsync(e).then(e => (this.resolved[t] = !0,
            e))
        },
        requireSync(e) {
            const t = this.resolve(e);
            return n(t)
        },
        resolve() {
            return 404
        }
    });
    function f(e) {
        const t = e.plugin.getMainInstance()
          , {storesMap: n} = e
          , c = e.parentStore.storeConfig
          , f = Object(r.a)(e);
        f.initSchema = function() {
            return h().pipe(Object(i.a)(e => (e.addToRecord(c, this.constructor),
            new c.Schema(this))))
        }
        ,
        f.syncSchema = function(e, n) {
            if (!e)
                return this.createSyncSchemaPayload().pipe(Object(o.a)(e => e.statusCode !== u.a.READY ? Object(a.a)(e) : this.syncSchema(e, n)));
            const r = t.switchTo(l.b.ENTITY_JOB).mutation(n)
              , i = t.getSession()
              , c = r.createOne({
                entityId: this.__ID,
                userRoleId: i ? i.userRoleId : null,
                payload: {
                    changes: e.changes,
                    schemaData: e.schemaData,
                    allStatusCodes: e.allStatusCodes,
                    statusCode: e.statusCode,
                    nameChanges: e.nameChanges || null,
                    toDrop: e.toDrop
                },
                processAt: Math.round(Date.now() / 1e3),
                status: d.a.QUEUED,
                type: "syncSchema"
            });
            return r.execute(!n).pipe(Object(s.a)(n ? c : c.getMainInstance()))
        }
        ,
        f.getModels = function() {
            const e = n.get(this)
              , r = e.mainDispatchId ? t.getBestInstance(e.mainDispatchId).getState() : t.getState()
              , i = e.get("slug");
            let o, s = null;
            for (const t in r)
                (o = r[t].schema) && o.entitySlug === i && (s ? s[t] = r[t] : s = {
                    [t]: r[t]
                });
            return s
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        ACTIVATE: "activate",
        ACTIVATE_IN_PROCESS: "activate_in_process",
        VALID: "valid",
        INVALID: "invalid",
        EXPIRED: "expired",
        REVOKED: "revoked"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        POP: "POP",
        PUSH: "PUSH",
        REPLACE: "REPLACE"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        GOOGLE_SPREADSHEET: "google_spreadsheet",
        ONTRAPORT: "ontraport",
        RAND_MCNALLY: "rand_mcnally",
        XERO: "xero"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        ANY_USER: "any_user",
        TEAM_MEMBERS: "team_members",
        NOBODY_ELSE: "nobody_else"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        API_ONLY: "api_only",
        ONLINE: "online",
        OFFLINE: "offline",
        EXPIRED: "expired",
        UNKNOWN: "unknown"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(873)
      , i = n(283);
    const o = Object(i.b)(r.a)
      , s = () => o
}
, function(e, t, n) {
    "use strict";
    var r = Object.getOwnPropertySymbols
      , i = Object.prototype.hasOwnProperty
      , o = Object.prototype.propertyIsEnumerable;
    function s(e) {
        if (null === e || void 0 === e)
            throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(e)
    }
    e.exports = function() {
        try {
            if (!Object.assign)
                return !1;
            var e = new String("abc");
            if (e[5] = "de",
            "5" === Object.getOwnPropertyNames(e)[0])
                return !1;
            for (var t = {}, n = 0; n < 10; n++)
                t["_" + String.fromCharCode(n)] = n;
            if ("0123456789" !== Object.getOwnPropertyNames(t).map((function(e) {
                return t[e]
            }
            )).join(""))
                return !1;
            var r = {};
            return "abcdefghijklmnopqrst".split("").forEach((function(e) {
                r[e] = e
            }
            )),
            "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r)).join("")
        } catch (i) {
            return !1
        }
    }() ? Object.assign : function(e, t) {
        for (var n, a, c = s(e), u = 1; u < arguments.length; u++) {
            for (var l in n = Object(arguments[u]))
                i.call(n, l) && (c[l] = n[l]);
            if (r) {
                a = r(n);
                for (var d = 0; d < a.length; d++)
                    o.call(n, a[d]) && (c[a[d]] = n[a[d]])
            }
        }
        return c
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        BLURRED: "blurred",
        CLOSED: "closed",
        FOCUSED: "focused",
        HIDDEN: "hidden"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return v
    }
    )),
    n.d(t, "a", (function() {
        return b
    }
    ));
    var r = n(104)
      , i = n(61)
      , o = (n(21),
    n(68))
      , s = n(30)
      , a = (n(73),
    n(103))
      , c = n(67)
      , u = n(62)
      , l = n(194)
      , d = n(85);
    function h(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1,
            r.configurable = !0,
            "value"in r && (r.writable = !0),
            Object.defineProperty(e, r.key, r)
        }
    }
    var f = function() {
        function e(e) {
            var t, n;
            this.name = e.name,
            this.description = e.description,
            this.locations = e.locations,
            this.isRepeatable = null !== (t = e.isRepeatable) && void 0 !== t && t,
            this.extensions = e.extensions && Object(o.a)(e.extensions),
            this.astNode = e.astNode,
            e.name || Object(s.a)(0, "Directive must be named."),
            Array.isArray(e.locations) || Object(s.a)(0, "@".concat(e.name, " locations must be an Array."));
            var i = null !== (n = e.args) && void 0 !== n ? n : {};
            Object(a.a)(i) && !Array.isArray(i) || Object(s.a)(0, "@".concat(e.name, " args must be an object with argument names as keys.")),
            this.args = Object(r.a)(i).map((function(e) {
                var t = e[0]
                  , n = e[1];
                return {
                    name: t,
                    description: n.description,
                    type: n.type,
                    defaultValue: n.defaultValue,
                    deprecationReason: n.deprecationReason,
                    extensions: n.extensions && Object(o.a)(n.extensions),
                    astNode: n.astNode
                }
            }
            ))
        }
        var t, n, c, u = e.prototype;
        return u.toConfig = function() {
            return {
                name: this.name,
                description: this.description,
                locations: this.locations,
                args: Object(d.d)(this.args),
                isRepeatable: this.isRepeatable,
                extensions: this.extensions,
                astNode: this.astNode
            }
        }
        ,
        u.toString = function() {
            return "@" + this.name
        }
        ,
        u.toJSON = function() {
            return this.toString()
        }
        ,
        t = e,
        (n = [{
            key: i.a,
            get: function() {
                return "GraphQLDirective"
            }
        }]) && h(t.prototype, n),
        c && h(t, c),
        e
    }();
    Object(c.a)(f);
    var p = new f({
        name: "include",
        description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
        locations: [u.a.FIELD, u.a.FRAGMENT_SPREAD, u.a.INLINE_FRAGMENT],
        args: {
            if: {
                type: new d.b(l.a),
                description: "Included when true."
            }
        }
    })
      , g = new f({
        name: "skip",
        description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
        locations: [u.a.FIELD, u.a.FRAGMENT_SPREAD, u.a.INLINE_FRAGMENT],
        args: {
            if: {
                type: new d.b(l.a),
                description: "Skipped when true."
            }
        }
    })
      , m = new f({
        name: "deprecated",
        description: "Marks an element of a GraphQL schema as no longer supported.",
        locations: [u.a.FIELD_DEFINITION, u.a.ARGUMENT_DEFINITION, u.a.INPUT_FIELD_DEFINITION, u.a.ENUM_VALUE],
        args: {
            reason: {
                type: l.b,
                description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
                defaultValue: "No longer supported"
            }
        }
    })
      , y = new f({
        name: "specifiedBy",
        description: "Exposes a URL that specifies the behaviour of this scalar.",
        locations: [u.a.SCALAR],
        args: {
            url: {
                type: new d.b(l.b),
                description: "The URL that specifies the behaviour of this scalar."
            }
        }
    })
      , v = Object.freeze([p, g, m, y]);
    function b(e) {
        void 0
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "d", (function() {
        return f
    }
    )),
    n.d(t, "e", (function() {
        return g
    }
    )),
    n.d(t, "f", (function() {
        return m
    }
    )),
    n.d(t, "g", (function() {
        return y
    }
    )),
    n.d(t, "b", (function() {
        return b
    }
    )),
    n.d(t, "a", (function() {
        return _
    }
    ));
    var r = n(83)
      , i = n(237);
    function o(e, t, n) {
        return n && (e = Object(i.a)(e)),
        e + Object(r.b)(t)
    }
    const s = e => "_".concat(e.toLowerCase())
      , a = /(?<!Mc)([A-Z])(?=[a-z])/g
      , c = /[a-z\d]_[a-z\d]/i
      , u = /.+(?<!Mc)[A-Z](?=[a-z])/
      , l = /__+/g
      , d = /(^|_)([a-z])/g
      , h = (e, t, n) => t ? "_".concat(n.toUpperCase()) : n.toUpperCase();
    function f(e, t, n) {
        let r = e[0].toLowerCase();
        return r += e.slice(1, e.length).replace(a, s),
        a.lastIndex = 0,
        r = r.replace(l, "_"),
        l.lastIndex = 0,
        t ? r.toUpperCase() : n ? (r = r.replace(d, h),
        d.lastIndex = 0,
        r) : r
    }
    const p = e => e;
    function g(e, t) {
        let n;
        "boolean" !== typeof t ? n = e.charAt(0) === e.charAt(0).toUpperCase() ? p : i.a : !0 === t ? (e = Object(r.b)(e),
        n = p) : n = i.a;
        let o = n(e[0]);
        return o += e.slice(1, e.length).replace(a, e => " ".concat(n(e))),
        o
    }
    function m(e) {
        if (!c.test(e))
            return e;
        const t = e.split("_")
          , n = t.length;
        let i = t[0]
          , o = 1;
        for (; o < n; )
            i += Object(r.b)(t[o]),
            o++;
        return i
    }
    function y(e, t) {
        return c.test(e) ? function(e, t) {
            const n = e.split("_")
              , i = n.length;
            let o = t ? Object(r.b)(n[0]) : n[0];
            if (1 === i)
                return o;
            let s = 1;
            if (t)
                for (; s < i; )
                    o += " ".concat(Object(r.b)(n[s])),
                    s++;
            else
                for (; s < i; )
                    o += " ".concat(n[s]),
                    s++;
            return o
        }(e, t) : g(e, t)
    }
    const v = (e, t, n) => c.test(t) ? Object(r.a)(n) ? "".concat(f(e, !1, !0), "_").concat(t) : "".concat(f(e), "_").concat(t) : u.test(t) ? "".concat(m(e)).concat(Object(r.b)(t)) : "".concat(e).concat(Object(r.b)(t));
    function b(e, t) {
        return v(e, t, e)
    }
    function _(e, t) {
        return v(e, t, t)
    }
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(823))
      , i = s(n(824))
      , o = s(n(825));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var a = (0,
    r.default)((function(e, t) {
        if (0 === e.length || (0,
        o.default)(t))
            return !1;
        for (var n = t, r = 0; r < e.length; ) {
            if ((0,
            o.default)(n) || !(0,
            i.default)(e[r], n))
                return !1;
            n = n[e[r]],
            r += 1
        }
        return !0
    }
    ));
    t.default = a,
    e.exports = t.default
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = function(e, t) {
        return (r = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(e, t) {
            e.__proto__ = t
        }
        || function(e, t) {
            for (var n in t)
                t.hasOwnProperty(n) && (e[n] = t[n])
        }
        )(e, t)
    };
    function i(e, t) {
        function n() {
            this.constructor = e
        }
        r(e, t),
        e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
        new n)
    }
}
, function(e, t, n) {
    "use strict";
    e.exports = function(e, t) {
        t || (t = {}),
        "function" === typeof t && (t = {
            cmp: t
        });
        var n, r = "boolean" === typeof t.cycles && t.cycles, i = t.cmp && (n = t.cmp,
        function(e) {
            return function(t, r) {
                var i = {
                    key: t,
                    value: e[t]
                }
                  , o = {
                    key: r,
                    value: e[r]
                };
                return n(i, o)
            }
        }
        ), o = [];
        return function e(t) {
            if (t && t.toJSON && "function" === typeof t.toJSON && (t = t.toJSON()),
            void 0 !== t) {
                if ("number" == typeof t)
                    return isFinite(t) ? "" + t : "null";
                if ("object" !== typeof t)
                    return JSON.stringify(t);
                var n, s;
                if (Array.isArray(t)) {
                    for (s = "[",
                    n = 0; n < t.length; n++)
                        n && (s += ","),
                        s += e(t[n]) || "null";
                    return s + "]"
                }
                if (null === t)
                    return "null";
                if (-1 !== o.indexOf(t)) {
                    if (r)
                        return JSON.stringify("__cycle__");
                    throw new TypeError("Converting circular structure to JSON")
                }
                var a = o.push(t) - 1
                  , c = Object.keys(t).sort(i && i(t));
                for (s = "",
                n = 0; n < c.length; n++) {
                    var u = c[n]
                      , l = e(t[u]);
                    l && (s && (s += ","),
                    s += JSON.stringify(u) + ":" + l)
                }
                return o.splice(a, 1),
                "{" + s + "}"
            }
        }(e)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(20);
    function i(e, t) {
        const n = Object(r.a)(e, null === t || void 0 === t ? void 0 : t.in);
        return n.setFullYear(n.getFullYear(), 0, 1),
        n.setHours(0, 0, 0, 0),
        n
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return f
    }
    ));
    var r = n(195)
      , i = n(31)
      , o = n(394)
      , s = n(72);
    let a, c;
    const u = Object(r.b)({
        resolved: {},
        chunkName: () => "prettier",
        isReady(e) {
            const t = this.resolve(e);
            return !0 === this.resolved[t] && !!n.m[t]
        },
        importAsync: () => Promise.all([n.e(7), n.e(5)]).then(n.bind(null, 402)),
        requireAsync(e) {
            const t = this.resolve(e);
            return this.resolved[t] = !1,
            this.importAsync(e).then(e => (this.resolved[t] = !0,
            e))
        },
        requireSync(e) {
            const t = this.resolve(e);
            return n(t)
        },
        resolve() {
            return 402
        }
    });
    function l() {
        return a ? Object(i.a)(a) : c || (c = u().pipe(Object(s.a)(e => (a = e,
        c = void 0,
        e))),
        c.subscribe(),
        Object(o.a)( () => a ? Object(i.a)(a) : c))
    }
    function d() {
        return a
    }
    const h = {};
    function f(e, t) {
        const n = d();
        return n ? n.prettier.format(e, {
            ...t || h,
            parser: "graphql",
            printWidth: 60,
            plugins: [n.graphql]
        }) : (l(),
        e)
    }
}
, function(e, t, n) {
    "use strict";
    (function(t) {
        var r = n(843)
          , i = n(844)
          , o = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
          , s = /[\n\r\t]/g
          , a = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
          , c = /:\d+$/
          , u = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
          , l = /^[a-zA-Z]:/;
        function d(e) {
            return (e || "").toString().replace(o, "")
        }
        var h = [["#", "hash"], ["?", "query"], function(e, t) {
            return g(t.protocol) ? e.replace(/\\/g, "/") : e
        }
        , ["/", "pathname"], ["@", "auth", 1], [NaN, "host", void 0, 1, 1], [/:(\d*)$/, "port", void 0, 1], [NaN, "hostname", void 0, 1, 1]]
          , f = {
            hash: 1,
            query: 1
        };
        function p(e) {
            var n, r = ("undefined" !== typeof window ? window : "undefined" !== typeof t ? t : "undefined" !== typeof self ? self : {}).location || {}, i = {}, o = typeof (e = e || r);
            if ("blob:" === e.protocol)
                i = new y(unescape(e.pathname),{});
            else if ("string" === o)
                for (n in i = new y(e,{}),
                f)
                    delete i[n];
            else if ("object" === o) {
                for (n in e)
                    n in f || (i[n] = e[n]);
                void 0 === i.slashes && (i.slashes = a.test(e.href))
            }
            return i
        }
        function g(e) {
            return "file:" === e || "ftp:" === e || "http:" === e || "https:" === e || "ws:" === e || "wss:" === e
        }
        function m(e, t) {
            e = (e = d(e)).replace(s, ""),
            t = t || {};
            var n, r = u.exec(e), i = r[1] ? r[1].toLowerCase() : "", o = !!r[2], a = !!r[3], c = 0;
            return o ? a ? (n = r[2] + r[3] + r[4],
            c = r[2].length + r[3].length) : (n = r[2] + r[4],
            c = r[2].length) : a ? (n = r[3] + r[4],
            c = r[3].length) : n = r[4],
            "file:" === i ? c >= 2 && (n = n.slice(2)) : g(i) ? n = r[4] : i ? o && (n = n.slice(2)) : c >= 2 && g(t.protocol) && (n = r[4]),
            {
                protocol: i,
                slashes: o || g(i),
                slashesCount: c,
                rest: n
            }
        }
        function y(e, t, n) {
            if (e = (e = d(e)).replace(s, ""),
            !(this instanceof y))
                return new y(e,t,n);
            var o, a, c, u, f, v, b = h.slice(), _ = typeof t, S = this, O = 0;
            for ("object" !== _ && "string" !== _ && (n = t,
            t = null),
            n && "function" !== typeof n && (n = i.parse),
            o = !(a = m(e || "", t = p(t))).protocol && !a.slashes,
            S.slashes = a.slashes || o && t.slashes,
            S.protocol = a.protocol || t.protocol || "",
            e = a.rest,
            ("file:" === a.protocol && (2 !== a.slashesCount || l.test(e)) || !a.slashes && (a.protocol || a.slashesCount < 2 || !g(S.protocol))) && (b[3] = [/(.*)/, "pathname"]); O < b.length; O++)
                "function" !== typeof (u = b[O]) ? (c = u[0],
                v = u[1],
                c !== c ? S[v] = e : "string" === typeof c ? ~(f = "@" === c ? e.lastIndexOf(c) : e.indexOf(c)) && ("number" === typeof u[2] ? (S[v] = e.slice(0, f),
                e = e.slice(f + u[2])) : (S[v] = e.slice(f),
                e = e.slice(0, f))) : (f = c.exec(e)) && (S[v] = f[1],
                e = e.slice(0, f.index)),
                S[v] = S[v] || o && u[3] && t[v] || "",
                u[4] && (S[v] = S[v].toLowerCase())) : e = u(e, S);
            n && (S.query = n(S.query)),
            o && t.slashes && "/" !== S.pathname.charAt(0) && ("" !== S.pathname || "" !== t.pathname) && (S.pathname = function(e, t) {
                if ("" === e)
                    return t;
                for (var n = (t || "/").split("/").slice(0, -1).concat(e.split("/")), r = n.length, i = n[r - 1], o = !1, s = 0; r--; )
                    "." === n[r] ? n.splice(r, 1) : ".." === n[r] ? (n.splice(r, 1),
                    s++) : s && (0 === r && (o = !0),
                    n.splice(r, 1),
                    s--);
                return o && n.unshift(""),
                "." !== i && ".." !== i || n.push(""),
                n.join("/")
            }(S.pathname, t.pathname)),
            "/" !== S.pathname.charAt(0) && g(S.protocol) && (S.pathname = "/" + S.pathname),
            r(S.port, S.protocol) || (S.host = S.hostname,
            S.port = ""),
            S.username = S.password = "",
            S.auth && (~(f = S.auth.indexOf(":")) ? (S.username = S.auth.slice(0, f),
            S.username = encodeURIComponent(decodeURIComponent(S.username)),
            S.password = S.auth.slice(f + 1),
            S.password = encodeURIComponent(decodeURIComponent(S.password))) : S.username = encodeURIComponent(decodeURIComponent(S.auth)),
            S.auth = S.password ? S.username + ":" + S.password : S.username),
            S.origin = "file:" !== S.protocol && g(S.protocol) && S.host ? S.protocol + "//" + S.host : "null",
            S.href = S.toString()
        }
        y.prototype = {
            set: function(e, t, n) {
                var o = this;
                switch (e) {
                case "query":
                    "string" === typeof t && t.length && (t = (n || i.parse)(t)),
                    o[e] = t;
                    break;
                case "port":
                    o[e] = t,
                    r(t, o.protocol) ? t && (o.host = o.hostname + ":" + t) : (o.host = o.hostname,
                    o[e] = "");
                    break;
                case "hostname":
                    o[e] = t,
                    o.port && (t += ":" + o.port),
                    o.host = t;
                    break;
                case "host":
                    o[e] = t,
                    c.test(t) ? (t = t.split(":"),
                    o.port = t.pop(),
                    o.hostname = t.join(":")) : (o.hostname = t,
                    o.port = "");
                    break;
                case "protocol":
                    o.protocol = t.toLowerCase(),
                    o.slashes = !n;
                    break;
                case "pathname":
                case "hash":
                    if (t) {
                        var s = "pathname" === e ? "/" : "#";
                        o[e] = t.charAt(0) !== s ? s + t : t
                    } else
                        o[e] = t;
                    break;
                case "username":
                case "password":
                    o[e] = encodeURIComponent(t);
                    break;
                case "auth":
                    var a = t.indexOf(":");
                    ~a ? (o.username = t.slice(0, a),
                    o.username = encodeURIComponent(decodeURIComponent(o.username)),
                    o.password = t.slice(a + 1),
                    o.password = encodeURIComponent(decodeURIComponent(o.password))) : o.username = encodeURIComponent(decodeURIComponent(t))
                }
                for (var u = 0; u < h.length; u++) {
                    var l = h[u];
                    l[4] && (o[l[1]] = o[l[1]].toLowerCase())
                }
                return o.auth = o.password ? o.username + ":" + o.password : o.username,
                o.origin = "file:" !== o.protocol && g(o.protocol) && o.host ? o.protocol + "//" + o.host : "null",
                o.href = o.toString(),
                o
            },
            toString: function(e) {
                e && "function" === typeof e || (e = i.stringify);
                var t, n = this, r = n.host, o = n.protocol;
                o && ":" !== o.charAt(o.length - 1) && (o += ":");
                var s = o + (n.protocol && n.slashes || g(n.protocol) ? "//" : "");
                return n.username ? (s += n.username,
                n.password && (s += ":" + n.password),
                s += "@") : n.password ? (s += ":" + n.password,
                s += "@") : "file:" !== n.protocol && g(n.protocol) && !r && "/" !== n.pathname && (s += "@"),
                (":" === r[r.length - 1] || c.test(n.hostname) && !n.port) && (r += ":"),
                s += r + n.pathname,
                (t = "object" === typeof n.query ? e(n.query) : n.query) && (s += "?" !== t.charAt(0) ? "?" + t : t),
                n.hash && (s += n.hash),
                s
            }
        },
        y.extractProtocol = m,
        y.location = p,
        y.trimLeft = d,
        y.qs = i,
        e.exports = y
    }
    ).call(this, n(167))
}
, function(e, t, n) {
    "use strict";
    var r = n(850)
      , i = {
        childContextTypes: !0,
        contextType: !0,
        contextTypes: !0,
        defaultProps: !0,
        displayName: !0,
        getDefaultProps: !0,
        getDerivedStateFromError: !0,
        getDerivedStateFromProps: !0,
        mixins: !0,
        propTypes: !0,
        type: !0
    }
      , o = {
        name: !0,
        length: !0,
        prototype: !0,
        caller: !0,
        callee: !0,
        arguments: !0,
        arity: !0
    }
      , s = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    }
      , a = {};
    function c(e) {
        return r.isMemo(e) ? s : a[e.$$typeof] || i
    }
    a[r.ForwardRef] = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    },
    a[r.Memo] = s;
    var u = Object.defineProperty
      , l = Object.getOwnPropertyNames
      , d = Object.getOwnPropertySymbols
      , h = Object.getOwnPropertyDescriptor
      , f = Object.getPrototypeOf
      , p = Object.prototype;
    e.exports = function e(t, n, r) {
        if ("string" !== typeof n) {
            if (p) {
                var i = f(n);
                i && i !== p && e(t, i, r)
            }
            var s = l(n);
            d && (s = s.concat(d(n)));
            for (var a = c(t), g = c(n), m = 0; m < s.length; ++m) {
                var y = s[m];
                if (!o[y] && (!r || !r[y]) && (!g || !g[y]) && (!a || !a[y])) {
                    var v = h(n, y);
                    try {
                        u(t, y, v)
                    } catch (b) {}
                }
            }
        }
        return t
    }
}
, function(e, t, n) {
    var r = n(855);
    e.exports = f,
    e.exports.parse = o,
    e.exports.compile = function(e, t) {
        return a(o(e, t), t)
    }
    ,
    e.exports.tokensToFunction = a,
    e.exports.tokensToRegExp = h;
    var i = new RegExp(["(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");
    function o(e, t) {
        for (var n, r = [], o = 0, s = 0, a = "", l = t && t.delimiter || "/"; null != (n = i.exec(e)); ) {
            var d = n[0]
              , h = n[1]
              , f = n.index;
            if (a += e.slice(s, f),
            s = f + d.length,
            h)
                a += h[1];
            else {
                var p = e[s]
                  , g = n[2]
                  , m = n[3]
                  , y = n[4]
                  , v = n[5]
                  , b = n[6]
                  , _ = n[7];
                a && (r.push(a),
                a = "");
                var S = null != g && null != p && p !== g
                  , O = "+" === b || "*" === b
                  , T = "?" === b || "*" === b
                  , I = n[2] || l
                  , x = y || v;
                r.push({
                    name: m || o++,
                    prefix: g || "",
                    delimiter: I,
                    optional: T,
                    repeat: O,
                    partial: S,
                    asterisk: !!_,
                    pattern: x ? u(x) : _ ? ".*" : "[^" + c(I) + "]+?"
                })
            }
        }
        return s < e.length && (a += e.substr(s)),
        a && r.push(a),
        r
    }
    function s(e) {
        return encodeURI(e).replace(/[\/?#]/g, (function(e) {
            return "%" + e.charCodeAt(0).toString(16).toUpperCase()
        }
        ))
    }
    function a(e, t) {
        for (var n = new Array(e.length), i = 0; i < e.length; i++)
            "object" === typeof e[i] && (n[i] = new RegExp("^(?:" + e[i].pattern + ")$",d(t)));
        return function(t, i) {
            for (var o = "", a = t || {}, c = (i || {}).pretty ? s : encodeURIComponent, u = 0; u < e.length; u++) {
                var l = e[u];
                if ("string" !== typeof l) {
                    var d, h = a[l.name];
                    if (null == h) {
                        if (l.optional) {
                            l.partial && (o += l.prefix);
                            continue
                        }
                        throw new TypeError('Expected "' + l.name + '" to be defined')
                    }
                    if (r(h)) {
                        if (!l.repeat)
                            throw new TypeError('Expected "' + l.name + '" to not repeat, but received `' + JSON.stringify(h) + "`");
                        if (0 === h.length) {
                            if (l.optional)
                                continue;
                            throw new TypeError('Expected "' + l.name + '" to not be empty')
                        }
                        for (var f = 0; f < h.length; f++) {
                            if (d = c(h[f]),
                            !n[u].test(d))
                                throw new TypeError('Expected all "' + l.name + '" to match "' + l.pattern + '", but received `' + JSON.stringify(d) + "`");
                            o += (0 === f ? l.prefix : l.delimiter) + d
                        }
                    } else {
                        if (d = l.asterisk ? encodeURI(h).replace(/[?#]/g, (function(e) {
                            return "%" + e.charCodeAt(0).toString(16).toUpperCase()
                        }
                        )) : c(h),
                        !n[u].test(d))
                            throw new TypeError('Expected "' + l.name + '" to match "' + l.pattern + '", but received "' + d + '"');
                        o += l.prefix + d
                    }
                } else
                    o += l
            }
            return o
        }
    }
    function c(e) {
        return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
    }
    function u(e) {
        return e.replace(/([=!:$\/()])/g, "\\$1")
    }
    function l(e, t) {
        return e.keys = t,
        e
    }
    function d(e) {
        return e && e.sensitive ? "" : "i"
    }
    function h(e, t, n) {
        r(t) || (n = t || n,
        t = []);
        for (var i = (n = n || {}).strict, o = !1 !== n.end, s = "", a = 0; a < e.length; a++) {
            var u = e[a];
            if ("string" === typeof u)
                s += c(u);
            else {
                var h = c(u.prefix)
                  , f = "(?:" + u.pattern + ")";
                t.push(u),
                u.repeat && (f += "(?:" + h + f + ")*"),
                s += f = u.optional ? u.partial ? h + "(" + f + ")?" : "(?:" + h + "(" + f + "))?" : h + "(" + f + ")"
            }
        }
        var p = c(n.delimiter || "/")
          , g = s.slice(-p.length) === p;
        return i || (s = (g ? s.slice(0, -p.length) : s) + "(?:" + p + "(?=$))?"),
        s += o ? "$" : i && g ? "" : "(?=" + p + "|$)",
        l(new RegExp("^" + s,d(n)), t)
    }
    function f(e, t, n) {
        return r(t) || (n = t || n,
        t = []),
        n = n || {},
        e instanceof RegExp ? function(e, t) {
            var n = e.source.match(/\((?!\?)/g);
            if (n)
                for (var r = 0; r < n.length; r++)
                    t.push({
                        name: r,
                        prefix: null,
                        delimiter: null,
                        optional: !1,
                        repeat: !1,
                        partial: !1,
                        asterisk: !1,
                        pattern: null
                    });
            return l(e, t)
        }(e, t) : r(e) ? function(e, t, n) {
            for (var r = [], i = 0; i < e.length; i++)
                r.push(f(e[i], t, n).source);
            return l(new RegExp("(?:" + r.join("|") + ")",d(n)), t)
        }(e, t, n) : function(e, t, n) {
            return h(o(e, n), t, n)
        }(e, t, n)
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(7).createContext({
        insertCss: null
    });
    e.exports = r
}
, function(e, t) {
    var n = "undefined" !== typeof Element
      , r = "function" === typeof Map
      , i = "function" === typeof Set
      , o = "function" === typeof ArrayBuffer && !!ArrayBuffer.isView;
    e.exports = function(e, t) {
        try {
            return function e(t, s) {
                if (t === s)
                    return !0;
                if (t && s && "object" == typeof t && "object" == typeof s) {
                    if (t.constructor !== s.constructor)
                        return !1;
                    var a, c, u, l;
                    if (Array.isArray(t)) {
                        if ((a = t.length) != s.length)
                            return !1;
                        for (c = a; 0 !== c--; )
                            if (!e(t[c], s[c]))
                                return !1;
                        return !0
                    }
                    if (r && t instanceof Map && s instanceof Map) {
                        if (t.size !== s.size)
                            return !1;
                        for (l = t.entries(); !(c = l.next()).done; )
                            if (!s.has(c.value[0]))
                                return !1;
                        for (l = t.entries(); !(c = l.next()).done; )
                            if (!e(c.value[1], s.get(c.value[0])))
                                return !1;
                        return !0
                    }
                    if (i && t instanceof Set && s instanceof Set) {
                        if (t.size !== s.size)
                            return !1;
                        for (l = t.entries(); !(c = l.next()).done; )
                            if (!s.has(c.value[0]))
                                return !1;
                        return !0
                    }
                    if (o && ArrayBuffer.isView(t) && ArrayBuffer.isView(s)) {
                        if ((a = t.length) != s.length)
                            return !1;
                        for (c = a; 0 !== c--; )
                            if (t[c] !== s[c])
                                return !1;
                        return !0
                    }
                    if (t.constructor === RegExp)
                        return t.source === s.source && t.flags === s.flags;
                    if (t.valueOf !== Object.prototype.valueOf && "function" === typeof t.valueOf && "function" === typeof s.valueOf)
                        return t.valueOf() === s.valueOf();
                    if (t.toString !== Object.prototype.toString && "function" === typeof t.toString && "function" === typeof s.toString)
                        return t.toString() === s.toString();
                    if ((a = (u = Object.keys(t)).length) !== Object.keys(s).length)
                        return !1;
                    for (c = a; 0 !== c--; )
                        if (!Object.prototype.hasOwnProperty.call(s, u[c]))
                            return !1;
                    if (n && t instanceof Element)
                        return !1;
                    for (c = a; 0 !== c--; )
                        if (("_owner" !== u[c] && "__v" !== u[c] && "__o" !== u[c] || !t.$$typeof) && !e(t[u[c]], s[u[c]]))
                            return !1;
                    return !0
                }
                return t !== t && s !== s
            }(e, t)
        } catch (s) {
            if ((s.message || "").match(/stack|recursion/i))
                return console.warn("react-fast-compare cannot handle circular refs"),
                !1;
            throw s
        }
    }
}
, function(e, t) {
    e.exports = function(e, t, n, r) {
        var i = n ? n.call(r, e, t) : void 0;
        if (void 0 !== i)
            return !!i;
        if (e === t)
            return !0;
        if ("object" !== typeof e || !e || "object" !== typeof t || !t)
            return !1;
        var o = Object.keys(e)
          , s = Object.keys(t);
        if (o.length !== s.length)
            return !1;
        for (var a = Object.prototype.hasOwnProperty.bind(t), c = 0; c < o.length; c++) {
            var u = o[c];
            if (!a(u))
                return !1;
            var l = e[u]
              , d = t[u];
            if (!1 === (i = n ? n.call(r, l, d, u) : void 0) || void 0 === i && l !== d)
                return !1
        }
        return !0
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return te
    }
    ));
    const r = {
        lessThanXSeconds: {
            one: "less than a second",
            other: "less than {{count}} seconds"
        },
        xSeconds: {
            one: "1 second",
            other: "{{count}} seconds"
        },
        halfAMinute: "half a minute",
        lessThanXMinutes: {
            one: "less than a minute",
            other: "less than {{count}} minutes"
        },
        xMinutes: {
            one: "1 minute",
            other: "{{count}} minutes"
        },
        aboutXHours: {
            one: "about 1 hour",
            other: "about {{count}} hours"
        },
        xHours: {
            one: "1 hour",
            other: "{{count}} hours"
        },
        xDays: {
            one: "1 day",
            other: "{{count}} days"
        },
        aboutXWeeks: {
            one: "about 1 week",
            other: "about {{count}} weeks"
        },
        xWeeks: {
            one: "1 week",
            other: "{{count}} weeks"
        },
        aboutXMonths: {
            one: "about 1 month",
            other: "about {{count}} months"
        },
        xMonths: {
            one: "1 month",
            other: "{{count}} months"
        },
        aboutXYears: {
            one: "about 1 year",
            other: "about {{count}} years"
        },
        xYears: {
            one: "1 year",
            other: "{{count}} years"
        },
        overXYears: {
            one: "over 1 year",
            other: "over {{count}} years"
        },
        almostXYears: {
            one: "almost 1 year",
            other: "almost {{count}} years"
        }
    };
    function i(e) {
        return function() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const n = t.width ? String(t.width) : e.defaultWidth
              , r = e.formats[n] || e.formats[e.defaultWidth];
            return r
        }
    }
    const o = {
        date: i({
            formats: {
                full: "EEEE, MMMM do, y",
                long: "MMMM do, y",
                medium: "MMM d, y",
                short: "MM/dd/yyyy"
            },
            defaultWidth: "full"
        }),
        time: i({
            formats: {
                full: "h:mm:ss a zzzz",
                long: "h:mm:ss a z",
                medium: "h:mm:ss a",
                short: "h:mm a"
            },
            defaultWidth: "full"
        }),
        dateTime: i({
            formats: {
                full: "{{date}} 'at' {{time}}",
                long: "{{date}} 'at' {{time}}",
                medium: "{{date}}, {{time}}",
                short: "{{date}}, {{time}}"
            },
            defaultWidth: "full"
        })
    }
      , s = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
    };
    function a(e) {
        return (t, n) => {
            let r;
            if ("formatting" === (null !== n && void 0 !== n && n.context ? String(n.context) : "standalone") && e.formattingValues) {
                const t = e.defaultFormattingWidth || e.defaultWidth
                  , i = null !== n && void 0 !== n && n.width ? String(n.width) : t;
                r = e.formattingValues[i] || e.formattingValues[t]
            } else {
                const t = e.defaultWidth
                  , i = null !== n && void 0 !== n && n.width ? String(n.width) : e.defaultWidth;
                r = e.values[i] || e.values[t]
            }
            return r[e.argumentCallback ? e.argumentCallback(t) : t]
        }
    }
    function c(e) {
        return function(t) {
            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const r = n.width
              , i = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth]
              , o = t.match(i);
            if (!o)
                return null;
            const s = o[0]
              , a = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth]
              , c = Array.isArray(a) ? l(a, e => e.test(s)) : u(a, e => e.test(s));
            let d;
            d = e.valueCallback ? e.valueCallback(c) : c,
            d = n.valueCallback ? n.valueCallback(d) : d;
            const h = t.slice(s.length);
            return {
                value: d,
                rest: h
            }
        }
    }
    function u(e, t) {
        for (const n in e)
            if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n]))
                return n
    }
    function l(e, t) {
        for (let n = 0; n < e.length; n++)
            if (t(e[n]))
                return n
    }
    var d;
    const h = {
        code: "en-US",
        formatDistance: (e, t, n) => {
            let i;
            const o = r[e];
            return i = "string" === typeof o ? o : 1 === t ? o.one : o.other.replace("{{count}}", t.toString()),
            null !== n && void 0 !== n && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + i : i + " ago" : i
        }
        ,
        formatLong: o,
        formatRelative: (e, t, n, r) => s[e],
        localize: {
            ordinalNumber: (e, t) => {
                const n = Number(e)
                  , r = n % 100;
                if (r > 20 || r < 10)
                    switch (r % 10) {
                    case 1:
                        return n + "st";
                    case 2:
                        return n + "nd";
                    case 3:
                        return n + "rd"
                    }
                return n + "th"
            }
            ,
            era: a({
                values: {
                    narrow: ["B", "A"],
                    abbreviated: ["BC", "AD"],
                    wide: ["Before Christ", "Anno Domini"]
                },
                defaultWidth: "wide"
            }),
            quarter: a({
                values: {
                    narrow: ["1", "2", "3", "4"],
                    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
                    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
                },
                defaultWidth: "wide",
                argumentCallback: e => e - 1
            }),
            month: a({
                values: {
                    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
                    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
                },
                defaultWidth: "wide"
            }),
            day: a({
                values: {
                    narrow: ["S", "M", "T", "W", "T", "F", "S"],
                    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
                },
                defaultWidth: "wide"
            }),
            dayPeriod: a({
                values: {
                    narrow: {
                        am: "a",
                        pm: "p",
                        midnight: "mi",
                        noon: "n",
                        morning: "morning",
                        afternoon: "afternoon",
                        evening: "evening",
                        night: "night"
                    },
                    abbreviated: {
                        am: "AM",
                        pm: "PM",
                        midnight: "midnight",
                        noon: "noon",
                        morning: "morning",
                        afternoon: "afternoon",
                        evening: "evening",
                        night: "night"
                    },
                    wide: {
                        am: "a.m.",
                        pm: "p.m.",
                        midnight: "midnight",
                        noon: "noon",
                        morning: "morning",
                        afternoon: "afternoon",
                        evening: "evening",
                        night: "night"
                    }
                },
                defaultWidth: "wide",
                formattingValues: {
                    narrow: {
                        am: "a",
                        pm: "p",
                        midnight: "mi",
                        noon: "n",
                        morning: "in the morning",
                        afternoon: "in the afternoon",
                        evening: "in the evening",
                        night: "at night"
                    },
                    abbreviated: {
                        am: "AM",
                        pm: "PM",
                        midnight: "midnight",
                        noon: "noon",
                        morning: "in the morning",
                        afternoon: "in the afternoon",
                        evening: "in the evening",
                        night: "at night"
                    },
                    wide: {
                        am: "a.m.",
                        pm: "p.m.",
                        midnight: "midnight",
                        noon: "noon",
                        morning: "in the morning",
                        afternoon: "in the afternoon",
                        evening: "in the evening",
                        night: "at night"
                    }
                },
                defaultFormattingWidth: "wide"
            })
        },
        match: {
            ordinalNumber: (d = {
                matchPattern: /^(\d+)(th|st|nd|rd)?/i,
                parsePattern: /\d+/i,
                valueCallback: e => parseInt(e, 10)
            },
            function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const n = e.match(d.matchPattern);
                if (!n)
                    return null;
                const r = n[0]
                  , i = e.match(d.parsePattern);
                if (!i)
                    return null;
                let o = d.valueCallback ? d.valueCallback(i[0]) : i[0];
                o = t.valueCallback ? t.valueCallback(o) : o;
                const s = e.slice(r.length);
                return {
                    value: o,
                    rest: s
                }
            }
            ),
            era: c({
                matchPatterns: {
                    narrow: /^(b|a)/i,
                    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
                    wide: /^(before christ|before common era|anno domini|common era)/i
                },
                defaultMatchWidth: "wide",
                parsePatterns: {
                    any: [/^b/i, /^(a|c)/i]
                },
                defaultParseWidth: "any"
            }),
            quarter: c({
                matchPatterns: {
                    narrow: /^[1234]/i,
                    abbreviated: /^q[1234]/i,
                    wide: /^[1234](th|st|nd|rd)? quarter/i
                },
                defaultMatchWidth: "wide",
                parsePatterns: {
                    any: [/1/i, /2/i, /3/i, /4/i]
                },
                defaultParseWidth: "any",
                valueCallback: e => e + 1
            }),
            month: c({
                matchPatterns: {
                    narrow: /^[jfmasond]/i,
                    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
                    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
                },
                defaultMatchWidth: "wide",
                parsePatterns: {
                    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
                    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
                },
                defaultParseWidth: "any"
            }),
            day: c({
                matchPatterns: {
                    narrow: /^[smtwf]/i,
                    short: /^(su|mo|tu|we|th|fr|sa)/i,
                    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
                    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
                },
                defaultMatchWidth: "wide",
                parsePatterns: {
                    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
                    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
                },
                defaultParseWidth: "any"
            }),
            dayPeriod: c({
                matchPatterns: {
                    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
                    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
                },
                defaultMatchWidth: "any",
                parsePatterns: {
                    any: {
                        am: /^a/i,
                        pm: /^p/i,
                        midnight: /^mi/i,
                        noon: /^no/i,
                        morning: /morning/i,
                        afternoon: /afternoon/i,
                        evening: /evening/i,
                        night: /night/i
                    }
                },
                defaultParseWidth: "any"
            })
        },
        options: {
            weekStartsOn: 0,
            firstWeekContainsDate: 1
        }
    };
    var f = n(91)
      , p = n(20);
    function g(e) {
        const t = Object(p.a)(e)
          , n = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
        return n.setUTCFullYear(t.getFullYear()),
        +e - +n
    }
    var m = n(42);
    var y = n(71)
      , v = n(287);
    function b(e, t, n) {
        const [r,i] = function(e) {
            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                n[r - 1] = arguments[r];
            const i = m.a.bind(null, e || n.find(e => "object" === typeof e));
            return n.map(i)
        }(null === n || void 0 === n ? void 0 : n.in, e, t)
          , o = Object(v.a)(r)
          , s = Object(v.a)(i)
          , a = +o - g(o)
          , c = +s - g(s);
        return Math.round((a - c) / y.b)
    }
    var _ = n(381);
    function S(e, t) {
        const n = Object(p.a)(e, null === t || void 0 === t ? void 0 : t.in);
        return b(n, Object(_.a)(n)) + 1
    }
    var O = n(102);
    function T(e, t) {
        return Object(O.a)(e, {
            ...t,
            weekStartsOn: 1
        })
    }
    function I(e, t) {
        const n = Object(p.a)(e, null === t || void 0 === t ? void 0 : t.in)
          , r = n.getFullYear()
          , i = Object(m.a)(n, 0);
        i.setFullYear(r + 1, 0, 4),
        i.setHours(0, 0, 0, 0);
        const o = T(i)
          , s = Object(m.a)(n, 0);
        s.setFullYear(r, 0, 4),
        s.setHours(0, 0, 0, 0);
        const a = T(s);
        return n.getTime() >= o.getTime() ? r + 1 : n.getTime() >= a.getTime() ? r : r - 1
    }
    function x(e, t) {
        const n = I(e, t)
          , r = Object(m.a)((null === t || void 0 === t ? void 0 : t.in) || e, 0);
        return r.setFullYear(n, 0, 4),
        r.setHours(0, 0, 0, 0),
        T(r)
    }
    function w(e, t) {
        const n = Object(p.a)(e, null === t || void 0 === t ? void 0 : t.in)
          , r = +T(n) - +x(n);
        return Math.round(r / y.e) + 1
    }
    function M(e, t) {
        var n, r, i, o, s, a, c, u;
        const l = Object(p.a)(e, null === t || void 0 === t ? void 0 : t.in)
          , d = l.getFullYear()
          , h = Object(f.a)()
          , g = null !== (n = null !== (r = null !== (i = null !== (o = null === t || void 0 === t ? void 0 : t.firstWeekContainsDate) && void 0 !== o ? o : null === t || void 0 === t || null === (s = t.locale) || void 0 === s || null === (a = s.options) || void 0 === a ? void 0 : a.firstWeekContainsDate) && void 0 !== i ? i : h.firstWeekContainsDate) && void 0 !== r ? r : null === (c = h.locale) || void 0 === c || null === (u = c.options) || void 0 === u ? void 0 : u.firstWeekContainsDate) && void 0 !== n ? n : 1
          , y = Object(m.a)((null === t || void 0 === t ? void 0 : t.in) || e, 0);
        y.setFullYear(d + 1, 0, g),
        y.setHours(0, 0, 0, 0);
        const v = Object(O.a)(y, t)
          , b = Object(m.a)((null === t || void 0 === t ? void 0 : t.in) || e, 0);
        b.setFullYear(d, 0, g),
        b.setHours(0, 0, 0, 0);
        const _ = Object(O.a)(b, t);
        return +l >= +v ? d + 1 : +l >= +_ ? d : d - 1
    }
    function A(e, t) {
        var n, r, i, o, s, a, c, u;
        const l = Object(f.a)()
          , d = null !== (n = null !== (r = null !== (i = null !== (o = null === t || void 0 === t ? void 0 : t.firstWeekContainsDate) && void 0 !== o ? o : null === t || void 0 === t || null === (s = t.locale) || void 0 === s || null === (a = s.options) || void 0 === a ? void 0 : a.firstWeekContainsDate) && void 0 !== i ? i : l.firstWeekContainsDate) && void 0 !== r ? r : null === (c = l.locale) || void 0 === c || null === (u = c.options) || void 0 === u ? void 0 : u.firstWeekContainsDate) && void 0 !== n ? n : 1
          , h = M(e, t)
          , p = Object(m.a)((null === t || void 0 === t ? void 0 : t.in) || e, 0);
        p.setFullYear(h, 0, d),
        p.setHours(0, 0, 0, 0);
        return Object(O.a)(p, t)
    }
    function E(e, t) {
        const n = Object(p.a)(e, null === t || void 0 === t ? void 0 : t.in)
          , r = +Object(O.a)(n, t) - +A(n, t);
        return Math.round(r / y.e) + 1
    }
    function C(e, t) {
        return (e < 0 ? "-" : "") + Math.abs(e).toString().padStart(t, "0")
    }
    const N = {
        y(e, t) {
            const n = e.getFullYear()
              , r = n > 0 ? n : 1 - n;
            return C("yy" === t ? r % 100 : r, t.length)
        },
        M(e, t) {
            const n = e.getMonth();
            return "M" === t ? String(n + 1) : C(n + 1, 2)
        },
        d: (e, t) => C(e.getDate(), t.length),
        a(e, t) {
            const n = e.getHours() / 12 >= 1 ? "pm" : "am";
            switch (t) {
            case "a":
            case "aa":
                return n.toUpperCase();
            case "aaa":
                return n;
            case "aaaaa":
                return n[0];
            case "aaaa":
            default:
                return "am" === n ? "a.m." : "p.m."
            }
        },
        h: (e, t) => C(e.getHours() % 12 || 12, t.length),
        H: (e, t) => C(e.getHours(), t.length),
        m: (e, t) => C(e.getMinutes(), t.length),
        s: (e, t) => C(e.getSeconds(), t.length),
        S(e, t) {
            const n = t.length
              , r = e.getMilliseconds();
            return C(Math.trunc(r * Math.pow(10, n - 3)), t.length)
        }
    }
      , R = "midnight"
      , P = "noon"
      , D = "morning"
      , F = "afternoon"
      , k = "evening"
      , j = "night"
      , L = {
        G: function(e, t, n) {
            const r = e.getFullYear() > 0 ? 1 : 0;
            switch (t) {
            case "G":
            case "GG":
            case "GGG":
                return n.era(r, {
                    width: "abbreviated"
                });
            case "GGGGG":
                return n.era(r, {
                    width: "narrow"
                });
            case "GGGG":
            default:
                return n.era(r, {
                    width: "wide"
                })
            }
        },
        y: function(e, t, n) {
            if ("yo" === t) {
                const t = e.getFullYear()
                  , r = t > 0 ? t : 1 - t;
                return n.ordinalNumber(r, {
                    unit: "year"
                })
            }
            return N.y(e, t)
        },
        Y: function(e, t, n, r) {
            const i = M(e, r)
              , o = i > 0 ? i : 1 - i;
            if ("YY" === t) {
                return C(o % 100, 2)
            }
            return "Yo" === t ? n.ordinalNumber(o, {
                unit: "year"
            }) : C(o, t.length)
        },
        R: function(e, t) {
            return C(I(e), t.length)
        },
        u: function(e, t) {
            return C(e.getFullYear(), t.length)
        },
        Q: function(e, t, n) {
            const r = Math.ceil((e.getMonth() + 1) / 3);
            switch (t) {
            case "Q":
                return String(r);
            case "QQ":
                return C(r, 2);
            case "Qo":
                return n.ordinalNumber(r, {
                    unit: "quarter"
                });
            case "QQQ":
                return n.quarter(r, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "QQQQQ":
                return n.quarter(r, {
                    width: "narrow",
                    context: "formatting"
                });
            case "QQQQ":
            default:
                return n.quarter(r, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        q: function(e, t, n) {
            const r = Math.ceil((e.getMonth() + 1) / 3);
            switch (t) {
            case "q":
                return String(r);
            case "qq":
                return C(r, 2);
            case "qo":
                return n.ordinalNumber(r, {
                    unit: "quarter"
                });
            case "qqq":
                return n.quarter(r, {
                    width: "abbreviated",
                    context: "standalone"
                });
            case "qqqqq":
                return n.quarter(r, {
                    width: "narrow",
                    context: "standalone"
                });
            case "qqqq":
            default:
                return n.quarter(r, {
                    width: "wide",
                    context: "standalone"
                })
            }
        },
        M: function(e, t, n) {
            const r = e.getMonth();
            switch (t) {
            case "M":
            case "MM":
                return N.M(e, t);
            case "Mo":
                return n.ordinalNumber(r + 1, {
                    unit: "month"
                });
            case "MMM":
                return n.month(r, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "MMMMM":
                return n.month(r, {
                    width: "narrow",
                    context: "formatting"
                });
            case "MMMM":
            default:
                return n.month(r, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        L: function(e, t, n) {
            const r = e.getMonth();
            switch (t) {
            case "L":
                return String(r + 1);
            case "LL":
                return C(r + 1, 2);
            case "Lo":
                return n.ordinalNumber(r + 1, {
                    unit: "month"
                });
            case "LLL":
                return n.month(r, {
                    width: "abbreviated",
                    context: "standalone"
                });
            case "LLLLL":
                return n.month(r, {
                    width: "narrow",
                    context: "standalone"
                });
            case "LLLL":
            default:
                return n.month(r, {
                    width: "wide",
                    context: "standalone"
                })
            }
        },
        w: function(e, t, n, r) {
            const i = E(e, r);
            return "wo" === t ? n.ordinalNumber(i, {
                unit: "week"
            }) : C(i, t.length)
        },
        I: function(e, t, n) {
            const r = w(e);
            return "Io" === t ? n.ordinalNumber(r, {
                unit: "week"
            }) : C(r, t.length)
        },
        d: function(e, t, n) {
            return "do" === t ? n.ordinalNumber(e.getDate(), {
                unit: "date"
            }) : N.d(e, t)
        },
        D: function(e, t, n) {
            const r = S(e);
            return "Do" === t ? n.ordinalNumber(r, {
                unit: "dayOfYear"
            }) : C(r, t.length)
        },
        E: function(e, t, n) {
            const r = e.getDay();
            switch (t) {
            case "E":
            case "EE":
            case "EEE":
                return n.day(r, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "EEEEE":
                return n.day(r, {
                    width: "narrow",
                    context: "formatting"
                });
            case "EEEEEE":
                return n.day(r, {
                    width: "short",
                    context: "formatting"
                });
            case "EEEE":
            default:
                return n.day(r, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        e: function(e, t, n, r) {
            const i = e.getDay()
              , o = (i - r.weekStartsOn + 8) % 7 || 7;
            switch (t) {
            case "e":
                return String(o);
            case "ee":
                return C(o, 2);
            case "eo":
                return n.ordinalNumber(o, {
                    unit: "day"
                });
            case "eee":
                return n.day(i, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "eeeee":
                return n.day(i, {
                    width: "narrow",
                    context: "formatting"
                });
            case "eeeeee":
                return n.day(i, {
                    width: "short",
                    context: "formatting"
                });
            case "eeee":
            default:
                return n.day(i, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        c: function(e, t, n, r) {
            const i = e.getDay()
              , o = (i - r.weekStartsOn + 8) % 7 || 7;
            switch (t) {
            case "c":
                return String(o);
            case "cc":
                return C(o, t.length);
            case "co":
                return n.ordinalNumber(o, {
                    unit: "day"
                });
            case "ccc":
                return n.day(i, {
                    width: "abbreviated",
                    context: "standalone"
                });
            case "ccccc":
                return n.day(i, {
                    width: "narrow",
                    context: "standalone"
                });
            case "cccccc":
                return n.day(i, {
                    width: "short",
                    context: "standalone"
                });
            case "cccc":
            default:
                return n.day(i, {
                    width: "wide",
                    context: "standalone"
                })
            }
        },
        i: function(e, t, n) {
            const r = e.getDay()
              , i = 0 === r ? 7 : r;
            switch (t) {
            case "i":
                return String(i);
            case "ii":
                return C(i, t.length);
            case "io":
                return n.ordinalNumber(i, {
                    unit: "day"
                });
            case "iii":
                return n.day(r, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "iiiii":
                return n.day(r, {
                    width: "narrow",
                    context: "formatting"
                });
            case "iiiiii":
                return n.day(r, {
                    width: "short",
                    context: "formatting"
                });
            case "iiii":
            default:
                return n.day(r, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        a: function(e, t, n) {
            const r = e.getHours() / 12 >= 1 ? "pm" : "am";
            switch (t) {
            case "a":
            case "aa":
                return n.dayPeriod(r, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "aaa":
                return n.dayPeriod(r, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "aaaaa":
                return n.dayPeriod(r, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaa":
            default:
                return n.dayPeriod(r, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        b: function(e, t, n) {
            const r = e.getHours();
            let i;
            switch (i = 12 === r ? P : 0 === r ? R : r / 12 >= 1 ? "pm" : "am",
            t) {
            case "b":
            case "bb":
                return n.dayPeriod(i, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "bbb":
                return n.dayPeriod(i, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "bbbbb":
                return n.dayPeriod(i, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbb":
            default:
                return n.dayPeriod(i, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        B: function(e, t, n) {
            const r = e.getHours();
            let i;
            switch (i = r >= 17 ? k : r >= 12 ? F : r >= 4 ? D : j,
            t) {
            case "B":
            case "BB":
            case "BBB":
                return n.dayPeriod(i, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "BBBBB":
                return n.dayPeriod(i, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBB":
            default:
                return n.dayPeriod(i, {
                    width: "wide",
                    context: "formatting"
                })
            }
        },
        h: function(e, t, n) {
            if ("ho" === t) {
                let t = e.getHours() % 12;
                return 0 === t && (t = 12),
                n.ordinalNumber(t, {
                    unit: "hour"
                })
            }
            return N.h(e, t)
        },
        H: function(e, t, n) {
            return "Ho" === t ? n.ordinalNumber(e.getHours(), {
                unit: "hour"
            }) : N.H(e, t)
        },
        K: function(e, t, n) {
            const r = e.getHours() % 12;
            return "Ko" === t ? n.ordinalNumber(r, {
                unit: "hour"
            }) : C(r, t.length)
        },
        k: function(e, t, n) {
            let r = e.getHours();
            return 0 === r && (r = 24),
            "ko" === t ? n.ordinalNumber(r, {
                unit: "hour"
            }) : C(r, t.length)
        },
        m: function(e, t, n) {
            return "mo" === t ? n.ordinalNumber(e.getMinutes(), {
                unit: "minute"
            }) : N.m(e, t)
        },
        s: function(e, t, n) {
            return "so" === t ? n.ordinalNumber(e.getSeconds(), {
                unit: "second"
            }) : N.s(e, t)
        },
        S: function(e, t) {
            return N.S(e, t)
        },
        X: function(e, t, n) {
            const r = e.getTimezoneOffset();
            if (0 === r)
                return "Z";
            switch (t) {
            case "X":
                return U(r);
            case "XXXX":
            case "XX":
                return q(r);
            case "XXXXX":
            case "XXX":
            default:
                return q(r, ":")
            }
        },
        x: function(e, t, n) {
            const r = e.getTimezoneOffset();
            switch (t) {
            case "x":
                return U(r);
            case "xxxx":
            case "xx":
                return q(r);
            case "xxxxx":
            case "xxx":
            default:
                return q(r, ":")
            }
        },
        O: function(e, t, n) {
            const r = e.getTimezoneOffset();
            switch (t) {
            case "O":
            case "OO":
            case "OOO":
                return "GMT" + V(r, ":");
            case "OOOO":
            default:
                return "GMT" + q(r, ":")
            }
        },
        z: function(e, t, n) {
            const r = e.getTimezoneOffset();
            switch (t) {
            case "z":
            case "zz":
            case "zzz":
                return "GMT" + V(r, ":");
            case "zzzz":
            default:
                return "GMT" + q(r, ":")
            }
        },
        t: function(e, t, n) {
            return C(Math.trunc(+e / 1e3), t.length)
        },
        T: function(e, t, n) {
            return C(+e, t.length)
        }
    };
    function V(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        const n = e > 0 ? "-" : "+"
          , r = Math.abs(e)
          , i = Math.trunc(r / 60)
          , o = r % 60;
        return 0 === o ? n + String(i) : n + String(i) + t + C(o, 2)
    }
    function U(e, t) {
        if (e % 60 === 0) {
            return (e > 0 ? "-" : "+") + C(Math.abs(e) / 60, 2)
        }
        return q(e, t)
    }
    function q(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        const n = e > 0 ? "-" : "+"
          , r = Math.abs(e)
          , i = C(Math.trunc(r / 60), 2)
          , o = C(r % 60, 2);
        return n + i + t + o
    }
    const Q = (e, t) => {
        switch (e) {
        case "P":
            return t.date({
                width: "short"
            });
        case "PP":
            return t.date({
                width: "medium"
            });
        case "PPP":
            return t.date({
                width: "long"
            });
        case "PPPP":
        default:
            return t.date({
                width: "full"
            })
        }
    }
      , B = (e, t) => {
        switch (e) {
        case "p":
            return t.time({
                width: "short"
            });
        case "pp":
            return t.time({
                width: "medium"
            });
        case "ppp":
            return t.time({
                width: "long"
            });
        case "pppp":
        default:
            return t.time({
                width: "full"
            })
        }
    }
      , G = {
        p: B,
        P: (e, t) => {
            const n = e.match(/(P+)(p+)?/) || []
              , r = n[1]
              , i = n[2];
            if (!i)
                return Q(e, t);
            let o;
            switch (r) {
            case "P":
                o = t.dateTime({
                    width: "short"
                });
                break;
            case "PP":
                o = t.dateTime({
                    width: "medium"
                });
                break;
            case "PPP":
                o = t.dateTime({
                    width: "long"
                });
                break;
            case "PPPP":
            default:
                o = t.dateTime({
                    width: "full"
                })
            }
            return o.replace("{{date}}", Q(r, t)).replace("{{time}}", B(i, t))
        }
    }
      , z = /^D+$/
      , H = /^Y+$/
      , K = ["D", "DD", "YY", "YYYY"];
    function Y(e) {
        return e instanceof Date || "object" === typeof e && "[object Date]" === Object.prototype.toString.call(e)
    }
    function W(e) {
        return !(!Y(e) && "number" !== typeof e || isNaN(+Object(p.a)(e)))
    }
    const $ = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
      , X = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
      , J = /^'([^]*?)'?$/
      , Z = /''/g
      , ee = /[a-zA-Z]/;
    function te(e, t, n) {
        var r, i, o, s, a, c, u, l, d, g, m, y, v, b, _, S, O, T;
        const I = Object(f.a)()
          , x = null !== (r = null !== (i = null === n || void 0 === n ? void 0 : n.locale) && void 0 !== i ? i : I.locale) && void 0 !== r ? r : h
          , w = null !== (o = null !== (s = null !== (a = null !== (c = null === n || void 0 === n ? void 0 : n.firstWeekContainsDate) && void 0 !== c ? c : null === n || void 0 === n || null === (u = n.locale) || void 0 === u || null === (l = u.options) || void 0 === l ? void 0 : l.firstWeekContainsDate) && void 0 !== a ? a : I.firstWeekContainsDate) && void 0 !== s ? s : null === (d = I.locale) || void 0 === d || null === (g = d.options) || void 0 === g ? void 0 : g.firstWeekContainsDate) && void 0 !== o ? o : 1
          , M = null !== (m = null !== (y = null !== (v = null !== (b = null === n || void 0 === n ? void 0 : n.weekStartsOn) && void 0 !== b ? b : null === n || void 0 === n || null === (_ = n.locale) || void 0 === _ || null === (S = _.options) || void 0 === S ? void 0 : S.weekStartsOn) && void 0 !== v ? v : I.weekStartsOn) && void 0 !== y ? y : null === (O = I.locale) || void 0 === O || null === (T = O.options) || void 0 === T ? void 0 : T.weekStartsOn) && void 0 !== m ? m : 0
          , A = Object(p.a)(e, null === n || void 0 === n ? void 0 : n.in);
        if (!W(A))
            throw new RangeError("Invalid time value");
        let E = t.match(X).map(e => {
            const t = e[0];
            if ("p" === t || "P" === t) {
                return (0,
                G[t])(e, x.formatLong)
            }
            return e
        }
        ).join("").match($).map(e => {
            if ("''" === e)
                return {
                    isToken: !1,
                    value: "'"
                };
            const t = e[0];
            if ("'" === t)
                return {
                    isToken: !1,
                    value: ne(e)
                };
            if (L[t])
                return {
                    isToken: !0,
                    value: e
                };
            if (t.match(ee))
                throw new RangeError("Format string contains an unescaped latin alphabet character `" + t + "`");
            return {
                isToken: !1,
                value: e
            }
        }
        );
        x.localize.preprocessor && (E = x.localize.preprocessor(A, E));
        const C = {
            firstWeekContainsDate: w,
            weekStartsOn: M,
            locale: x
        };
        return E.map(r => {
            if (!r.isToken)
                return r.value;
            const i = r.value;
            (null !== n && void 0 !== n && n.useAdditionalWeekYearTokens || !function(e) {
                return H.test(e)
            }(i)) && (null !== n && void 0 !== n && n.useAdditionalDayOfYearTokens || !function(e) {
                return z.test(e)
            }(i)) || function(e, t, n) {
                const r = function(e, t, n) {
                    const r = "Y" === e[0] ? "years" : "days of the month";
                    return "Use `".concat(e.toLowerCase(), "` instead of `").concat(e, "` (in `").concat(t, "`) for formatting ").concat(r, " to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md")
                }(e, t, n);
                if (console.warn(r),
                K.includes(e))
                    throw new RangeError(r)
            }(i, t, String(e));
            return (0,
            L[i[0]])(A, i, x.localize, C)
        }
        ).join("")
    }
    function ne(e) {
        const t = e.match(J);
        return t ? t[1].replace(Z, "'") : e
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return g
    }
    ));
    var r = n(394)
      , i = n(31)
      , o = n(280)
      , s = n(859)
      , a = n(52)
      , c = n(74)
      , u = n(72);
    var l = n(274);
    function d() {
        return this.dataSourcesQuery().selectAll().whereNotIn("status", [l.b.PENDING_DELETE, l.b.PENDING_SETUP, l.b.INACTIVE, l.b.ERROR])
    }
    function h(e, t) {
        if (!this.isMissingDataSources)
            return Object(i.a)(this.dataSources);
        const {dataSources: n} = this
          , r = t ? this.getDataSourcesToSyncQuery() : this.dataSourcesQuery().selectAll(!0);
        return n && r.andWhereNotIn(r.primaryKey, Object.keys(n)),
        r.fetchAllRecords({
            dispatchId: e
        })
    }
    var f = n(77);
    let p = n(188).a;
    function g(e) {
        const t = e.plugin.getMainInstance()
          , {storesMap: n} = e
          , l = e.getRecordBuilder().registerExtension("module:logic.RecordPropsMixin").registerExtension("../RecordMixin").Class
          , g = l.prototype;
        Object(o.a)(e, g),
        function(e) {
            const {recordAccessors: t, storesMap: n} = e
              , r = {
                connections: {
                    get() {
                        return n.get(this).storeConfig.connections
                    }
                },
                clientConnections: {
                    get() {
                        return n.get(this).storeConfig.clientConnections
                    }
                }
            };
            let i;
            for (let o in r)
                i = r[o],
                i.enumerable = !1,
                i.configurable = !0,
                i.set = i.set,
                t[o] = i;
            t.types = n.get(e.plugin).storeConfig.pluginAccessors.types
        }(e),
        g.getDataSourcesToSyncQuery = d,
        g.fetchMissingDataSources = h;
        const m = (e, i) => {
            const o = n.get(e).storeConfig;
            return o[i] || (o[i] = Object(r.a)( () => {
                return (n = t.switchTo(f.b.ENTITY_JOB),
                r = e.__ID,
                n.query().selectAll(!0).where("entityId", r).andWhere(e => e.where(e => e.whereNull("completeAt").andWhere("processAt", ">", ":X_MINUTE_BEGIN")).orWhere("completeAt", ">", ":X_MINUTE_BEGIN")))[i.indexOf("Local") > -1 ? "localSubscribeToAllRecords" : "subscribeToAllRecords"]({
                    variables: {
                        X_MINUTE_BEGIN: -60
                    }
                });
                var n, r
            }
            ).pipe(Object(s.a)(1))),
            o[i]
        }
          , y = l.build;
        function v(e) {
            return n.get(t).getBestStore(n.get(this).mainDispatchId).get(e)
        }
        return l.build = function(e) {
            const r = y.call(this, e)
              , i = n.get(r);
            let o = i.storeConfig;
            return o || (o = {},
            i.storeConfig = p(o)),
            o.clientConnections || (o.clientConnections = {}),
            o.connections || (o.connections = {}),
            o.incompleteJobsSub$ = void 0,
            o.incompleteJobsLocalSub$ = void 0,
            "undefined" === typeof o.graphqlRoleSchemas && (o.graphqlRoleSchemas = {},
            o.graphqlRoleLimitedIntrospectionSchemas = {},
            o.graphqlLongnameToUrl = n.get(t).storeConfig.graphqlLongnameToUrl),
            r
        }
        ,
        g.getConnection = function(e, n) {
            return t.getConnection(e, n)
        }
        ,
        g.getPlugin = function() {
            return t
        }
        ,
        g.getOrInitSchema = function(e) {
            const t = n.get(this)
              , r = t.get("schema");
            return r ? Object(i.a)(r) : !0 !== e || t.value.mutation ? this.initSchema().pipe(Object(u.a)(n => (t.value.mutation ? t.instance.schema = n : e && e.switchTo(this.__typename).update(this, {
                schema: n
            }, !0),
            n))) : this.initSchema().pipe(Object(a.a)(e => this.setLocalState({
                schema: e
            }).pipe(Object(c.a)(e))))
        }
        ,
        g.getModelByName = v,
        g.switchTo = v,
        g.getModelNameFromGraphqlOperation = function(e) {
            let r = n.get(this).get("schema");
            return r && r.graphqlOpsToModelName[e] || t.schema.graphqlOpsToModelName[e]
        }
        ,
        g.pluginMutation = function(e, t) {
            return n.get(this).parentInstance.pluginMutation(e, t)
        }
        ,
        g.subscribeToRecentJobs = function() {
            return m(this, "recentJobsSub$")
        }
        ,
        g.localSubscribeToRecentJobs = function() {
            return m(this, "recentJobsLocalSub$")
        }
        ,
        g.getAppUserRelationshipFields = function() {
            const e = t.switchTo(f.b.USER)
              , {virtualFields: n} = e
              , {slug: r} = this;
            let i, o = null;
            for (let t in n)
                i = n[t],
                i.isRefModel && i.model.schema.entitySlug === r && i.field.props && i.field.props.userEmailFieldPath && (o || (o = []),
                o.push(i.field));
            return o
        }
        ,
        g.syncAppUsersToOwnData = function() {
            return Object(i.a)({
                statusCode: 200,
                data: null
            })
        }
        ,
        g
    }
    var m = n(876)
      , y = n(193);
    m.a.init().setPackageName("@isomorix/core-entity").setModuleName("@isomorix/core/entity/record/logic").addSource(y.b)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return d
    }
    ));
    var r = n(14)
      , i = n(121)
      , o = function(e) {
        function t(t, n) {
            var r = e.call(this, t, n) || this;
            return r.scheduler = t,
            r.work = n,
            r
        }
        return r.a(t, e),
        t.prototype.schedule = function(t, n) {
            return void 0 === n && (n = 0),
            n > 0 ? e.prototype.schedule.call(this, t, n) : (this.delay = n,
            this.state = t,
            this.scheduler.flush(this),
            this)
        }
        ,
        t.prototype.execute = function(t, n) {
            return n > 0 || this.closed ? e.prototype.execute.call(this, t, n) : this._execute(t, n)
        }
        ,
        t.prototype.requestAsyncId = function(t, n, r) {
            return void 0 === r && (r = 0),
            null !== r && r > 0 || null === r && this.delay > 0 ? e.prototype.requestAsyncId.call(this, t, n, r) : t.flush(this)
        }
        ,
        t
    }(n(156).a)
      , s = new (function(e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }
        return r.a(t, e),
        t
    }(n(155).a))(o)
      , a = n(38)
      , c = n(283)
      , u = n(122)
      , l = n(226)
      , d = function(e) {
        function t(t, n, r) {
            void 0 === t && (t = Number.POSITIVE_INFINITY),
            void 0 === n && (n = Number.POSITIVE_INFINITY);
            var i = e.call(this) || this;
            return i.scheduler = r,
            i._events = [],
            i._infiniteTimeWindow = !1,
            i._bufferSize = t < 1 ? 1 : t,
            i._windowTime = n < 1 ? 1 : n,
            n === Number.POSITIVE_INFINITY ? (i._infiniteTimeWindow = !0,
            i.next = i.nextInfiniteTimeWindow) : i.next = i.nextTimeWindow,
            i
        }
        return r.a(t, e),
        t.prototype.nextInfiniteTimeWindow = function(t) {
            if (!this.isStopped) {
                var n = this._events;
                n.push(t),
                n.length > this._bufferSize && n.shift()
            }
            e.prototype.next.call(this, t)
        }
        ,
        t.prototype.nextTimeWindow = function(t) {
            this.isStopped || (this._events.push(new h(this._getNow(),t)),
            this._trimBufferThenGetEvents()),
            e.prototype.next.call(this, t)
        }
        ,
        t.prototype._subscribe = function(e) {
            var t, n = this._infiniteTimeWindow, r = n ? this._events : this._trimBufferThenGetEvents(), i = this.scheduler, o = r.length;
            if (this.closed)
                throw new u.a;
            if (this.isStopped || this.hasError ? t = a.a.EMPTY : (this.observers.push(e),
            t = new l.a(this,e)),
            i && e.add(e = new c.a(e,i)),
            n)
                for (var s = 0; s < o && !e.closed; s++)
                    e.next(r[s]);
            else
                for (s = 0; s < o && !e.closed; s++)
                    e.next(r[s].value);
            return this.hasError ? e.error(this.thrownError) : this.isStopped && e.complete(),
            t
        }
        ,
        t.prototype._getNow = function() {
            return (this.scheduler || s).now()
        }
        ,
        t.prototype._trimBufferThenGetEvents = function() {
            for (var e = this._getNow(), t = this._bufferSize, n = this._windowTime, r = this._events, i = r.length, o = 0; o < i && !(e - r[o].time < n); )
                o++;
            return i > t && (o = Math.max(o, i - t)),
            o > 0 && r.splice(0, o),
            r
        }
        ,
        t
    }(i.a)
      , h = function() {
        return function(e, t) {
            this.time = e,
            this.value = t
        }
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return v
    }
    ));
    var r = n(1)
      , i = n(22);
    class o extends i.a {
        constructor(e, t, n) {
            super(),
            this.logic = t,
            this.opIdx = n,
            this.manager = e,
            this.waitingFor = void 0,
            this.neededBy = void 0
        }
        setDestination(e) {
            if (!(e instanceof i.a))
                throw new Error("The outer subscriber must be an rxjs Subscriber instance");
            this.syncErrorThrowable = e.syncErrorThrowable,
            this.destination = e,
            e.add(this)
        }
        _next() {}
        _error(e) {
            this.unsubscribe()
        }
        _complete() {
            this.unsubscribe()
        }
        unsubscribe() {
            if (this.closed)
                return;
            super.unsubscribe();
            const {manager: e} = this;
            this.manager = void 0,
            this.logic = void 0,
            e.closeoutDeps(this)
        }
    }
    var s = n(31)
      , a = n(78)
      , c = n(860)
      , u = n(163)
      , l = n(93)
      , d = n(158);
    class h extends i.a {
        constructor(e, t, n) {
            super(),
            this.manager = e,
            this.isStopped = !0,
            this.opIdx = n,
            this.logic = t,
            this.waitingFor = void 0,
            this.opsDeps = void 0,
            this._taken = !1,
            this._isStream = !1,
            this._streamType = void 0,
            this.cancelIfCompleteBeforeNext = !1,
            this._hasQueuedValue = !1,
            this._nextValue = void 0,
            this.innerValue = void 0,
            this._state = void 0,
            this.callOp = this._opReady,
            this.opsDeps = void 0,
            this._isForceAbandonOp = !1
        }
        forceAbandonOp() {
            if (!this.isStopped) {
                const e = new this.constructor(this.manager,this.logic,this.opIdx);
                return e._state = this._state,
                e.opsDeps = this.opsDeps,
                this._isForceAbandonOp = !0,
                this.unsubscribe(),
                e
            }
            return this.waitingFor && this.waitingFor.complete(),
            this
        }
        getOpDep(e, t) {
            if (this.closed)
                return;
            const n = this.manager
              , r = n.opsIdxMap[e];
            if (this.opIdx > r || this.opIdx === r && !this.waitingFor)
                return;
            let i, {opsDeps: o} = this;
            return o ? (({[e]: i} = o),
            i || t || (o[e] = i = new d.a(n,e,this))) : t || (this.opsDeps = o = n.checkoutOpsDeps(),
            this.callOp = this._ensureOpReady,
            o[e] = i = new d.a(n,e,this)),
            i
        }
        _ensureOpReady(e, t) {
            const {[t]: n} = this.opsDeps;
            return this.innerValue = e,
            n ? n.ensureOpReady(e) : this._opReady(e, t)
        }
        _opReady(e, t) {
            if (this.closed)
                return;
            const {logic: n} = this;
            let i = e;
            if (n[t]) {
                const {[r.A]: s, [r.c]: a} = n;
                if (!n[r.x]) {
                    this.isStopped = !1,
                    this.innerValue = e,
                    this.waitingFor = void 0;
                    try {
                        i = a ? n[t].call(s || n, e, this, ...a) : n[t].call(s || n, e, this),
                        "undefined" !== typeof i && this.next(i)
                    } catch (o) {
                        if (this.closed)
                            throw o;
                        this.error(p(this, o))
                    }
                    return
                }
                try {
                    i = a ? n[t].call(s || n, e, ...a) : n[t].call(s || n, e),
                    "undefined" === typeof i && (i = e)
                } catch (o) {
                    if (this.closed)
                        throw o;
                    return this.waitingFor = void 0,
                    void this.manager.error(p(this, o))
                }
            }
            if (this._callOpDep()) {
                if (!this.waitingFor)
                    return i;
                this.waitingFor = void 0,
                this.manager.next(i)
            }
        }
        pipe() {
            return Object(s.a)(this.innerValue).pipe(...arguments)
        }
        cancel() {
            this.isStopped || (this._unsubscribeAndRecycle(),
            this.manager.cancel(void 0, this.logic))
        }
        next(e) {
            if (!(this.isStopped || this._taken && !this._isStream)) {
                if (!this._taken) {
                    this._taken = !0;
                    const t = Object(c.a)(e);
                    if (this._streamType = t,
                    "observable" === t)
                        return this._isStream = !0,
                        void (Object(u.b)(e) ? e.operator ? this._isStream = e.subscribe(this) : this._isStream = e.subscribe(new g(this)) : this._isStream = e.subscribe(new m(this)));
                    if ("promise" === t)
                        return this._isStream = !0,
                        void (this._isStream = Object(a.a)(e).subscribe(new g(this)))
                }
                this._hasQueuedValue ? e = this._nextValue : "undefined" === typeof e ? e = this.innerValue : this.innerValue = e,
                this._next(e)
            }
        }
        error(e) {
            this.isStopped ? f(this, e) : (this._unsubscribeAndRecycle(),
            this.manager.error(p(this, e)))
        }
        complete() {
            this.isStopped || (this.cancelIfCompleteBeforeNext ? this.cancel() : this._next(this.innerValue))
        }
        _callOpDep() {
            if (this.opsDeps) {
                const {[this.op]: e} = this.opsDeps;
                if (e && (e.complete(),
                this.closed))
                    return !1
            }
            return !0
        }
        _next(e) {
            this._callOpDep() && (this._unsubscribeAndRecycle(),
            this.manager.next(e))
        }
        _error(e) {
            this.destination.isStopped ? this.unsubscribe() : (this._unsubscribeAndRecycle(),
            this.manager.error(p(this, e)))
        }
        unsubscribe() {
            if (this.closed)
                console.warn("GOT UNSUBSCRIBE, but CLOSED");
            else if (super.unsubscribe(),
            !this._isRecycle) {
                const {manager: e} = this;
                this.manager = void 0,
                this.logic = void 0,
                this.innerValue = void 0,
                this._nextValue = void 0,
                this._state = void 0,
                this._isForceAbandonOp ? (this.waitingFor && (this.waitingFor.complete(),
                this.waitingFor = void 0),
                this.opsDeps = void 0,
                this.callOp = void 0) : this.opsDeps && (e.checkinOpsDeps(this.opsDeps),
                this.opsDeps = void 0,
                this.waitingFor = void 0,
                this.callOp = void 0)
            }
        }
        _unsubscribeAndRecycle() {
            this.closed || (this._isRecycle = !0,
            super._unsubscribeAndRecycle(),
            this._isRecycle = !1,
            this._isStream = !1,
            this._taken = !1,
            this.isStopped = !0,
            this.cancelIfCompleteBeforeNext = !1,
            this._hasQueuedValue = !1,
            this._nextValue = void 0)
        }
        setNextValue(e, t) {
            if (this.isStopped)
                return !1;
            this._hasQueuedValue = !0,
            this._nextValue = e,
            t && (this.cancelIfCompleteBeforeNext = !0)
        }
        getState(e) {
            if (!this.closed)
                return e ? this.manager.parent.getLogicState(this.logic[r.m]) : this._state
        }
        setState(e, t) {
            if (!this.closed)
                return t ? this.manager.parent.setLogicState(this.logic[r.m], e) : this._state = e,
                e
        }
        get op() {
            return this.closed ? void 0 : this.manager.op
        }
        get prevOp() {
            return this.closed ? void 0 : this.manager.prevOp
        }
        get isPendingOp() {
            return this.closed ? void 0 : this.manager.isPendingOp
        }
        get streamId() {
            return this.closed ? void 0 : this.manager.streamId
        }
        get streamName() {
            return this.closed ? void 0 : this.manager.streamName
        }
        getLogicIdx(e) {
            return this.closed ? void 0 : this.manager.getLogicIdx("undefined" === typeof e ? this.logic[r.m] : e)
        }
        determineLogicId(e) {
            return this.closed ? void 0 : this.manager.determineLogicId(e)
        }
        getOps() {
            return this.closed ? void 0 : this.manager.getOps()
        }
        getOpIndex(e) {
            return this.closed ? void 0 : this.manager.getOpIndex(e)
        }
        getNextOp(e) {
            return this.closed ? void 0 : this.manager.getNextOp(e)
        }
        getCompleteOp() {
            return this.closed ? void 0 : this.manager.completeOp
        }
        getCancelOp() {
            return this.closed ? void 0 : this.manager.cancelOp
        }
        getErrorOp() {
            return this.closed ? void 0 : this.manager.errorOp
        }
        isNextOp(e) {
            return this.closed ? void 0 : this.manager.isNextOp(e)
        }
        isCompleteOp(e) {
            return this.closed ? void 0 : this.manager.isCompleteOp(e)
        }
        isCancelOp(e) {
            return this.closed ? void 0 : this.manager.isCancelOp(e)
        }
        isErrorOp(e) {
            return this.closed ? void 0 : this.manager.isErrorOp(e)
        }
        isCancelOrErrorOp(e) {
            return this.closed ? void 0 : this.manager.isCancelOrErrorOp(e)
        }
        isCompleteOrCancelOp(e) {
            return this.closed ? void 0 : this.manager.isCompleteOrCancelOp(e)
        }
        hasLogic(e, t) {
            return this.closed ? void 0 : this.manager.hasLogic(e, t)
        }
        addDependency(e, t, n, r) {
            return !this.closed && this.manager.addDependency(e, t, n, r)
        }
        getGlobalLogic(e) {
            return this.closed ? void 0 : this.manager.getGlobalLogic(e)
        }
        getLogic(e) {
            return this.closed ? void 0 : this.manager.getLogic(e)
        }
        getNextLogic(e, t) {
            return this.closed ? void 0 : this.manager.getNextLogic(e, t)
        }
        addLogic(e, t, n) {
            return !this.closed && this.manager.addLogic(e, t, n)
        }
        removeLogic(e, t, n) {
            return !this.closed && this.manager.removeLogic(e, t, n)
        }
        replaceLogic(e, t, n, r) {
            return !this.closed && this.manager.replaceLogic(e, t, n, r)
        }
        addOrReplaceLogic(e, t, n) {
            return !this.closed && this.manager.addOrReplaceLogic(e, t, n)
        }
    }
    let f;
    function p(e, t) {
        if (t instanceof l.a)
            return t;
        let n;
        return n = "string" === typeof t ? t : "ObjectUnsubscribedError" === t.name ? "ObjectUnsubscribedError caught by LogicObserver. This means that next, error, or complete was called on a Subject that was already unsubscribed" : e._isStream ? "observable" === e._streamType ? "observable error" : "promise exception" : "logic error",
        new l.a(n,e.manager,e.logic,t)
    }
    f = () => {}
    ;
    class g extends i.a {
        constructor(e) {
            super(),
            this.observer = e
        }
        _next(e) {
            this.unsubscribe(),
            this.observer.next(e),
            this.observer = void 0
        }
        _error(e) {
            this.unsubscribe(),
            this.observer.error(e),
            this.observer = void 0
        }
        _complete() {
            this.unsubscribe(),
            this.observer.complete(),
            this.observer = void 0
        }
    }
    class m {
        constructor(e) {
            this.observer = e,
            this.closed = !1
        }
        next(e) {
            this.closed || (this.closed = !0,
            this.observer.next(e),
            this.observer = void 0)
        }
        error(e) {
            this.closed || (this.closed = !0,
            this.observer.error(e),
            this.observer = void 0)
        }
        complete() {
            this.closed || (this.closed = !0,
            this.observer.complete(),
            this.observer = void 0)
        }
    }
    var y = n(33);
    function v(e, t) {
        let n = 0
          , i = 0
          , s = !1;
        e || (e = function() {
            return ++n
        }
        ,
        s = !0);
        const a = y.a.checkoutMap()
          , c = y.a.checkoutMap()
          , u = y.a.checkoutMap();
        t && (t.objectPool = y.a,
        t.networks = a,
        t.subnets = c,
        t.dispatches = u);
        class l {
            constructor(e, t) {
                this.id = e || ++i,
                this.parent = t,
                a.set(this.id, this)
            }
            getNetwork(e, t) {
                if (a.has(e))
                    return a.get(e);
                if (!t) {
                    const t = new this.constructor(e,this);
                    return a.set(e, t),
                    t
                }
            }
            registerChildManager(e, t, n) {
                const {parent: r, dispatchId: i} = e;
                let o = u.get(i);
                o || (o = y.a.checkoutSet(),
                u.set(i, o)),
                o.add(r),
                (r.waitingFor || r.neededBy) && this.cloneDeps(r, e, e, !1),
                !n && e.isInner && e.begin(t)
            }
            childManagerComplete(e, t) {
                const {dispatchId: n} = e
                  , r = u.get(n);
                r.delete(t),
                0 === r.size && (u.delete(n),
                y.a.checkinSet(r))
            }
            getDispatchId(t, n) {
                return e(t, n)
            }
            createLogicObserver(e, t, n, i, s) {
                if (i && "number" !== typeof i) {
                    const s = e.isInner ? new h(e,t,n) : new o(e,t,n);
                    return e.logicObservers.set(t[r.m], s),
                    this.cloneDeps(i, s, e, !1),
                    s
                }
                return s ? e.isInner ? new h(e,t,n) : new o(e,t,n) : !e.isInner || t[r.x] ? n : new h(e,t,n)
            }
            cloneLogicObserver(e, t, n, i) {
                if (i && "number" !== typeof i) {
                    const s = e.isInner ? new h(e,t,n) : new o(e,t,n);
                    return e.logicObservers.set(t[r.m], s),
                    this.cloneDeps(i, s, e, !0),
                    s
                }
                return e.isInner ? t[r.x] ? n : new h(e,t,n) : n
            }
            cloneDeps(e, t, n, r) {
                const {waitingFor: i, neededBy: o} = e;
                if (!i && !o)
                    return;
                let s, a, c, l, d, h, f, p;
                if (!r) {
                    if (({dispatchId: s} = n),
                    a = u.get(s),
                    !a)
                        return;
                    c = i ? i.size : 0,
                    c += o ? o.size : 0
                }
                if (r || c < a) {
                    if (i)
                        for ([d,f] of i) {
                            if (r)
                                h = d;
                            else {
                                if (!a.has(d))
                                    continue;
                                h = d.getChild(s)
                            }
                            for (l of f)
                                n._addDependency(h, l)
                        }
                    if (o)
                        for ([d,p] of o) {
                            if (r)
                                h = d;
                            else {
                                if (!a.has(d))
                                    continue;
                                h = d.getChild(s)
                            }
                            for (l of p)
                                h._addDependency(n, l)
                        }
                } else
                    for (d of a) {
                        if (h = d.getChild(s),
                        i && (f = i.get(d)))
                            for (l of f)
                                n._addDependency(h, l);
                        if (o && (p = o.get(d)))
                            for (l of p)
                                h._addDependency(n, l)
                    }
            }
        }
        return s ? l : new l
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return c
    }
    ));
    var r = n(368)
      , i = n(131)
      , o = n(37)
      , s = n(876)
      , a = n(193);
    const c = s.a.initModule("@isomorix/core/location/record/logic").setPackageName("@isomorix/core-location").add(a.b.findByName("trxOptimisticExecute")).addSource(a.b);
    var u = n(58)
      , l = n(240);
    const {PUSH: d, POP: h} = r.a;
    c.findExistingBuilder(u.n).useRelative("trxPrepare", 100).setLogicMgr(c).setName("manageStateChanges").setPure(!0).setDescription(void 0).add((function(e) {
        const {meta: t, payload: n} = e
          , r = t.instance
          , s = r.__ID
          , a = n.mutation.recordDataType[s];
        if (!s)
            return t.instance.syncWithWindowHistory(!1),
            e;
        const c = t.store.value
          , u = c.get("changeType")
          , f = c.pChanges;
        if (u === h && a !== i.a || !f)
            return e;
        let p;
        for (let i of l.e)
            if (f[i]) {
                p = !0;
                break
            }
        if (!p)
            return e;
        const g = c.store.storeConfig
          , m = g.windowHistory
          , y = g.historyArray;
        let v = c.get("historyIdx");
        if (a === i.c) {
            if (f.key || (r.key = r.createKey()),
            u === d) {
                if (r.saveScrollPositions(null, c.state.key),
                y[v + 1]) {
                    if (g.scrollMap) {
                        const {scrollMap: e} = g
                          , t = y.length;
                        let n = v + 1;
                        for (; n < t; )
                            e.delete(y[n].key),
                            n++
                    }
                    y.splice(v + 1)
                }
                v = g.historyArray.length,
                r.historyIdx = v
            }
            y[v] = Object(l.b)(c.pState)
        }
        if (m) {
            const e = y[v]
              , n = c.getPrevState();
            if (a === i.a || !n || n.hostname === e.hostname && n.port === e.port && n.protocol === e.protocol) {
                const n = u === d ? "pushState" : "replaceState";
                try {
                    m[n](e, e.title, Object(o.c)(r))
                } catch (b) {
                    const {href: e} = r
                      , n = t.mainActionMeta.instance;
                    t.mainActionMeta.subscribe( () => {
                        n.href === e && (window.location.href = e)
                    }
                    )
                }
            } else
                window.location.href = Object(o.b)(e, e)
        }
        return e
    }
    ), !0)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(26)
      , i = n(78)
      , o = n(120);
    function s(e) {
        return new r.a((function(t) {
            var n;
            try {
                n = e()
            } catch (r) {
                return void t.error(r)
            }
            return (n ? Object(i.a)(n) : Object(o.b)()).subscribe(t)
        }
        ))
    }
}
, function(e, t, n) {
    "use strict";
    function r(e, t, n, r, i) {
        if (!t)
            return "undefined" === typeof t ? n : t;
        let o = t.charAt(0);
        if ("." === o) {
            let e = n || r;
            if (!e)
                throw new Error('Unable to parse relative module "'.concat(t, '" because no module or packageName exists to use as the base name for the relative module path.'));
            if ("." !== t.charAt(1))
                t = "".concat(e, "/").concat(t.replace("./", ""));
            else if ("." === t.charAt(3)) {
                const n = t.split("/")
                  , r = e.split("/");
                let i = n.length;
                for (; i && ".." === n[0]; ) {
                    if (!r.pop())
                        throw new Error('Unable to parse relative module "'.concat(t, '" because it is referencing a parent module that is outside of the scope of the base module "').concat(e, '".'));
                    n.shift(),
                    i--
                }
                t = "".concat(r.join("/"), "/").concat(n.join("/"))
            } else {
                const n = e.lastIndexOf("/");
                if (n < 0)
                    throw new Error('Unable to parse relative module "'.concat(t, '" because it is referencing a parent module that is outside of the scope of the base module "').concat(e, '".'));
                t = "".concat(e.substring(0, n), "/").concat(t.replace("../", ""))
            }
            o = t.charAt(0)
        }
        if (!r && i) {
            if ("@" === o) {
                const e = t.indexOf("/") + 1;
                r = t.substring(0, e),
                t = t.substring(e)
            } else
                r = "";
            r += "".concat(t.substring(0, t.indexOf("/"))),
            e[i] = r
        } else
            "@" === o && (t = t.substring(t.indexOf("/") + 1));
        return t
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return h
    }
    )),
    n.d(t, "b", (function() {
        return f
    }
    )),
    n.d(t, "a", (function() {
        return p
    }
    ));
    var r = n(0)
      , i = n(72)
      , o = n(31)
      , s = n(15);
    const a = Object(i.a)(e => e.payload.resp);
    function c(e, t) {
        return {
            configurable: !0,
            enumerable: !1,
            value(n, i) {
                const s = t.get(this);
                if (!s)
                    throw new Error("Unable to dispatch ".concat(e, " because a store could not be found for the instance."));
                let c = null;
                "number" === typeof i ? c = i : Object(r.E)(i) && (c = i.meta.dispatchId,
                n || (n = i.payload));
                const u = s.dispatch(e, n, c);
                return u ? u.meta.pipe(a) : Object(o.a)(!1)
            }
        }
    }
    const u = (e, t) => {
        const n = t[s.j]
          , r = t[s.a];
        let i = "Unable to add action dispatcher ";
        return i += 'Unable to add a default action dispatcher as indicated by logic "'.concat(n, '" associated with store "').concat(e.storeName, "\" because it uses an action type that is not a string and therefore it cannot be determined what action type to create a dispatcher for. Set the logic's action type to a single action type or an Array of action types, not a function, RegExp or an Array containing either of those. Got: ").concat(r.join(", ")),
        i
    }
    ;
    function l(e, t, n, r, i) {
        if ("function" === typeof i)
            i.call(this, e, t, n, r);
        else if (i) {
            const t = this[s.a];
            if (Array.isArray(t))
                for (let r of t) {
                    if ("string" !== typeof r)
                        throw new Error(u(e, this));
                    n[r] = !0
                }
            else {
                if ("string" !== typeof t)
                    throw new Error(u(e, this));
                n[t] = !0
            }
        }
    }
    function d(e, t, n, r, i) {
        if ("function" === typeof i)
            return i.call(this, e, t, n, r);
        if (i) {
            const n = "string" === typeof i ? i : this[s.j];
            if (!n)
                throw new Error('Unable to register action accessor for instance associated with the "'.concat(e.storeName, '" store because the logic does not define a name, which is used as the name of the accessor when `true` is given (indicating a default accessor should be added).'));
            const o = ( (e, t, n) => {
                const r = t[s.a];
                if (Array.isArray(r)) {
                    const r = t[s.j]
                      , i = t[s.a];
                    let o = "Unable to add action ";
                    throw o += n ? "accessor method " : "dispatcher ",
                    o += 'provided by logic "'.concat(r, '" associated with store "').concat(e.storeName, '" because the default implementation (indicated by providing `true`) is not compatible with logic that defines a list of actions for its ').concat(s.a, " property. It is only compatible with logic that targets a single action type. Got: ").concat(i.join(", ")),
                    new Error(o)
                }
                return r
            }
            )(e, this, !0);
            return r[n] = c(o, t),
            n
        }
    }
    function h(e, t, n, r) {
        l.call(this, e, t, n, r, !0),
        d.call(this, e, t, n, r, !0)
    }
    function f(e, t) {
        return function n(r, i, o, s) {
            l.call(this, r, i, o, s, e),
            n.accessorName = d.call(this, r, i, o, s, t)
        }
    }
    function p(e, t, n, r) {
        let i, o, a, c, l = e.pendingStoreMgr.logicArray, d = l.length - 1;
        for (; d >= 0; )
            if (c = l[d],
            d--,
            i = c[s.f])
                if ("function" === typeof i)
                    c[s.f](e, t, n, r);
                else if (o = c[s.a],
                Array.isArray(o))
                    for (a of o) {
                        if ("string" !== typeof a)
                            throw new Error(u(e, c));
                        n[a] || (n[a] = !0)
                    }
                else {
                    if ("string" !== typeof o)
                        throw new Error(u(e, c));
                    n[o] || (n[o] = !0)
                }
    }
    h.accessorName = "__LOGIC_NAME__"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return u
    }
    ));
    var r = n(31)
      , i = n(78)
      , o = n(72)
      , s = n(74)
      , a = (n(52),
    n(164))
      , c = n(163);
    n(860);
    function u(e, t, n, u) {
        if (e) {
            if (u) {
                if (Object(a.a)(e))
                    e = Object(i.a)(e);
                else if (!Object(c.a)(e))
                    return t.payload[u] = e,
                    n ? t : Object(r.a)(t);
                return e.pipe(Object(o.a)(e => (t.payload[u] = e,
                t)))
            }
            if (n)
                return n.setNextValue(t),
                e;
            if (Object(a.a)(e))
                e = Object(i.a)(e);
            else if (!Object(c.a)(e))
                return Object(r.a)(t);
            return e.pipe(Object(s.a)(t))
        }
        return u && (t.payload[u] = e),
        n ? t : Object(r.a)(t)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(58);
    const i = n(139).a.init().setActionType(r.m)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "h", (function() {
        return p
    }
    )),
    n.d(t, "g", (function() {
        return b
    }
    )),
    n.d(t, "f", (function() {
        return _
    }
    )),
    n.d(t, "i", (function() {
        return S
    }
    )),
    n.d(t, "d", (function() {
        return O
    }
    )),
    n.d(t, "c", (function() {
        return T
    }
    )),
    n.d(t, "e", (function() {
        return I
    }
    )),
    n.d(t, "a", (function() {
        return w
    }
    )),
    n.d(t, "b", (function() {
        return M
    }
    ));
    var r = n(234);
    const i = (e, t) => {
        if (!(t <= 0) && (e = e.substring(t + 1)))
            return e.replace("c", "").replace("n", "s")
    }
      , o = (e, t, n) => {
        let o;
        if (e instanceof RegExp) {
            if (n)
                return e;
            o = e.toString()
        } else {
            if ("/" !== e.charAt(0))
                return t ? void 0 : n ? new RegExp(e) : [e, void 0];
            o = e
        }
        o = Object(r.c)(o);
        const s = o.lastIndexOf("/");
        return t ? i(o, s) : n ? new RegExp(o.substring(0, s),i(o, s)) : [o.substring(0, s), i(o, s)]
    }
    ;
    function s(e) {
        return o(e, !1, !0)
    }
    const a = (e, t) => e === t
      , c = (e, t) => t !== e
      , u = (e, t) => !!e.test(t) && (e.lastIndex = 0,
    !0)
      , l = (e, t) => !u(e, t)
      , d = u
      , h = l
      , f = {
        string: (e, t) => e === t || "*" === e,
        undefined: a,
        number: a,
        boolean: a,
        bigint: a,
        symbol: a,
        function: (e, t) => e(t),
        object: (e, t) => {
            if (null === e)
                return null === t;
            if (e instanceof RegExp)
                return e.test(t);
            for (let n of e)
                if (f[typeof n](n, t))
                    return !0;
            return !1
        }
    }
      , p = (e, t) => f[typeof e](e, t)
      , g = new Map
      , m = new Map
      , y = new Map
      , v = new Map;
    g.set("eq", "=").set("neq", "!=").set("gt", ">").set("lt", "<").set("gte", ">=").set("lte", "<=").set("in", "in").set("nin", "nin").set("isNull", "isNull").set("isNotNull", "isNotNull").set("like", "like").set("nlike", "nlike").set("rlike", "rlike").set("nrlike", "nrlike").set("exists", "exists").set("nexists", "nexists").set("nmatches", "nmatches").set("matches", "matches"),
    m.set("eq", "neq").set("neq", "eq").set("gt", "lte").set("lt", "gte").set("gte", "lt").set("lte", "gt").set("in", "nin").set("nin", "in").set("isNull", "isNotNull").set("isNotNull", "isNull").set("like", "nlike").set("nlike", "like").set("rlike", "nrlike").set("nrlike", "rlike").set("exists", "nexists").set("nexists", "exists").set("matches", "nmatches").set("nmatches", "matches"),
    y.set("eq", a).set("neq", c).set("gt", (e, t) => t > e).set("lt", (e, t) => t < e).set("gte", (e, t) => t >= e).set("lte", (e, t) => t <= e).set("in", (e, t) => e.indexOf(t) > -1).set("nin", (e, t) => e.indexOf(t) < 0).set("isNull", (e, t) => null === t).set("isNotNull", (e, t) => null !== t).set("like", d).set("nlike", h).set("rlike", u).set("nrlike", l).set("exists", (e, t) => null !== t && "undefined" !== typeof t).set("nexists", (e, t) => "undefined" === typeof t || null === t).set("matches", p).set("nmatches", (e, t) => !p(e, t)),
    function() {
        const e = g.size;
        let t = 0;
        for (let[n,r] of g)
            if (v.set(r, n),
            t++,
            t <= 6)
                v.set(n, n),
                g.set(r, r),
                y.set(r, y.get(n)),
                m.set(r, g.get(m.get(n)));
            else if (t === e)
                break;
        v.set("<>", "neq"),
        y.set("<>", c),
        g.set("<>", "!="),
        m.set("<>", "=")
    }();
    const b = (e, t) => t ? m.get(v.get(e)) : v.get(e)
      , _ = (e, t) => t ? m.get(g.get(e)) : g.get(e)
      , S = e => v.has(e)
      , O = (e, t) => t ? y.get(m.get(e)) : y.get(e)
      , T = e => {
        if (e instanceof RegExp) {
            if (e.__likeExp)
                return e;
            e = (e = e.toString()).substring(1, e.lastIndexOf("/")).replace(/(?<!\\)\.(?<!\\)\*/g, "%").replace(/(?<!\\)\./g, "_")
        }
        const t = new RegExp((n = e,
        n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).replace(/%/g, ".*").replace(/_/g, "."),"i");
        var n;
        return t.__likeExp = e,
        t
    }
      , I = s
      , x = (e, t) => {
        const n = e ? l : u;
        let r, i;
        return (e, o) => (e !== i && (i = e,
        r = t(e)),
        n(r, o))
    }
      , w = e => x(e, T)
      , M = e => x(e, s)
}
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(e, t, n) {
    n(170)("flat")
}
, function(e, t, n) {
    var r = n(307);
    e.exports = r && !Symbol.sham && "symbol" == typeof Symbol.iterator
}
, function(e, t, n) {
    var r = n(206)
      , i = n(65)
      , o = n(311)
      , s = function(e) {
        return function(t, n, s) {
            var a, c = r(t), u = i(c.length), l = o(s, u);
            if (e && n != n) {
                for (; u > l; )
                    if ((a = c[l++]) != a)
                        return !0
            } else
                for (; u > l; l++)
                    if ((e || l in c) && c[l] === n)
                        return e || l || 0;
            return !e && -1
        }
    };
    e.exports = {
        includes: s(!0),
        indexOf: s(!1)
    }
}
, function(e, t, n) {
    n(170)("flatMap")
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(456)
      , s = n(49)
      , a = n(45)
      , c = n(81)
      , u = n(457)
      , l = n(94);
    r({
        target: "Promise",
        proto: !0,
        real: !0,
        forced: !!o && s((function() {
            o.prototype.finally.call({
                then: function() {}
            }, (function() {}
            ))
        }
        ))
    }, {
        finally: function(e) {
            var t = c(this, a("Promise"))
              , n = "function" == typeof e;
            return this.then(n ? function(n) {
                return u(t, e()).then((function() {
                    return n
                }
                ))
            }
            : e, n ? function(n) {
                return u(t, e()).then((function() {
                    throw n
                }
                ))
            }
            : e)
        }
    }),
    i || "function" != typeof o || o.prototype.finally || l(o.prototype, "finally", a("Promise").prototype.finally)
}
, function(e, t, n) {
    var r = n(56)
      , i = n(455)
      , o = n(258)
      , s = n(50);
    e.exports = function(e, t) {
        for (var n = i(t), a = s.f, c = o.f, u = 0; u < n.length; u++) {
            var l = n[u];
            r(e, l) || a(e, l, c(t, l))
        }
    }
}
, function(e, t, n) {
    var r = n(45)
      , i = n(259)
      , o = n(317)
      , s = n(18);
    e.exports = r("Reflect", "ownKeys") || function(e) {
        var t = i.f(s(e))
          , n = o.f;
        return n ? t.concat(n(e)) : t
    }
}
, function(e, t, n) {
    var r = n(39);
    e.exports = r.Promise
}
, function(e, t, n) {
    var r = n(18)
      , i = n(51)
      , o = n(208);
    e.exports = function(e, t) {
        if (r(e),
        i(t) && t.constructor === e)
            return t;
        var n = o.f(e);
        return (0,
        n.resolve)(t),
        n.promise
    }
}
, function(e, t, n) {
    var r = n(53)
      , i = n(50)
      , o = n(209)
      , s = n(319).UNSUPPORTED_Y;
    r && ("g" != /./g.flags || s) && i.f(RegExp.prototype, "flags", {
        configurable: !0,
        get: o
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(460)
      , i = n(18)
      , o = n(87)
      , s = n(65)
      , a = n(114)
      , c = n(113)
      , u = n(320)
      , l = n(462)
      , d = Math.max
      , h = Math.min
      , f = Math.floor
      , p = /\$([$&'`]|\d\d?|<[^>]*>)/g
      , g = /\$([$&'`]|\d\d?)/g;
    r("replace", 2, (function(e, t, n, r) {
        var m = r.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
          , y = r.REPLACE_KEEPS_$0
          , v = m ? "$" : "$0";
        return [function(n, r) {
            var i = c(this)
              , o = void 0 == n ? void 0 : n[e];
            return void 0 !== o ? o.call(n, i, r) : t.call(String(i), n, r)
        }
        , function(e, r) {
            if (!m && y || "string" === typeof r && -1 === r.indexOf(v)) {
                var o = n(t, e, this, r);
                if (o.done)
                    return o.value
            }
            var c = i(e)
              , f = String(this)
              , p = "function" === typeof r;
            p || (r = String(r));
            var g = c.global;
            if (g) {
                var _ = c.unicode;
                c.lastIndex = 0
            }
            for (var S = []; ; ) {
                var O = l(c, f);
                if (null === O)
                    break;
                if (S.push(O),
                !g)
                    break;
                "" === String(O[0]) && (c.lastIndex = u(f, s(c.lastIndex), _))
            }
            for (var T, I = "", x = 0, w = 0; w < S.length; w++) {
                O = S[w];
                for (var M = String(O[0]), A = d(h(a(O.index), f.length), 0), E = [], C = 1; C < O.length; C++)
                    E.push(void 0 === (T = O[C]) ? T : String(T));
                var N = O.groups;
                if (p) {
                    var R = [M].concat(E, A, f);
                    void 0 !== N && R.push(N);
                    var P = String(r.apply(void 0, R))
                } else
                    P = b(M, f, A, E, N, r);
                A >= x && (I += f.slice(x, A) + P,
                x = A + M.length)
            }
            return I + f.slice(x)
        }
        ];
        function b(e, n, r, i, s, a) {
            var c = r + e.length
              , u = i.length
              , l = g;
            return void 0 !== s && (s = o(s),
            l = p),
            t.call(a, l, (function(t, o) {
                var a;
                switch (o.charAt(0)) {
                case "$":
                    return "$";
                case "&":
                    return e;
                case "`":
                    return n.slice(0, r);
                case "'":
                    return n.slice(c);
                case "<":
                    a = s[o.slice(1, -1)];
                    break;
                default:
                    var l = +o;
                    if (0 === l)
                        return t;
                    if (l > u) {
                        var d = f(l / 10);
                        return 0 === d ? t : d <= u ? void 0 === i[d - 1] ? o.charAt(1) : i[d - 1] + o.charAt(1) : t
                    }
                    a = i[l - 1]
                }
                return void 0 === a ? "" : a
            }
            ))
        }
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n(461);
    var r = n(94)
      , i = n(49)
      , o = n(40)
      , s = n(260)
      , a = n(64)
      , c = o("species")
      , u = !i((function() {
        var e = /./;
        return e.exec = function() {
            var e = [];
            return e.groups = {
                a: "7"
            },
            e
        }
        ,
        "7" !== "".replace(e, "$<a>")
    }
    ))
      , l = "$0" === "a".replace(/./, "$0")
      , d = o("replace")
      , h = !!/./[d] && "" === /./[d]("a", "$0")
      , f = !i((function() {
        var e = /(?:)/
          , t = e.exec;
        e.exec = function() {
            return t.apply(this, arguments)
        }
        ;
        var n = "ab".split(e);
        return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
    }
    ));
    e.exports = function(e, t, n, d) {
        var p = o(e)
          , g = !i((function() {
            var t = {};
            return t[p] = function() {
                return 7
            }
            ,
            7 != ""[e](t)
        }
        ))
          , m = g && !i((function() {
            var t = !1
              , n = /a/;
            return "split" === e && ((n = {}).constructor = {},
            n.constructor[c] = function() {
                return n
            }
            ,
            n.flags = "",
            n[p] = /./[p]),
            n.exec = function() {
                return t = !0,
                null
            }
            ,
            n[p](""),
            !t
        }
        ));
        if (!g || !m || "replace" === e && (!u || !l || h) || "split" === e && !f) {
            var y = /./[p]
              , v = n(p, ""[e], (function(e, t, n, r, i) {
                return t.exec === s ? g && !i ? {
                    done: !0,
                    value: y.call(t, n, r)
                } : {
                    done: !0,
                    value: e.call(n, t, r)
                } : {
                    done: !1
                }
            }
            ), {
                REPLACE_KEEPS_$0: l,
                REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: h
            })
              , b = v[0]
              , _ = v[1];
            r(String.prototype, e, b),
            r(RegExp.prototype, p, 2 == t ? function(e, t) {
                return _.call(e, this, t)
            }
            : function(e) {
                return _.call(e, this)
            }
            )
        }
        d && a(RegExp.prototype[p], "sham", !0)
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(260);
    r({
        target: "RegExp",
        proto: !0,
        forced: /./.exec !== i
    }, {
        exec: i
    })
}
, function(e, t, n) {
    var r = n(129)
      , i = n(260);
    e.exports = function(e, t) {
        var n = e.exec;
        if ("function" === typeof n) {
            var o = n.call(e, t);
            if ("object" !== typeof o)
                throw TypeError("RegExp exec method returned something other than an Object or null");
            return o
        }
        if ("RegExp" !== r(e))
            throw TypeError("RegExp#exec called on incompatible receiver");
        return i.call(e, t)
    }
}
, function(e, t, n) {
    n(95)("Float32", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }
    ))
}
, function(e, t, n) {
    var r = {};
    r[n(40)("toStringTag")] = "z",
    e.exports = "[object z]" === String(r)
}
, function(e, t, n) {
    var r = n(49);
    e.exports = !r((function() {
        function e() {}
        return e.prototype.constructor = null,
        Object.getPrototypeOf(new e) !== e.prototype
    }
    ))
}
, function(e, t, n) {
    var r = n(51);
    e.exports = function(e) {
        if (!r(e) && null !== e)
            throw TypeError("Can't set " + String(e) + " as a prototype");
        return e
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(39)
      , i = n(53)
      , o = n(322)
      , s = n(64)
      , a = n(145)
      , c = n(49)
      , u = n(117)
      , l = n(114)
      , d = n(65)
      , h = n(323)
      , f = n(468)
      , p = n(116)
      , g = n(144)
      , m = n(259).f
      , y = n(50).f
      , v = n(324)
      , b = n(146)
      , _ = n(60)
      , S = _.get
      , O = _.set
      , T = r.ArrayBuffer
      , I = T
      , x = r.DataView
      , w = x && x.prototype
      , M = Object.prototype
      , A = r.RangeError
      , E = f.pack
      , C = f.unpack
      , N = function(e) {
        return [255 & e]
    }
      , R = function(e) {
        return [255 & e, e >> 8 & 255]
    }
      , P = function(e) {
        return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]
    }
      , D = function(e) {
        return e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0]
    }
      , F = function(e) {
        return E(e, 23, 4)
    }
      , k = function(e) {
        return E(e, 52, 8)
    }
      , j = function(e, t) {
        y(e.prototype, t, {
            get: function() {
                return S(this)[t]
            }
        })
    }
      , L = function(e, t, n, r) {
        var i = h(n)
          , o = S(e);
        if (i + t > o.byteLength)
            throw A("Wrong index");
        var s = S(o.buffer).bytes
          , a = i + o.byteOffset
          , c = s.slice(a, a + t);
        return r ? c : c.reverse()
    }
      , V = function(e, t, n, r, i, o) {
        var s = h(n)
          , a = S(e);
        if (s + t > a.byteLength)
            throw A("Wrong index");
        for (var c = S(a.buffer).bytes, u = s + a.byteOffset, l = r(+i), d = 0; d < t; d++)
            c[u + d] = l[o ? d : t - d - 1]
    };
    if (o) {
        if (!c((function() {
            T(1)
        }
        )) || !c((function() {
            new T(-1)
        }
        )) || c((function() {
            return new T,
            new T(1.5),
            new T(NaN),
            "ArrayBuffer" != T.name
        }
        ))) {
            for (var U, q = (I = function(e) {
                return u(this, I),
                new T(h(e))
            }
            ).prototype = T.prototype, Q = m(T), B = 0; Q.length > B; )
                (U = Q[B++])in I || s(I, U, T[U]);
            q.constructor = I
        }
        g && p(w) !== M && g(w, M);
        var G = new x(new I(2))
          , z = w.setInt8;
        G.setInt8(0, 2147483648),
        G.setInt8(1, 2147483649),
        !G.getInt8(0) && G.getInt8(1) || a(w, {
            setInt8: function(e, t) {
                z.call(this, e, t << 24 >> 24)
            },
            setUint8: function(e, t) {
                z.call(this, e, t << 24 >> 24)
            }
        }, {
            unsafe: !0
        })
    } else
        I = function(e) {
            u(this, I, "ArrayBuffer");
            var t = h(e);
            O(this, {
                bytes: v.call(new Array(t), 0),
                byteLength: t
            }),
            i || (this.byteLength = t)
        }
        ,
        x = function(e, t, n) {
            u(this, x, "DataView"),
            u(e, I, "DataView");
            var r = S(e).byteLength
              , o = l(t);
            if (o < 0 || o > r)
                throw A("Wrong offset");
            if (o + (n = void 0 === n ? r - o : d(n)) > r)
                throw A("Wrong length");
            O(this, {
                buffer: e,
                byteLength: n,
                byteOffset: o
            }),
            i || (this.buffer = e,
            this.byteLength = n,
            this.byteOffset = o)
        }
        ,
        i && (j(I, "byteLength"),
        j(x, "buffer"),
        j(x, "byteLength"),
        j(x, "byteOffset")),
        a(x.prototype, {
            getInt8: function(e) {
                return L(this, 1, e)[0] << 24 >> 24
            },
            getUint8: function(e) {
                return L(this, 1, e)[0]
            },
            getInt16: function(e) {
                var t = L(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
                return (t[1] << 8 | t[0]) << 16 >> 16
            },
            getUint16: function(e) {
                var t = L(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
                return t[1] << 8 | t[0]
            },
            getInt32: function(e) {
                return D(L(this, 4, e, arguments.length > 1 ? arguments[1] : void 0))
            },
            getUint32: function(e) {
                return D(L(this, 4, e, arguments.length > 1 ? arguments[1] : void 0)) >>> 0
            },
            getFloat32: function(e) {
                return C(L(this, 4, e, arguments.length > 1 ? arguments[1] : void 0), 23)
            },
            getFloat64: function(e) {
                return C(L(this, 8, e, arguments.length > 1 ? arguments[1] : void 0), 52)
            },
            setInt8: function(e, t) {
                V(this, 1, e, N, t)
            },
            setUint8: function(e, t) {
                V(this, 1, e, N, t)
            },
            setInt16: function(e, t) {
                V(this, 2, e, R, t, arguments.length > 2 ? arguments[2] : void 0)
            },
            setUint16: function(e, t) {
                V(this, 2, e, R, t, arguments.length > 2 ? arguments[2] : void 0)
            },
            setInt32: function(e, t) {
                V(this, 4, e, P, t, arguments.length > 2 ? arguments[2] : void 0)
            },
            setUint32: function(e, t) {
                V(this, 4, e, P, t, arguments.length > 2 ? arguments[2] : void 0)
            },
            setFloat32: function(e, t) {
                V(this, 4, e, F, t, arguments.length > 2 ? arguments[2] : void 0)
            },
            setFloat64: function(e, t) {
                V(this, 8, e, k, t, arguments.length > 2 ? arguments[2] : void 0)
            }
        });
    b(I, "ArrayBuffer"),
    b(x, "DataView"),
    e.exports = {
        ArrayBuffer: I,
        DataView: x
    }
}
, function(e, t) {
    var n = Math.abs
      , r = Math.pow
      , i = Math.floor
      , o = Math.log
      , s = Math.LN2;
    e.exports = {
        pack: function(e, t, a) {
            var c, u, l, d = new Array(a), h = 8 * a - t - 1, f = (1 << h) - 1, p = f >> 1, g = 23 === t ? r(2, -24) - r(2, -77) : 0, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0, y = 0;
            for ((e = n(e)) != e || e === 1 / 0 ? (u = e != e ? 1 : 0,
            c = f) : (c = i(o(e) / s),
            e * (l = r(2, -c)) < 1 && (c--,
            l *= 2),
            (e += c + p >= 1 ? g / l : g * r(2, 1 - p)) * l >= 2 && (c++,
            l /= 2),
            c + p >= f ? (u = 0,
            c = f) : c + p >= 1 ? (u = (e * l - 1) * r(2, t),
            c += p) : (u = e * r(2, p - 1) * r(2, t),
            c = 0)); t >= 8; d[y++] = 255 & u,
            u /= 256,
            t -= 8)
                ;
            for (c = c << t | u,
            h += t; h > 0; d[y++] = 255 & c,
            c /= 256,
            h -= 8)
                ;
            return d[--y] |= 128 * m,
            d
        },
        unpack: function(e, t) {
            var n, i = e.length, o = 8 * i - t - 1, s = (1 << o) - 1, a = s >> 1, c = o - 7, u = i - 1, l = e[u--], d = 127 & l;
            for (l >>= 7; c > 0; d = 256 * d + e[u],
            u--,
            c -= 8)
                ;
            for (n = d & (1 << -c) - 1,
            d >>= -c,
            c += t; c > 0; n = 256 * n + e[u],
            u--,
            c -= 8)
                ;
            if (0 === d)
                d = 1 - a;
            else {
                if (d === s)
                    return n ? NaN : l ? -1 / 0 : 1 / 0;
                n += r(2, t),
                d -= a
            }
            return (l ? -1 : 1) * n * r(2, d - t)
        }
    }
}
, function(e, t, n) {
    var r = n(114);
    e.exports = function(e) {
        var t = r(e);
        if (t < 0)
            throw RangeError("The argument can't be less than 0");
        return t
    }
}
, function(e, t, n) {
    var r = n(51)
      , i = n(471)
      , o = n(40)("species");
    e.exports = function(e, t) {
        var n;
        return i(e) && ("function" != typeof (n = e.constructor) || n !== Array && !i(n.prototype) ? r(n) && null === (n = n[o]) && (n = void 0) : n = void 0),
        new (void 0 === n ? Array : n)(0 === t ? 0 : t)
    }
}
, function(e, t, n) {
    var r = n(129);
    e.exports = Array.isArray || function(e) {
        return "Array" == r(e)
    }
}
, function(e, t, n) {
    n(95)("Float64", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }
    ))
}
, function(e, t, n) {
    n(95)("Int8", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }
    ))
}
, function(e, t, n) {
    n(95)("Int16", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }
    ))
}
, function(e, t, n) {
    n(95)("Int32", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }
    ))
}
, function(e, t, n) {
    n(95)("Uint8", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }
    ))
}
, function(e, t, n) {
    n(95)("Uint8", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }
    ), !0)
}
, function(e, t, n) {
    n(95)("Uint16", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }
    ))
}
, function(e, t, n) {
    n(95)("Uint32", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var r = n(115)
      , i = n(324)
      , o = r.aTypedArray;
    (0,
    r.exportTypedArrayMethod)("fill", (function(e) {
        return i.apply(o(this), arguments)
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var r = n(261);
    (0,
    n(115).exportTypedArrayStaticMethod)("from", n(326), r)
}
, function(e, t, n) {
    "use strict";
    var r = n(115)
      , i = n(261)
      , o = r.aTypedArrayConstructor;
    (0,
    r.exportTypedArrayStaticMethod)("of", (function() {
        for (var e = 0, t = arguments.length, n = new (o(this))(t); t > e; )
            n[e] = arguments[e++];
        return n
    }
    ), i)
}
, function(e, t, n) {
    "use strict";
    var r = n(115)
      , i = n(65)
      , o = n(325)
      , s = n(87)
      , a = n(49)
      , c = r.aTypedArray;
    (0,
    r.exportTypedArrayMethod)("set", (function(e) {
        c(this);
        var t = o(arguments.length > 1 ? arguments[1] : void 0, 1)
          , n = this.length
          , r = s(e)
          , a = i(r.length)
          , u = 0;
        if (a + t > n)
            throw RangeError("Wrong length");
        for (; u < a; )
            this[t + u] = r[u++]
    }
    ), a((function() {
        new Int8Array(1).set({})
    }
    )))
}
, function(e, t, n) {
    "use strict";
    var r = n(115)
      , i = r.aTypedArray
      , o = r.exportTypedArrayMethod
      , s = [].sort;
    o("sort", (function(e) {
        return s.call(i(this), e)
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(53)
      , o = n(116)
      , s = n(144)
      , a = n(112)
      , c = n(50)
      , u = n(128)
      , l = n(27)
      , d = n(64)
      , h = n(60)
      , f = h.set
      , p = h.getterFor("AggregateError")
      , g = function(e, t) {
        var n = this;
        if (!(n instanceof g))
            return new g(e,t);
        s && (n = s(new Error(t), o(n)));
        var r = [];
        return l(e, r.push, r),
        i ? f(n, {
            errors: r,
            type: "AggregateError"
        }) : n.errors = r,
        void 0 !== t && d(n, "message", String(t)),
        n
    };
    g.prototype = a(Error.prototype, {
        constructor: u(5, g),
        message: u(5, ""),
        name: u(5, "AggregateError")
    }),
    i && c.f(g.prototype, "errors", {
        get: function() {
            return p(this).errors
        },
        configurable: !0
    }),
    r({
        global: !0
    }, {
        AggregateError: g
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(53)
      , i = n(170)
      , o = n(87)
      , s = n(65)
      , a = n(50).f;
    r && !("lastIndex"in []) && (a(Array.prototype, "lastIndex", {
        configurable: !0,
        get: function() {
            var e = o(this)
              , t = s(e.length);
            return 0 == t ? 0 : t - 1
        }
    }),
    i("lastIndex"))
}
, function(e, t, n) {
    "use strict";
    var r = n(53)
      , i = n(170)
      , o = n(87)
      , s = n(65)
      , a = n(50).f;
    r && !("lastItem"in []) && (a(Array.prototype, "lastItem", {
        configurable: !0,
        get: function() {
            var e = o(this)
              , t = s(e.length);
            return 0 == t ? void 0 : e[t - 1]
        },
        set: function(e) {
            var t = o(this)
              , n = s(t.length);
            return t[0 == n ? 0 : n - 1] = e
        }
    }),
    i("lastItem"))
}
, function(e, t, n) {
    var r = n(10)
      , i = n(330)
      , o = n(45)
      , s = n(112)
      , a = function() {
        var e = o("Object", "freeze");
        return e ? e(s(null)) : s(null)
    };
    r({
        global: !0
    }, {
        compositeKey: function() {
            return i.apply(Object, arguments).get("object", a)
        }
    })
}
, function(e, t, n) {
    var r = n(49);
    e.exports = !r((function() {
        return Object.isExtensible(Object.preventExtensions({}))
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var r = n(145)
      , i = n(211).getWeakData
      , o = n(18)
      , s = n(51)
      , a = n(117)
      , c = n(27)
      , u = n(327)
      , l = n(56)
      , d = n(60)
      , h = d.set
      , f = d.getterFor
      , p = u.find
      , g = u.findIndex
      , m = 0
      , y = function(e) {
        return e.frozen || (e.frozen = new v)
    }
      , v = function() {
        this.entries = []
    }
      , b = function(e, t) {
        return p(e.entries, (function(e) {
            return e[0] === t
        }
        ))
    };
    v.prototype = {
        get: function(e) {
            var t = b(this, e);
            if (t)
                return t[1]
        },
        has: function(e) {
            return !!b(this, e)
        },
        set: function(e, t) {
            var n = b(this, e);
            n ? n[1] = t : this.entries.push([e, t])
        },
        delete: function(e) {
            var t = g(this.entries, (function(t) {
                return t[0] === e
            }
            ));
            return ~t && this.entries.splice(t, 1),
            !!~t
        }
    },
    e.exports = {
        getConstructor: function(e, t, n, u) {
            var d = e((function(e, r) {
                a(e, d, t),
                h(e, {
                    type: t,
                    id: m++,
                    frozen: void 0
                }),
                void 0 != r && c(r, e[u], e, n)
            }
            ))
              , p = f(t)
              , g = function(e, t, n) {
                var r = p(e)
                  , s = i(o(t), !0);
                return !0 === s ? y(r).set(t, n) : s[r.id] = n,
                e
            };
            return r(d.prototype, {
                delete: function(e) {
                    var t = p(this);
                    if (!s(e))
                        return !1;
                    var n = i(e);
                    return !0 === n ? y(t).delete(e) : n && l(n, t.id) && delete n[t.id]
                },
                has: function(e) {
                    var t = p(this);
                    if (!s(e))
                        return !1;
                    var n = i(e);
                    return !0 === n ? y(t).has(e) : n && l(n, t.id)
                }
            }),
            r(d.prototype, n ? {
                get: function(e) {
                    var t = p(this);
                    if (s(e)) {
                        var n = i(e);
                        return !0 === n ? y(t).get(e) : n ? n[t.id] : void 0
                    }
                },
                set: function(e, t) {
                    return g(this, e, t)
                }
            } : {
                add: function(e) {
                    return g(this, e, !0)
                }
            }),
            d
        }
    }
}
, function(e, t, n) {
    var r = n(10)
      , i = n(330)
      , o = n(45);
    r({
        global: !0
    }, {
        compositeSymbol: function() {
            return 1 === arguments.length && "string" === typeof arguments[0] ? o("Symbol").for(arguments[0]) : i.apply(null, arguments).get("symbol", o("Symbol"))
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(212);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        deleteAll: function() {
            return o.apply(this, arguments)
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(44)
      , a = n(88)
      , c = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        every: function(e) {
            var t = o(this)
              , n = a(t)
              , r = s(e, arguments.length > 1 ? arguments[1] : void 0, 3);
            return !c(n, (function(e, n) {
                if (!r(n, e, t))
                    return c.stop()
            }
            ), void 0, !0, !0).stopped
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(44)
      , u = n(81)
      , l = n(88)
      , d = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        filter: function(e) {
            var t = s(this)
              , n = l(t)
              , r = c(e, arguments.length > 1 ? arguments[1] : void 0, 3)
              , i = new (u(t, o("Map")))
              , h = a(i.set);
            return d(n, (function(e, n) {
                r(n, e, t) && h.call(i, e, n)
            }
            ), void 0, !0, !0),
            i
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(44)
      , a = n(88)
      , c = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        find: function(e) {
            var t = o(this)
              , n = a(t)
              , r = s(e, arguments.length > 1 ? arguments[1] : void 0, 3);
            return c(n, (function(e, n) {
                if (r(n, e, t))
                    return c.stop(n)
            }
            ), void 0, !0, !0).result
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(44)
      , a = n(88)
      , c = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        findKey: function(e) {
            var t = o(this)
              , n = a(t)
              , r = s(e, arguments.length > 1 ? arguments[1] : void 0, 3);
            return c(n, (function(e, n) {
                if (r(n, e, t))
                    return c.stop(e)
            }
            ), void 0, !0, !0).result
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Map",
        stat: !0
    }, {
        from: n(213)
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(27)
      , o = n(34);
    r({
        target: "Map",
        stat: !0
    }, {
        groupBy: function(e, t) {
            var n = new this;
            o(t);
            var r = o(n.has)
              , s = o(n.get)
              , a = o(n.set);
            return i(e, (function(e) {
                var i = t(e);
                r.call(n, i) ? s.call(n, i).push(e) : a.call(n, i, [e])
            }
            )),
            n
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(88)
      , a = n(500)
      , c = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        includes: function(e) {
            return c(s(o(this)), (function(t, n) {
                if (a(n, e))
                    return c.stop()
            }
            ), void 0, !0, !0).stopped
        }
    })
}
, function(e, t) {
    e.exports = function(e, t) {
        return e === t || e != e && t != t
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(27)
      , o = n(34);
    r({
        target: "Map",
        stat: !0
    }, {
        keyBy: function(e, t) {
            var n = new this;
            o(t);
            var r = o(n.set);
            return i(e, (function(e) {
                r.call(n, t(e), e)
            }
            )),
            n
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(88)
      , a = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        keyOf: function(e) {
            return a(s(o(this)), (function(t, n) {
                if (n === e)
                    return a.stop(t)
            }
            ), void 0, !0, !0).result
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(44)
      , u = n(81)
      , l = n(88)
      , d = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        mapKeys: function(e) {
            var t = s(this)
              , n = l(t)
              , r = c(e, arguments.length > 1 ? arguments[1] : void 0, 3)
              , i = new (u(t, o("Map")))
              , h = a(i.set);
            return d(n, (function(e, n) {
                h.call(i, r(n, e, t), n)
            }
            ), void 0, !0, !0),
            i
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(44)
      , u = n(81)
      , l = n(88)
      , d = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        mapValues: function(e) {
            var t = s(this)
              , n = l(t)
              , r = c(e, arguments.length > 1 ? arguments[1] : void 0, 3)
              , i = new (u(t, o("Map")))
              , h = a(i.set);
            return d(n, (function(e, n) {
                h.call(i, e, r(n, e, t))
            }
            ), void 0, !0, !0),
            i
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(34)
      , a = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        merge: function(e) {
            for (var t = o(this), n = s(t.set), r = 0; r < arguments.length; )
                a(arguments[r++], n, t, !0);
            return t
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Map",
        stat: !0
    }, {
        of: n(214)
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(34)
      , a = n(88)
      , c = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        reduce: function(e) {
            var t = o(this)
              , n = a(t)
              , r = arguments.length < 2
              , i = r ? void 0 : arguments[1];
            if (s(e),
            c(n, (function(n, o) {
                r ? (r = !1,
                i = o) : i = e(i, o, n, t)
            }
            ), void 0, !0, !0),
            r)
                throw TypeError("Reduce of empty map with no initial value");
            return i
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(44)
      , a = n(88)
      , c = n(27);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        some: function(e) {
            var t = o(this)
              , n = a(t)
              , r = s(e, arguments.length > 1 ? arguments[1] : void 0, 3);
            return c(n, (function(e, n) {
                if (r(n, e, t))
                    return c.stop()
            }
            ), void 0, !0, !0).stopped
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(34);
    r({
        target: "Map",
        proto: !0,
        real: !0,
        forced: i
    }, {
        update: function(e, t) {
            var n = o(this)
              , r = arguments.length;
            s(t);
            var i = n.has(e);
            if (!i && r < 3)
                throw TypeError("Updating absent value");
            var a = i ? n.get(e) : s(r > 2 ? arguments[2] : void 0)(e, n);
            return n.set(e, t(a, e, n)),
            n
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = Math.min
      , o = Math.max;
    r({
        target: "Math",
        stat: !0
    }, {
        clamp: function(e, t, n) {
            return i(n, o(t, e))
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Math",
        stat: !0
    }, {
        DEG_PER_RAD: Math.PI / 180
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = 180 / Math.PI;
    r({
        target: "Math",
        stat: !0
    }, {
        degrees: function(e) {
            return e * i
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(335)
      , o = n(514);
    r({
        target: "Math",
        stat: !0
    }, {
        fscale: function(e, t, n, r, s) {
            return o(i(e, t, n, r, s))
        }
    })
}
, function(e, t, n) {
    var r = n(515)
      , i = Math.abs
      , o = Math.pow
      , s = o(2, -52)
      , a = o(2, -23)
      , c = o(2, 127) * (2 - a)
      , u = o(2, -126);
    e.exports = Math.fround || function(e) {
        var t, n, o = i(e), l = r(e);
        return o < u ? l * (o / u / a + 1 / s - 1 / s) * u * a : (n = (t = (1 + a / s) * o) - (t - o)) > c || n != n ? l * (1 / 0) : l * n
    }
}
, function(e, t) {
    e.exports = Math.sign || function(e) {
        return 0 == (e = +e) || e != e ? e : e < 0 ? -1 : 1
    }
}
, function(e, t, n) {
    n(10)({
        target: "Math",
        stat: !0
    }, {
        iaddh: function(e, t, n, r) {
            var i = e >>> 0
              , o = n >>> 0;
            return (t >>> 0) + (r >>> 0) + ((i & o | (i | o) & ~(i + o >>> 0)) >>> 31) | 0
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Math",
        stat: !0
    }, {
        imulh: function(e, t) {
            var n = +e
              , r = +t
              , i = 65535 & n
              , o = 65535 & r
              , s = n >> 16
              , a = r >> 16
              , c = (s * o >>> 0) + (i * o >>> 16);
            return s * a + (c >> 16) + ((i * a >>> 0) + (65535 & c) >> 16)
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Math",
        stat: !0
    }, {
        isubh: function(e, t, n, r) {
            var i = e >>> 0
              , o = n >>> 0;
            return (t >>> 0) - (r >>> 0) - ((~i & o | ~(i ^ o) & i - o >>> 0) >>> 31) | 0
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Math",
        stat: !0
    }, {
        RAD_PER_DEG: 180 / Math.PI
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = Math.PI / 180;
    r({
        target: "Math",
        stat: !0
    }, {
        radians: function(e) {
            return e * i
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Math",
        stat: !0
    }, {
        scale: n(335)
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(18)
      , o = n(523)
      , s = n(174)
      , a = n(60)
      , c = a.set
      , u = a.getterFor("Seeded Random Generator")
      , l = s((function(e) {
        c(this, {
            type: "Seeded Random Generator",
            seed: e % 2147483647
        })
    }
    ), "Seeded Random", (function() {
        var e = u(this);
        return {
            value: (1073741823 & (e.seed = (1103515245 * e.seed + 12345) % 2147483647)) / 1073741823,
            done: !1
        }
    }
    ));
    r({
        target: "Math",
        stat: !0,
        forced: !0
    }, {
        seededPRNG: function(e) {
            var t = i(e).seed;
            if (!o(t))
                throw TypeError('Math.seededPRNG() argument should have a "seed" field with a finite value.');
            return new l(t)
        }
    })
}
, function(e, t, n) {
    var r = n(39).isFinite;
    e.exports = Number.isFinite || function(e) {
        return "number" == typeof e && r(e)
    }
}
, function(e, t, n) {
    n(10)({
        target: "Math",
        stat: !0
    }, {
        signbit: function(e) {
            return (e = +e) == e && 0 == e ? 1 / e == -1 / 0 : e < 0
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Math",
        stat: !0
    }, {
        umulh: function(e, t) {
            var n = +e
              , r = +t
              , i = 65535 & n
              , o = 65535 & r
              , s = n >>> 16
              , a = r >>> 16
              , c = (s * o >>> 0) + (i * o >>> 16);
            return s * a + (c >>> 16) + ((i * a >>> 0) + (65535 & c) >>> 16)
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(114)
      , o = n(527)
      , s = /^[\da-z]+$/;
    r({
        target: "Number",
        stat: !0
    }, {
        fromString: function(e, t) {
            var n, r, a = 1;
            if ("string" != typeof e)
                throw TypeError("Invalid number representation");
            if (!e.length)
                throw SyntaxError("Invalid number representation");
            if ("-" == e.charAt(0) && (a = -1,
            !(e = e.slice(1)).length))
                throw SyntaxError("Invalid number representation");
            if ((n = void 0 === t ? 10 : i(t)) < 2 || n > 36)
                throw RangeError("Invalid radix");
            if (!s.test(e) || (r = o(e, n)).toString(n) !== e)
                throw SyntaxError("Invalid number representation");
            return a * r
        }
    })
}
, function(e, t, n) {
    var r = n(39)
      , i = n(528).trim
      , o = n(336)
      , s = r.parseInt
      , a = /^[+-]?0[Xx]/
      , c = 8 !== s(o + "08") || 22 !== s(o + "0x16");
    e.exports = c ? function(e, t) {
        var n = i(String(e));
        return s(n, t >>> 0 || (a.test(n) ? 16 : 10))
    }
    : s
}
, function(e, t, n) {
    var r = n(113)
      , i = "[" + n(336) + "]"
      , o = RegExp("^" + i + i + "*")
      , s = RegExp(i + i + "*$")
      , a = function(e) {
        return function(t) {
            var n = String(r(t));
            return 1 & e && (n = n.replace(o, "")),
            2 & e && (n = n.replace(s, "")),
            n
        }
    };
    e.exports = {
        start: a(1),
        end: a(2),
        trim: a(3)
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(53)
      , o = n(263)
      , s = n(34)
      , a = n(18)
      , c = n(51)
      , u = n(117)
      , l = n(50).f
      , d = n(64)
      , h = n(145)
      , f = n(175)
      , p = n(27)
      , g = n(530)
      , m = n(40)
      , y = n(60)
      , v = m("observable")
      , b = y.get
      , _ = y.set
      , S = function(e) {
        return null == e ? void 0 : s(e)
    }
      , O = function(e) {
        var t = e.cleanup;
        if (t) {
            e.cleanup = void 0;
            try {
                t()
            } catch (n) {
                g(n)
            }
        }
    }
      , T = function(e) {
        return void 0 === e.observer
    }
      , I = function(e, t) {
        if (!i) {
            e.closed = !0;
            var n = t.subscriptionObserver;
            n && (n.closed = !0)
        }
        t.observer = void 0
    }
      , x = function(e, t) {
        var n, r = _(this, {
            cleanup: void 0,
            observer: a(e),
            subscriptionObserver: void 0
        });
        i || (this.closed = !1);
        try {
            (n = S(e.start)) && n.call(e, this)
        } catch (l) {
            g(l)
        }
        if (!T(r)) {
            var o = r.subscriptionObserver = new w(this);
            try {
                var c = t(o)
                  , u = c;
                null != c && (r.cleanup = "function" === typeof c.unsubscribe ? function() {
                    u.unsubscribe()
                }
                : s(c))
            } catch (l) {
                return void o.error(l)
            }
            T(r) && O(r)
        }
    };
    x.prototype = h({}, {
        unsubscribe: function() {
            var e = b(this);
            T(e) || (I(this, e),
            O(e))
        }
    }),
    i && l(x.prototype, "closed", {
        configurable: !0,
        get: function() {
            return T(b(this))
        }
    });
    var w = function(e) {
        _(this, {
            subscription: e
        }),
        i || (this.closed = !1)
    };
    w.prototype = h({}, {
        next: function(e) {
            var t = b(b(this).subscription);
            if (!T(t)) {
                var n = t.observer;
                try {
                    var r = S(n.next);
                    r && r.call(n, e)
                } catch (i) {
                    g(i)
                }
            }
        },
        error: function(e) {
            var t = b(this).subscription
              , n = b(t);
            if (!T(n)) {
                var r = n.observer;
                I(t, n);
                try {
                    var i = S(r.error);
                    i ? i.call(r, e) : g(e)
                } catch (o) {
                    g(o)
                }
                O(n)
            }
        },
        complete: function() {
            var e = b(this).subscription
              , t = b(e);
            if (!T(t)) {
                var n = t.observer;
                I(e, t);
                try {
                    var r = S(n.complete);
                    r && r.call(n)
                } catch (i) {
                    g(i)
                }
                O(t)
            }
        }
    }),
    i && l(w.prototype, "closed", {
        configurable: !0,
        get: function() {
            return T(b(b(this).subscription))
        }
    });
    var M = function(e) {
        u(this, M, "Observable"),
        _(this, {
            subscriber: s(e)
        })
    };
    h(M.prototype, {
        subscribe: function(e) {
            var t = arguments.length;
            return new x("function" === typeof e ? {
                next: e,
                error: t > 1 ? arguments[1] : void 0,
                complete: t > 2 ? arguments[2] : void 0
            } : c(e) ? e : {},b(this).subscriber)
        }
    }),
    h(M, {
        from: function(e) {
            var t = "function" === typeof this ? this : M
              , n = S(a(e)[v]);
            if (n) {
                var r = a(n.call(e));
                return r.constructor === t ? r : new t((function(e) {
                    return r.subscribe(e)
                }
                ))
            }
            var i = f(e);
            return new t((function(e) {
                p(i, (function(t) {
                    if (e.next(t),
                    e.closed)
                        return p.stop()
                }
                ), void 0, !1, !0),
                e.complete()
            }
            ))
        },
        of: function() {
            for (var e = "function" === typeof this ? this : M, t = arguments.length, n = new Array(t), r = 0; r < t; )
                n[r] = arguments[r++];
            return new e((function(e) {
                for (var r = 0; r < t; r++)
                    if (e.next(n[r]),
                    e.closed)
                        return;
                e.complete()
            }
            ))
        }
    }),
    d(M.prototype, v, (function() {
        return this
    }
    )),
    r({
        global: !0
    }, {
        Observable: M
    }),
    o("Observable")
}
, function(e, t, n) {
    var r = n(39);
    e.exports = function(e, t) {
        var n = r.console;
        n && n.error && (1 === arguments.length ? n.error(e) : n.error(e, t))
    }
}
, function(e, t, n) {
    n(532)
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(34)
      , o = n(208)
      , s = n(266)
      , a = n(27);
    r({
        target: "Promise",
        stat: !0
    }, {
        allSettled: function(e) {
            var t = this
              , n = o.f(t)
              , r = n.resolve
              , c = n.reject
              , u = s((function() {
                var n = i(t.resolve)
                  , o = []
                  , s = 0
                  , c = 1;
                a(e, (function(e) {
                    var i = s++
                      , a = !1;
                    o.push(void 0),
                    c++,
                    n.call(t, e).then((function(e) {
                        a || (a = !0,
                        o[i] = {
                            status: "fulfilled",
                            value: e
                        },
                        --c || r(o))
                    }
                    ), (function(e) {
                        a || (a = !0,
                        o[i] = {
                            status: "rejected",
                            reason: e
                        },
                        --c || r(o))
                    }
                    ))
                }
                )),
                --c || r(o)
            }
            ));
            return u.error && c(u.value),
            n.promise
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(34)
      , o = n(45)
      , s = n(208)
      , a = n(266)
      , c = n(27);
    r({
        target: "Promise",
        stat: !0
    }, {
        any: function(e) {
            var t = this
              , n = s.f(t)
              , r = n.resolve
              , u = n.reject
              , l = a((function() {
                var n = i(t.resolve)
                  , s = []
                  , a = 0
                  , l = 1
                  , d = !1;
                c(e, (function(e) {
                    var i = a++
                      , c = !1;
                    s.push(void 0),
                    l++,
                    n.call(t, e).then((function(e) {
                        c || d || (d = !0,
                        r(e))
                    }
                    ), (function(e) {
                        c || d || (c = !0,
                        s[i] = e,
                        --l || u(new (o("AggregateError"))(s,"No one promise resolved")))
                    }
                    ))
                }
                )),
                --l || u(new (o("AggregateError"))(s,"No one promise resolved"))
            }
            ));
            return l.error && u(l.value),
            n.promise
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(208)
      , o = n(266);
    r({
        target: "Promise",
        stat: !0
    }, {
        try: function(e) {
            var t = i.f(this)
              , n = o(e);
            return (n.error ? t.reject : t.resolve)(n.value),
            t.promise
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(96)
      , o = n(18)
      , s = i.toKey
      , a = i.set;
    r({
        target: "Reflect",
        stat: !0
    }, {
        defineMetadata: function(e, t, n) {
            var r = arguments.length < 4 ? void 0 : s(arguments[3]);
            a(e, t, o(n), r)
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(96)
      , o = n(18)
      , s = i.toKey
      , a = i.getMap
      , c = i.store;
    r({
        target: "Reflect",
        stat: !0
    }, {
        deleteMetadata: function(e, t) {
            var n = arguments.length < 3 ? void 0 : s(arguments[2])
              , r = a(o(t), n, !1);
            if (void 0 === r || !r.delete(e))
                return !1;
            if (r.size)
                return !0;
            var i = c.get(t);
            return i.delete(n),
            !!i.size || c.delete(t)
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(96)
      , o = n(18)
      , s = n(116)
      , a = i.has
      , c = i.get
      , u = i.toKey
      , l = function(e, t, n) {
        if (a(e, t, n))
            return c(e, t, n);
        var r = s(t);
        return null !== r ? l(e, r, n) : void 0
    };
    r({
        target: "Reflect",
        stat: !0
    }, {
        getMetadata: function(e, t) {
            var n = arguments.length < 3 ? void 0 : u(arguments[2]);
            return l(e, o(t), n)
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(539)
      , o = n(96)
      , s = n(18)
      , a = n(116)
      , c = n(27)
      , u = o.keys
      , l = o.toKey
      , d = function(e, t) {
        var n = u(e, t)
          , r = a(e);
        if (null === r)
            return n;
        var o = d(r, t);
        return o.length ? n.length ? function(e) {
            var t = [];
            return c(e, t.push, t),
            t
        }(new i(n.concat(o))) : o : n
    };
    r({
        target: "Reflect",
        stat: !0
    }, {
        getMetadataKeys: function(e) {
            var t = arguments.length < 2 ? void 0 : l(arguments[1]);
            return d(s(e), t)
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(264)
      , i = n(332);
    e.exports = r("Set", (function(e) {
        return function() {
            return e(this, arguments.length ? arguments[0] : void 0)
        }
    }
    ), i)
}
, function(e, t, n) {
    var r = n(10)
      , i = n(96)
      , o = n(18)
      , s = i.get
      , a = i.toKey;
    r({
        target: "Reflect",
        stat: !0
    }, {
        getOwnMetadata: function(e, t) {
            var n = arguments.length < 3 ? void 0 : a(arguments[2]);
            return s(e, o(t), n)
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(96)
      , o = n(18)
      , s = i.keys
      , a = i.toKey;
    r({
        target: "Reflect",
        stat: !0
    }, {
        getOwnMetadataKeys: function(e) {
            var t = arguments.length < 2 ? void 0 : a(arguments[1]);
            return s(o(e), t)
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(96)
      , o = n(18)
      , s = n(116)
      , a = i.has
      , c = i.toKey
      , u = function(e, t, n) {
        if (a(e, t, n))
            return !0;
        var r = s(t);
        return null !== r && u(e, r, n)
    };
    r({
        target: "Reflect",
        stat: !0
    }, {
        hasMetadata: function(e, t) {
            var n = arguments.length < 3 ? void 0 : c(arguments[2]);
            return u(e, o(t), n)
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(96)
      , o = n(18)
      , s = i.has
      , a = i.toKey;
    r({
        target: "Reflect",
        stat: !0
    }, {
        hasOwnMetadata: function(e, t) {
            var n = arguments.length < 3 ? void 0 : a(arguments[2]);
            return s(e, o(t), n)
        }
    })
}
, function(e, t, n) {
    var r = n(10)
      , i = n(96)
      , o = n(18)
      , s = i.toKey
      , a = i.set;
    r({
        target: "Reflect",
        stat: !0
    }, {
        metadata: function(e, t) {
            return function(n, r) {
                a(e, t, o(n), s(r))
            }
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(337);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        addAll: function() {
            return o.apply(this, arguments)
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(212);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        deleteAll: function() {
            return o.apply(this, arguments)
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(81)
      , u = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        difference: function(e) {
            var t = s(this)
              , n = new (c(t, o("Set")))(t)
              , r = a(n.delete);
            return u(e, (function(e) {
                r.call(n, e)
            }
            )),
            n
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(44)
      , a = n(130)
      , c = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        every: function(e) {
            var t = o(this)
              , n = a(t)
              , r = s(e, arguments.length > 1 ? arguments[1] : void 0, 3);
            return !c(n, (function(e) {
                if (!r(e, e, t))
                    return c.stop()
            }
            ), void 0, !1, !0).stopped
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(44)
      , u = n(81)
      , l = n(130)
      , d = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        filter: function(e) {
            var t = s(this)
              , n = l(t)
              , r = c(e, arguments.length > 1 ? arguments[1] : void 0, 3)
              , i = new (u(t, o("Set")))
              , h = a(i.add);
            return d(n, (function(e) {
                r(e, e, t) && h.call(i, e)
            }
            ), void 0, !1, !0),
            i
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(44)
      , a = n(130)
      , c = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        find: function(e) {
            var t = o(this)
              , n = a(t)
              , r = s(e, arguments.length > 1 ? arguments[1] : void 0, 3);
            return c(n, (function(e) {
                if (r(e, e, t))
                    return c.stop(e)
            }
            ), void 0, !1, !0).result
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Set",
        stat: !0
    }, {
        from: n(213)
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(81)
      , u = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        intersection: function(e) {
            var t = s(this)
              , n = new (c(t, o("Set")))
              , r = a(t.has)
              , i = a(n.add);
            return u(e, (function(e) {
                r.call(t, e) && i.call(n, e)
            }
            )),
            n
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(34)
      , a = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        isDisjointFrom: function(e) {
            var t = o(this)
              , n = s(t.has);
            return !a(e, (function(e) {
                if (!0 === n.call(t, e))
                    return a.stop()
            }
            )).stopped
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(175)
      , u = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        isSubsetOf: function(e) {
            var t = c(this)
              , n = s(e)
              , r = n.has;
            return "function" != typeof r && (n = new (o("Set"))(e),
            r = a(n.has)),
            !u(t, (function(e) {
                if (!1 === r.call(n, e))
                    return u.stop()
            }
            ), void 0, !1, !0).stopped
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(34)
      , a = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        isSupersetOf: function(e) {
            var t = o(this)
              , n = s(t.has);
            return !a(e, (function(e) {
                if (!1 === n.call(t, e))
                    return a.stop()
            }
            )).stopped
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(130)
      , a = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        join: function(e) {
            var t = o(this)
              , n = s(t)
              , r = void 0 === e ? "," : String(e)
              , i = [];
            return a(n, i.push, i, !1, !0),
            i.join(r)
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(44)
      , u = n(81)
      , l = n(130)
      , d = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        map: function(e) {
            var t = s(this)
              , n = l(t)
              , r = c(e, arguments.length > 1 ? arguments[1] : void 0, 3)
              , i = new (u(t, o("Set")))
              , h = a(i.add);
            return d(n, (function(e) {
                h.call(i, r(e, e, t))
            }
            ), void 0, !1, !0),
            i
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "Set",
        stat: !0
    }, {
        of: n(214)
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(34)
      , a = n(130)
      , c = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        reduce: function(e) {
            var t = o(this)
              , n = a(t)
              , r = arguments.length < 2
              , i = r ? void 0 : arguments[1];
            if (s(e),
            c(n, (function(n) {
                r ? (r = !1,
                i = n) : i = e(i, n, n, t)
            }
            ), void 0, !1, !0),
            r)
                throw TypeError("Reduce of empty set with no initial value");
            return i
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(18)
      , s = n(44)
      , a = n(130)
      , c = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        some: function(e) {
            var t = o(this)
              , n = a(t)
              , r = s(e, arguments.length > 1 ? arguments[1] : void 0, 3);
            return c(n, (function(e) {
                if (r(e, e, t))
                    return c.stop()
            }
            ), void 0, !1, !0).stopped
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(81)
      , u = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        symmetricDifference: function(e) {
            var t = s(this)
              , n = new (c(t, o("Set")))(t)
              , r = a(n.delete)
              , i = a(n.add);
            return u(e, (function(e) {
                r.call(n, e) || i.call(n, e)
            }
            )),
            n
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(45)
      , s = n(18)
      , a = n(34)
      , c = n(81)
      , u = n(27);
    r({
        target: "Set",
        proto: !0,
        real: !0,
        forced: i
    }, {
        union: function(e) {
            var t = s(this)
              , n = new (c(t, o("Set")))(t);
            return u(e, a(n.add), n),
            n
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(171).charAt;
    r({
        target: "String",
        proto: !0
    }, {
        at: function(e) {
            return i(this, e)
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(174)
      , o = n(113)
      , s = n(60)
      , a = n(171)
      , c = a.codeAt
      , u = a.charAt
      , l = s.set
      , d = s.getterFor("String Iterator")
      , h = i((function(e) {
        l(this, {
            type: "String Iterator",
            string: e,
            index: 0
        })
    }
    ), "String", (function() {
        var e, t = d(this), n = t.string, r = t.index;
        return r >= n.length ? {
            value: void 0,
            done: !0
        } : (e = u(n, r),
        t.index += e.length,
        {
            value: {
                codePoint: c(e, 0),
                position: r
            },
            done: !1
        })
    }
    ));
    r({
        target: "String",
        proto: !0
    }, {
        codePoints: function() {
            return new h(String(o(this)))
        }
    })
}
, function(e, t, n) {
    n(566)
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(174)
      , o = n(113)
      , s = n(65)
      , a = n(34)
      , c = n(18)
      , u = n(129)
      , l = n(338)
      , d = n(209)
      , h = n(64)
      , f = n(49)
      , p = n(40)
      , g = n(81)
      , m = n(320)
      , y = n(60)
      , v = n(24)
      , b = p("matchAll")
      , _ = y.set
      , S = y.getterFor("RegExp String Iterator")
      , O = RegExp.prototype
      , T = O.exec
      , I = "".matchAll
      , x = !!I && !f((function() {
        "a".matchAll(/./)
    }
    ))
      , w = i((function(e, t, n, r) {
        _(this, {
            type: "RegExp String Iterator",
            regexp: e,
            string: t,
            global: n,
            unicode: r,
            done: !1
        })
    }
    ), "RegExp String", (function() {
        var e = S(this);
        if (e.done)
            return {
                value: void 0,
                done: !0
            };
        var t = e.regexp
          , n = e.string
          , r = function(e, t) {
            var n, r = e.exec;
            if ("function" == typeof r) {
                if ("object" != typeof (n = r.call(e, t)))
                    throw TypeError("Incorrect exec result");
                return n
            }
            return T.call(e, t)
        }(t, n);
        return null === r ? {
            value: void 0,
            done: e.done = !0
        } : e.global ? ("" == String(r[0]) && (t.lastIndex = m(n, s(t.lastIndex), e.unicode)),
        {
            value: r,
            done: !1
        }) : (e.done = !0,
        {
            value: r,
            done: !1
        })
    }
    ))
      , M = function(e) {
        var t, n, r, i, o, a, u = c(this), l = String(e);
        return t = g(u, RegExp),
        void 0 === (n = u.flags) && u instanceof RegExp && !("flags"in O) && (n = d.call(u)),
        r = void 0 === n ? "" : String(n),
        i = new t(t === RegExp ? u.source : u,r),
        o = !!~r.indexOf("g"),
        a = !!~r.indexOf("u"),
        i.lastIndex = s(u.lastIndex),
        new w(i,l,o,a)
    };
    r({
        target: "String",
        proto: !0,
        forced: x
    }, {
        matchAll: function(e) {
            var t, n, r, i = o(this);
            if (null != e) {
                if (l(e) && !~String(o("flags"in O ? e.flags : d.call(e))).indexOf("g"))
                    throw TypeError("`.matchAll` does not allow non-global regexes");
                if (x)
                    return I.apply(i, arguments);
                if (void 0 === (n = e[b]) && v && "RegExp" == u(e) && (n = M),
                null != n)
                    return a(n).call(e, i)
            } else if (x)
                return I.apply(i, arguments);
            return t = String(i),
            r = new RegExp(e,"g"),
            v ? M.call(r, t) : r[b](t)
        }
    }),
    v || b in O || h(O, b, M)
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(113)
      , o = n(338)
      , s = n(209)
      , a = n(40)
      , c = n(24)
      , u = a("replace")
      , l = RegExp.prototype;
    r({
        target: "String",
        proto: !0
    }, {
        replaceAll: function e(t, n) {
            var r, a, d, h, f, p, g, m, y = i(this);
            if (null != t) {
                if ((r = o(t)) && !~String(i("flags"in l ? t.flags : s.call(t))).indexOf("g"))
                    throw TypeError("`.replaceAll` does not allow non-global regexes");
                if (void 0 !== (a = t[u]))
                    return a.call(t, y, n);
                if (c && r)
                    return String(y).replace(t, n)
            }
            if (d = String(y),
            "" === (h = String(t)))
                return e.call(d, /(?:)/g, n);
            if (f = d.split(h),
            "function" !== typeof n)
                return f.join(String(n));
            for (g = (p = f[0]).length,
            m = 1; m < f.length; m++)
                p += String(n(h, g, d)),
                g += h.length + f[m].length,
                p += f[m];
            return p
        }
    })
}
, function(e, t, n) {
    n(267)("dispose")
}
, function(e, t, n) {
    var r = n(40);
    t.f = r
}
, function(e, t, n) {
    n(267)("observable")
}
, function(e, t, n) {
    n(267)("patternMatch")
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(212);
    r({
        target: "WeakMap",
        proto: !0,
        real: !0,
        forced: i
    }, {
        deleteAll: function() {
            return o.apply(this, arguments)
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "WeakMap",
        stat: !0
    }, {
        from: n(213)
    })
}
, function(e, t, n) {
    n(10)({
        target: "WeakMap",
        stat: !0
    }, {
        of: n(214)
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(337);
    r({
        target: "WeakSet",
        proto: !0,
        real: !0,
        forced: i
    }, {
        addAll: function() {
            return o.apply(this, arguments)
        }
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(10)
      , i = n(24)
      , o = n(212);
    r({
        target: "WeakSet",
        proto: !0,
        real: !0,
        forced: i
    }, {
        deleteAll: function() {
            return o.apply(this, arguments)
        }
    })
}
, function(e, t, n) {
    n(10)({
        target: "WeakSet",
        stat: !0
    }, {
        from: n(213)
    })
}
, function(e, t, n) {
    n(10)({
        target: "WeakSet",
        stat: !0
    }, {
        of: n(214)
    })
}
, function(e, t, n) {
    var r = n(39)
      , i = n(580)
      , o = n(339)
      , s = n(64)
      , a = n(40)
      , c = a("iterator")
      , u = a("toStringTag")
      , l = o.values;
    for (var d in i) {
        var h = r[d]
          , f = h && h.prototype;
        if (f) {
            if (f[c] !== l)
                try {
                    s(f, c, l)
                } catch (g) {
                    f[c] = l
                }
            if (f[u] || s(f, u, d),
            i[d])
                for (var p in o)
                    if (f[p] !== o[p])
                        try {
                            s(f, p, o[p])
                        } catch (g) {
                            f[p] = o[p]
                        }
        }
    }
}
, function(e, t) {
    e.exports = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
    }
}
, function(e, t, n) {
    var r = n(10)
      , i = n(39)
      , o = n(582);
    r({
        global: !0,
        bind: !0,
        enumerable: !0,
        forced: !i.setImmediate || !i.clearImmediate
    }, {
        setImmediate: o.set,
        clearImmediate: o.clear
    })
}
, function(e, t, n) {
    var r, i, o, s = n(39), a = n(49), c = n(129), u = n(44), l = n(312), d = n(254), h = n(583), f = s.location, p = s.setImmediate, g = s.clearImmediate, m = s.process, y = s.MessageChannel, v = s.Dispatch, b = 0, _ = {}, S = function(e) {
        if (_.hasOwnProperty(e)) {
            var t = _[e];
            delete _[e],
            t()
        }
    }, O = function(e) {
        return function() {
            S(e)
        }
    }, T = function(e) {
        S(e.data)
    }, I = function(e) {
        s.postMessage(e + "", f.protocol + "//" + f.host)
    };
    p && g || (p = function(e) {
        for (var t = [], n = 1; arguments.length > n; )
            t.push(arguments[n++]);
        return _[++b] = function() {
            ("function" == typeof e ? e : Function(e)).apply(void 0, t)
        }
        ,
        r(b),
        b
    }
    ,
    g = function(e) {
        delete _[e]
    }
    ,
    "process" == c(m) ? r = function(e) {
        m.nextTick(O(e))
    }
    : v && v.now ? r = function(e) {
        v.now(O(e))
    }
    : y && !h ? (o = (i = new y).port2,
    i.port1.onmessage = T,
    r = u(o.postMessage, o, 1)) : !s.addEventListener || "function" != typeof postMessage || s.importScripts || a(I) || "file:" === f.protocol ? r = "onreadystatechange"in d("script") ? function(e) {
        l.appendChild(d("script")).onreadystatechange = function() {
            l.removeChild(this),
            S(e)
        }
    }
    : function(e) {
        setTimeout(O(e), 0)
    }
    : (r = I,
    s.addEventListener("message", T, !1))),
    e.exports = {
        set: p,
        clear: g
    }
}
, function(e, t, n) {
    var r = n(584);
    e.exports = /(iphone|ipod|ipad).*applewebkit/i.test(r)
}
, function(e, t, n) {
    var r = n(45);
    e.exports = r("navigator", "userAgent") || ""
}
, function(e, t, n) {
    "use strict";
    n(586);
    var r, i = n(10), o = n(53), s = n(340), a = n(39), c = n(308), u = n(94), l = n(117), d = n(56), h = n(587), f = n(588), p = n(171).codeAt, g = n(590), m = n(146), y = n(341), v = n(60), b = a.URL, _ = y.URLSearchParams, S = y.getState, O = v.set, T = v.getterFor("URL"), I = Math.floor, x = Math.pow, w = /[A-Za-z]/, M = /[\d+-.A-Za-z]/, A = /\d/, E = /^(0x|0X)/, C = /^[0-7]+$/, N = /^\d+$/, R = /^[\dA-Fa-f]+$/, P = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/, D = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/, F = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g, k = /[\u0009\u000A\u000D]/g, j = function(e, t) {
        var n, r, i;
        if ("[" == t.charAt(0)) {
            if ("]" != t.charAt(t.length - 1))
                return "Invalid host";
            if (!(n = V(t.slice(1, -1))))
                return "Invalid host";
            e.host = n
        } else if (K(e)) {
            if (t = g(t),
            P.test(t))
                return "Invalid host";
            if (null === (n = L(t)))
                return "Invalid host";
            e.host = n
        } else {
            if (D.test(t))
                return "Invalid host";
            for (n = "",
            r = f(t),
            i = 0; i < r.length; i++)
                n += z(r[i], q);
            e.host = n
        }
    }, L = function(e) {
        var t, n, r, i, o, s, a, c = e.split(".");
        if (c.length && "" == c[c.length - 1] && c.pop(),
        (t = c.length) > 4)
            return e;
        for (n = [],
        r = 0; r < t; r++) {
            if ("" == (i = c[r]))
                return e;
            if (o = 10,
            i.length > 1 && "0" == i.charAt(0) && (o = E.test(i) ? 16 : 8,
            i = i.slice(8 == o ? 1 : 2)),
            "" === i)
                s = 0;
            else {
                if (!(10 == o ? N : 8 == o ? C : R).test(i))
                    return e;
                s = parseInt(i, o)
            }
            n.push(s)
        }
        for (r = 0; r < t; r++)
            if (s = n[r],
            r == t - 1) {
                if (s >= x(256, 5 - t))
                    return null
            } else if (s > 255)
                return null;
        for (a = n.pop(),
        r = 0; r < n.length; r++)
            a += n[r] * x(256, 3 - r);
        return a
    }, V = function(e) {
        var t, n, r, i, o, s, a, c = [0, 0, 0, 0, 0, 0, 0, 0], u = 0, l = null, d = 0, h = function() {
            return e.charAt(d)
        };
        if (":" == h()) {
            if (":" != e.charAt(1))
                return;
            d += 2,
            l = ++u
        }
        for (; h(); ) {
            if (8 == u)
                return;
            if (":" != h()) {
                for (t = n = 0; n < 4 && R.test(h()); )
                    t = 16 * t + parseInt(h(), 16),
                    d++,
                    n++;
                if ("." == h()) {
                    if (0 == n)
                        return;
                    if (d -= n,
                    u > 6)
                        return;
                    for (r = 0; h(); ) {
                        if (i = null,
                        r > 0) {
                            if (!("." == h() && r < 4))
                                return;
                            d++
                        }
                        if (!A.test(h()))
                            return;
                        for (; A.test(h()); ) {
                            if (o = parseInt(h(), 10),
                            null === i)
                                i = o;
                            else {
                                if (0 == i)
                                    return;
                                i = 10 * i + o
                            }
                            if (i > 255)
                                return;
                            d++
                        }
                        c[u] = 256 * c[u] + i,
                        2 != ++r && 4 != r || u++
                    }
                    if (4 != r)
                        return;
                    break
                }
                if (":" == h()) {
                    if (d++,
                    !h())
                        return
                } else if (h())
                    return;
                c[u++] = t
            } else {
                if (null !== l)
                    return;
                d++,
                l = ++u
            }
        }
        if (null !== l)
            for (s = u - l,
            u = 7; 0 != u && s > 0; )
                a = c[u],
                c[u--] = c[l + s - 1],
                c[l + --s] = a;
        else if (8 != u)
            return;
        return c
    }, U = function(e) {
        var t, n, r, i;
        if ("number" == typeof e) {
            for (t = [],
            n = 0; n < 4; n++)
                t.unshift(e % 256),
                e = I(e / 256);
            return t.join(".")
        }
        if ("object" == typeof e) {
            for (t = "",
            r = function(e) {
                for (var t = null, n = 1, r = null, i = 0, o = 0; o < 8; o++)
                    0 !== e[o] ? (i > n && (t = r,
                    n = i),
                    r = null,
                    i = 0) : (null === r && (r = o),
                    ++i);
                return i > n && (t = r,
                n = i),
                t
            }(e),
            n = 0; n < 8; n++)
                i && 0 === e[n] || (i && (i = !1),
                r === n ? (t += n ? ":" : "::",
                i = !0) : (t += e[n].toString(16),
                n < 7 && (t += ":")));
            return "[" + t + "]"
        }
        return e
    }, q = {}, Q = h({}, q, {
        " ": 1,
        '"': 1,
        "<": 1,
        ">": 1,
        "`": 1
    }), B = h({}, Q, {
        "#": 1,
        "?": 1,
        "{": 1,
        "}": 1
    }), G = h({}, B, {
        "/": 1,
        ":": 1,
        ";": 1,
        "=": 1,
        "@": 1,
        "[": 1,
        "\\": 1,
        "]": 1,
        "^": 1,
        "|": 1
    }), z = function(e, t) {
        var n = p(e, 0);
        return n > 32 && n < 127 && !d(t, e) ? e : encodeURIComponent(e)
    }, H = {
        ftp: 21,
        file: null,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
    }, K = function(e) {
        return d(H, e.scheme)
    }, Y = function(e) {
        return "" != e.username || "" != e.password
    }, W = function(e) {
        return !e.host || e.cannotBeABaseURL || "file" == e.scheme
    }, $ = function(e, t) {
        var n;
        return 2 == e.length && w.test(e.charAt(0)) && (":" == (n = e.charAt(1)) || !t && "|" == n)
    }, X = function(e) {
        var t;
        return e.length > 1 && $(e.slice(0, 2)) && (2 == e.length || "/" === (t = e.charAt(2)) || "\\" === t || "?" === t || "#" === t)
    }, J = function(e) {
        var t = e.path
          , n = t.length;
        !n || "file" == e.scheme && 1 == n && $(t[0], !0) || t.pop()
    }, Z = function(e) {
        return "." === e || "%2e" === e.toLowerCase()
    }, ee = {}, te = {}, ne = {}, re = {}, ie = {}, oe = {}, se = {}, ae = {}, ce = {}, ue = {}, le = {}, de = {}, he = {}, fe = {}, pe = {}, ge = {}, me = {}, ye = {}, ve = {}, be = {}, _e = {}, Se = function(e, t, n, i) {
        var o, s, a, c, u, l = n || ee, h = 0, p = "", g = !1, m = !1, y = !1;
        for (n || (e.scheme = "",
        e.username = "",
        e.password = "",
        e.host = null,
        e.port = null,
        e.path = [],
        e.query = null,
        e.fragment = null,
        e.cannotBeABaseURL = !1,
        t = t.replace(F, "")),
        t = t.replace(k, ""),
        o = f(t); h <= o.length; ) {
            switch (s = o[h],
            l) {
            case ee:
                if (!s || !w.test(s)) {
                    if (n)
                        return "Invalid scheme";
                    l = ne;
                    continue
                }
                p += s.toLowerCase(),
                l = te;
                break;
            case te:
                if (s && (M.test(s) || "+" == s || "-" == s || "." == s))
                    p += s.toLowerCase();
                else {
                    if (":" != s) {
                        if (n)
                            return "Invalid scheme";
                        p = "",
                        l = ne,
                        h = 0;
                        continue
                    }
                    if (n && (K(e) != d(H, p) || "file" == p && (Y(e) || null !== e.port) || "file" == e.scheme && !e.host))
                        return;
                    if (e.scheme = p,
                    n)
                        return void (K(e) && H[e.scheme] == e.port && (e.port = null));
                    p = "",
                    "file" == e.scheme ? l = fe : K(e) && i && i.scheme == e.scheme ? l = re : K(e) ? l = ae : "/" == o[h + 1] ? (l = ie,
                    h++) : (e.cannotBeABaseURL = !0,
                    e.path.push(""),
                    l = ve)
                }
                break;
            case ne:
                if (!i || i.cannotBeABaseURL && "#" != s)
                    return "Invalid scheme";
                if (i.cannotBeABaseURL && "#" == s) {
                    e.scheme = i.scheme,
                    e.path = i.path.slice(),
                    e.query = i.query,
                    e.fragment = "",
                    e.cannotBeABaseURL = !0,
                    l = _e;
                    break
                }
                l = "file" == i.scheme ? fe : oe;
                continue;
            case re:
                if ("/" != s || "/" != o[h + 1]) {
                    l = oe;
                    continue
                }
                l = ce,
                h++;
                break;
            case ie:
                if ("/" == s) {
                    l = ue;
                    break
                }
                l = ye;
                continue;
            case oe:
                if (e.scheme = i.scheme,
                s == r)
                    e.username = i.username,
                    e.password = i.password,
                    e.host = i.host,
                    e.port = i.port,
                    e.path = i.path.slice(),
                    e.query = i.query;
                else if ("/" == s || "\\" == s && K(e))
                    l = se;
                else if ("?" == s)
                    e.username = i.username,
                    e.password = i.password,
                    e.host = i.host,
                    e.port = i.port,
                    e.path = i.path.slice(),
                    e.query = "",
                    l = be;
                else {
                    if ("#" != s) {
                        e.username = i.username,
                        e.password = i.password,
                        e.host = i.host,
                        e.port = i.port,
                        e.path = i.path.slice(),
                        e.path.pop(),
                        l = ye;
                        continue
                    }
                    e.username = i.username,
                    e.password = i.password,
                    e.host = i.host,
                    e.port = i.port,
                    e.path = i.path.slice(),
                    e.query = i.query,
                    e.fragment = "",
                    l = _e
                }
                break;
            case se:
                if (!K(e) || "/" != s && "\\" != s) {
                    if ("/" != s) {
                        e.username = i.username,
                        e.password = i.password,
                        e.host = i.host,
                        e.port = i.port,
                        l = ye;
                        continue
                    }
                    l = ue
                } else
                    l = ce;
                break;
            case ae:
                if (l = ce,
                "/" != s || "/" != p.charAt(h + 1))
                    continue;
                h++;
                break;
            case ce:
                if ("/" != s && "\\" != s) {
                    l = ue;
                    continue
                }
                break;
            case ue:
                if ("@" == s) {
                    g && (p = "%40" + p),
                    g = !0,
                    a = f(p);
                    for (var v = 0; v < a.length; v++) {
                        var b = a[v];
                        if (":" != b || y) {
                            var _ = z(b, G);
                            y ? e.password += _ : e.username += _
                        } else
                            y = !0
                    }
                    p = ""
                } else if (s == r || "/" == s || "?" == s || "#" == s || "\\" == s && K(e)) {
                    if (g && "" == p)
                        return "Invalid authority";
                    h -= f(p).length + 1,
                    p = "",
                    l = le
                } else
                    p += s;
                break;
            case le:
            case de:
                if (n && "file" == e.scheme) {
                    l = ge;
                    continue
                }
                if (":" != s || m) {
                    if (s == r || "/" == s || "?" == s || "#" == s || "\\" == s && K(e)) {
                        if (K(e) && "" == p)
                            return "Invalid host";
                        if (n && "" == p && (Y(e) || null !== e.port))
                            return;
                        if (c = j(e, p))
                            return c;
                        if (p = "",
                        l = me,
                        n)
                            return;
                        continue
                    }
                    "[" == s ? m = !0 : "]" == s && (m = !1),
                    p += s
                } else {
                    if ("" == p)
                        return "Invalid host";
                    if (c = j(e, p))
                        return c;
                    if (p = "",
                    l = he,
                    n == de)
                        return
                }
                break;
            case he:
                if (!A.test(s)) {
                    if (s == r || "/" == s || "?" == s || "#" == s || "\\" == s && K(e) || n) {
                        if ("" != p) {
                            var S = parseInt(p, 10);
                            if (S > 65535)
                                return "Invalid port";
                            e.port = K(e) && S === H[e.scheme] ? null : S,
                            p = ""
                        }
                        if (n)
                            return;
                        l = me;
                        continue
                    }
                    return "Invalid port"
                }
                p += s;
                break;
            case fe:
                if (e.scheme = "file",
                "/" == s || "\\" == s)
                    l = pe;
                else {
                    if (!i || "file" != i.scheme) {
                        l = ye;
                        continue
                    }
                    if (s == r)
                        e.host = i.host,
                        e.path = i.path.slice(),
                        e.query = i.query;
                    else if ("?" == s)
                        e.host = i.host,
                        e.path = i.path.slice(),
                        e.query = "",
                        l = be;
                    else {
                        if ("#" != s) {
                            X(o.slice(h).join("")) || (e.host = i.host,
                            e.path = i.path.slice(),
                            J(e)),
                            l = ye;
                            continue
                        }
                        e.host = i.host,
                        e.path = i.path.slice(),
                        e.query = i.query,
                        e.fragment = "",
                        l = _e
                    }
                }
                break;
            case pe:
                if ("/" == s || "\\" == s) {
                    l = ge;
                    break
                }
                i && "file" == i.scheme && !X(o.slice(h).join("")) && ($(i.path[0], !0) ? e.path.push(i.path[0]) : e.host = i.host),
                l = ye;
                continue;
            case ge:
                if (s == r || "/" == s || "\\" == s || "?" == s || "#" == s) {
                    if (!n && $(p))
                        l = ye;
                    else if ("" == p) {
                        if (e.host = "",
                        n)
                            return;
                        l = me
                    } else {
                        if (c = j(e, p))
                            return c;
                        if ("localhost" == e.host && (e.host = ""),
                        n)
                            return;
                        p = "",
                        l = me
                    }
                    continue
                }
                p += s;
                break;
            case me:
                if (K(e)) {
                    if (l = ye,
                    "/" != s && "\\" != s)
                        continue
                } else if (n || "?" != s)
                    if (n || "#" != s) {
                        if (s != r && (l = ye,
                        "/" != s))
                            continue
                    } else
                        e.fragment = "",
                        l = _e;
                else
                    e.query = "",
                    l = be;
                break;
            case ye:
                if (s == r || "/" == s || "\\" == s && K(e) || !n && ("?" == s || "#" == s)) {
                    if (".." === (u = (u = p).toLowerCase()) || "%2e." === u || ".%2e" === u || "%2e%2e" === u ? (J(e),
                    "/" == s || "\\" == s && K(e) || e.path.push("")) : Z(p) ? "/" == s || "\\" == s && K(e) || e.path.push("") : ("file" == e.scheme && !e.path.length && $(p) && (e.host && (e.host = ""),
                    p = p.charAt(0) + ":"),
                    e.path.push(p)),
                    p = "",
                    "file" == e.scheme && (s == r || "?" == s || "#" == s))
                        for (; e.path.length > 1 && "" === e.path[0]; )
                            e.path.shift();
                    "?" == s ? (e.query = "",
                    l = be) : "#" == s && (e.fragment = "",
                    l = _e)
                } else
                    p += z(s, B);
                break;
            case ve:
                "?" == s ? (e.query = "",
                l = be) : "#" == s ? (e.fragment = "",
                l = _e) : s != r && (e.path[0] += z(s, q));
                break;
            case be:
                n || "#" != s ? s != r && ("'" == s && K(e) ? e.query += "%27" : e.query += "#" == s ? "%23" : z(s, q)) : (e.fragment = "",
                l = _e);
                break;
            case _e:
                s != r && (e.fragment += z(s, Q))
            }
            h++
        }
    }, Oe = function(e) {
        var t, n, r = l(this, Oe, "URL"), i = arguments.length > 1 ? arguments[1] : void 0, s = String(e), a = O(r, {
            type: "URL"
        });
        if (void 0 !== i)
            if (i instanceof Oe)
                t = T(i);
            else if (n = Se(t = {}, String(i)))
                throw TypeError(n);
        if (n = Se(a, s, null, t))
            throw TypeError(n);
        var c = a.searchParams = new _
          , u = S(c);
        u.updateSearchParams(a.query),
        u.updateURL = function() {
            a.query = String(c) || null
        }
        ,
        o || (r.href = Ie.call(r),
        r.origin = xe.call(r),
        r.protocol = we.call(r),
        r.username = Me.call(r),
        r.password = Ae.call(r),
        r.host = Ee.call(r),
        r.hostname = Ce.call(r),
        r.port = Ne.call(r),
        r.pathname = Re.call(r),
        r.search = Pe.call(r),
        r.searchParams = De.call(r),
        r.hash = Fe.call(r))
    }, Te = Oe.prototype, Ie = function() {
        var e = T(this)
          , t = e.scheme
          , n = e.username
          , r = e.password
          , i = e.host
          , o = e.port
          , s = e.path
          , a = e.query
          , c = e.fragment
          , u = t + ":";
        return null !== i ? (u += "//",
        Y(e) && (u += n + (r ? ":" + r : "") + "@"),
        u += U(i),
        null !== o && (u += ":" + o)) : "file" == t && (u += "//"),
        u += e.cannotBeABaseURL ? s[0] : s.length ? "/" + s.join("/") : "",
        null !== a && (u += "?" + a),
        null !== c && (u += "#" + c),
        u
    }, xe = function() {
        var e = T(this)
          , t = e.scheme
          , n = e.port;
        if ("blob" == t)
            try {
                return new URL(t.path[0]).origin
            } catch (r) {
                return "null"
            }
        return "file" != t && K(e) ? t + "://" + U(e.host) + (null !== n ? ":" + n : "") : "null"
    }, we = function() {
        return T(this).scheme + ":"
    }, Me = function() {
        return T(this).username
    }, Ae = function() {
        return T(this).password
    }, Ee = function() {
        var e = T(this)
          , t = e.host
          , n = e.port;
        return null === t ? "" : null === n ? U(t) : U(t) + ":" + n
    }, Ce = function() {
        var e = T(this).host;
        return null === e ? "" : U(e)
    }, Ne = function() {
        var e = T(this).port;
        return null === e ? "" : String(e)
    }, Re = function() {
        var e = T(this)
          , t = e.path;
        return e.cannotBeABaseURL ? t[0] : t.length ? "/" + t.join("/") : ""
    }, Pe = function() {
        var e = T(this).query;
        return e ? "?" + e : ""
    }, De = function() {
        return T(this).searchParams
    }, Fe = function() {
        var e = T(this).fragment;
        return e ? "#" + e : ""
    }, ke = function(e, t) {
        return {
            get: e,
            set: t,
            configurable: !0,
            enumerable: !0
        }
    };
    if (o && c(Te, {
        href: ke(Ie, (function(e) {
            var t = T(this)
              , n = String(e)
              , r = Se(t, n);
            if (r)
                throw TypeError(r);
            S(t.searchParams).updateSearchParams(t.query)
        }
        )),
        origin: ke(xe),
        protocol: ke(we, (function(e) {
            var t = T(this);
            Se(t, String(e) + ":", ee)
        }
        )),
        username: ke(Me, (function(e) {
            var t = T(this)
              , n = f(String(e));
            if (!W(t)) {
                t.username = "";
                for (var r = 0; r < n.length; r++)
                    t.username += z(n[r], G)
            }
        }
        )),
        password: ke(Ae, (function(e) {
            var t = T(this)
              , n = f(String(e));
            if (!W(t)) {
                t.password = "";
                for (var r = 0; r < n.length; r++)
                    t.password += z(n[r], G)
            }
        }
        )),
        host: ke(Ee, (function(e) {
            var t = T(this);
            t.cannotBeABaseURL || Se(t, String(e), le)
        }
        )),
        hostname: ke(Ce, (function(e) {
            var t = T(this);
            t.cannotBeABaseURL || Se(t, String(e), de)
        }
        )),
        port: ke(Ne, (function(e) {
            var t = T(this);
            W(t) || ("" == (e = String(e)) ? t.port = null : Se(t, e, he))
        }
        )),
        pathname: ke(Re, (function(e) {
            var t = T(this);
            t.cannotBeABaseURL || (t.path = [],
            Se(t, e + "", me))
        }
        )),
        search: ke(Pe, (function(e) {
            var t = T(this);
            "" == (e = String(e)) ? t.query = null : ("?" == e.charAt(0) && (e = e.slice(1)),
            t.query = "",
            Se(t, e, be)),
            S(t.searchParams).updateSearchParams(t.query)
        }
        )),
        searchParams: ke(De),
        hash: ke(Fe, (function(e) {
            var t = T(this);
            "" != (e = String(e)) ? ("#" == e.charAt(0) && (e = e.slice(1)),
            t.fragment = "",
            Se(t, e, _e)) : t.fragment = null
        }
        ))
    }),
    u(Te, "toJSON", (function() {
        return Ie.call(this)
    }
    ), {
        enumerable: !0
    }),
    u(Te, "toString", (function() {
        return Ie.call(this)
    }
    ), {
        enumerable: !0
    }),
    b) {
        var je = b.createObjectURL
          , Le = b.revokeObjectURL;
        je && u(Oe, "createObjectURL", (function(e) {
            return je.apply(b, arguments)
        }
        )),
        Le && u(Oe, "revokeObjectURL", (function(e) {
            return Le.apply(b, arguments)
        }
        ))
    }
    m(Oe, "URL"),
    i({
        global: !0,
        forced: !s,
        sham: !o
    }, {
        URL: Oe
    })
}
, function(e, t, n) {
    "use strict";
    var r = n(171).charAt
      , i = n(60)
      , o = n(265)
      , s = i.set
      , a = i.getterFor("String Iterator");
    o(String, "String", (function(e) {
        s(this, {
            type: "String Iterator",
            string: String(e),
            index: 0
        })
    }
    ), (function() {
        var e, t = a(this), n = t.string, i = t.index;
        return i >= n.length ? {
            value: void 0,
            done: !0
        } : (e = r(n, i),
        t.index += e.length,
        {
            value: e,
            done: !1
        })
    }
    ))
}
, function(e, t, n) {
    "use strict";
    var r = n(53)
      , i = n(49)
      , o = n(309)
      , s = n(317)
      , a = n(314)
      , c = n(87)
      , u = n(255)
      , l = Object.assign
      , d = Object.defineProperty;
    e.exports = !l || i((function() {
        if (r && 1 !== l({
            b: 1
        }, l(d({}, "a", {
            enumerable: !0,
            get: function() {
                d(this, "b", {
                    value: 3,
                    enumerable: !1
                })
            }
        }), {
            b: 2
        })).b)
            return !0;
        var e = {}
          , t = {}
          , n = Symbol();
        return e[n] = 7,
        "abcdefghijklmnopqrst".split("").forEach((function(e) {
            t[e] = e
        }
        )),
        7 != l({}, e)[n] || "abcdefghijklmnopqrst" != o(l({}, t)).join("")
    }
    )) ? function(e, t) {
        for (var n = c(e), i = arguments.length, l = 1, d = s.f, h = a.f; i > l; )
            for (var f, p = u(arguments[l++]), g = d ? o(p).concat(d(p)) : o(p), m = g.length, y = 0; m > y; )
                f = g[y++],
                r && !h.call(p, f) || (n[f] = p[f]);
        return n
    }
    : l
}
, function(e, t, n) {
    "use strict";
    var r = n(44)
      , i = n(87)
      , o = n(329)
      , s = n(262)
      , a = n(65)
      , c = n(589)
      , u = n(172);
    e.exports = function(e) {
        var t, n, l, d, h, f, p = i(e), g = "function" == typeof this ? this : Array, m = arguments.length, y = m > 1 ? arguments[1] : void 0, v = void 0 !== y, b = u(p), _ = 0;
        if (v && (y = r(y, m > 2 ? arguments[2] : void 0, 2)),
        void 0 == b || g == Array && s(b))
            for (n = new g(t = a(p.length)); t > _; _++)
                f = v ? y(p[_], _) : p[_],
                c(n, _, f);
        else
            for (h = (d = b.call(p)).next,
            n = new g; !(l = h.call(d)).done; _++)
                f = v ? o(d, y, [l.value, _], !0) : l.value,
                c(n, _, f);
        return n.length = _,
        n
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(204)
      , i = n(50)
      , o = n(128);
    e.exports = function(e, t, n) {
        var s = r(t);
        s in e ? i.f(e, s, o(0, n)) : e[s] = n
    }
}
, function(e, t, n) {
    "use strict";
    var r = /[^\0-\u007E]/
      , i = /[.\u3002\uFF0E\uFF61]/g
      , o = "Overflow: input needs wider integers to process"
      , s = Math.floor
      , a = String.fromCharCode
      , c = function(e) {
        return e + 22 + 75 * (e < 26)
    }
      , u = function(e, t, n) {
        var r = 0;
        for (e = n ? s(e / 700) : e >> 1,
        e += s(e / t); e > 455; r += 36)
            e = s(e / 35);
        return s(r + 36 * e / (e + 38))
    }
      , l = function(e) {
        var t, n, r = [], i = (e = function(e) {
            for (var t = [], n = 0, r = e.length; n < r; ) {
                var i = e.charCodeAt(n++);
                if (i >= 55296 && i <= 56319 && n < r) {
                    var o = e.charCodeAt(n++);
                    56320 == (64512 & o) ? t.push(((1023 & i) << 10) + (1023 & o) + 65536) : (t.push(i),
                    n--)
                } else
                    t.push(i)
            }
            return t
        }(e)).length, l = 128, d = 0, h = 72;
        for (t = 0; t < e.length; t++)
            (n = e[t]) < 128 && r.push(a(n));
        var f = r.length
          , p = f;
        for (f && r.push("-"); p < i; ) {
            var g = 2147483647;
            for (t = 0; t < e.length; t++)
                (n = e[t]) >= l && n < g && (g = n);
            var m = p + 1;
            if (g - l > s((2147483647 - d) / m))
                throw RangeError(o);
            for (d += (g - l) * m,
            l = g,
            t = 0; t < e.length; t++) {
                if ((n = e[t]) < l && ++d > 2147483647)
                    throw RangeError(o);
                if (n == l) {
                    for (var y = d, v = 36; ; v += 36) {
                        var b = v <= h ? 1 : v >= h + 26 ? 26 : v - h;
                        if (y < b)
                            break;
                        var _ = y - b
                          , S = 36 - b;
                        r.push(a(c(b + _ % S))),
                        y = s(_ / S)
                    }
                    r.push(a(c(y))),
                    h = u(d, m, p == f),
                    d = 0,
                    ++p
                }
            }
            ++d,
            ++l
        }
        return r.join("")
    };
    e.exports = function(e) {
        var t, n, o = [], s = e.toLowerCase().replace(i, ".").split(".");
        for (t = 0; t < s.length; t++)
            n = s[t],
            o.push(r.test(n) ? "xn--" + l(n) : n);
        return o.join(".")
    }
}
, function(e, t, n) {
    "use strict";
    n(10)({
        target: "URL",
        proto: !0,
        enumerable: !0
    }, {
        toJSON: function() {
            return URL.prototype.toString.call(this)
        }
    })
}
, function(e, t, n) {
    "use strict";
    (function(e) {
        var r = n(593)
          , i = n(594)
          , o = n(595);
        function s() {
            return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }
        function a(e, t) {
            if (s() < t)
                throw new RangeError("Invalid typed array length");
            return c.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = c.prototype : (null === e && (e = new c(t)),
            e.length = t),
            e
        }
        function c(e, t, n) {
            if (!c.TYPED_ARRAY_SUPPORT && !(this instanceof c))
                return new c(e,t,n);
            if ("number" === typeof e) {
                if ("string" === typeof t)
                    throw new Error("If encoding is specified then the first argument must be a string");
                return d(this, e)
            }
            return u(this, e, t, n)
        }
        function u(e, t, n, r) {
            if ("number" === typeof t)
                throw new TypeError('"value" argument must not be a number');
            return "undefined" !== typeof ArrayBuffer && t instanceof ArrayBuffer ? function(e, t, n, r) {
                if (t.byteLength,
                n < 0 || t.byteLength < n)
                    throw new RangeError("'offset' is out of bounds");
                if (t.byteLength < n + (r || 0))
                    throw new RangeError("'length' is out of bounds");
                t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t,n) : new Uint8Array(t,n,r);
                c.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = c.prototype : e = h(e, t);
                return e
            }(e, t, n, r) : "string" === typeof t ? function(e, t, n) {
                "string" === typeof n && "" !== n || (n = "utf8");
                if (!c.isEncoding(n))
                    throw new TypeError('"encoding" must be a valid string encoding');
                var r = 0 | p(t, n)
                  , i = (e = a(e, r)).write(t, n);
                i !== r && (e = e.slice(0, i));
                return e
            }(e, t, n) : function(e, t) {
                if (c.isBuffer(t)) {
                    var n = 0 | f(t.length);
                    return 0 === (e = a(e, n)).length || t.copy(e, 0, 0, n),
                    e
                }
                if (t) {
                    if ("undefined" !== typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length"in t)
                        return "number" !== typeof t.length || (r = t.length) !== r ? a(e, 0) : h(e, t);
                    if ("Buffer" === t.type && o(t.data))
                        return h(e, t.data)
                }
                var r;
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
            }(e, t)
        }
        function l(e) {
            if ("number" !== typeof e)
                throw new TypeError('"size" argument must be a number');
            if (e < 0)
                throw new RangeError('"size" argument must not be negative')
        }
        function d(e, t) {
            if (l(t),
            e = a(e, t < 0 ? 0 : 0 | f(t)),
            !c.TYPED_ARRAY_SUPPORT)
                for (var n = 0; n < t; ++n)
                    e[n] = 0;
            return e
        }
        function h(e, t) {
            var n = t.length < 0 ? 0 : 0 | f(t.length);
            e = a(e, n);
            for (var r = 0; r < n; r += 1)
                e[r] = 255 & t[r];
            return e
        }
        function f(e) {
            if (e >= s())
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s().toString(16) + " bytes");
            return 0 | e
        }
        function p(e, t) {
            if (c.isBuffer(e))
                return e.length;
            if ("undefined" !== typeof ArrayBuffer && "function" === typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))
                return e.byteLength;
            "string" !== typeof e && (e = "" + e);
            var n = e.length;
            if (0 === n)
                return 0;
            for (var r = !1; ; )
                switch (t) {
                case "ascii":
                case "latin1":
                case "binary":
                    return n;
                case "utf8":
                case "utf-8":
                case void 0:
                    return U(e).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return 2 * n;
                case "hex":
                    return n >>> 1;
                case "base64":
                    return q(e).length;
                default:
                    if (r)
                        return U(e).length;
                    t = ("" + t).toLowerCase(),
                    r = !0
                }
        }
        function g(e, t, n) {
            var r = !1;
            if ((void 0 === t || t < 0) && (t = 0),
            t > this.length)
                return "";
            if ((void 0 === n || n > this.length) && (n = this.length),
            n <= 0)
                return "";
            if ((n >>>= 0) <= (t >>>= 0))
                return "";
            for (e || (e = "utf8"); ; )
                switch (e) {
                case "hex":
                    return E(this, t, n);
                case "utf8":
                case "utf-8":
                    return w(this, t, n);
                case "ascii":
                    return M(this, t, n);
                case "latin1":
                case "binary":
                    return A(this, t, n);
                case "base64":
                    return x(this, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return C(this, t, n);
                default:
                    if (r)
                        throw new TypeError("Unknown encoding: " + e);
                    e = (e + "").toLowerCase(),
                    r = !0
                }
        }
        function m(e, t, n) {
            var r = e[t];
            e[t] = e[n],
            e[n] = r
        }
        function y(e, t, n, r, i) {
            if (0 === e.length)
                return -1;
            if ("string" === typeof n ? (r = n,
            n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648),
            n = +n,
            isNaN(n) && (n = i ? 0 : e.length - 1),
            n < 0 && (n = e.length + n),
            n >= e.length) {
                if (i)
                    return -1;
                n = e.length - 1
            } else if (n < 0) {
                if (!i)
                    return -1;
                n = 0
            }
            if ("string" === typeof t && (t = c.from(t, r)),
            c.isBuffer(t))
                return 0 === t.length ? -1 : v(e, t, n, r, i);
            if ("number" === typeof t)
                return t &= 255,
                c.TYPED_ARRAY_SUPPORT && "function" === typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : v(e, [t], n, r, i);
            throw new TypeError("val must be string, number or Buffer")
        }
        function v(e, t, n, r, i) {
            var o, s = 1, a = e.length, c = t.length;
            if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                if (e.length < 2 || t.length < 2)
                    return -1;
                s = 2,
                a /= 2,
                c /= 2,
                n /= 2
            }
            function u(e, t) {
                return 1 === s ? e[t] : e.readUInt16BE(t * s)
            }
            if (i) {
                var l = -1;
                for (o = n; o < a; o++)
                    if (u(e, o) === u(t, -1 === l ? 0 : o - l)) {
                        if (-1 === l && (l = o),
                        o - l + 1 === c)
                            return l * s
                    } else
                        -1 !== l && (o -= o - l),
                        l = -1
            } else
                for (n + c > a && (n = a - c),
                o = n; o >= 0; o--) {
                    for (var d = !0, h = 0; h < c; h++)
                        if (u(e, o + h) !== u(t, h)) {
                            d = !1;
                            break
                        }
                    if (d)
                        return o
                }
            return -1
        }
        function b(e, t, n, r) {
            n = Number(n) || 0;
            var i = e.length - n;
            r ? (r = Number(r)) > i && (r = i) : r = i;
            var o = t.length;
            if (o % 2 !== 0)
                throw new TypeError("Invalid hex string");
            r > o / 2 && (r = o / 2);
            for (var s = 0; s < r; ++s) {
                var a = parseInt(t.substr(2 * s, 2), 16);
                if (isNaN(a))
                    return s;
                e[n + s] = a
            }
            return s
        }
        function _(e, t, n, r) {
            return Q(U(t, e.length - n), e, n, r)
        }
        function S(e, t, n, r) {
            return Q(function(e) {
                for (var t = [], n = 0; n < e.length; ++n)
                    t.push(255 & e.charCodeAt(n));
                return t
            }(t), e, n, r)
        }
        function O(e, t, n, r) {
            return S(e, t, n, r)
        }
        function T(e, t, n, r) {
            return Q(q(t), e, n, r)
        }
        function I(e, t, n, r) {
            return Q(function(e, t) {
                for (var n, r, i, o = [], s = 0; s < e.length && !((t -= 2) < 0); ++s)
                    n = e.charCodeAt(s),
                    r = n >> 8,
                    i = n % 256,
                    o.push(i),
                    o.push(r);
                return o
            }(t, e.length - n), e, n, r)
        }
        function x(e, t, n) {
            return 0 === t && n === e.length ? r.fromByteArray(e) : r.fromByteArray(e.slice(t, n))
        }
        function w(e, t, n) {
            n = Math.min(e.length, n);
            for (var r = [], i = t; i < n; ) {
                var o, s, a, c, u = e[i], l = null, d = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
                if (i + d <= n)
                    switch (d) {
                    case 1:
                        u < 128 && (l = u);
                        break;
                    case 2:
                        128 === (192 & (o = e[i + 1])) && (c = (31 & u) << 6 | 63 & o) > 127 && (l = c);
                        break;
                    case 3:
                        o = e[i + 1],
                        s = e[i + 2],
                        128 === (192 & o) && 128 === (192 & s) && (c = (15 & u) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (c < 55296 || c > 57343) && (l = c);
                        break;
                    case 4:
                        o = e[i + 1],
                        s = e[i + 2],
                        a = e[i + 3],
                        128 === (192 & o) && 128 === (192 & s) && 128 === (192 & a) && (c = (15 & u) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && c < 1114112 && (l = c)
                    }
                null === l ? (l = 65533,
                d = 1) : l > 65535 && (l -= 65536,
                r.push(l >>> 10 & 1023 | 55296),
                l = 56320 | 1023 & l),
                r.push(l),
                i += d
            }
            return function(e) {
                var t = e.length;
                if (t <= 4096)
                    return String.fromCharCode.apply(String, e);
                var n = ""
                  , r = 0;
                for (; r < t; )
                    n += String.fromCharCode.apply(String, e.slice(r, r += 4096));
                return n
            }(r)
        }
        t.Buffer = c,
        t.SlowBuffer = function(e) {
            +e != e && (e = 0);
            return c.alloc(+e)
        }
        ,
        t.INSPECT_MAX_BYTES = 50,
        c.TYPED_ARRAY_SUPPORT = void 0 !== e.TYPED_ARRAY_SUPPORT ? e.TYPED_ARRAY_SUPPORT : function() {
            try {
                var e = new Uint8Array(1);
                return e.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42
                    }
                },
                42 === e.foo() && "function" === typeof e.subarray && 0 === e.subarray(1, 1).byteLength
            } catch (t) {
                return !1
            }
        }(),
        t.kMaxLength = s(),
        c.poolSize = 8192,
        c._augment = function(e) {
            return e.__proto__ = c.prototype,
            e
        }
        ,
        c.from = function(e, t, n) {
            return u(null, e, t, n)
        }
        ,
        c.TYPED_ARRAY_SUPPORT && (c.prototype.__proto__ = Uint8Array.prototype,
        c.__proto__ = Uint8Array,
        "undefined" !== typeof Symbol && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, {
            value: null,
            configurable: !0
        })),
        c.alloc = function(e, t, n) {
            return function(e, t, n, r) {
                return l(t),
                t <= 0 ? a(e, t) : void 0 !== n ? "string" === typeof r ? a(e, t).fill(n, r) : a(e, t).fill(n) : a(e, t)
            }(null, e, t, n)
        }
        ,
        c.allocUnsafe = function(e) {
            return d(null, e)
        }
        ,
        c.allocUnsafeSlow = function(e) {
            return d(null, e)
        }
        ,
        c.isBuffer = function(e) {
            return !(null == e || !e._isBuffer)
        }
        ,
        c.compare = function(e, t) {
            if (!c.isBuffer(e) || !c.isBuffer(t))
                throw new TypeError("Arguments must be Buffers");
            if (e === t)
                return 0;
            for (var n = e.length, r = t.length, i = 0, o = Math.min(n, r); i < o; ++i)
                if (e[i] !== t[i]) {
                    n = e[i],
                    r = t[i];
                    break
                }
            return n < r ? -1 : r < n ? 1 : 0
        }
        ,
        c.isEncoding = function(e) {
            switch (String(e).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
            }
        }
        ,
        c.concat = function(e, t) {
            if (!o(e))
                throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === e.length)
                return c.alloc(0);
            var n;
            if (void 0 === t)
                for (t = 0,
                n = 0; n < e.length; ++n)
                    t += e[n].length;
            var r = c.allocUnsafe(t)
              , i = 0;
            for (n = 0; n < e.length; ++n) {
                var s = e[n];
                if (!c.isBuffer(s))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                s.copy(r, i),
                i += s.length
            }
            return r
        }
        ,
        c.byteLength = p,
        c.prototype._isBuffer = !0,
        c.prototype.swap16 = function() {
            var e = this.length;
            if (e % 2 !== 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var t = 0; t < e; t += 2)
                m(this, t, t + 1);
            return this
        }
        ,
        c.prototype.swap32 = function() {
            var e = this.length;
            if (e % 4 !== 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var t = 0; t < e; t += 4)
                m(this, t, t + 3),
                m(this, t + 1, t + 2);
            return this
        }
        ,
        c.prototype.swap64 = function() {
            var e = this.length;
            if (e % 8 !== 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var t = 0; t < e; t += 8)
                m(this, t, t + 7),
                m(this, t + 1, t + 6),
                m(this, t + 2, t + 5),
                m(this, t + 3, t + 4);
            return this
        }
        ,
        c.prototype.toString = function() {
            var e = 0 | this.length;
            return 0 === e ? "" : 0 === arguments.length ? w(this, 0, e) : g.apply(this, arguments)
        }
        ,
        c.prototype.equals = function(e) {
            if (!c.isBuffer(e))
                throw new TypeError("Argument must be a Buffer");
            return this === e || 0 === c.compare(this, e)
        }
        ,
        c.prototype.inspect = function() {
            var e = ""
              , n = t.INSPECT_MAX_BYTES;
            return this.length > 0 && (e = this.toString("hex", 0, n).match(/.{2}/g).join(" "),
            this.length > n && (e += " ... ")),
            "<Buffer " + e + ">"
        }
        ,
        c.prototype.compare = function(e, t, n, r, i) {
            if (!c.isBuffer(e))
                throw new TypeError("Argument must be a Buffer");
            if (void 0 === t && (t = 0),
            void 0 === n && (n = e ? e.length : 0),
            void 0 === r && (r = 0),
            void 0 === i && (i = this.length),
            t < 0 || n > e.length || r < 0 || i > this.length)
                throw new RangeError("out of range index");
            if (r >= i && t >= n)
                return 0;
            if (r >= i)
                return -1;
            if (t >= n)
                return 1;
            if (this === e)
                return 0;
            for (var o = (i >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (t >>>= 0), a = Math.min(o, s), u = this.slice(r, i), l = e.slice(t, n), d = 0; d < a; ++d)
                if (u[d] !== l[d]) {
                    o = u[d],
                    s = l[d];
                    break
                }
            return o < s ? -1 : s < o ? 1 : 0
        }
        ,
        c.prototype.includes = function(e, t, n) {
            return -1 !== this.indexOf(e, t, n)
        }
        ,
        c.prototype.indexOf = function(e, t, n) {
            return y(this, e, t, n, !0)
        }
        ,
        c.prototype.lastIndexOf = function(e, t, n) {
            return y(this, e, t, n, !1)
        }
        ,
        c.prototype.write = function(e, t, n, r) {
            if (void 0 === t)
                r = "utf8",
                n = this.length,
                t = 0;
            else if (void 0 === n && "string" === typeof t)
                r = t,
                n = this.length,
                t = 0;
            else {
                if (!isFinite(t))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t |= 0,
                isFinite(n) ? (n |= 0,
                void 0 === r && (r = "utf8")) : (r = n,
                n = void 0)
            }
            var i = this.length - t;
            if ((void 0 === n || n > i) && (n = i),
            e.length > 0 && (n < 0 || t < 0) || t > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            r || (r = "utf8");
            for (var o = !1; ; )
                switch (r) {
                case "hex":
                    return b(this, e, t, n);
                case "utf8":
                case "utf-8":
                    return _(this, e, t, n);
                case "ascii":
                    return S(this, e, t, n);
                case "latin1":
                case "binary":
                    return O(this, e, t, n);
                case "base64":
                    return T(this, e, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return I(this, e, t, n);
                default:
                    if (o)
                        throw new TypeError("Unknown encoding: " + r);
                    r = ("" + r).toLowerCase(),
                    o = !0
                }
        }
        ,
        c.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }
        ;
        function M(e, t, n) {
            var r = "";
            n = Math.min(e.length, n);
            for (var i = t; i < n; ++i)
                r += String.fromCharCode(127 & e[i]);
            return r
        }
        function A(e, t, n) {
            var r = "";
            n = Math.min(e.length, n);
            for (var i = t; i < n; ++i)
                r += String.fromCharCode(e[i]);
            return r
        }
        function E(e, t, n) {
            var r = e.length;
            (!t || t < 0) && (t = 0),
            (!n || n < 0 || n > r) && (n = r);
            for (var i = "", o = t; o < n; ++o)
                i += V(e[o]);
            return i
        }
        function C(e, t, n) {
            for (var r = e.slice(t, n), i = "", o = 0; o < r.length; o += 2)
                i += String.fromCharCode(r[o] + 256 * r[o + 1]);
            return i
        }
        function N(e, t, n) {
            if (e % 1 !== 0 || e < 0)
                throw new RangeError("offset is not uint");
            if (e + t > n)
                throw new RangeError("Trying to access beyond buffer length")
        }
        function R(e, t, n, r, i, o) {
            if (!c.isBuffer(e))
                throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t > i || t < o)
                throw new RangeError('"value" argument is out of bounds');
            if (n + r > e.length)
                throw new RangeError("Index out of range")
        }
        function P(e, t, n, r) {
            t < 0 && (t = 65535 + t + 1);
            for (var i = 0, o = Math.min(e.length - n, 2); i < o; ++i)
                e[n + i] = (t & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i)
        }
        function D(e, t, n, r) {
            t < 0 && (t = 4294967295 + t + 1);
            for (var i = 0, o = Math.min(e.length - n, 4); i < o; ++i)
                e[n + i] = t >>> 8 * (r ? i : 3 - i) & 255
        }
        function F(e, t, n, r, i, o) {
            if (n + r > e.length)
                throw new RangeError("Index out of range");
            if (n < 0)
                throw new RangeError("Index out of range")
        }
        function k(e, t, n, r, o) {
            return o || F(e, 0, n, 4),
            i.write(e, t, n, r, 23, 4),
            n + 4
        }
        function j(e, t, n, r, o) {
            return o || F(e, 0, n, 8),
            i.write(e, t, n, r, 52, 8),
            n + 8
        }
        c.prototype.slice = function(e, t) {
            var n, r = this.length;
            if ((e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
            (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
            t < e && (t = e),
            c.TYPED_ARRAY_SUPPORT)
                (n = this.subarray(e, t)).__proto__ = c.prototype;
            else {
                var i = t - e;
                n = new c(i,void 0);
                for (var o = 0; o < i; ++o)
                    n[o] = this[o + e]
            }
            return n
        }
        ,
        c.prototype.readUIntLE = function(e, t, n) {
            e |= 0,
            t |= 0,
            n || N(e, t, this.length);
            for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256); )
                r += this[e + o] * i;
            return r
        }
        ,
        c.prototype.readUIntBE = function(e, t, n) {
            e |= 0,
            t |= 0,
            n || N(e, t, this.length);
            for (var r = this[e + --t], i = 1; t > 0 && (i *= 256); )
                r += this[e + --t] * i;
            return r
        }
        ,
        c.prototype.readUInt8 = function(e, t) {
            return t || N(e, 1, this.length),
            this[e]
        }
        ,
        c.prototype.readUInt16LE = function(e, t) {
            return t || N(e, 2, this.length),
            this[e] | this[e + 1] << 8
        }
        ,
        c.prototype.readUInt16BE = function(e, t) {
            return t || N(e, 2, this.length),
            this[e] << 8 | this[e + 1]
        }
        ,
        c.prototype.readUInt32LE = function(e, t) {
            return t || N(e, 4, this.length),
            (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
        }
        ,
        c.prototype.readUInt32BE = function(e, t) {
            return t || N(e, 4, this.length),
            16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
        }
        ,
        c.prototype.readIntLE = function(e, t, n) {
            e |= 0,
            t |= 0,
            n || N(e, t, this.length);
            for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256); )
                r += this[e + o] * i;
            return r >= (i *= 128) && (r -= Math.pow(2, 8 * t)),
            r
        }
        ,
        c.prototype.readIntBE = function(e, t, n) {
            e |= 0,
            t |= 0,
            n || N(e, t, this.length);
            for (var r = t, i = 1, o = this[e + --r]; r > 0 && (i *= 256); )
                o += this[e + --r] * i;
            return o >= (i *= 128) && (o -= Math.pow(2, 8 * t)),
            o
        }
        ,
        c.prototype.readInt8 = function(e, t) {
            return t || N(e, 1, this.length),
            128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
        }
        ,
        c.prototype.readInt16LE = function(e, t) {
            t || N(e, 2, this.length);
            var n = this[e] | this[e + 1] << 8;
            return 32768 & n ? 4294901760 | n : n
        }
        ,
        c.prototype.readInt16BE = function(e, t) {
            t || N(e, 2, this.length);
            var n = this[e + 1] | this[e] << 8;
            return 32768 & n ? 4294901760 | n : n
        }
        ,
        c.prototype.readInt32LE = function(e, t) {
            return t || N(e, 4, this.length),
            this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
        }
        ,
        c.prototype.readInt32BE = function(e, t) {
            return t || N(e, 4, this.length),
            this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
        }
        ,
        c.prototype.readFloatLE = function(e, t) {
            return t || N(e, 4, this.length),
            i.read(this, e, !0, 23, 4)
        }
        ,
        c.prototype.readFloatBE = function(e, t) {
            return t || N(e, 4, this.length),
            i.read(this, e, !1, 23, 4)
        }
        ,
        c.prototype.readDoubleLE = function(e, t) {
            return t || N(e, 8, this.length),
            i.read(this, e, !0, 52, 8)
        }
        ,
        c.prototype.readDoubleBE = function(e, t) {
            return t || N(e, 8, this.length),
            i.read(this, e, !1, 52, 8)
        }
        ,
        c.prototype.writeUIntLE = function(e, t, n, r) {
            (e = +e,
            t |= 0,
            n |= 0,
            r) || R(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
            var i = 1
              , o = 0;
            for (this[t] = 255 & e; ++o < n && (i *= 256); )
                this[t + o] = e / i & 255;
            return t + n
        }
        ,
        c.prototype.writeUIntBE = function(e, t, n, r) {
            (e = +e,
            t |= 0,
            n |= 0,
            r) || R(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
            var i = n - 1
              , o = 1;
            for (this[t + i] = 255 & e; --i >= 0 && (o *= 256); )
                this[t + i] = e / o & 255;
            return t + n
        }
        ,
        c.prototype.writeUInt8 = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 1, 255, 0),
            c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
            this[t] = 255 & e,
            t + 1
        }
        ,
        c.prototype.writeUInt16LE = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 2, 65535, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
            this[t + 1] = e >>> 8) : P(this, e, t, !0),
            t + 2
        }
        ,
        c.prototype.writeUInt16BE = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 2, 65535, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8,
            this[t + 1] = 255 & e) : P(this, e, t, !1),
            t + 2
        }
        ,
        c.prototype.writeUInt32LE = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 4, 4294967295, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24,
            this[t + 2] = e >>> 16,
            this[t + 1] = e >>> 8,
            this[t] = 255 & e) : D(this, e, t, !0),
            t + 4
        }
        ,
        c.prototype.writeUInt32BE = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 4, 4294967295, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24,
            this[t + 1] = e >>> 16,
            this[t + 2] = e >>> 8,
            this[t + 3] = 255 & e) : D(this, e, t, !1),
            t + 4
        }
        ,
        c.prototype.writeIntLE = function(e, t, n, r) {
            if (e = +e,
            t |= 0,
            !r) {
                var i = Math.pow(2, 8 * n - 1);
                R(this, e, t, n, i - 1, -i)
            }
            var o = 0
              , s = 1
              , a = 0;
            for (this[t] = 255 & e; ++o < n && (s *= 256); )
                e < 0 && 0 === a && 0 !== this[t + o - 1] && (a = 1),
                this[t + o] = (e / s >> 0) - a & 255;
            return t + n
        }
        ,
        c.prototype.writeIntBE = function(e, t, n, r) {
            if (e = +e,
            t |= 0,
            !r) {
                var i = Math.pow(2, 8 * n - 1);
                R(this, e, t, n, i - 1, -i)
            }
            var o = n - 1
              , s = 1
              , a = 0;
            for (this[t + o] = 255 & e; --o >= 0 && (s *= 256); )
                e < 0 && 0 === a && 0 !== this[t + o + 1] && (a = 1),
                this[t + o] = (e / s >> 0) - a & 255;
            return t + n
        }
        ,
        c.prototype.writeInt8 = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 1, 127, -128),
            c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
            e < 0 && (e = 255 + e + 1),
            this[t] = 255 & e,
            t + 1
        }
        ,
        c.prototype.writeInt16LE = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 2, 32767, -32768),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
            this[t + 1] = e >>> 8) : P(this, e, t, !0),
            t + 2
        }
        ,
        c.prototype.writeInt16BE = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 2, 32767, -32768),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8,
            this[t + 1] = 255 & e) : P(this, e, t, !1),
            t + 2
        }
        ,
        c.prototype.writeInt32LE = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 4, 2147483647, -2147483648),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
            this[t + 1] = e >>> 8,
            this[t + 2] = e >>> 16,
            this[t + 3] = e >>> 24) : D(this, e, t, !0),
            t + 4
        }
        ,
        c.prototype.writeInt32BE = function(e, t, n) {
            return e = +e,
            t |= 0,
            n || R(this, e, t, 4, 2147483647, -2147483648),
            e < 0 && (e = 4294967295 + e + 1),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24,
            this[t + 1] = e >>> 16,
            this[t + 2] = e >>> 8,
            this[t + 3] = 255 & e) : D(this, e, t, !1),
            t + 4
        }
        ,
        c.prototype.writeFloatLE = function(e, t, n) {
            return k(this, e, t, !0, n)
        }
        ,
        c.prototype.writeFloatBE = function(e, t, n) {
            return k(this, e, t, !1, n)
        }
        ,
        c.prototype.writeDoubleLE = function(e, t, n) {
            return j(this, e, t, !0, n)
        }
        ,
        c.prototype.writeDoubleBE = function(e, t, n) {
            return j(this, e, t, !1, n)
        }
        ,
        c.prototype.copy = function(e, t, n, r) {
            if (n || (n = 0),
            r || 0 === r || (r = this.length),
            t >= e.length && (t = e.length),
            t || (t = 0),
            r > 0 && r < n && (r = n),
            r === n)
                return 0;
            if (0 === e.length || 0 === this.length)
                return 0;
            if (t < 0)
                throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length)
                throw new RangeError("sourceStart out of bounds");
            if (r < 0)
                throw new RangeError("sourceEnd out of bounds");
            r > this.length && (r = this.length),
            e.length - t < r - n && (r = e.length - t + n);
            var i, o = r - n;
            if (this === e && n < t && t < r)
                for (i = o - 1; i >= 0; --i)
                    e[i + t] = this[i + n];
            else if (o < 1e3 || !c.TYPED_ARRAY_SUPPORT)
                for (i = 0; i < o; ++i)
                    e[i + t] = this[i + n];
            else
                Uint8Array.prototype.set.call(e, this.subarray(n, n + o), t);
            return o
        }
        ,
        c.prototype.fill = function(e, t, n, r) {
            if ("string" === typeof e) {
                if ("string" === typeof t ? (r = t,
                t = 0,
                n = this.length) : "string" === typeof n && (r = n,
                n = this.length),
                1 === e.length) {
                    var i = e.charCodeAt(0);
                    i < 256 && (e = i)
                }
                if (void 0 !== r && "string" !== typeof r)
                    throw new TypeError("encoding must be a string");
                if ("string" === typeof r && !c.isEncoding(r))
                    throw new TypeError("Unknown encoding: " + r)
            } else
                "number" === typeof e && (e &= 255);
            if (t < 0 || this.length < t || this.length < n)
                throw new RangeError("Out of range index");
            if (n <= t)
                return this;
            var o;
            if (t >>>= 0,
            n = void 0 === n ? this.length : n >>> 0,
            e || (e = 0),
            "number" === typeof e)
                for (o = t; o < n; ++o)
                    this[o] = e;
            else {
                var s = c.isBuffer(e) ? e : U(new c(e,r).toString())
                  , a = s.length;
                for (o = 0; o < n - t; ++o)
                    this[o + t] = s[o % a]
            }
            return this
        }
        ;
        var L = /[^+\/0-9A-Za-z-_]/g;
        function V(e) {
            return e < 16 ? "0" + e.toString(16) : e.toString(16)
        }
        function U(e, t) {
            var n;
            t = t || 1 / 0;
            for (var r = e.length, i = null, o = [], s = 0; s < r; ++s) {
                if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
                    if (!i) {
                        if (n > 56319) {
                            (t -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        if (s + 1 === r) {
                            (t -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        i = n;
                        continue
                    }
                    if (n < 56320) {
                        (t -= 3) > -1 && o.push(239, 191, 189),
                        i = n;
                        continue
                    }
                    n = 65536 + (i - 55296 << 10 | n - 56320)
                } else
                    i && (t -= 3) > -1 && o.push(239, 191, 189);
                if (i = null,
                n < 128) {
                    if ((t -= 1) < 0)
                        break;
                    o.push(n)
                } else if (n < 2048) {
                    if ((t -= 2) < 0)
                        break;
                    o.push(n >> 6 | 192, 63 & n | 128)
                } else if (n < 65536) {
                    if ((t -= 3) < 0)
                        break;
                    o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                } else {
                    if (!(n < 1114112))
                        throw new Error("Invalid code point");
                    if ((t -= 4) < 0)
                        break;
                    o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                }
            }
            return o
        }
        function q(e) {
            return r.toByteArray(function(e) {
                if ((e = function(e) {
                    return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
                }(e).replace(L, "")).length < 2)
                    return "";
                for (; e.length % 4 !== 0; )
                    e += "=";
                return e
            }(e))
        }
        function Q(e, t, n, r) {
            for (var i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i)
                t[i + n] = e[i];
            return i
        }
    }
    ).call(this, n(167))
}
, function(e, t, n) {
    "use strict";
    t.byteLength = function(e) {
        var t = u(e)
          , n = t[0]
          , r = t[1];
        return 3 * (n + r) / 4 - r
    }
    ,
    t.toByteArray = function(e) {
        var t, n, r = u(e), s = r[0], a = r[1], c = new o(function(e, t, n) {
            return 3 * (t + n) / 4 - n
        }(0, s, a)), l = 0, d = a > 0 ? s - 4 : s;
        for (n = 0; n < d; n += 4)
            t = i[e.charCodeAt(n)] << 18 | i[e.charCodeAt(n + 1)] << 12 | i[e.charCodeAt(n + 2)] << 6 | i[e.charCodeAt(n + 3)],
            c[l++] = t >> 16 & 255,
            c[l++] = t >> 8 & 255,
            c[l++] = 255 & t;
        2 === a && (t = i[e.charCodeAt(n)] << 2 | i[e.charCodeAt(n + 1)] >> 4,
        c[l++] = 255 & t);
        1 === a && (t = i[e.charCodeAt(n)] << 10 | i[e.charCodeAt(n + 1)] << 4 | i[e.charCodeAt(n + 2)] >> 2,
        c[l++] = t >> 8 & 255,
        c[l++] = 255 & t);
        return c
    }
    ,
    t.fromByteArray = function(e) {
        for (var t, n = e.length, i = n % 3, o = [], s = 0, a = n - i; s < a; s += 16383)
            o.push(l(e, s, s + 16383 > a ? a : s + 16383));
        1 === i ? (t = e[n - 1],
        o.push(r[t >> 2] + r[t << 4 & 63] + "==")) : 2 === i && (t = (e[n - 2] << 8) + e[n - 1],
        o.push(r[t >> 10] + r[t >> 4 & 63] + r[t << 2 & 63] + "="));
        return o.join("")
    }
    ;
    for (var r = [], i = [], o = "undefined" !== typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, c = s.length; a < c; ++a)
        r[a] = s[a],
        i[s.charCodeAt(a)] = a;
    function u(e) {
        var t = e.length;
        if (t % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
        var n = e.indexOf("=");
        return -1 === n && (n = t),
        [n, n === t ? 0 : 4 - n % 4]
    }
    function l(e, t, n) {
        for (var i, o, s = [], a = t; a < n; a += 3)
            i = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]),
            s.push(r[(o = i) >> 18 & 63] + r[o >> 12 & 63] + r[o >> 6 & 63] + r[63 & o]);
        return s.join("")
    }
    i["-".charCodeAt(0)] = 62,
    i["_".charCodeAt(0)] = 63
}
, function(e, t) {
    t.read = function(e, t, n, r, i) {
        var o, s, a = 8 * i - r - 1, c = (1 << a) - 1, u = c >> 1, l = -7, d = n ? i - 1 : 0, h = n ? -1 : 1, f = e[t + d];
        for (d += h,
        o = f & (1 << -l) - 1,
        f >>= -l,
        l += a; l > 0; o = 256 * o + e[t + d],
        d += h,
        l -= 8)
            ;
        for (s = o & (1 << -l) - 1,
        o >>= -l,
        l += r; l > 0; s = 256 * s + e[t + d],
        d += h,
        l -= 8)
            ;
        if (0 === o)
            o = 1 - u;
        else {
            if (o === c)
                return s ? NaN : 1 / 0 * (f ? -1 : 1);
            s += Math.pow(2, r),
            o -= u
        }
        return (f ? -1 : 1) * s * Math.pow(2, o - r)
    }
    ,
    t.write = function(e, t, n, r, i, o) {
        var s, a, c, u = 8 * o - i - 1, l = (1 << u) - 1, d = l >> 1, h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : o - 1, p = r ? 1 : -1, g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
        for (t = Math.abs(t),
        isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0,
        s = l) : (s = Math.floor(Math.log(t) / Math.LN2),
        t * (c = Math.pow(2, -s)) < 1 && (s--,
        c *= 2),
        (t += s + d >= 1 ? h / c : h * Math.pow(2, 1 - d)) * c >= 2 && (s++,
        c /= 2),
        s + d >= l ? (a = 0,
        s = l) : s + d >= 1 ? (a = (t * c - 1) * Math.pow(2, i),
        s += d) : (a = t * Math.pow(2, d - 1) * Math.pow(2, i),
        s = 0)); i >= 8; e[n + f] = 255 & a,
        f += p,
        a /= 256,
        i -= 8)
            ;
        for (s = s << i | a,
        u += i; u > 0; e[n + f] = 255 & s,
        f += p,
        s /= 256,
        u -= 8)
            ;
        e[n + f - p] |= 128 * g
    }
}
, function(e, t) {
    var n = {}.toString;
    e.exports = Array.isArray || function(e) {
        return "[object Array]" == n.call(e)
    }
}
, function(e, t, n) {
    "use strict";
    function r() {
        return this
    }
    function i(e, t) {
        t.setPermCheck = r
    }
    n.r(t),
    n.d(t, "client", (function() {
        return i
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.r(t),
    n.d(t, "client", (function() {
        return a
    }
    ));
    var r = n(33);
    function i(e) {
        return this.activeRecord || (this.activeRecord = e),
        this
    }
    function o(e) {
        return this.activeRecord === e && (this.activeRecord = null),
        this
    }
    function s(e, t) {
        if (!this.activeRecord)
            return this;
        const n = this.mutations[this.activeRecord.__typename];
        let {cascadesByRecord: i} = n;
        i || (i = r.a.checkoutMap(),
        n.cascadesByRecord = i);
        let o, s = i.get(this.activeRecord);
        if (s ? o = s.get(e) : (s = r.a.checkoutMap(),
        i.set(this.activeRecord, s)),
        !t)
            return o && r.a.checkinSet(o),
            s.set(e, null),
            this;
        o || (o = r.a.checkoutSet(),
        s.set(e, o));
        for (let r in t)
            o.add(r);
        return this
    }
    function a(e) {
        e.setActiveRecord = i,
        e.clearActiveRecord = o,
        e.addToActiveRecord = s
    }
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(599)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function e(t, n, o, s) {
        var a = function(r) {
            for (var i = n.length, a = 0; a < i; ) {
                if (t === n[a])
                    return o[a];
                a += 1
            }
            for (var c in n[a + 1] = t,
            o[a + 1] = r,
            t)
                r[c] = s ? e(t[c], n, o, !0) : t[c];
            return r
        };
        switch ((0,
        i.default)(t)) {
        case "Object":
            return a({});
        case "Array":
            return a([]);
        case "Date":
            return new Date(t.valueOf());
        case "RegExp":
            return (0,
            r.default)(t);
        default:
            return t
        }
    }
    ;
    var r = o(n(600))
      , i = o(n(602));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(601)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return new RegExp(e.source,(e.global ? "g" : "") + (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.sticky ? "y" : "") + (e.unicode ? "u" : ""))
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(603)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(604);
    var o = (0,
    ((r = i) && r.__esModule ? r : {
        default: r
    }).default)((function(e) {
        return null === e ? "Null" : void 0 === e ? "Undefined" : Object.prototype.toString.call(e).slice(8, -1)
    }
    ));
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(177)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(269)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(177)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(608)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(609))
      , i = o(n(808));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function e(t, n, o, s, a) {
        return t === n || (null == t || null == n || !(0,
        i.default)(t) && !(0,
        i.default)(n) ? t !== t && n !== n : (0,
        r.default)(t, n, o, s, e, a))
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(610)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = d(n(611))
      , i = d(n(702))
      , o = d(n(714))
      , s = d(n(726))
      , a = d(n(784))
      , c = d(n(805))
      , u = d(n(806))
      , l = d(n(807));
    function d(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var h = "[object Object]"
      , f = Object.prototype.hasOwnProperty;
    t.default = function(e, t, n, d, p, g) {
        var m = (0,
        c.default)(e)
          , y = (0,
        c.default)(t)
          , v = m ? "[object Array]" : (0,
        a.default)(e)
          , b = y ? "[object Array]" : (0,
        a.default)(t)
          , _ = (v = "[object Arguments]" == v ? h : v) == h
          , S = (b = "[object Arguments]" == b ? h : b) == h
          , O = v == b;
        if (O && (0,
        u.default)(e)) {
            if (!(0,
            u.default)(t))
                return !1;
            m = !0,
            _ = !1
        }
        if (O && !_)
            return g || (g = new r.default),
            m || (0,
            l.default)(e) ? (0,
            i.default)(e, t, n, d, p, g) : (0,
            o.default)(e, t, v, n, d, p, g);
        if (!(1 & n)) {
            var T = _ && f.call(e, "__wrapped__")
              , I = S && f.call(t, "__wrapped__");
            if (T || I) {
                var x = T ? e.value() : e
                  , w = I ? t.value() : t;
                return g || (g = new r.default),
                p(x, w, n, d, g)
            }
        }
        return !!O && (g || (g = new r.default),
        (0,
        s.default)(e, t, n, d, p, g))
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(612)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = u(n(613))
      , i = u(n(629))
      , o = u(n(632))
      , s = u(n(634))
      , a = u(n(636))
      , c = u(n(638));
    function u(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    function l(e) {
        var t = this.__data__ = new r.default(e);
        this.size = t.size
    }
    l.prototype.clear = i.default,
    l.prototype.delete = o.default,
    l.prototype.get = s.default,
    l.prototype.has = a.default,
    l.prototype.set = c.default,
    t.default = l,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(215)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(615)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function() {
        this.__data__ = [],
        this.size = 0
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(617)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(618), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    var s = Array.prototype.splice;
    t.default = function(e) {
        var t = this.__data__
          , n = (0,
        o.default)(t, e);
        return !(n < 0) && (n == t.length - 1 ? t.pop() : s.call(t, n, 1),
        --this.size,
        !0)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(216)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(346)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(621)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(622), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e) {
        var t = this.__data__
          , n = (0,
        o.default)(t, e);
        return n < 0 ? void 0 : t[n][1]
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(216)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(624)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(625), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e) {
        return (0,
        o.default)(this.__data__, e) > -1
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(216)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(627)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(628), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e, t) {
        var n = this.__data__
          , r = (0,
        o.default)(n, e);
        return r < 0 ? (++this.size,
        n.push([e, t])) : n[r][1] = t,
        this
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(216)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(630)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(631), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function() {
        this.__data__ = new o.default,
        this.size = 0
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(215)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(633)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        var t = this.__data__
          , n = t.delete(e);
        return this.size = t.size,
        n
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(635)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return this.__data__.get(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(637)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return this.__data__.has(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(639)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(640))
      , i = s(n(641))
      , o = s(n(666));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function(e, t) {
        var n = this.__data__;
        if (n instanceof r.default) {
            var s = n.__data__;
            if (!i.default || s.length < 199)
                return s.push([e, t]),
                this.size = ++n.size,
                this;
            n = this.__data__ = new o.default(s)
        }
        return n.set(e, t),
        this.size = n.size,
        this
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(215)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(270)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(148)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(644)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = a(n(645))
      , i = a(n(656))
      , o = a(n(661))
      , s = a(n(662));
    function a(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var c = /^\[object .+?Constructor\]$/
      , u = Function.prototype
      , l = Object.prototype
      , d = u.toString
      , h = l.hasOwnProperty
      , f = RegExp("^" + d.call(h).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    t.default = function(e) {
        return !(!(0,
        o.default)(e) || (0,
        i.default)(e)) && ((0,
        r.default)(e) ? f : c).test((0,
        s.default)(e))
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(347)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(217)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(271)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(98)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(348)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(651)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(652), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    var s = Object.prototype
      , a = s.hasOwnProperty
      , c = s.toString
      , u = o.default ? o.default.toStringTag : void 0;
    t.default = function(e) {
        var t = a.call(e, u)
          , n = e[u];
        try {
            e[u] = void 0;
            var r = !0
        } catch (o) {}
        var i = c.call(e);
        return r && (t ? e[u] = n : delete e[u]),
        i
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(271)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(654)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = Object.prototype.toString;
    t.default = function(e) {
        return r.call(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(349)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(657)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(658), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    var s = function() {
        var e = /[^.]+$/.exec(o.default && o.default.keys && o.default.keys.IE_PROTO || "");
        return e ? "Symbol(src)_1." + e : ""
    }();
    t.default = function(e) {
        return !!s && s in e
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(659)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(660);
    var o = ((r = i) && r.__esModule ? r : {
        default: r
    }).default["__core-js_shared__"];
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(98)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(349)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(350)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(664)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e, t) {
        return null == e ? void 0 : e[t]
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(98)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(351)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(668)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(669))
      , i = s(n(686))
      , o = s(n(687));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function() {
        this.size = 0,
        this.__data__ = {
            hash: new r.default,
            map: new (o.default || i.default),
            string: new r.default
        }
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(670)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = c(n(671))
      , i = c(n(675))
      , o = c(n(677))
      , s = c(n(680))
      , a = c(n(683));
    function c(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    function u(e) {
        var t = -1
          , n = null == e ? 0 : e.length;
        for (this.clear(); ++t < n; ) {
            var r = e[t];
            this.set(r[0], r[1])
        }
    }
    u.prototype.clear = r.default,
    u.prototype.delete = i.default,
    u.prototype.get = o.default,
    u.prototype.has = s.default,
    u.prototype.set = a.default,
    t.default = u,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(672)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(673), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function() {
        this.__data__ = o.default ? (0,
        o.default)(null) : {},
        this.size = 0
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(218)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(148)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(676)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        var t = this.has(e) && delete this.__data__[e];
        return this.size -= t ? 1 : 0,
        t
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(678)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(679), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    var s = Object.prototype.hasOwnProperty;
    t.default = function(e) {
        var t = this.__data__;
        if (o.default) {
            var n = t[e];
            return "__lodash_hash_undefined__" === n ? void 0 : n
        }
        return s.call(t, e) ? t[e] : void 0
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(218)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(681)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(682), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    var s = Object.prototype.hasOwnProperty;
    t.default = function(e) {
        var t = this.__data__;
        return o.default ? void 0 !== t[e] : s.call(t, e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(218)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(684)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(685), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e, t) {
        var n = this.__data__;
        return this.size += this.has(e) ? 0 : 1,
        n[e] = o.default && void 0 === t ? "__lodash_hash_undefined__" : t,
        this
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(218)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(215)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(270)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(689)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(690), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e) {
        var t = (0,
        o.default)(this, e).delete(e);
        return this.size -= t ? 1 : 0,
        t
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(219)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(692)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    t.default = function(e) {
        var t = "undefined" === typeof e ? "undefined" : r(e);
        return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(694)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(695), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e) {
        return (0,
        o.default)(this, e).get(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(219)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(697)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(698), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e) {
        return (0,
        o.default)(this, e).has(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(219)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(700)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(701), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    t.default = function(e, t) {
        var n = (0,
        o.default)(this, e)
          , r = n.size;
        return n.set(e, t),
        this.size += n.size == r ? 0 : 1,
        this
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(219)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(352)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(704)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(705))
      , i = s(n(706))
      , o = s(n(708));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    function a(e) {
        var t = -1
          , n = null == e ? 0 : e.length;
        for (this.__data__ = new r.default; ++t < n; )
            this.add(e[t])
    }
    a.prototype.add = a.prototype.push = i.default,
    a.prototype.has = o.default,
    t.default = a,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(351)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(707)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    t.default = function(e) {
        return this.__data__.set(e, "__lodash_hash_undefined__"),
        this
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(709)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return this.__data__.has(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(711)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e, t) {
        for (var n = -1, r = null == e ? 0 : e.length; ++n < r; )
            if (t(e[n], n, e))
                return !0;
        return !1
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(713)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e, t) {
        return e.has(t)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(715)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = u(n(716))
      , i = u(n(717))
      , o = u(n(720))
      , s = u(n(721))
      , a = u(n(722))
      , c = u(n(724));
    function u(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var l = r.default ? r.default.prototype : void 0
      , d = l ? l.valueOf : void 0;
    t.default = function(e, t, n, r, u, l, h) {
        switch (n) {
        case "[object DataView]":
            if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
                return !1;
            e = e.buffer,
            t = t.buffer;
        case "[object ArrayBuffer]":
            return !(e.byteLength != t.byteLength || !l(new i.default(e), new i.default(t)));
        case "[object Boolean]":
        case "[object Date]":
        case "[object Number]":
            return (0,
            o.default)(+e, +t);
        case "[object Error]":
            return e.name == t.name && e.message == t.message;
        case "[object RegExp]":
        case "[object String]":
            return e == t + "";
        case "[object Map]":
            var f = a.default;
        case "[object Set]":
            var p = 1 & r;
            if (f || (f = c.default),
            e.size != t.size && !p)
                return !1;
            var g = h.get(e);
            if (g)
                return g == t;
            r |= 2,
            h.set(e, t);
            var m = (0,
            s.default)(f(e), f(t), r, u, l, h);
            return h.delete(e),
            m;
        case "[object Symbol]":
            if (d)
                return d.call(e) == d.call(t)
        }
        return !1
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(271)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(718)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(719);
    var o = ((r = i) && r.__esModule ? r : {
        default: r
    }).default.Uint8Array;
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(98)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(346)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(352)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(723)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        var t = -1
          , n = Array(e.size);
        return e.forEach((function(e, r) {
            n[++t] = [r, e]
        }
        )),
        n
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(725)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        var t = -1
          , n = Array(e.size);
        return e.forEach((function(e) {
            n[++t] = e
        }
        )),
        n
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(727)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(728), o = (r = i) && r.__esModule ? r : {
        default: r
    };
    var s = Object.prototype.hasOwnProperty;
    t.default = function(e, t, n, r, i, a) {
        var c = 1 & n
          , u = (0,
        o.default)(e)
          , l = u.length;
        if (l != (0,
        o.default)(t).length && !c)
            return !1;
        for (var d = l; d--; ) {
            var h = u[d];
            if (!(c ? h in t : s.call(t, h)))
                return !1
        }
        var f = a.get(e);
        if (f && a.get(t))
            return f == t;
        var p = !0;
        a.set(e, t),
        a.set(t, e);
        for (var g = c; ++d < l; ) {
            var m = e[h = u[d]]
              , y = t[h];
            if (r)
                var v = c ? r(y, m, h, t, e, a) : r(m, y, h, e, t, a);
            if (!(void 0 === v ? m === y || i(m, y, n, r, a) : v)) {
                p = !1;
                break
            }
            g || (g = "constructor" == h)
        }
        if (p && !g) {
            var b = e.constructor
              , _ = t.constructor;
            b == _ || !("constructor"in e) || !("constructor"in t) || "function" == typeof b && b instanceof b && "function" == typeof _ && _ instanceof _ || (p = !1)
        }
        return a.delete(e),
        a.delete(t),
        p
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(729)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(730))
      , i = s(n(735))
      , o = s(n(741));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function(e) {
        return (0,
        r.default)(e, o.default, i.default)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(731)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(732))
      , i = o(n(734));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function(e, t, n) {
        var o = t(e);
        return (0,
        i.default)(e) ? o : (0,
        r.default)(o, n(e))
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(733)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e, t) {
        for (var n = -1, r = t.length, i = e.length; ++n < r; )
            e[i + n] = t[n];
        return e
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(272)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(736)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(737))
      , i = o(n(739));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = Object.prototype.propertyIsEnumerable
      , a = Object.getOwnPropertySymbols
      , c = a ? function(e) {
        return null == e ? [] : (e = Object(e),
        (0,
        r.default)(a(e), (function(t) {
            return s.call(e, t)
        }
        )))
    }
    : i.default;
    t.default = c,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(738)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e, t) {
        for (var n = -1, r = null == e ? 0 : e.length, i = 0, o = []; ++n < r; ) {
            var s = e[n];
            t(s, n, e) && (o[i++] = s)
        }
        return o
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(740)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function() {
        return []
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(742)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(743))
      , i = s(n(772))
      , o = s(n(780));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function(e) {
        return (0,
        o.default)(e) ? (0,
        r.default)(e) : (0,
        i.default)(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(744)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = u(n(745))
      , i = u(n(747))
      , o = u(n(754))
      , s = u(n(755))
      , a = u(n(759))
      , c = u(n(761));
    function u(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var l = Object.prototype.hasOwnProperty;
    t.default = function(e, t) {
        var n = (0,
        o.default)(e)
          , u = !n && (0,
        i.default)(e)
          , d = !n && !u && (0,
        s.default)(e)
          , h = !n && !u && !d && (0,
        c.default)(e)
          , f = n || u || d || h
          , p = f ? (0,
        r.default)(e.length, String) : []
          , g = p.length;
        for (var m in e)
            !t && !l.call(e, m) || f && ("length" == m || d && ("offset" == m || "parent" == m) || h && ("buffer" == m || "byteLength" == m || "byteOffset" == m) || (0,
            a.default)(m, g)) || p.push(m);
        return p
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(746)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e, t) {
        for (var n = -1, r = Array(e); ++n < e; )
            r[n] = t(n);
        return r
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(748)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(749))
      , i = o(n(753));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = Object.prototype
      , a = s.hasOwnProperty
      , c = s.propertyIsEnumerable
      , u = (0,
    r.default)(function() {
        return arguments
    }()) ? r.default : function(e) {
        return (0,
        i.default)(e) && a.call(e, "callee") && !c.call(e, "callee")
    }
    ;
    t.default = u,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(750)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(751))
      , i = o(n(752));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function(e) {
        return (0,
        i.default)(e) && "[object Arguments]" == (0,
        r.default)(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(217)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(220)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(220)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(272)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(353)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(98)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(758)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function() {
        return !1
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(760)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
      , i = /^(?:0|[1-9]\d*)$/;
    t.default = function(e, t) {
        var n = "undefined" === typeof e ? "undefined" : r(e);
        return !!(t = null == t ? 9007199254740991 : t) && ("number" == n || "symbol" != n && i.test(e)) && e > -1 && e % 1 == 0 && e < t
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(355)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(763)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = s(n(764))
      , i = s(n(765))
      , o = s(n(766));
    function s(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var a = {};
    a["[object Float32Array]"] = a["[object Float64Array]"] = a["[object Int8Array]"] = a["[object Int16Array]"] = a["[object Int32Array]"] = a["[object Uint8Array]"] = a["[object Uint8ClampedArray]"] = a["[object Uint16Array]"] = a["[object Uint32Array]"] = !0,
    a["[object Arguments]"] = a["[object Array]"] = a["[object ArrayBuffer]"] = a["[object Boolean]"] = a["[object DataView]"] = a["[object Date]"] = a["[object Error]"] = a["[object Function]"] = a["[object Map]"] = a["[object Number]"] = a["[object Object]"] = a["[object RegExp]"] = a["[object Set]"] = a["[object String]"] = a["[object WeakMap]"] = !1,
    t.default = function(e) {
        return (0,
        o.default)(e) && (0,
        i.default)(e.length) && !!a[(0,
        r.default)(e)]
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(217)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(356)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(220)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(768)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return function(t) {
            return e(t)
        }
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(770)
}
, function(e, t, n) {
    "use strict";
    (function(e) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        var r, i = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        , o = n(771), s = (r = o) && r.__esModule ? r : {
            default: r
        };
        var a = "object" == i(t) && t && !t.nodeType && t
          , c = a && "object" == i(e) && e && !e.nodeType && e
          , u = c && c.exports === a && s.default.process
          , l = function() {
            try {
                var e = c && c.require && c.require("util").types;
                return e || u && u.binding && u.binding("util")
            } catch (t) {}
        }();
        t.default = l,
        e.exports = t.default
    }
    ).call(this, n(354)(e))
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(348)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(773)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(774))
      , i = o(n(776));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = Object.prototype.hasOwnProperty;
    t.default = function(e) {
        if (!(0,
        r.default)(e))
            return (0,
            i.default)(e);
        var t = [];
        for (var n in Object(e))
            s.call(e, n) && "constructor" != n && t.push(n);
        return t
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(775)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = Object.prototype;
    t.default = function(e) {
        var t = e && e.constructor;
        return e === ("function" == typeof t && t.prototype || r)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(777)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(778);
    var o = (0,
    ((r = i) && r.__esModule ? r : {
        default: r
    }).default)(Object.keys, Object);
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(779)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e, t) {
        return function(n) {
            return e(t(n))
        }
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(781)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(782))
      , i = o(n(783));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = function(e) {
        return null != e && (0,
        i.default)(e.length) && !(0,
        r.default)(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(347)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(356)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(785)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = l(n(786))
      , i = l(n(790))
      , o = l(n(791))
      , s = l(n(795))
      , a = l(n(799))
      , c = l(n(803))
      , u = l(n(804));
    function l(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var d = (0,
    u.default)(r.default)
      , h = (0,
    u.default)(i.default)
      , f = (0,
    u.default)(o.default)
      , p = (0,
    u.default)(s.default)
      , g = (0,
    u.default)(a.default)
      , m = c.default;
    (r.default && "[object DataView]" != m(new r.default(new ArrayBuffer(1))) || i.default && "[object Map]" != m(new i.default) || o.default && "[object Promise]" != m(o.default.resolve()) || s.default && "[object Set]" != m(new s.default) || a.default && "[object WeakMap]" != m(new a.default)) && (m = function(e) {
        var t = (0,
        c.default)(e)
          , n = "[object Object]" == t ? e.constructor : void 0
          , r = n ? (0,
        u.default)(n) : "";
        if (r)
            switch (r) {
            case d:
                return "[object DataView]";
            case h:
                return "[object Map]";
            case f:
                return "[object Promise]";
            case p:
                return "[object Set]";
            case g:
                return "[object WeakMap]"
            }
        return t
    }
    ),
    t.default = m,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(787)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(788))
      , i = o(n(789));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = (0,
    r.default)(i.default, "DataView");
    t.default = s,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(148)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(98)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(270)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(792)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(793))
      , i = o(n(794));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = (0,
    r.default)(i.default, "Promise");
    t.default = s,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(148)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(98)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(796)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(797))
      , i = o(n(798));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = (0,
    r.default)(i.default, "Set");
    t.default = s,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(148)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(98)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(800)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(801))
      , i = o(n(802));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = (0,
    r.default)(i.default, "WeakMap");
    t.default = s,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(148)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(98)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(217)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(350)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(272)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(353)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(355)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(220)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(118)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(177)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(269)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(357)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(358)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(177)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(118)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(269)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(818)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return "[object Object]" === Object.prototype.toString.call(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(820)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(821))
      , i = o(n(822));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = (0,
    r.default)((function(e, t, n) {
        var r, o = {};
        for (r in t)
            (0,
            i.default)(r, t) && (o[r] = (0,
            i.default)(r, n) ? e(r, t[r], n[r]) : t[r]);
        for (r in n)
            (0,
            i.default)(r, n) && !(0,
            i.default)(r, o) && (o[r] = n[r]);
        return o
    }
    ));
    t.default = s,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(358)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(273)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(118)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(273)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(826)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r, i = n(827);
    var o = (0,
    ((r = i) && r.__esModule ? r : {
        default: r
    }).default)((function(e) {
        return null == e
    }
    ));
    t.default = o,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(177)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(118)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(830)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = Number.isInteger || function(e) {
        return e << 0 === e
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(832)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var r = o(n(833))
      , i = o(n(834));
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var s = (0,
    r.default)((function(e, t) {
        var n = e < 0 ? t.length + e : e;
        return (0,
        i.default)(t) ? t.charAt(n) : t[n]
    }
    ));
    t.default = s,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(118)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(835)
}
, function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function(e) {
        return "[object String]" === Object.prototype.toString.call(e)
    }
    ,
    e.exports = t.default
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(364)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(273)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(118)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(118)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(357)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(364)
}
, function(e, t, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    e.exports = n(118)
}
, function(e, t, n) {
    "use strict";
    e.exports = function(e, t) {
        if (t = t.split(":")[0],
        !(e = +e))
            return !1;
        switch (t) {
        case "http":
        case "ws":
            return 80 !== e;
        case "https":
        case "wss":
            return 443 !== e;
        case "ftp":
            return 21 !== e;
        case "gopher":
            return 70 !== e;
        case "file":
            return !1
        }
        return 0 !== e
    }
}
, function(e, t, n) {
    "use strict";
    var r = Object.prototype.hasOwnProperty;
    function i(e) {
        try {
            return decodeURIComponent(e.replace(/\+/g, " "))
        } catch (t) {
            return null
        }
    }
    function o(e) {
        try {
            return encodeURIComponent(e)
        } catch (t) {
            return null
        }
    }
    t.stringify = function(e, t) {
        t = t || "";
        var n, i, s = [];
        for (i in "string" !== typeof t && (t = "?"),
        e)
            if (r.call(e, i)) {
                if ((n = e[i]) || null !== n && void 0 !== n && !isNaN(n) || (n = ""),
                i = o(i),
                n = o(n),
                null === i || null === n)
                    continue;
                s.push(i + "=" + n)
            }
        return s.length ? t + s.join("&") : ""
    }
    ,
    t.parse = function(e) {
        for (var t, n = /([^=?#&]+)=?([^&]*)/g, r = {}; t = n.exec(e); ) {
            var o = i(t[1])
              , s = i(t[2]);
            null === o || null === s || o in r || (r[o] = s)
        }
        return r
    }
}
, function(e, t, n) {
    "use strict";
    e.exports = e => encodeURIComponent(e).replace(/[!'()*]/g, e => "%" + e.charCodeAt(0).toString(16).toUpperCase())
}
, function(e, t, n) {
    "use strict";
    var r = new RegExp("%[a-f0-9]{2}","gi")
      , i = new RegExp("(%[a-f0-9]{2})+","gi");
    function o(e, t) {
        try {
            return decodeURIComponent(e.join(""))
        } catch (i) {}
        if (1 === e.length)
            return e;
        t = t || 1;
        var n = e.slice(0, t)
          , r = e.slice(t);
        return Array.prototype.concat.call([], o(n), o(r))
    }
    function s(e) {
        try {
            return decodeURIComponent(e)
        } catch (i) {
            for (var t = e.match(r), n = 1; n < t.length; n++)
                t = (e = o(t, n).join("")).match(r);
            return e
        }
    }
    e.exports = function(e) {
        if ("string" !== typeof e)
            throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e + "`");
        try {
            return e = e.replace(/\+/g, " "),
            decodeURIComponent(e)
        } catch (t) {
            return function(e) {
                for (var n = {
                    "%FE%FF": "\ufffd\ufffd",
                    "%FF%FE": "\ufffd\ufffd"
                }, r = i.exec(e); r; ) {
                    try {
                        n[r[0]] = decodeURIComponent(r[0])
                    } catch (t) {
                        var o = s(r[0]);
                        o !== r[0] && (n[r[0]] = o)
                    }
                    r = i.exec(e)
                }
                n["%C2"] = "\ufffd";
                for (var a = Object.keys(n), c = 0; c < a.length; c++) {
                    var u = a[c];
                    e = e.replace(new RegExp(u,"g"), n[u])
                }
                return e
            }(e)
        }
    }
}
, function(e, t, n) {
    "use strict";
    e.exports = (e, t) => {
        if ("string" !== typeof e || "string" !== typeof t)
            throw new TypeError("Expected the arguments to be of type `string`");
        if ("" === t)
            return [e];
        const n = e.indexOf(t);
        return -1 === n ? [e] : [e.slice(0, n), e.slice(n + t.length)]
    }
}
, function(e, t, n) {
    "use strict";
    e.exports = function(e, t) {
        for (var n = {}, r = Object.keys(e), i = Array.isArray(t), o = 0; o < r.length; o++) {
            var s = r[o]
              , a = e[s];
            (i ? -1 !== t.indexOf(s) : t(s, a, e)) && (n[s] = a)
        }
        return n
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(374)
      , i = 60103
      , o = 60106;
    t.Fragment = 60107,
    t.StrictMode = 60108,
    t.Profiler = 60114;
    var s = 60109
      , a = 60110
      , c = 60112;
    t.Suspense = 60113;
    var u = 60115
      , l = 60116;
    if ("function" === typeof Symbol && Symbol.for) {
        var d = Symbol.for;
        i = d("react.element"),
        o = d("react.portal"),
        t.Fragment = d("react.fragment"),
        t.StrictMode = d("react.strict_mode"),
        t.Profiler = d("react.profiler"),
        s = d("react.provider"),
        a = d("react.context"),
        c = d("react.forward_ref"),
        t.Suspense = d("react.suspense"),
        u = d("react.memo"),
        l = d("react.lazy")
    }
    var h = "function" === typeof Symbol && Symbol.iterator;
    function f(e) {
        for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)
            t += "&args[]=" + encodeURIComponent(arguments[n]);
        return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var p = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , g = {};
    function m(e, t, n) {
        this.props = e,
        this.context = t,
        this.refs = g,
        this.updater = n || p
    }
    function y() {}
    function v(e, t, n) {
        this.props = e,
        this.context = t,
        this.refs = g,
        this.updater = n || p
    }
    m.prototype.isReactComponent = {},
    m.prototype.setState = function(e, t) {
        if ("object" !== typeof e && "function" !== typeof e && null != e)
            throw Error(f(85));
        this.updater.enqueueSetState(this, e, t, "setState")
    }
    ,
    m.prototype.forceUpdate = function(e) {
        this.updater.enqueueForceUpdate(this, e, "forceUpdate")
    }
    ,
    y.prototype = m.prototype;
    var b = v.prototype = new y;
    b.constructor = v,
    r(b, m.prototype),
    b.isPureReactComponent = !0;
    var _ = {
        current: null
    }
      , S = Object.prototype.hasOwnProperty
      , O = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function T(e, t, n) {
        var r, o = {}, s = null, a = null;
        if (null != t)
            for (r in void 0 !== t.ref && (a = t.ref),
            void 0 !== t.key && (s = "" + t.key),
            t)
                S.call(t, r) && !O.hasOwnProperty(r) && (o[r] = t[r]);
        var c = arguments.length - 2;
        if (1 === c)
            o.children = n;
        else if (1 < c) {
            for (var u = Array(c), l = 0; l < c; l++)
                u[l] = arguments[l + 2];
            o.children = u
        }
        if (e && e.defaultProps)
            for (r in c = e.defaultProps)
                void 0 === o[r] && (o[r] = c[r]);
        return {
            $$typeof: i,
            type: e,
            key: s,
            ref: a,
            props: o,
            _owner: _.current
        }
    }
    function I(e) {
        return "object" === typeof e && null !== e && e.$$typeof === i
    }
    var x = /\/+/g;
    function w(e, t) {
        return "object" === typeof e && null !== e && null != e.key ? function(e) {
            var t = {
                "=": "=0",
                ":": "=2"
            };
            return "$" + e.replace(/[=:]/g, (function(e) {
                return t[e]
            }
            ))
        }("" + e.key) : t.toString(36)
    }
    function M(e, t, n, r, s) {
        var a = typeof e;
        "undefined" !== a && "boolean" !== a || (e = null);
        var c = !1;
        if (null === e)
            c = !0;
        else
            switch (a) {
            case "string":
            case "number":
                c = !0;
                break;
            case "object":
                switch (e.$$typeof) {
                case i:
                case o:
                    c = !0
                }
            }
        if (c)
            return s = s(c = e),
            e = "" === r ? "." + w(c, 0) : r,
            Array.isArray(s) ? (n = "",
            null != e && (n = e.replace(x, "$&/") + "/"),
            M(s, t, n, "", (function(e) {
                return e
            }
            ))) : null != s && (I(s) && (s = function(e, t) {
                return {
                    $$typeof: i,
                    type: e.type,
                    key: t,
                    ref: e.ref,
                    props: e.props,
                    _owner: e._owner
                }
            }(s, n + (!s.key || c && c.key === s.key ? "" : ("" + s.key).replace(x, "$&/") + "/") + e)),
            t.push(s)),
            1;
        if (c = 0,
        r = "" === r ? "." : r + ":",
        Array.isArray(e))
            for (var u = 0; u < e.length; u++) {
                var l = r + w(a = e[u], u);
                c += M(a, t, n, l, s)
            }
        else if ("function" === typeof (l = function(e) {
            return null === e || "object" !== typeof e ? null : "function" === typeof (e = h && e[h] || e["@@iterator"]) ? e : null
        }(e)))
            for (e = l.call(e),
            u = 0; !(a = e.next()).done; )
                c += M(a = a.value, t, n, l = r + w(a, u++), s);
        else if ("object" === a)
            throw t = "" + e,
            Error(f(31, "[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t));
        return c
    }
    function A(e, t, n) {
        if (null == e)
            return e;
        var r = []
          , i = 0;
        return M(e, r, "", "", (function(e) {
            return t.call(n, e, i++)
        }
        )),
        r
    }
    function E(e) {
        if (-1 === e._status) {
            var t = e._result;
            t = t(),
            e._status = 0,
            e._result = t,
            t.then((function(t) {
                0 === e._status && (t = t.default,
                e._status = 1,
                e._result = t)
            }
            ), (function(t) {
                0 === e._status && (e._status = 2,
                e._result = t)
            }
            ))
        }
        if (1 === e._status)
            return e._result;
        throw e._result
    }
    var C = {
        current: null
    };
    function N() {
        var e = C.current;
        if (null === e)
            throw Error(f(321));
        return e
    }
    var R = {
        ReactCurrentDispatcher: C,
        ReactCurrentBatchConfig: {
            transition: 0
        },
        ReactCurrentOwner: _,
        IsSomeRendererActing: {
            current: !1
        },
        assign: r
    };
    t.Children = {
        map: A,
        forEach: function(e, t, n) {
            A(e, (function() {
                t.apply(this, arguments)
            }
            ), n)
        },
        count: function(e) {
            var t = 0;
            return A(e, (function() {
                t++
            }
            )),
            t
        },
        toArray: function(e) {
            return A(e, (function(e) {
                return e
            }
            )) || []
        },
        only: function(e) {
            if (!I(e))
                throw Error(f(143));
            return e
        }
    },
    t.Component = m,
    t.PureComponent = v,
    t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = R,
    t.cloneElement = function(e, t, n) {
        if (null === e || void 0 === e)
            throw Error(f(267, e));
        var o = r({}, e.props)
          , s = e.key
          , a = e.ref
          , c = e._owner;
        if (null != t) {
            if (void 0 !== t.ref && (a = t.ref,
            c = _.current),
            void 0 !== t.key && (s = "" + t.key),
            e.type && e.type.defaultProps)
                var u = e.type.defaultProps;
            for (l in t)
                S.call(t, l) && !O.hasOwnProperty(l) && (o[l] = void 0 === t[l] && void 0 !== u ? u[l] : t[l])
        }
        var l = arguments.length - 2;
        if (1 === l)
            o.children = n;
        else if (1 < l) {
            u = Array(l);
            for (var d = 0; d < l; d++)
                u[d] = arguments[d + 2];
            o.children = u
        }
        return {
            $$typeof: i,
            type: e.type,
            key: s,
            ref: a,
            props: o,
            _owner: c
        }
    }
    ,
    t.createContext = function(e, t) {
        return void 0 === t && (t = null),
        (e = {
            $$typeof: a,
            _calculateChangedBits: t,
            _currentValue: e,
            _currentValue2: e,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        }).Provider = {
            $$typeof: s,
            _context: e
        },
        e.Consumer = e
    }
    ,
    t.createElement = T,
    t.createFactory = function(e) {
        var t = T.bind(null, e);
        return t.type = e,
        t
    }
    ,
    t.createRef = function() {
        return {
            current: null
        }
    }
    ,
    t.forwardRef = function(e) {
        return {
            $$typeof: c,
            render: e
        }
    }
    ,
    t.isValidElement = I,
    t.lazy = function(e) {
        return {
            $$typeof: l,
            _payload: {
                _status: -1,
                _result: e
            },
            _init: E
        }
    }
    ,
    t.memo = function(e, t) {
        return {
            $$typeof: u,
            type: e,
            compare: void 0 === t ? null : t
        }
    }
    ,
    t.useCallback = function(e, t) {
        return N().useCallback(e, t)
    }
    ,
    t.useContext = function(e, t) {
        return N().useContext(e, t)
    }
    ,
    t.useDebugValue = function() {}
    ,
    t.useEffect = function(e, t) {
        return N().useEffect(e, t)
    }
    ,
    t.useImperativeHandle = function(e, t, n) {
        return N().useImperativeHandle(e, t, n)
    }
    ,
    t.useLayoutEffect = function(e, t) {
        return N().useLayoutEffect(e, t)
    }
    ,
    t.useMemo = function(e, t) {
        return N().useMemo(e, t)
    }
    ,
    t.useReducer = function(e, t, n) {
        return N().useReducer(e, t, n)
    }
    ,
    t.useRef = function(e) {
        return N().useRef(e)
    }
    ,
    t.useState = function(e) {
        return N().useState(e)
    }
    ,
    t.version = "17.0.2"
}
, function(e, t, n) {
    "use strict";
    e.exports = n(851)
}
, function(e, t, n) {
    "use strict";
    var r = "function" === typeof Symbol && Symbol.for
      , i = r ? Symbol.for("react.element") : 60103
      , o = r ? Symbol.for("react.portal") : 60106
      , s = r ? Symbol.for("react.fragment") : 60107
      , a = r ? Symbol.for("react.strict_mode") : 60108
      , c = r ? Symbol.for("react.profiler") : 60114
      , u = r ? Symbol.for("react.provider") : 60109
      , l = r ? Symbol.for("react.context") : 60110
      , d = r ? Symbol.for("react.async_mode") : 60111
      , h = r ? Symbol.for("react.concurrent_mode") : 60111
      , f = r ? Symbol.for("react.forward_ref") : 60112
      , p = r ? Symbol.for("react.suspense") : 60113
      , g = r ? Symbol.for("react.suspense_list") : 60120
      , m = r ? Symbol.for("react.memo") : 60115
      , y = r ? Symbol.for("react.lazy") : 60116
      , v = r ? Symbol.for("react.block") : 60121
      , b = r ? Symbol.for("react.fundamental") : 60117
      , _ = r ? Symbol.for("react.responder") : 60118
      , S = r ? Symbol.for("react.scope") : 60119;
    function O(e) {
        if ("object" === typeof e && null !== e) {
            var t = e.$$typeof;
            switch (t) {
            case i:
                switch (e = e.type) {
                case d:
                case h:
                case s:
                case c:
                case a:
                case p:
                    return e;
                default:
                    switch (e = e && e.$$typeof) {
                    case l:
                    case f:
                    case y:
                    case m:
                    case u:
                        return e;
                    default:
                        return t
                    }
                }
            case o:
                return t
            }
        }
    }
    function T(e) {
        return O(e) === h
    }
    t.AsyncMode = d,
    t.ConcurrentMode = h,
    t.ContextConsumer = l,
    t.ContextProvider = u,
    t.Element = i,
    t.ForwardRef = f,
    t.Fragment = s,
    t.Lazy = y,
    t.Memo = m,
    t.Portal = o,
    t.Profiler = c,
    t.StrictMode = a,
    t.Suspense = p,
    t.isAsyncMode = function(e) {
        return T(e) || O(e) === d
    }
    ,
    t.isConcurrentMode = T,
    t.isContextConsumer = function(e) {
        return O(e) === l
    }
    ,
    t.isContextProvider = function(e) {
        return O(e) === u
    }
    ,
    t.isElement = function(e) {
        return "object" === typeof e && null !== e && e.$$typeof === i
    }
    ,
    t.isForwardRef = function(e) {
        return O(e) === f
    }
    ,
    t.isFragment = function(e) {
        return O(e) === s
    }
    ,
    t.isLazy = function(e) {
        return O(e) === y
    }
    ,
    t.isMemo = function(e) {
        return O(e) === m
    }
    ,
    t.isPortal = function(e) {
        return O(e) === o
    }
    ,
    t.isProfiler = function(e) {
        return O(e) === c
    }
    ,
    t.isStrictMode = function(e) {
        return O(e) === a
    }
    ,
    t.isSuspense = function(e) {
        return O(e) === p
    }
    ,
    t.isValidElementType = function(e) {
        return "string" === typeof e || "function" === typeof e || e === s || e === h || e === c || e === a || e === p || e === g || "object" === typeof e && null !== e && (e.$$typeof === y || e.$$typeof === m || e.$$typeof === u || e.$$typeof === l || e.$$typeof === f || e.$$typeof === b || e.$$typeof === _ || e.$$typeof === S || e.$$typeof === v)
    }
    ,
    t.typeOf = O
}
, function(e, t, n) {
    "use strict";
    var r = n(7)
      , i = n(374)
      , o = n(853);
    function s(e) {
        for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)
            t += "&args[]=" + encodeURIComponent(arguments[n]);
        return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    if (!r)
        throw Error(s(227));
    var a = new Set
      , c = {};
    function u(e, t) {
        l(e, t),
        l(e + "Capture", t)
    }
    function l(e, t) {
        for (c[e] = t,
        e = 0; e < t.length; e++)
            a.add(t[e])
    }
    var d = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement)
      , h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
      , f = Object.prototype.hasOwnProperty
      , p = {}
      , g = {};
    function m(e, t, n, r, i, o, s) {
        this.acceptsBooleans = 2 === t || 3 === t || 4 === t,
        this.attributeName = r,
        this.attributeNamespace = i,
        this.mustUseProperty = n,
        this.propertyName = e,
        this.type = t,
        this.sanitizeURL = o,
        this.removeEmptyString = s
    }
    var y = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e) {
        y[e] = new m(e,0,!1,e,null,!1,!1)
    }
    )),
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function(e) {
        var t = e[0];
        y[t] = new m(t,1,!1,e[1],null,!1,!1)
    }
    )),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach((function(e) {
        y[e] = new m(e,2,!1,e.toLowerCase(),null,!1,!1)
    }
    )),
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function(e) {
        y[e] = new m(e,2,!1,e,null,!1,!1)
    }
    )),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e) {
        y[e] = new m(e,3,!1,e.toLowerCase(),null,!1,!1)
    }
    )),
    ["checked", "multiple", "muted", "selected"].forEach((function(e) {
        y[e] = new m(e,3,!0,e,null,!1,!1)
    }
    )),
    ["capture", "download"].forEach((function(e) {
        y[e] = new m(e,4,!1,e,null,!1,!1)
    }
    )),
    ["cols", "rows", "size", "span"].forEach((function(e) {
        y[e] = new m(e,6,!1,e,null,!1,!1)
    }
    )),
    ["rowSpan", "start"].forEach((function(e) {
        y[e] = new m(e,5,!1,e.toLowerCase(),null,!1,!1)
    }
    ));
    var v = /[\-:]([a-z])/g;
    function b(e) {
        return e[1].toUpperCase()
    }
    function _(e, t, n, r) {
        var i = y.hasOwnProperty(t) ? y[t] : null;
        (null !== i ? 0 === i.type : !r && (2 < t.length && ("o" === t[0] || "O" === t[0]) && ("n" === t[1] || "N" === t[1]))) || (function(e, t, n, r) {
            if (null === t || "undefined" === typeof t || function(e, t, n, r) {
                if (null !== n && 0 === n.type)
                    return !1;
                switch (typeof t) {
                case "function":
                case "symbol":
                    return !0;
                case "boolean":
                    return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
                default:
                    return !1
                }
            }(e, t, n, r))
                return !0;
            if (r)
                return !1;
            if (null !== n)
                switch (n.type) {
                case 3:
                    return !t;
                case 4:
                    return !1 === t;
                case 5:
                    return isNaN(t);
                case 6:
                    return isNaN(t) || 1 > t
                }
            return !1
        }(t, n, i, r) && (n = null),
        r || null === i ? function(e) {
            return !!f.call(g, e) || !f.call(p, e) && (h.test(e) ? g[e] = !0 : (p[e] = !0,
            !1))
        }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName,
        r = i.attributeNamespace,
        null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n,
        r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e) {
        var t = e.replace(v, b);
        y[t] = new m(t,1,!1,e,null,!1,!1)
    }
    )),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e) {
        var t = e.replace(v, b);
        y[t] = new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)
    }
    )),
    ["xml:base", "xml:lang", "xml:space"].forEach((function(e) {
        var t = e.replace(v, b);
        y[t] = new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)
    }
    )),
    ["tabIndex", "crossOrigin"].forEach((function(e) {
        y[e] = new m(e,1,!1,e.toLowerCase(),null,!1,!1)
    }
    )),
    y.xlinkHref = new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),
    ["src", "href", "action", "formAction"].forEach((function(e) {
        y[e] = new m(e,1,!1,e.toLowerCase(),null,!0,!0)
    }
    ));
    var S = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , O = 60103
      , T = 60106
      , I = 60107
      , x = 60108
      , w = 60114
      , M = 60109
      , A = 60110
      , E = 60112
      , C = 60113
      , N = 60120
      , R = 60115
      , P = 60116
      , D = 60121
      , F = 60128
      , k = 60129
      , j = 60130
      , L = 60131;
    if ("function" === typeof Symbol && Symbol.for) {
        var V = Symbol.for;
        O = V("react.element"),
        T = V("react.portal"),
        I = V("react.fragment"),
        x = V("react.strict_mode"),
        w = V("react.profiler"),
        M = V("react.provider"),
        A = V("react.context"),
        E = V("react.forward_ref"),
        C = V("react.suspense"),
        N = V("react.suspense_list"),
        R = V("react.memo"),
        P = V("react.lazy"),
        D = V("react.block"),
        V("react.scope"),
        F = V("react.opaque.id"),
        k = V("react.debug_trace_mode"),
        j = V("react.offscreen"),
        L = V("react.legacy_hidden")
    }
    var U, q = "function" === typeof Symbol && Symbol.iterator;
    function Q(e) {
        return null === e || "object" !== typeof e ? null : "function" === typeof (e = q && e[q] || e["@@iterator"]) ? e : null
    }
    function B(e) {
        if (void 0 === U)
            try {
                throw Error()
            } catch (n) {
                var t = n.stack.trim().match(/\n( *(at )?)/);
                U = t && t[1] || ""
            }
        return "\n" + U + e
    }
    var G = !1;
    function z(e, t) {
        if (!e || G)
            return "";
        G = !0;
        var n = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (t)
                if (t = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(t.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                "object" === typeof Reflect && Reflect.construct) {
                    try {
                        Reflect.construct(t, [])
                    } catch (c) {
                        var r = c
                    }
                    Reflect.construct(e, [], t)
                } else {
                    try {
                        t.call()
                    } catch (c) {
                        r = c
                    }
                    e.call(t.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (c) {
                    r = c
                }
                e()
            }
        } catch (c) {
            if (c && r && "string" === typeof c.stack) {
                for (var i = c.stack.split("\n"), o = r.stack.split("\n"), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a]; )
                    a--;
                for (; 1 <= s && 0 <= a; s--,
                a--)
                    if (i[s] !== o[a]) {
                        if (1 !== s || 1 !== a)
                            do {
                                if (s--,
                                0 > --a || i[s] !== o[a])
                                    return "\n" + i[s].replace(" at new ", " at ")
                            } while (1 <= s && 0 <= a);
                        break
                    }
            }
        } finally {
            G = !1,
            Error.prepareStackTrace = n
        }
        return (e = e ? e.displayName || e.name : "") ? B(e) : ""
    }
    function H(e) {
        switch (e.tag) {
        case 5:
            return B(e.type);
        case 16:
            return B("Lazy");
        case 13:
            return B("Suspense");
        case 19:
            return B("SuspenseList");
        case 0:
        case 2:
        case 15:
            return e = z(e.type, !1);
        case 11:
            return e = z(e.type.render, !1);
        case 22:
            return e = z(e.type._render, !1);
        case 1:
            return e = z(e.type, !0);
        default:
            return ""
        }
    }
    function K(e) {
        if (null == e)
            return null;
        if ("function" === typeof e)
            return e.displayName || e.name || null;
        if ("string" === typeof e)
            return e;
        switch (e) {
        case I:
            return "Fragment";
        case T:
            return "Portal";
        case w:
            return "Profiler";
        case x:
            return "StrictMode";
        case C:
            return "Suspense";
        case N:
            return "SuspenseList"
        }
        if ("object" === typeof e)
            switch (e.$$typeof) {
            case A:
                return (e.displayName || "Context") + ".Consumer";
            case M:
                return (e._context.displayName || "Context") + ".Provider";
            case E:
                var t = e.render;
                return t = t.displayName || t.name || "",
                e.displayName || ("" !== t ? "ForwardRef(" + t + ")" : "ForwardRef");
            case R:
                return K(e.type);
            case D:
                return K(e._render);
            case P:
                t = e._payload,
                e = e._init;
                try {
                    return K(e(t))
                } catch (n) {}
            }
        return null
    }
    function Y(e) {
        switch (typeof e) {
        case "boolean":
        case "number":
        case "object":
        case "string":
        case "undefined":
            return e;
        default:
            return ""
        }
    }
    function W(e) {
        var t = e.type;
        return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
    }
    function $(e) {
        e._valueTracker || (e._valueTracker = function(e) {
            var t = W(e) ? "checked" : "value"
              , n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
              , r = "" + e[t];
            if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) {
                var i = n.get
                  , o = n.set;
                return Object.defineProperty(e, t, {
                    configurable: !0,
                    get: function() {
                        return i.call(this)
                    },
                    set: function(e) {
                        r = "" + e,
                        o.call(this, e)
                    }
                }),
                Object.defineProperty(e, t, {
                    enumerable: n.enumerable
                }),
                {
                    getValue: function() {
                        return r
                    },
                    setValue: function(e) {
                        r = "" + e
                    },
                    stopTracking: function() {
                        e._valueTracker = null,
                        delete e[t]
                    }
                }
            }
        }(e))
    }
    function X(e) {
        if (!e)
            return !1;
        var t = e._valueTracker;
        if (!t)
            return !0;
        var n = t.getValue()
          , r = "";
        return e && (r = W(e) ? e.checked ? "true" : "false" : e.value),
        (e = r) !== n && (t.setValue(e),
        !0)
    }
    function J(e) {
        if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0)))
            return null;
        try {
            return e.activeElement || e.body
        } catch (t) {
            return e.body
        }
    }
    function Z(e, t) {
        var n = t.checked;
        return i({}, t, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: null != n ? n : e._wrapperState.initialChecked
        })
    }
    function ee(e, t) {
        var n = null == t.defaultValue ? "" : t.defaultValue
          , r = null != t.checked ? t.checked : t.defaultChecked;
        n = Y(null != t.value ? t.value : n),
        e._wrapperState = {
            initialChecked: r,
            initialValue: n,
            controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
        }
    }
    function te(e, t) {
        null != (t = t.checked) && _(e, "checked", t, !1)
    }
    function ne(e, t) {
        te(e, t);
        var n = Y(t.value)
          , r = t.type;
        if (null != n)
            "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
        else if ("submit" === r || "reset" === r)
            return void e.removeAttribute("value");
        t.hasOwnProperty("value") ? ie(e, t.type, n) : t.hasOwnProperty("defaultValue") && ie(e, t.type, Y(t.defaultValue)),
        null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
    }
    function re(e, t, n) {
        if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
            var r = t.type;
            if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value))
                return;
            t = "" + e._wrapperState.initialValue,
            n || t === e.value || (e.value = t),
            e.defaultValue = t
        }
        "" !== (n = e.name) && (e.name = ""),
        e.defaultChecked = !!e._wrapperState.initialChecked,
        "" !== n && (e.name = n)
    }
    function ie(e, t, n) {
        "number" === t && J(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
    }
    function oe(e, t) {
        return e = i({
            children: void 0
        }, t),
        (t = function(e) {
            var t = "";
            return r.Children.forEach(e, (function(e) {
                null != e && (t += e)
            }
            )),
            t
        }(t.children)) && (e.children = t),
        e
    }
    function se(e, t, n, r) {
        if (e = e.options,
        t) {
            t = {};
            for (var i = 0; i < n.length; i++)
                t["$" + n[i]] = !0;
            for (n = 0; n < e.length; n++)
                i = t.hasOwnProperty("$" + e[n].value),
                e[n].selected !== i && (e[n].selected = i),
                i && r && (e[n].defaultSelected = !0)
        } else {
            for (n = "" + Y(n),
            t = null,
            i = 0; i < e.length; i++) {
                if (e[i].value === n)
                    return e[i].selected = !0,
                    void (r && (e[i].defaultSelected = !0));
                null !== t || e[i].disabled || (t = e[i])
            }
            null !== t && (t.selected = !0)
        }
    }
    function ae(e, t) {
        if (null != t.dangerouslySetInnerHTML)
            throw Error(s(91));
        return i({}, t, {
            value: void 0,
            defaultValue: void 0,
            children: "" + e._wrapperState.initialValue
        })
    }
    function ce(e, t) {
        var n = t.value;
        if (null == n) {
            if (n = t.children,
            t = t.defaultValue,
            null != n) {
                if (null != t)
                    throw Error(s(92));
                if (Array.isArray(n)) {
                    if (!(1 >= n.length))
                        throw Error(s(93));
                    n = n[0]
                }
                t = n
            }
            null == t && (t = ""),
            n = t
        }
        e._wrapperState = {
            initialValue: Y(n)
        }
    }
    function ue(e, t) {
        var n = Y(t.value)
          , r = Y(t.defaultValue);
        null != n && ((n = "" + n) !== e.value && (e.value = n),
        null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)),
        null != r && (e.defaultValue = "" + r)
    }
    function le(e) {
        var t = e.textContent;
        t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t)
    }
    var de = "http://www.w3.org/1999/xhtml"
      , he = "http://www.w3.org/2000/svg";
    function fe(e) {
        switch (e) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
        }
    }
    function pe(e, t) {
        return null == e || "http://www.w3.org/1999/xhtml" === e ? fe(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
    }
    var ge, me = function(e) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(t, n, r, i) {
            MSApp.execUnsafeLocalFunction((function() {
                return e(t, n)
            }
            ))
        }
        : e
    }((function(e, t) {
        if (e.namespaceURI !== he || "innerHTML"in e)
            e.innerHTML = t;
        else {
            for ((ge = ge || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
            t = ge.firstChild; e.firstChild; )
                e.removeChild(e.firstChild);
            for (; t.firstChild; )
                e.appendChild(t.firstChild)
        }
    }
    ));
    function ye(e, t) {
        if (t) {
            var n = e.firstChild;
            if (n && n === e.lastChild && 3 === n.nodeType)
                return void (n.nodeValue = t)
        }
        e.textContent = t
    }
    var ve = {
        animationIterationCount: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }
      , be = ["Webkit", "ms", "Moz", "O"];
    function _e(e, t, n) {
        return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || ve.hasOwnProperty(e) && ve[e] ? ("" + t).trim() : t + "px"
    }
    function Se(e, t) {
        for (var n in e = e.style,
        t)
            if (t.hasOwnProperty(n)) {
                var r = 0 === n.indexOf("--")
                  , i = _e(n, t[n], r);
                "float" === n && (n = "cssFloat"),
                r ? e.setProperty(n, i) : e[n] = i
            }
    }
    Object.keys(ve).forEach((function(e) {
        be.forEach((function(t) {
            t = t + e.charAt(0).toUpperCase() + e.substring(1),
            ve[t] = ve[e]
        }
        ))
    }
    ));
    var Oe = i({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function Te(e, t) {
        if (t) {
            if (Oe[e] && (null != t.children || null != t.dangerouslySetInnerHTML))
                throw Error(s(137, e));
            if (null != t.dangerouslySetInnerHTML) {
                if (null != t.children)
                    throw Error(s(60));
                if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html"in t.dangerouslySetInnerHTML))
                    throw Error(s(61))
            }
            if (null != t.style && "object" !== typeof t.style)
                throw Error(s(62))
        }
    }
    function Ie(e, t) {
        if (-1 === e.indexOf("-"))
            return "string" === typeof t.is;
        switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    function xe(e) {
        return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement),
        3 === e.nodeType ? e.parentNode : e
    }
    var we = null
      , Me = null
      , Ae = null;
    function Ee(e) {
        if (e = Jr(e)) {
            if ("function" !== typeof we)
                throw Error(s(280));
            var t = e.stateNode;
            t && (t = ei(t),
            we(e.stateNode, e.type, t))
        }
    }
    function Ce(e) {
        Me ? Ae ? Ae.push(e) : Ae = [e] : Me = e
    }
    function Ne() {
        if (Me) {
            var e = Me
              , t = Ae;
            if (Ae = Me = null,
            Ee(e),
            t)
                for (e = 0; e < t.length; e++)
                    Ee(t[e])
        }
    }
    function Re(e, t) {
        return e(t)
    }
    function Pe(e, t, n, r, i) {
        return e(t, n, r, i)
    }
    function De() {}
    var Fe = Re
      , ke = !1
      , je = !1;
    function Le() {
        null === Me && null === Ae || (De(),
        Ne())
    }
    function Ve(e, t) {
        var n = e.stateNode;
        if (null === n)
            return null;
        var r = ei(n);
        if (null === r)
            return null;
        n = r[t];
        e: switch (t) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)),
            e = !r;
            break e;
        default:
            e = !1
        }
        if (e)
            return null;
        if (n && "function" !== typeof n)
            throw Error(s(231, t, typeof n));
        return n
    }
    var Ue = !1;
    if (d)
        try {
            var qe = {};
            Object.defineProperty(qe, "passive", {
                get: function() {
                    Ue = !0
                }
            }),
            window.addEventListener("test", qe, qe),
            window.removeEventListener("test", qe, qe)
        } catch (ou) {
            Ue = !1
        }
    function Qe(e, t, n, r, i, o, s, a, c) {
        var u = Array.prototype.slice.call(arguments, 3);
        try {
            t.apply(n, u)
        } catch (l) {
            this.onError(l)
        }
    }
    var Be = !1
      , Ge = null
      , ze = !1
      , He = null
      , Ke = {
        onError: function(e) {
            Be = !0,
            Ge = e
        }
    };
    function Ye(e, t, n, r, i, o, s, a, c) {
        Be = !1,
        Ge = null,
        Qe.apply(Ke, arguments)
    }
    function We(e) {
        var t = e
          , n = e;
        if (e.alternate)
            for (; t.return; )
                t = t.return;
        else {
            e = t;
            do {
                0 !== (1026 & (t = e).flags) && (n = t.return),
                e = t.return
            } while (e)
        }
        return 3 === t.tag ? n : null
    }
    function $e(e) {
        if (13 === e.tag) {
            var t = e.memoizedState;
            if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)),
            null !== t)
                return t.dehydrated
        }
        return null
    }
    function Xe(e) {
        if (We(e) !== e)
            throw Error(s(188))
    }
    function Je(e) {
        if (!(e = function(e) {
            var t = e.alternate;
            if (!t) {
                if (null === (t = We(e)))
                    throw Error(s(188));
                return t !== e ? null : e
            }
            for (var n = e, r = t; ; ) {
                var i = n.return;
                if (null === i)
                    break;
                var o = i.alternate;
                if (null === o) {
                    if (null !== (r = i.return)) {
                        n = r;
                        continue
                    }
                    break
                }
                if (i.child === o.child) {
                    for (o = i.child; o; ) {
                        if (o === n)
                            return Xe(i),
                            e;
                        if (o === r)
                            return Xe(i),
                            t;
                        o = o.sibling
                    }
                    throw Error(s(188))
                }
                if (n.return !== r.return)
                    n = i,
                    r = o;
                else {
                    for (var a = !1, c = i.child; c; ) {
                        if (c === n) {
                            a = !0,
                            n = i,
                            r = o;
                            break
                        }
                        if (c === r) {
                            a = !0,
                            r = i,
                            n = o;
                            break
                        }
                        c = c.sibling
                    }
                    if (!a) {
                        for (c = o.child; c; ) {
                            if (c === n) {
                                a = !0,
                                n = o,
                                r = i;
                                break
                            }
                            if (c === r) {
                                a = !0,
                                r = o,
                                n = i;
                                break
                            }
                            c = c.sibling
                        }
                        if (!a)
                            throw Error(s(189))
                    }
                }
                if (n.alternate !== r)
                    throw Error(s(190))
            }
            if (3 !== n.tag)
                throw Error(s(188));
            return n.stateNode.current === n ? e : t
        }(e)))
            return null;
        for (var t = e; ; ) {
            if (5 === t.tag || 6 === t.tag)
                return t;
            if (t.child)
                t.child.return = t,
                t = t.child;
            else {
                if (t === e)
                    break;
                for (; !t.sibling; ) {
                    if (!t.return || t.return === e)
                        return null;
                    t = t.return
                }
                t.sibling.return = t.return,
                t = t.sibling
            }
        }
        return null
    }
    function Ze(e, t) {
        for (var n = e.alternate; null !== t; ) {
            if (t === e || t === n)
                return !0;
            t = t.return
        }
        return !1
    }
    var et, tt, nt, rt, it = !1, ot = [], st = null, at = null, ct = null, ut = new Map, lt = new Map, dt = [], ht = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function ft(e, t, n, r, i) {
        return {
            blockedOn: e,
            domEventName: t,
            eventSystemFlags: 16 | n,
            nativeEvent: i,
            targetContainers: [r]
        }
    }
    function pt(e, t) {
        switch (e) {
        case "focusin":
        case "focusout":
            st = null;
            break;
        case "dragenter":
        case "dragleave":
            at = null;
            break;
        case "mouseover":
        case "mouseout":
            ct = null;
            break;
        case "pointerover":
        case "pointerout":
            ut.delete(t.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            lt.delete(t.pointerId)
        }
    }
    function gt(e, t, n, r, i, o) {
        return null === e || e.nativeEvent !== o ? (e = ft(t, n, r, i, o),
        null !== t && (null !== (t = Jr(t)) && tt(t)),
        e) : (e.eventSystemFlags |= r,
        t = e.targetContainers,
        null !== i && -1 === t.indexOf(i) && t.push(i),
        e)
    }
    function mt(e) {
        var t = Xr(e.target);
        if (null !== t) {
            var n = We(t);
            if (null !== n)
                if (13 === (t = n.tag)) {
                    if (null !== (t = $e(n)))
                        return e.blockedOn = t,
                        void rt(e.lanePriority, (function() {
                            o.unstable_runWithPriority(e.priority, (function() {
                                nt(n)
                            }
                            ))
                        }
                        ))
                } else if (3 === t && n.stateNode.hydrate)
                    return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
        }
        e.blockedOn = null
    }
    function yt(e) {
        if (null !== e.blockedOn)
            return !1;
        for (var t = e.targetContainers; 0 < t.length; ) {
            var n = Jt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
            if (null !== n)
                return null !== (t = Jr(n)) && tt(t),
                e.blockedOn = n,
                !1;
            t.shift()
        }
        return !0
    }
    function vt(e, t, n) {
        yt(e) && n.delete(t)
    }
    function bt() {
        for (it = !1; 0 < ot.length; ) {
            var e = ot[0];
            if (null !== e.blockedOn) {
                null !== (e = Jr(e.blockedOn)) && et(e);
                break
            }
            for (var t = e.targetContainers; 0 < t.length; ) {
                var n = Jt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
                if (null !== n) {
                    e.blockedOn = n;
                    break
                }
                t.shift()
            }
            null === e.blockedOn && ot.shift()
        }
        null !== st && yt(st) && (st = null),
        null !== at && yt(at) && (at = null),
        null !== ct && yt(ct) && (ct = null),
        ut.forEach(vt),
        lt.forEach(vt)
    }
    function _t(e, t) {
        e.blockedOn === t && (e.blockedOn = null,
        it || (it = !0,
        o.unstable_scheduleCallback(o.unstable_NormalPriority, bt)))
    }
    function St(e) {
        function t(t) {
            return _t(t, e)
        }
        if (0 < ot.length) {
            _t(ot[0], e);
            for (var n = 1; n < ot.length; n++) {
                var r = ot[n];
                r.blockedOn === e && (r.blockedOn = null)
            }
        }
        for (null !== st && _t(st, e),
        null !== at && _t(at, e),
        null !== ct && _t(ct, e),
        ut.forEach(t),
        lt.forEach(t),
        n = 0; n < dt.length; n++)
            (r = dt[n]).blockedOn === e && (r.blockedOn = null);
        for (; 0 < dt.length && null === (n = dt[0]).blockedOn; )
            mt(n),
            null === n.blockedOn && dt.shift()
    }
    function Ot(e, t) {
        var n = {};
        return n[e.toLowerCase()] = t.toLowerCase(),
        n["Webkit" + e] = "webkit" + t,
        n["Moz" + e] = "moz" + t,
        n
    }
    var Tt = {
        animationend: Ot("Animation", "AnimationEnd"),
        animationiteration: Ot("Animation", "AnimationIteration"),
        animationstart: Ot("Animation", "AnimationStart"),
        transitionend: Ot("Transition", "TransitionEnd")
    }
      , It = {}
      , xt = {};
    function wt(e) {
        if (It[e])
            return It[e];
        if (!Tt[e])
            return e;
        var t, n = Tt[e];
        for (t in n)
            if (n.hasOwnProperty(t) && t in xt)
                return It[e] = n[t];
        return e
    }
    d && (xt = document.createElement("div").style,
    "AnimationEvent"in window || (delete Tt.animationend.animation,
    delete Tt.animationiteration.animation,
    delete Tt.animationstart.animation),
    "TransitionEvent"in window || delete Tt.transitionend.transition);
    var Mt = wt("animationend")
      , At = wt("animationiteration")
      , Et = wt("animationstart")
      , Ct = wt("transitionend")
      , Nt = new Map
      , Rt = new Map
      , Pt = ["abort", "abort", Mt, "animationEnd", At, "animationIteration", Et, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", Ct, "transitionEnd", "waiting", "waiting"];
    function Dt(e, t) {
        for (var n = 0; n < e.length; n += 2) {
            var r = e[n]
              , i = e[n + 1];
            i = "on" + (i[0].toUpperCase() + i.slice(1)),
            Rt.set(r, t),
            Nt.set(r, i),
            u(i, [r])
        }
    }
    (0,
    o.unstable_now)();
    var Ft = 8;
    function kt(e) {
        if (0 !== (1 & e))
            return Ft = 15,
            1;
        if (0 !== (2 & e))
            return Ft = 14,
            2;
        if (0 !== (4 & e))
            return Ft = 13,
            4;
        var t = 24 & e;
        return 0 !== t ? (Ft = 12,
        t) : 0 !== (32 & e) ? (Ft = 11,
        32) : 0 !== (t = 192 & e) ? (Ft = 10,
        t) : 0 !== (256 & e) ? (Ft = 9,
        256) : 0 !== (t = 3584 & e) ? (Ft = 8,
        t) : 0 !== (4096 & e) ? (Ft = 7,
        4096) : 0 !== (t = 4186112 & e) ? (Ft = 6,
        t) : 0 !== (t = 62914560 & e) ? (Ft = 5,
        t) : 67108864 & e ? (Ft = 4,
        67108864) : 0 !== (134217728 & e) ? (Ft = 3,
        134217728) : 0 !== (t = 805306368 & e) ? (Ft = 2,
        t) : 0 !== (1073741824 & e) ? (Ft = 1,
        1073741824) : (Ft = 8,
        e)
    }
    function jt(e, t) {
        var n = e.pendingLanes;
        if (0 === n)
            return Ft = 0;
        var r = 0
          , i = 0
          , o = e.expiredLanes
          , s = e.suspendedLanes
          , a = e.pingedLanes;
        if (0 !== o)
            r = o,
            i = Ft = 15;
        else if (0 !== (o = 134217727 & n)) {
            var c = o & ~s;
            0 !== c ? (r = kt(c),
            i = Ft) : 0 !== (a &= o) && (r = kt(a),
            i = Ft)
        } else
            0 !== (o = n & ~s) ? (r = kt(o),
            i = Ft) : 0 !== a && (r = kt(a),
            i = Ft);
        if (0 === r)
            return 0;
        if (r = n & ((0 > (r = 31 - Bt(r)) ? 0 : 1 << r) << 1) - 1,
        0 !== t && t !== r && 0 === (t & s)) {
            if (kt(t),
            i <= Ft)
                return t;
            Ft = i
        }
        if (0 !== (t = e.entangledLanes))
            for (e = e.entanglements,
            t &= r; 0 < t; )
                i = 1 << (n = 31 - Bt(t)),
                r |= e[n],
                t &= ~i;
        return r
    }
    function Lt(e) {
        return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
    }
    function Vt(e, t) {
        switch (e) {
        case 15:
            return 1;
        case 14:
            return 2;
        case 12:
            return 0 === (e = Ut(24 & ~t)) ? Vt(10, t) : e;
        case 10:
            return 0 === (e = Ut(192 & ~t)) ? Vt(8, t) : e;
        case 8:
            return 0 === (e = Ut(3584 & ~t)) && (0 === (e = Ut(4186112 & ~t)) && (e = 512)),
            e;
        case 2:
            return 0 === (t = Ut(805306368 & ~t)) && (t = 268435456),
            t
        }
        throw Error(s(358, e))
    }
    function Ut(e) {
        return e & -e
    }
    function qt(e) {
        for (var t = [], n = 0; 31 > n; n++)
            t.push(e);
        return t
    }
    function Qt(e, t, n) {
        e.pendingLanes |= t;
        var r = t - 1;
        e.suspendedLanes &= r,
        e.pingedLanes &= r,
        (e = e.eventTimes)[t = 31 - Bt(t)] = n
    }
    var Bt = Math.clz32 ? Math.clz32 : function(e) {
        return 0 === e ? 32 : 31 - (Gt(e) / zt | 0) | 0
    }
      , Gt = Math.log
      , zt = Math.LN2;
    var Ht = o.unstable_UserBlockingPriority
      , Kt = o.unstable_runWithPriority
      , Yt = !0;
    function Wt(e, t, n, r) {
        ke || De();
        var i = Xt
          , o = ke;
        ke = !0;
        try {
            Pe(i, e, t, n, r)
        } finally {
            (ke = o) || Le()
        }
    }
    function $t(e, t, n, r) {
        Kt(Ht, Xt.bind(null, e, t, n, r))
    }
    function Xt(e, t, n, r) {
        var i;
        if (Yt)
            if ((i = 0 === (4 & t)) && 0 < ot.length && -1 < ht.indexOf(e))
                e = ft(null, e, t, n, r),
                ot.push(e);
            else {
                var o = Jt(e, t, n, r);
                if (null === o)
                    i && pt(e, r);
                else {
                    if (i) {
                        if (-1 < ht.indexOf(e))
                            return e = ft(o, e, t, n, r),
                            void ot.push(e);
                        if (function(e, t, n, r, i) {
                            switch (t) {
                            case "focusin":
                                return st = gt(st, e, t, n, r, i),
                                !0;
                            case "dragenter":
                                return at = gt(at, e, t, n, r, i),
                                !0;
                            case "mouseover":
                                return ct = gt(ct, e, t, n, r, i),
                                !0;
                            case "pointerover":
                                var o = i.pointerId;
                                return ut.set(o, gt(ut.get(o) || null, e, t, n, r, i)),
                                !0;
                            case "gotpointercapture":
                                return o = i.pointerId,
                                lt.set(o, gt(lt.get(o) || null, e, t, n, r, i)),
                                !0
                            }
                            return !1
                        }(o, e, t, n, r))
                            return;
                        pt(e, r)
                    }
                    Cr(e, t, r, null, n)
                }
            }
    }
    function Jt(e, t, n, r) {
        var i = xe(r);
        if (null !== (i = Xr(i))) {
            var o = We(i);
            if (null === o)
                i = null;
            else {
                var s = o.tag;
                if (13 === s) {
                    if (null !== (i = $e(o)))
                        return i;
                    i = null
                } else if (3 === s) {
                    if (o.stateNode.hydrate)
                        return 3 === o.tag ? o.stateNode.containerInfo : null;
                    i = null
                } else
                    o !== i && (i = null)
            }
        }
        return Cr(e, t, r, i, n),
        null
    }
    var Zt = null
      , en = null
      , tn = null;
    function nn() {
        if (tn)
            return tn;
        var e, t, n = en, r = n.length, i = "value"in Zt ? Zt.value : Zt.textContent, o = i.length;
        for (e = 0; e < r && n[e] === i[e]; e++)
            ;
        var s = r - e;
        for (t = 1; t <= s && n[r - t] === i[o - t]; t++)
            ;
        return tn = i.slice(e, 1 < t ? 1 - t : void 0)
    }
    function rn(e) {
        var t = e.keyCode;
        return "charCode"in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t,
        10 === e && (e = 13),
        32 <= e || 13 === e ? e : 0
    }
    function on() {
        return !0
    }
    function sn() {
        return !1
    }
    function an(e) {
        function t(t, n, r, i, o) {
            for (var s in this._reactName = t,
            this._targetInst = r,
            this.type = n,
            this.nativeEvent = i,
            this.target = o,
            this.currentTarget = null,
            e)
                e.hasOwnProperty(s) && (t = e[s],
                this[s] = t ? t(i) : i[s]);
            return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? on : sn,
            this.isPropagationStopped = sn,
            this
        }
        return i(t.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var e = this.nativeEvent;
                e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1),
                this.isDefaultPrevented = on)
            },
            stopPropagation: function() {
                var e = this.nativeEvent;
                e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0),
                this.isPropagationStopped = on)
            },
            persist: function() {},
            isPersistent: on
        }),
        t
    }
    var cn, un, ln, dn = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(e) {
            return e.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, hn = an(dn), fn = i({}, dn, {
        view: 0,
        detail: 0
    }), pn = an(fn), gn = i({}, fn, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: wn,
        button: 0,
        buttons: 0,
        relatedTarget: function(e) {
            return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
        },
        movementX: function(e) {
            return "movementX"in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (cn = e.screenX - ln.screenX,
            un = e.screenY - ln.screenY) : un = cn = 0,
            ln = e),
            cn)
        },
        movementY: function(e) {
            return "movementY"in e ? e.movementY : un
        }
    }), mn = an(gn), yn = an(i({}, gn, {
        dataTransfer: 0
    })), vn = an(i({}, fn, {
        relatedTarget: 0
    })), bn = an(i({}, dn, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })), _n = an(i({}, dn, {
        clipboardData: function(e) {
            return "clipboardData"in e ? e.clipboardData : window.clipboardData
        }
    })), Sn = an(i({}, dn, {
        data: 0
    })), On = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, Tn = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, In = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function xn(e) {
        var t = this.nativeEvent;
        return t.getModifierState ? t.getModifierState(e) : !!(e = In[e]) && !!t[e]
    }
    function wn() {
        return xn
    }
    var Mn = an(i({}, fn, {
        key: function(e) {
            if (e.key) {
                var t = On[e.key] || e.key;
                if ("Unidentified" !== t)
                    return t
            }
            return "keypress" === e.type ? 13 === (e = rn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? Tn[e.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: wn,
        charCode: function(e) {
            return "keypress" === e.type ? rn(e) : 0
        },
        keyCode: function(e) {
            return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
        },
        which: function(e) {
            return "keypress" === e.type ? rn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
        }
    }))
      , An = an(i({}, gn, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }))
      , En = an(i({}, fn, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: wn
    }))
      , Cn = an(i({}, dn, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }))
      , Nn = an(i({}, gn, {
        deltaX: function(e) {
            return "deltaX"in e ? e.deltaX : "wheelDeltaX"in e ? -e.wheelDeltaX : 0
        },
        deltaY: function(e) {
            return "deltaY"in e ? e.deltaY : "wheelDeltaY"in e ? -e.wheelDeltaY : "wheelDelta"in e ? -e.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }))
      , Rn = [9, 13, 27, 32]
      , Pn = d && "CompositionEvent"in window
      , Dn = null;
    d && "documentMode"in document && (Dn = document.documentMode);
    var Fn = d && "TextEvent"in window && !Dn
      , kn = d && (!Pn || Dn && 8 < Dn && 11 >= Dn)
      , jn = String.fromCharCode(32)
      , Ln = !1;
    function Vn(e, t) {
        switch (e) {
        case "keyup":
            return -1 !== Rn.indexOf(t.keyCode);
        case "keydown":
            return 229 !== t.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function Un(e) {
        return "object" === typeof (e = e.detail) && "data"in e ? e.data : null
    }
    var qn = !1;
    var Qn = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function Bn(e) {
        var t = e && e.nodeName && e.nodeName.toLowerCase();
        return "input" === t ? !!Qn[e.type] : "textarea" === t
    }
    function Gn(e, t, n, r) {
        Ce(r),
        0 < (t = Rr(t, "onChange")).length && (n = new hn("onChange","change",null,n,r),
        e.push({
            event: n,
            listeners: t
        }))
    }
    var zn = null
      , Hn = null;
    function Kn(e) {
        Ir(e, 0)
    }
    function Yn(e) {
        if (X(Zr(e)))
            return e
    }
    function Wn(e, t) {
        if ("change" === e)
            return t
    }
    var $n = !1;
    if (d) {
        var Xn;
        if (d) {
            var Jn = "oninput"in document;
            if (!Jn) {
                var Zn = document.createElement("div");
                Zn.setAttribute("oninput", "return;"),
                Jn = "function" === typeof Zn.oninput
            }
            Xn = Jn
        } else
            Xn = !1;
        $n = Xn && (!document.documentMode || 9 < document.documentMode)
    }
    function er() {
        zn && (zn.detachEvent("onpropertychange", tr),
        Hn = zn = null)
    }
    function tr(e) {
        if ("value" === e.propertyName && Yn(Hn)) {
            var t = [];
            if (Gn(t, Hn, e, xe(e)),
            e = Kn,
            ke)
                e(t);
            else {
                ke = !0;
                try {
                    Re(e, t)
                } finally {
                    ke = !1,
                    Le()
                }
            }
        }
    }
    function nr(e, t, n) {
        "focusin" === e ? (er(),
        Hn = n,
        (zn = t).attachEvent("onpropertychange", tr)) : "focusout" === e && er()
    }
    function rr(e) {
        if ("selectionchange" === e || "keyup" === e || "keydown" === e)
            return Yn(Hn)
    }
    function ir(e, t) {
        if ("click" === e)
            return Yn(t)
    }
    function or(e, t) {
        if ("input" === e || "change" === e)
            return Yn(t)
    }
    var sr = "function" === typeof Object.is ? Object.is : function(e, t) {
        return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
    }
      , ar = Object.prototype.hasOwnProperty;
    function cr(e, t) {
        if (sr(e, t))
            return !0;
        if ("object" !== typeof e || null === e || "object" !== typeof t || null === t)
            return !1;
        var n = Object.keys(e)
          , r = Object.keys(t);
        if (n.length !== r.length)
            return !1;
        for (r = 0; r < n.length; r++)
            if (!ar.call(t, n[r]) || !sr(e[n[r]], t[n[r]]))
                return !1;
        return !0
    }
    function ur(e) {
        for (; e && e.firstChild; )
            e = e.firstChild;
        return e
    }
    function lr(e, t) {
        var n, r = ur(e);
        for (e = 0; r; ) {
            if (3 === r.nodeType) {
                if (n = e + r.textContent.length,
                e <= t && n >= t)
                    return {
                        node: r,
                        offset: t - e
                    };
                e = n
            }
            e: {
                for (; r; ) {
                    if (r.nextSibling) {
                        r = r.nextSibling;
                        break e
                    }
                    r = r.parentNode
                }
                r = void 0
            }
            r = ur(r)
        }
    }
    function dr() {
        for (var e = window, t = J(); t instanceof e.HTMLIFrameElement; ) {
            try {
                var n = "string" === typeof t.contentWindow.location.href
            } catch (r) {
                n = !1
            }
            if (!n)
                break;
            t = J((e = t.contentWindow).document)
        }
        return t
    }
    function hr(e) {
        var t = e && e.nodeName && e.nodeName.toLowerCase();
        return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
    }
    var fr = d && "documentMode"in document && 11 >= document.documentMode
      , pr = null
      , gr = null
      , mr = null
      , yr = !1;
    function vr(e, t, n) {
        var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
        yr || null == pr || pr !== J(r) || ("selectionStart"in (r = pr) && hr(r) ? r = {
            start: r.selectionStart,
            end: r.selectionEnd
        } : r = {
            anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
            anchorOffset: r.anchorOffset,
            focusNode: r.focusNode,
            focusOffset: r.focusOffset
        },
        mr && cr(mr, r) || (mr = r,
        0 < (r = Rr(gr, "onSelect")).length && (t = new hn("onSelect","select",null,t,n),
        e.push({
            event: t,
            listeners: r
        }),
        t.target = pr)))
    }
    Dt("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0),
    Dt("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1),
    Dt(Pt, 2);
    for (var br = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), _r = 0; _r < br.length; _r++)
        Rt.set(br[_r], 0);
    l("onMouseEnter", ["mouseout", "mouseover"]),
    l("onMouseLeave", ["mouseout", "mouseover"]),
    l("onPointerEnter", ["pointerout", "pointerover"]),
    l("onPointerLeave", ["pointerout", "pointerover"]),
    u("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    u("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    u("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    u("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    u("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    u("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Sr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , Or = new Set("cancel close invalid load scroll toggle".split(" ").concat(Sr));
    function Tr(e, t, n) {
        var r = e.type || "unknown-event";
        e.currentTarget = n,
        function(e, t, n, r, i, o, a, c, u) {
            if (Ye.apply(this, arguments),
            Be) {
                if (!Be)
                    throw Error(s(198));
                var l = Ge;
                Be = !1,
                Ge = null,
                ze || (ze = !0,
                He = l)
            }
        }(r, t, void 0, e),
        e.currentTarget = null
    }
    function Ir(e, t) {
        t = 0 !== (4 & t);
        for (var n = 0; n < e.length; n++) {
            var r = e[n]
              , i = r.event;
            r = r.listeners;
            e: {
                var o = void 0;
                if (t)
                    for (var s = r.length - 1; 0 <= s; s--) {
                        var a = r[s]
                          , c = a.instance
                          , u = a.currentTarget;
                        if (a = a.listener,
                        c !== o && i.isPropagationStopped())
                            break e;
                        Tr(i, a, u),
                        o = c
                    }
                else
                    for (s = 0; s < r.length; s++) {
                        if (c = (a = r[s]).instance,
                        u = a.currentTarget,
                        a = a.listener,
                        c !== o && i.isPropagationStopped())
                            break e;
                        Tr(i, a, u),
                        o = c
                    }
            }
        }
        if (ze)
            throw e = He,
            ze = !1,
            He = null,
            e
    }
    function xr(e, t) {
        var n = ti(t)
          , r = e + "__bubble";
        n.has(r) || (Er(t, e, 2, !1),
        n.add(r))
    }
    var wr = "_reactListening" + Math.random().toString(36).slice(2);
    function Mr(e) {
        e[wr] || (e[wr] = !0,
        a.forEach((function(t) {
            Or.has(t) || Ar(t, !1, e, null),
            Ar(t, !0, e, null)
        }
        )))
    }
    function Ar(e, t, n, r) {
        var i = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0
          , o = n;
        if ("selectionchange" === e && 9 !== n.nodeType && (o = n.ownerDocument),
        null !== r && !t && Or.has(e)) {
            if ("scroll" !== e)
                return;
            i |= 2,
            o = r
        }
        var s = ti(o)
          , a = e + "__" + (t ? "capture" : "bubble");
        s.has(a) || (t && (i |= 4),
        Er(o, e, i, t),
        s.add(a))
    }
    function Er(e, t, n, r) {
        var i = Rt.get(t);
        switch (void 0 === i ? 2 : i) {
        case 0:
            i = Wt;
            break;
        case 1:
            i = $t;
            break;
        default:
            i = Xt
        }
        n = i.bind(null, t, n, e),
        i = void 0,
        !Ue || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0),
        r ? void 0 !== i ? e.addEventListener(t, n, {
            capture: !0,
            passive: i
        }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, {
            passive: i
        }) : e.addEventListener(t, n, !1)
    }
    function Cr(e, t, n, r, i) {
        var o = r;
        if (0 === (1 & t) && 0 === (2 & t) && null !== r)
            e: for (; ; ) {
                if (null === r)
                    return;
                var s = r.tag;
                if (3 === s || 4 === s) {
                    var a = r.stateNode.containerInfo;
                    if (a === i || 8 === a.nodeType && a.parentNode === i)
                        break;
                    if (4 === s)
                        for (s = r.return; null !== s; ) {
                            var c = s.tag;
                            if ((3 === c || 4 === c) && ((c = s.stateNode.containerInfo) === i || 8 === c.nodeType && c.parentNode === i))
                                return;
                            s = s.return
                        }
                    for (; null !== a; ) {
                        if (null === (s = Xr(a)))
                            return;
                        if (5 === (c = s.tag) || 6 === c) {
                            r = o = s;
                            continue e
                        }
                        a = a.parentNode
                    }
                }
                r = r.return
            }
        !function(e, t, n) {
            if (je)
                return e(t, n);
            je = !0;
            try {
                Fe(e, t, n)
            } finally {
                je = !1,
                Le()
            }
        }((function() {
            var r = o
              , i = xe(n)
              , s = [];
            e: {
                var a = Nt.get(e);
                if (void 0 !== a) {
                    var c = hn
                      , u = e;
                    switch (e) {
                    case "keypress":
                        if (0 === rn(n))
                            break e;
                    case "keydown":
                    case "keyup":
                        c = Mn;
                        break;
                    case "focusin":
                        u = "focus",
                        c = vn;
                        break;
                    case "focusout":
                        u = "blur",
                        c = vn;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        c = vn;
                        break;
                    case "click":
                        if (2 === n.button)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        c = mn;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        c = yn;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        c = En;
                        break;
                    case Mt:
                    case At:
                    case Et:
                        c = bn;
                        break;
                    case Ct:
                        c = Cn;
                        break;
                    case "scroll":
                        c = pn;
                        break;
                    case "wheel":
                        c = Nn;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        c = _n;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        c = An
                    }
                    var l = 0 !== (4 & t)
                      , d = !l && "scroll" === e
                      , h = l ? null !== a ? a + "Capture" : null : a;
                    l = [];
                    for (var f, p = r; null !== p; ) {
                        var g = (f = p).stateNode;
                        if (5 === f.tag && null !== g && (f = g,
                        null !== h && (null != (g = Ve(p, h)) && l.push(Nr(p, g, f)))),
                        d)
                            break;
                        p = p.return
                    }
                    0 < l.length && (a = new c(a,u,null,n,i),
                    s.push({
                        event: a,
                        listeners: l
                    }))
                }
            }
            if (0 === (7 & t)) {
                if (c = "mouseout" === e || "pointerout" === e,
                (!(a = "mouseover" === e || "pointerover" === e) || 0 !== (16 & t) || !(u = n.relatedTarget || n.fromElement) || !Xr(u) && !u[Wr]) && (c || a) && (a = i.window === i ? i : (a = i.ownerDocument) ? a.defaultView || a.parentWindow : window,
                c ? (c = r,
                null !== (u = (u = n.relatedTarget || n.toElement) ? Xr(u) : null) && (u !== (d = We(u)) || 5 !== u.tag && 6 !== u.tag) && (u = null)) : (c = null,
                u = r),
                c !== u)) {
                    if (l = mn,
                    g = "onMouseLeave",
                    h = "onMouseEnter",
                    p = "mouse",
                    "pointerout" !== e && "pointerover" !== e || (l = An,
                    g = "onPointerLeave",
                    h = "onPointerEnter",
                    p = "pointer"),
                    d = null == c ? a : Zr(c),
                    f = null == u ? a : Zr(u),
                    (a = new l(g,p + "leave",c,n,i)).target = d,
                    a.relatedTarget = f,
                    g = null,
                    Xr(i) === r && ((l = new l(h,p + "enter",u,n,i)).target = f,
                    l.relatedTarget = d,
                    g = l),
                    d = g,
                    c && u)
                        e: {
                            for (h = u,
                            p = 0,
                            f = l = c; f; f = Pr(f))
                                p++;
                            for (f = 0,
                            g = h; g; g = Pr(g))
                                f++;
                            for (; 0 < p - f; )
                                l = Pr(l),
                                p--;
                            for (; 0 < f - p; )
                                h = Pr(h),
                                f--;
                            for (; p--; ) {
                                if (l === h || null !== h && l === h.alternate)
                                    break e;
                                l = Pr(l),
                                h = Pr(h)
                            }
                            l = null
                        }
                    else
                        l = null;
                    null !== c && Dr(s, a, c, l, !1),
                    null !== u && null !== d && Dr(s, d, u, l, !0)
                }
                if ("select" === (c = (a = r ? Zr(r) : window).nodeName && a.nodeName.toLowerCase()) || "input" === c && "file" === a.type)
                    var m = Wn;
                else if (Bn(a))
                    if ($n)
                        m = or;
                    else {
                        m = rr;
                        var y = nr
                    }
                else
                    (c = a.nodeName) && "input" === c.toLowerCase() && ("checkbox" === a.type || "radio" === a.type) && (m = ir);
                switch (m && (m = m(e, r)) ? Gn(s, m, n, i) : (y && y(e, a, r),
                "focusout" === e && (y = a._wrapperState) && y.controlled && "number" === a.type && ie(a, "number", a.value)),
                y = r ? Zr(r) : window,
                e) {
                case "focusin":
                    (Bn(y) || "true" === y.contentEditable) && (pr = y,
                    gr = r,
                    mr = null);
                    break;
                case "focusout":
                    mr = gr = pr = null;
                    break;
                case "mousedown":
                    yr = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    yr = !1,
                    vr(s, n, i);
                    break;
                case "selectionchange":
                    if (fr)
                        break;
                case "keydown":
                case "keyup":
                    vr(s, n, i)
                }
                var v;
                if (Pn)
                    e: {
                        switch (e) {
                        case "compositionstart":
                            var b = "onCompositionStart";
                            break e;
                        case "compositionend":
                            b = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            b = "onCompositionUpdate";
                            break e
                        }
                        b = void 0
                    }
                else
                    qn ? Vn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart");
                b && (kn && "ko" !== n.locale && (qn || "onCompositionStart" !== b ? "onCompositionEnd" === b && qn && (v = nn()) : (en = "value"in (Zt = i) ? Zt.value : Zt.textContent,
                qn = !0)),
                0 < (y = Rr(r, b)).length && (b = new Sn(b,e,null,n,i),
                s.push({
                    event: b,
                    listeners: y
                }),
                v ? b.data = v : null !== (v = Un(n)) && (b.data = v))),
                (v = Fn ? function(e, t) {
                    switch (e) {
                    case "compositionend":
                        return Un(t);
                    case "keypress":
                        return 32 !== t.which ? null : (Ln = !0,
                        jn);
                    case "textInput":
                        return (e = t.data) === jn && Ln ? null : e;
                    default:
                        return null
                    }
                }(e, n) : function(e, t) {
                    if (qn)
                        return "compositionend" === e || !Pn && Vn(e, t) ? (e = nn(),
                        tn = en = Zt = null,
                        qn = !1,
                        e) : null;
                    switch (e) {
                    case "paste":
                        return null;
                    case "keypress":
                        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                            if (t.char && 1 < t.char.length)
                                return t.char;
                            if (t.which)
                                return String.fromCharCode(t.which)
                        }
                        return null;
                    case "compositionend":
                        return kn && "ko" !== t.locale ? null : t.data;
                    default:
                        return null
                    }
                }(e, n)) && (0 < (r = Rr(r, "onBeforeInput")).length && (i = new Sn("onBeforeInput","beforeinput",null,n,i),
                s.push({
                    event: i,
                    listeners: r
                }),
                i.data = v))
            }
            Ir(s, t)
        }
        ))
    }
    function Nr(e, t, n) {
        return {
            instance: e,
            listener: t,
            currentTarget: n
        }
    }
    function Rr(e, t) {
        for (var n = t + "Capture", r = []; null !== e; ) {
            var i = e
              , o = i.stateNode;
            5 === i.tag && null !== o && (i = o,
            null != (o = Ve(e, n)) && r.unshift(Nr(e, o, i)),
            null != (o = Ve(e, t)) && r.push(Nr(e, o, i))),
            e = e.return
        }
        return r
    }
    function Pr(e) {
        if (null === e)
            return null;
        do {
            e = e.return
        } while (e && 5 !== e.tag);
        return e || null
    }
    function Dr(e, t, n, r, i) {
        for (var o = t._reactName, s = []; null !== n && n !== r; ) {
            var a = n
              , c = a.alternate
              , u = a.stateNode;
            if (null !== c && c === r)
                break;
            5 === a.tag && null !== u && (a = u,
            i ? null != (c = Ve(n, o)) && s.unshift(Nr(n, c, a)) : i || null != (c = Ve(n, o)) && s.push(Nr(n, c, a))),
            n = n.return
        }
        0 !== s.length && e.push({
            event: t,
            listeners: s
        })
    }
    function Fr() {}
    var kr = null
      , jr = null;
    function Lr(e, t) {
        switch (e) {
        case "button":
        case "input":
        case "select":
        case "textarea":
            return !!t.autoFocus
        }
        return !1
    }
    function Vr(e, t) {
        return "textarea" === e || "option" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
    }
    var Ur = "function" === typeof setTimeout ? setTimeout : void 0
      , qr = "function" === typeof clearTimeout ? clearTimeout : void 0;
    function Qr(e) {
        1 === e.nodeType ? e.textContent = "" : 9 === e.nodeType && (null != (e = e.body) && (e.textContent = ""))
    }
    function Br(e) {
        for (; null != e; e = e.nextSibling) {
            var t = e.nodeType;
            if (1 === t || 3 === t)
                break
        }
        return e
    }
    function Gr(e) {
        e = e.previousSibling;
        for (var t = 0; e; ) {
            if (8 === e.nodeType) {
                var n = e.data;
                if ("$" === n || "$!" === n || "$?" === n) {
                    if (0 === t)
                        return e;
                    t--
                } else
                    "/$" === n && t++
            }
            e = e.previousSibling
        }
        return null
    }
    var zr = 0;
    var Hr = Math.random().toString(36).slice(2)
      , Kr = "__reactFiber$" + Hr
      , Yr = "__reactProps$" + Hr
      , Wr = "__reactContainer$" + Hr
      , $r = "__reactEvents$" + Hr;
    function Xr(e) {
        var t = e[Kr];
        if (t)
            return t;
        for (var n = e.parentNode; n; ) {
            if (t = n[Wr] || n[Kr]) {
                if (n = t.alternate,
                null !== t.child || null !== n && null !== n.child)
                    for (e = Gr(e); null !== e; ) {
                        if (n = e[Kr])
                            return n;
                        e = Gr(e)
                    }
                return t
            }
            n = (e = n).parentNode
        }
        return null
    }
    function Jr(e) {
        return !(e = e[Kr] || e[Wr]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e
    }
    function Zr(e) {
        if (5 === e.tag || 6 === e.tag)
            return e.stateNode;
        throw Error(s(33))
    }
    function ei(e) {
        return e[Yr] || null
    }
    function ti(e) {
        var t = e[$r];
        return void 0 === t && (t = e[$r] = new Set),
        t
    }
    var ni = []
      , ri = -1;
    function ii(e) {
        return {
            current: e
        }
    }
    function oi(e) {
        0 > ri || (e.current = ni[ri],
        ni[ri] = null,
        ri--)
    }
    function si(e, t) {
        ri++,
        ni[ri] = e.current,
        e.current = t
    }
    var ai = {}
      , ci = ii(ai)
      , ui = ii(!1)
      , li = ai;
    function di(e, t) {
        var n = e.type.contextTypes;
        if (!n)
            return ai;
        var r = e.stateNode;
        if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
            return r.__reactInternalMemoizedMaskedChildContext;
        var i, o = {};
        for (i in n)
            o[i] = t[i];
        return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t,
        e.__reactInternalMemoizedMaskedChildContext = o),
        o
    }
    function hi(e) {
        return null !== (e = e.childContextTypes) && void 0 !== e
    }
    function fi() {
        oi(ui),
        oi(ci)
    }
    function pi(e, t, n) {
        if (ci.current !== ai)
            throw Error(s(168));
        si(ci, t),
        si(ui, n)
    }
    function gi(e, t, n) {
        var r = e.stateNode;
        if (e = t.childContextTypes,
        "function" !== typeof r.getChildContext)
            return n;
        for (var o in r = r.getChildContext())
            if (!(o in e))
                throw Error(s(108, K(t) || "Unknown", o));
        return i({}, n, r)
    }
    function mi(e) {
        return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ai,
        li = ci.current,
        si(ci, e),
        si(ui, ui.current),
        !0
    }
    function yi(e, t, n) {
        var r = e.stateNode;
        if (!r)
            throw Error(s(169));
        n ? (e = gi(e, t, li),
        r.__reactInternalMemoizedMergedChildContext = e,
        oi(ui),
        oi(ci),
        si(ci, e)) : oi(ui),
        si(ui, n)
    }
    var vi = null
      , bi = null
      , _i = o.unstable_runWithPriority
      , Si = o.unstable_scheduleCallback
      , Oi = o.unstable_cancelCallback
      , Ti = o.unstable_shouldYield
      , Ii = o.unstable_requestPaint
      , xi = o.unstable_now
      , wi = o.unstable_getCurrentPriorityLevel
      , Mi = o.unstable_ImmediatePriority
      , Ai = o.unstable_UserBlockingPriority
      , Ei = o.unstable_NormalPriority
      , Ci = o.unstable_LowPriority
      , Ni = o.unstable_IdlePriority
      , Ri = {}
      , Pi = void 0 !== Ii ? Ii : function() {}
      , Di = null
      , Fi = null
      , ki = !1
      , ji = xi()
      , Li = 1e4 > ji ? xi : function() {
        return xi() - ji
    }
    ;
    function Vi() {
        switch (wi()) {
        case Mi:
            return 99;
        case Ai:
            return 98;
        case Ei:
            return 97;
        case Ci:
            return 96;
        case Ni:
            return 95;
        default:
            throw Error(s(332))
        }
    }
    function Ui(e) {
        switch (e) {
        case 99:
            return Mi;
        case 98:
            return Ai;
        case 97:
            return Ei;
        case 96:
            return Ci;
        case 95:
            return Ni;
        default:
            throw Error(s(332))
        }
    }
    function qi(e, t) {
        return e = Ui(e),
        _i(e, t)
    }
    function Qi(e, t, n) {
        return e = Ui(e),
        Si(e, t, n)
    }
    function Bi() {
        if (null !== Fi) {
            var e = Fi;
            Fi = null,
            Oi(e)
        }
        Gi()
    }
    function Gi() {
        if (!ki && null !== Di) {
            ki = !0;
            var e = 0;
            try {
                var t = Di;
                qi(99, (function() {
                    for (; e < t.length; e++) {
                        var n = t[e];
                        do {
                            n = n(!0)
                        } while (null !== n)
                    }
                }
                )),
                Di = null
            } catch (n) {
                throw null !== Di && (Di = Di.slice(e + 1)),
                Si(Mi, Bi),
                n
            } finally {
                ki = !1
            }
        }
    }
    var zi = S.ReactCurrentBatchConfig;
    function Hi(e, t) {
        if (e && e.defaultProps) {
            for (var n in t = i({}, t),
            e = e.defaultProps)
                void 0 === t[n] && (t[n] = e[n]);
            return t
        }
        return t
    }
    var Ki = ii(null)
      , Yi = null
      , Wi = null
      , $i = null;
    function Xi() {
        $i = Wi = Yi = null
    }
    function Ji(e) {
        var t = Ki.current;
        oi(Ki),
        e.type._context._currentValue = t
    }
    function Zi(e, t) {
        for (; null !== e; ) {
            var n = e.alternate;
            if ((e.childLanes & t) === t) {
                if (null === n || (n.childLanes & t) === t)
                    break;
                n.childLanes |= t
            } else
                e.childLanes |= t,
                null !== n && (n.childLanes |= t);
            e = e.return
        }
    }
    function eo(e, t) {
        Yi = e,
        $i = Wi = null,
        null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (Rs = !0),
        e.firstContext = null)
    }
    function to(e, t) {
        if ($i !== e && !1 !== t && 0 !== t)
            if ("number" === typeof t && 1073741823 !== t || ($i = e,
            t = 1073741823),
            t = {
                context: e,
                observedBits: t,
                next: null
            },
            null === Wi) {
                if (null === Yi)
                    throw Error(s(308));
                Wi = t,
                Yi.dependencies = {
                    lanes: 0,
                    firstContext: t,
                    responders: null
                }
            } else
                Wi = Wi.next = t;
        return e._currentValue
    }
    var no = !1;
    function ro(e) {
        e.updateQueue = {
            baseState: e.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null
            },
            effects: null
        }
    }
    function io(e, t) {
        e = e.updateQueue,
        t.updateQueue === e && (t.updateQueue = {
            baseState: e.baseState,
            firstBaseUpdate: e.firstBaseUpdate,
            lastBaseUpdate: e.lastBaseUpdate,
            shared: e.shared,
            effects: e.effects
        })
    }
    function oo(e, t) {
        return {
            eventTime: e,
            lane: t,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function so(e, t) {
        if (null !== (e = e.updateQueue)) {
            var n = (e = e.shared).pending;
            null === n ? t.next = t : (t.next = n.next,
            n.next = t),
            e.pending = t
        }
    }
    function ao(e, t) {
        var n = e.updateQueue
          , r = e.alternate;
        if (null !== r && n === (r = r.updateQueue)) {
            var i = null
              , o = null;
            if (null !== (n = n.firstBaseUpdate)) {
                do {
                    var s = {
                        eventTime: n.eventTime,
                        lane: n.lane,
                        tag: n.tag,
                        payload: n.payload,
                        callback: n.callback,
                        next: null
                    };
                    null === o ? i = o = s : o = o.next = s,
                    n = n.next
                } while (null !== n);
                null === o ? i = o = t : o = o.next = t
            } else
                i = o = t;
            return n = {
                baseState: r.baseState,
                firstBaseUpdate: i,
                lastBaseUpdate: o,
                shared: r.shared,
                effects: r.effects
            },
            void (e.updateQueue = n)
        }
        null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t,
        n.lastBaseUpdate = t
    }
    function co(e, t, n, r) {
        var o = e.updateQueue;
        no = !1;
        var s = o.firstBaseUpdate
          , a = o.lastBaseUpdate
          , c = o.shared.pending;
        if (null !== c) {
            o.shared.pending = null;
            var u = c
              , l = u.next;
            u.next = null,
            null === a ? s = l : a.next = l,
            a = u;
            var d = e.alternate;
            if (null !== d) {
                var h = (d = d.updateQueue).lastBaseUpdate;
                h !== a && (null === h ? d.firstBaseUpdate = l : h.next = l,
                d.lastBaseUpdate = u)
            }
        }
        if (null !== s) {
            for (h = o.baseState,
            a = 0,
            d = l = u = null; ; ) {
                c = s.lane;
                var f = s.eventTime;
                if ((r & c) === c) {
                    null !== d && (d = d.next = {
                        eventTime: f,
                        lane: 0,
                        tag: s.tag,
                        payload: s.payload,
                        callback: s.callback,
                        next: null
                    });
                    e: {
                        var p = e
                          , g = s;
                        switch (c = t,
                        f = n,
                        g.tag) {
                        case 1:
                            if ("function" === typeof (p = g.payload)) {
                                h = p.call(f, h, c);
                                break e
                            }
                            h = p;
                            break e;
                        case 3:
                            p.flags = -4097 & p.flags | 64;
                        case 0:
                            if (null === (c = "function" === typeof (p = g.payload) ? p.call(f, h, c) : p) || void 0 === c)
                                break e;
                            h = i({}, h, c);
                            break e;
                        case 2:
                            no = !0
                        }
                    }
                    null !== s.callback && (e.flags |= 32,
                    null === (c = o.effects) ? o.effects = [s] : c.push(s))
                } else
                    f = {
                        eventTime: f,
                        lane: c,
                        tag: s.tag,
                        payload: s.payload,
                        callback: s.callback,
                        next: null
                    },
                    null === d ? (l = d = f,
                    u = h) : d = d.next = f,
                    a |= c;
                if (null === (s = s.next)) {
                    if (null === (c = o.shared.pending))
                        break;
                    s = c.next,
                    c.next = null,
                    o.lastBaseUpdate = c,
                    o.shared.pending = null
                }
            }
            null === d && (u = h),
            o.baseState = u,
            o.firstBaseUpdate = l,
            o.lastBaseUpdate = d,
            Da |= a,
            e.lanes = a,
            e.memoizedState = h
        }
    }
    function uo(e, t, n) {
        if (e = t.effects,
        t.effects = null,
        null !== e)
            for (t = 0; t < e.length; t++) {
                var r = e[t]
                  , i = r.callback;
                if (null !== i) {
                    if (r.callback = null,
                    r = n,
                    "function" !== typeof i)
                        throw Error(s(191, i));
                    i.call(r)
                }
            }
    }
    var lo = (new r.Component).refs;
    function ho(e, t, n, r) {
        n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : i({}, t, n),
        e.memoizedState = n,
        0 === e.lanes && (e.updateQueue.baseState = n)
    }
    var fo = {
        isMounted: function(e) {
            return !!(e = e._reactInternals) && We(e) === e
        },
        enqueueSetState: function(e, t, n) {
            e = e._reactInternals;
            var r = oc()
              , i = sc(e)
              , o = oo(r, i);
            o.payload = t,
            void 0 !== n && null !== n && (o.callback = n),
            so(e, o),
            ac(e, i, r)
        },
        enqueueReplaceState: function(e, t, n) {
            e = e._reactInternals;
            var r = oc()
              , i = sc(e)
              , o = oo(r, i);
            o.tag = 1,
            o.payload = t,
            void 0 !== n && null !== n && (o.callback = n),
            so(e, o),
            ac(e, i, r)
        },
        enqueueForceUpdate: function(e, t) {
            e = e._reactInternals;
            var n = oc()
              , r = sc(e)
              , i = oo(n, r);
            i.tag = 2,
            void 0 !== t && null !== t && (i.callback = t),
            so(e, i),
            ac(e, r, n)
        }
    };
    function po(e, t, n, r, i, o, s) {
        return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, s) : !t.prototype || !t.prototype.isPureReactComponent || (!cr(n, r) || !cr(i, o))
    }
    function go(e, t, n) {
        var r = !1
          , i = ai
          , o = t.contextType;
        return "object" === typeof o && null !== o ? o = to(o) : (i = hi(t) ? li : ci.current,
        o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? di(e, i) : ai),
        t = new t(n,o),
        e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null,
        t.updater = fo,
        e.stateNode = t,
        t._reactInternals = e,
        r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i,
        e.__reactInternalMemoizedMaskedChildContext = o),
        t
    }
    function mo(e, t, n, r) {
        e = t.state,
        "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r),
        "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r),
        t.state !== e && fo.enqueueReplaceState(t, t.state, null)
    }
    function yo(e, t, n, r) {
        var i = e.stateNode;
        i.props = n,
        i.state = e.memoizedState,
        i.refs = lo,
        ro(e);
        var o = t.contextType;
        "object" === typeof o && null !== o ? i.context = to(o) : (o = hi(t) ? li : ci.current,
        i.context = di(e, o)),
        co(e, n, i, r),
        i.state = e.memoizedState,
        "function" === typeof (o = t.getDerivedStateFromProps) && (ho(e, t, o, n),
        i.state = e.memoizedState),
        "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state,
        "function" === typeof i.componentWillMount && i.componentWillMount(),
        "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(),
        t !== i.state && fo.enqueueReplaceState(i, i.state, null),
        co(e, n, i, r),
        i.state = e.memoizedState),
        "function" === typeof i.componentDidMount && (e.flags |= 4)
    }
    var vo = Array.isArray;
    function bo(e, t, n) {
        if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
            if (n._owner) {
                if (n = n._owner) {
                    if (1 !== n.tag)
                        throw Error(s(309));
                    var r = n.stateNode
                }
                if (!r)
                    throw Error(s(147, e));
                var i = "" + e;
                return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === i ? t.ref : ((t = function(e) {
                    var t = r.refs;
                    t === lo && (t = r.refs = {}),
                    null === e ? delete t[i] : t[i] = e
                }
                )._stringRef = i,
                t)
            }
            if ("string" !== typeof e)
                throw Error(s(284));
            if (!n._owner)
                throw Error(s(290, e))
        }
        return e
    }
    function _o(e, t) {
        if ("textarea" !== e.type)
            throw Error(s(31, "[object Object]" === Object.prototype.toString.call(t) ? "object with keys {" + Object.keys(t).join(", ") + "}" : t))
    }
    function So(e) {
        function t(t, n) {
            if (e) {
                var r = t.lastEffect;
                null !== r ? (r.nextEffect = n,
                t.lastEffect = n) : t.firstEffect = t.lastEffect = n,
                n.nextEffect = null,
                n.flags = 8
            }
        }
        function n(n, r) {
            if (!e)
                return null;
            for (; null !== r; )
                t(n, r),
                r = r.sibling;
            return null
        }
        function r(e, t) {
            for (e = new Map; null !== t; )
                null !== t.key ? e.set(t.key, t) : e.set(t.index, t),
                t = t.sibling;
            return e
        }
        function i(e, t) {
            return (e = Vc(e, t)).index = 0,
            e.sibling = null,
            e
        }
        function o(t, n, r) {
            return t.index = r,
            e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags = 2,
            n) : r : (t.flags = 2,
            n) : n
        }
        function a(t) {
            return e && null === t.alternate && (t.flags = 2),
            t
        }
        function c(e, t, n, r) {
            return null === t || 6 !== t.tag ? ((t = Bc(n, e.mode, r)).return = e,
            t) : ((t = i(t, n)).return = e,
            t)
        }
        function u(e, t, n, r) {
            return null !== t && t.elementType === n.type ? ((r = i(t, n.props)).ref = bo(e, t, n),
            r.return = e,
            r) : ((r = Uc(n.type, n.key, n.props, null, e.mode, r)).ref = bo(e, t, n),
            r.return = e,
            r)
        }
        function l(e, t, n, r) {
            return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Gc(n, e.mode, r)).return = e,
            t) : ((t = i(t, n.children || [])).return = e,
            t)
        }
        function d(e, t, n, r, o) {
            return null === t || 7 !== t.tag ? ((t = qc(n, e.mode, r, o)).return = e,
            t) : ((t = i(t, n)).return = e,
            t)
        }
        function h(e, t, n) {
            if ("string" === typeof t || "number" === typeof t)
                return (t = Bc("" + t, e.mode, n)).return = e,
                t;
            if ("object" === typeof t && null !== t) {
                switch (t.$$typeof) {
                case O:
                    return (n = Uc(t.type, t.key, t.props, null, e.mode, n)).ref = bo(e, null, t),
                    n.return = e,
                    n;
                case T:
                    return (t = Gc(t, e.mode, n)).return = e,
                    t
                }
                if (vo(t) || Q(t))
                    return (t = qc(t, e.mode, n, null)).return = e,
                    t;
                _o(e, t)
            }
            return null
        }
        function f(e, t, n, r) {
            var i = null !== t ? t.key : null;
            if ("string" === typeof n || "number" === typeof n)
                return null !== i ? null : c(e, t, "" + n, r);
            if ("object" === typeof n && null !== n) {
                switch (n.$$typeof) {
                case O:
                    return n.key === i ? n.type === I ? d(e, t, n.props.children, r, i) : u(e, t, n, r) : null;
                case T:
                    return n.key === i ? l(e, t, n, r) : null
                }
                if (vo(n) || Q(n))
                    return null !== i ? null : d(e, t, n, r, null);
                _o(e, n)
            }
            return null
        }
        function p(e, t, n, r, i) {
            if ("string" === typeof r || "number" === typeof r)
                return c(t, e = e.get(n) || null, "" + r, i);
            if ("object" === typeof r && null !== r) {
                switch (r.$$typeof) {
                case O:
                    return e = e.get(null === r.key ? n : r.key) || null,
                    r.type === I ? d(t, e, r.props.children, i, r.key) : u(t, e, r, i);
                case T:
                    return l(t, e = e.get(null === r.key ? n : r.key) || null, r, i)
                }
                if (vo(r) || Q(r))
                    return d(t, e = e.get(n) || null, r, i, null);
                _o(t, r)
            }
            return null
        }
        function g(i, s, a, c) {
            for (var u = null, l = null, d = s, g = s = 0, m = null; null !== d && g < a.length; g++) {
                d.index > g ? (m = d,
                d = null) : m = d.sibling;
                var y = f(i, d, a[g], c);
                if (null === y) {
                    null === d && (d = m);
                    break
                }
                e && d && null === y.alternate && t(i, d),
                s = o(y, s, g),
                null === l ? u = y : l.sibling = y,
                l = y,
                d = m
            }
            if (g === a.length)
                return n(i, d),
                u;
            if (null === d) {
                for (; g < a.length; g++)
                    null !== (d = h(i, a[g], c)) && (s = o(d, s, g),
                    null === l ? u = d : l.sibling = d,
                    l = d);
                return u
            }
            for (d = r(i, d); g < a.length; g++)
                null !== (m = p(d, i, g, a[g], c)) && (e && null !== m.alternate && d.delete(null === m.key ? g : m.key),
                s = o(m, s, g),
                null === l ? u = m : l.sibling = m,
                l = m);
            return e && d.forEach((function(e) {
                return t(i, e)
            }
            )),
            u
        }
        function m(i, a, c, u) {
            var l = Q(c);
            if ("function" !== typeof l)
                throw Error(s(150));
            if (null == (c = l.call(c)))
                throw Error(s(151));
            for (var d = l = null, g = a, m = a = 0, y = null, v = c.next(); null !== g && !v.done; m++,
            v = c.next()) {
                g.index > m ? (y = g,
                g = null) : y = g.sibling;
                var b = f(i, g, v.value, u);
                if (null === b) {
                    null === g && (g = y);
                    break
                }
                e && g && null === b.alternate && t(i, g),
                a = o(b, a, m),
                null === d ? l = b : d.sibling = b,
                d = b,
                g = y
            }
            if (v.done)
                return n(i, g),
                l;
            if (null === g) {
                for (; !v.done; m++,
                v = c.next())
                    null !== (v = h(i, v.value, u)) && (a = o(v, a, m),
                    null === d ? l = v : d.sibling = v,
                    d = v);
                return l
            }
            for (g = r(i, g); !v.done; m++,
            v = c.next())
                null !== (v = p(g, i, m, v.value, u)) && (e && null !== v.alternate && g.delete(null === v.key ? m : v.key),
                a = o(v, a, m),
                null === d ? l = v : d.sibling = v,
                d = v);
            return e && g.forEach((function(e) {
                return t(i, e)
            }
            )),
            l
        }
        return function(e, r, o, c) {
            var u = "object" === typeof o && null !== o && o.type === I && null === o.key;
            u && (o = o.props.children);
            var l = "object" === typeof o && null !== o;
            if (l)
                switch (o.$$typeof) {
                case O:
                    e: {
                        for (l = o.key,
                        u = r; null !== u; ) {
                            if (u.key === l) {
                                switch (u.tag) {
                                case 7:
                                    if (o.type === I) {
                                        n(e, u.sibling),
                                        (r = i(u, o.props.children)).return = e,
                                        e = r;
                                        break e
                                    }
                                    break;
                                default:
                                    if (u.elementType === o.type) {
                                        n(e, u.sibling),
                                        (r = i(u, o.props)).ref = bo(e, u, o),
                                        r.return = e,
                                        e = r;
                                        break e
                                    }
                                }
                                n(e, u);
                                break
                            }
                            t(e, u),
                            u = u.sibling
                        }
                        o.type === I ? ((r = qc(o.props.children, e.mode, c, o.key)).return = e,
                        e = r) : ((c = Uc(o.type, o.key, o.props, null, e.mode, c)).ref = bo(e, r, o),
                        c.return = e,
                        e = c)
                    }
                    return a(e);
                case T:
                    e: {
                        for (u = o.key; null !== r; ) {
                            if (r.key === u) {
                                if (4 === r.tag && r.stateNode.containerInfo === o.containerInfo && r.stateNode.implementation === o.implementation) {
                                    n(e, r.sibling),
                                    (r = i(r, o.children || [])).return = e,
                                    e = r;
                                    break e
                                }
                                n(e, r);
                                break
                            }
                            t(e, r),
                            r = r.sibling
                        }
                        (r = Gc(o, e.mode, c)).return = e,
                        e = r
                    }
                    return a(e)
                }
            if ("string" === typeof o || "number" === typeof o)
                return o = "" + o,
                null !== r && 6 === r.tag ? (n(e, r.sibling),
                (r = i(r, o)).return = e,
                e = r) : (n(e, r),
                (r = Bc(o, e.mode, c)).return = e,
                e = r),
                a(e);
            if (vo(o))
                return g(e, r, o, c);
            if (Q(o))
                return m(e, r, o, c);
            if (l && _o(e, o),
            "undefined" === typeof o && !u)
                switch (e.tag) {
                case 1:
                case 22:
                case 0:
                case 11:
                case 15:
                    throw Error(s(152, K(e.type) || "Component"))
                }
            return n(e, r)
        }
    }
    var Oo = So(!0)
      , To = So(!1)
      , Io = {}
      , xo = ii(Io)
      , wo = ii(Io)
      , Mo = ii(Io);
    function Ao(e) {
        if (e === Io)
            throw Error(s(174));
        return e
    }
    function Eo(e, t) {
        switch (si(Mo, t),
        si(wo, e),
        si(xo, Io),
        e = t.nodeType) {
        case 9:
        case 11:
            t = (t = t.documentElement) ? t.namespaceURI : pe(null, "");
            break;
        default:
            t = pe(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName)
        }
        oi(xo),
        si(xo, t)
    }
    function Co() {
        oi(xo),
        oi(wo),
        oi(Mo)
    }
    function No(e) {
        Ao(Mo.current);
        var t = Ao(xo.current)
          , n = pe(t, e.type);
        t !== n && (si(wo, e),
        si(xo, n))
    }
    function Ro(e) {
        wo.current === e && (oi(xo),
        oi(wo))
    }
    var Po = ii(0);
    function Do(e) {
        for (var t = e; null !== t; ) {
            if (13 === t.tag) {
                var n = t.memoizedState;
                if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data))
                    return t
            } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                if (0 !== (64 & t.flags))
                    return t
            } else if (null !== t.child) {
                t.child.return = t,
                t = t.child;
                continue
            }
            if (t === e)
                break;
            for (; null === t.sibling; ) {
                if (null === t.return || t.return === e)
                    return null;
                t = t.return
            }
            t.sibling.return = t.return,
            t = t.sibling
        }
        return null
    }
    var Fo = null
      , ko = null
      , jo = !1;
    function Lo(e, t) {
        var n = jc(5, null, null, 0);
        n.elementType = "DELETED",
        n.type = "DELETED",
        n.stateNode = t,
        n.return = e,
        n.flags = 8,
        null !== e.lastEffect ? (e.lastEffect.nextEffect = n,
        e.lastEffect = n) : e.firstEffect = e.lastEffect = n
    }
    function Vo(e, t) {
        switch (e.tag) {
        case 5:
            var n = e.type;
            return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t,
            !0);
        case 6:
            return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t,
            !0);
        case 13:
        default:
            return !1
        }
    }
    function Uo(e) {
        if (jo) {
            var t = ko;
            if (t) {
                var n = t;
                if (!Vo(e, t)) {
                    if (!(t = Br(n.nextSibling)) || !Vo(e, t))
                        return e.flags = -1025 & e.flags | 2,
                        jo = !1,
                        void (Fo = e);
                    Lo(Fo, n)
                }
                Fo = e,
                ko = Br(t.firstChild)
            } else
                e.flags = -1025 & e.flags | 2,
                jo = !1,
                Fo = e
        }
    }
    function qo(e) {
        for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag; )
            e = e.return;
        Fo = e
    }
    function Qo(e) {
        if (e !== Fo)
            return !1;
        if (!jo)
            return qo(e),
            jo = !0,
            !1;
        var t = e.type;
        if (5 !== e.tag || "head" !== t && "body" !== t && !Vr(t, e.memoizedProps))
            for (t = ko; t; )
                Lo(e, t),
                t = Br(t.nextSibling);
        if (qo(e),
        13 === e.tag) {
            if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null))
                throw Error(s(317));
            e: {
                for (e = e.nextSibling,
                t = 0; e; ) {
                    if (8 === e.nodeType) {
                        var n = e.data;
                        if ("/$" === n) {
                            if (0 === t) {
                                ko = Br(e.nextSibling);
                                break e
                            }
                            t--
                        } else
                            "$" !== n && "$!" !== n && "$?" !== n || t++
                    }
                    e = e.nextSibling
                }
                ko = null
            }
        } else
            ko = Fo ? Br(e.stateNode.nextSibling) : null;
        return !0
    }
    function Bo() {
        ko = Fo = null,
        jo = !1
    }
    var Go = [];
    function zo() {
        for (var e = 0; e < Go.length; e++)
            Go[e]._workInProgressVersionPrimary = null;
        Go.length = 0
    }
    var Ho = S.ReactCurrentDispatcher
      , Ko = S.ReactCurrentBatchConfig
      , Yo = 0
      , Wo = null
      , $o = null
      , Xo = null
      , Jo = !1
      , Zo = !1;
    function es() {
        throw Error(s(321))
    }
    function ts(e, t) {
        if (null === t)
            return !1;
        for (var n = 0; n < t.length && n < e.length; n++)
            if (!sr(e[n], t[n]))
                return !1;
        return !0
    }
    function ns(e, t, n, r, i, o) {
        if (Yo = o,
        Wo = t,
        t.memoizedState = null,
        t.updateQueue = null,
        t.lanes = 0,
        Ho.current = null === e || null === e.memoizedState ? As : Es,
        e = n(r, i),
        Zo) {
            o = 0;
            do {
                if (Zo = !1,
                !(25 > o))
                    throw Error(s(301));
                o += 1,
                Xo = $o = null,
                t.updateQueue = null,
                Ho.current = Cs,
                e = n(r, i)
            } while (Zo)
        }
        if (Ho.current = Ms,
        t = null !== $o && null !== $o.next,
        Yo = 0,
        Xo = $o = Wo = null,
        Jo = !1,
        t)
            throw Error(s(300));
        return e
    }
    function rs() {
        var e = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return null === Xo ? Wo.memoizedState = Xo = e : Xo = Xo.next = e,
        Xo
    }
    function is() {
        if (null === $o) {
            var e = Wo.alternate;
            e = null !== e ? e.memoizedState : null
        } else
            e = $o.next;
        var t = null === Xo ? Wo.memoizedState : Xo.next;
        if (null !== t)
            Xo = t,
            $o = e;
        else {
            if (null === e)
                throw Error(s(310));
            e = {
                memoizedState: ($o = e).memoizedState,
                baseState: $o.baseState,
                baseQueue: $o.baseQueue,
                queue: $o.queue,
                next: null
            },
            null === Xo ? Wo.memoizedState = Xo = e : Xo = Xo.next = e
        }
        return Xo
    }
    function os(e, t) {
        return "function" === typeof t ? t(e) : t
    }
    function ss(e) {
        var t = is()
          , n = t.queue;
        if (null === n)
            throw Error(s(311));
        n.lastRenderedReducer = e;
        var r = $o
          , i = r.baseQueue
          , o = n.pending;
        if (null !== o) {
            if (null !== i) {
                var a = i.next;
                i.next = o.next,
                o.next = a
            }
            r.baseQueue = i = o,
            n.pending = null
        }
        if (null !== i) {
            i = i.next,
            r = r.baseState;
            var c = a = o = null
              , u = i;
            do {
                var l = u.lane;
                if ((Yo & l) === l)
                    null !== c && (c = c.next = {
                        lane: 0,
                        action: u.action,
                        eagerReducer: u.eagerReducer,
                        eagerState: u.eagerState,
                        next: null
                    }),
                    r = u.eagerReducer === e ? u.eagerState : e(r, u.action);
                else {
                    var d = {
                        lane: l,
                        action: u.action,
                        eagerReducer: u.eagerReducer,
                        eagerState: u.eagerState,
                        next: null
                    };
                    null === c ? (a = c = d,
                    o = r) : c = c.next = d,
                    Wo.lanes |= l,
                    Da |= l
                }
                u = u.next
            } while (null !== u && u !== i);
            null === c ? o = r : c.next = a,
            sr(r, t.memoizedState) || (Rs = !0),
            t.memoizedState = r,
            t.baseState = o,
            t.baseQueue = c,
            n.lastRenderedState = r
        }
        return [t.memoizedState, n.dispatch]
    }
    function as(e) {
        var t = is()
          , n = t.queue;
        if (null === n)
            throw Error(s(311));
        n.lastRenderedReducer = e;
        var r = n.dispatch
          , i = n.pending
          , o = t.memoizedState;
        if (null !== i) {
            n.pending = null;
            var a = i = i.next;
            do {
                o = e(o, a.action),
                a = a.next
            } while (a !== i);
            sr(o, t.memoizedState) || (Rs = !0),
            t.memoizedState = o,
            null === t.baseQueue && (t.baseState = o),
            n.lastRenderedState = o
        }
        return [o, r]
    }
    function cs(e, t, n) {
        var r = t._getVersion;
        r = r(t._source);
        var i = t._workInProgressVersionPrimary;
        if (null !== i ? e = i === r : (e = e.mutableReadLanes,
        (e = (Yo & e) === e) && (t._workInProgressVersionPrimary = r,
        Go.push(t))),
        e)
            return n(t._source);
        throw Go.push(t),
        Error(s(350))
    }
    function us(e, t, n, r) {
        var i = wa;
        if (null === i)
            throw Error(s(349));
        var o = t._getVersion
          , a = o(t._source)
          , c = Ho.current
          , u = c.useState((function() {
            return cs(i, t, n)
        }
        ))
          , l = u[1]
          , d = u[0];
        u = Xo;
        var h = e.memoizedState
          , f = h.refs
          , p = f.getSnapshot
          , g = h.source;
        h = h.subscribe;
        var m = Wo;
        return e.memoizedState = {
            refs: f,
            source: t,
            subscribe: r
        },
        c.useEffect((function() {
            f.getSnapshot = n,
            f.setSnapshot = l;
            var e = o(t._source);
            if (!sr(a, e)) {
                e = n(t._source),
                sr(d, e) || (l(e),
                e = sc(m),
                i.mutableReadLanes |= e & i.pendingLanes),
                e = i.mutableReadLanes,
                i.entangledLanes |= e;
                for (var r = i.entanglements, s = e; 0 < s; ) {
                    var c = 31 - Bt(s)
                      , u = 1 << c;
                    r[c] |= e,
                    s &= ~u
                }
            }
        }
        ), [n, t, r]),
        c.useEffect((function() {
            return r(t._source, (function() {
                var e = f.getSnapshot
                  , n = f.setSnapshot;
                try {
                    n(e(t._source));
                    var r = sc(m);
                    i.mutableReadLanes |= r & i.pendingLanes
                } catch (o) {
                    n((function() {
                        throw o
                    }
                    ))
                }
            }
            ))
        }
        ), [t, r]),
        sr(p, n) && sr(g, t) && sr(h, r) || ((e = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: os,
            lastRenderedState: d
        }).dispatch = l = ws.bind(null, Wo, e),
        u.queue = e,
        u.baseQueue = null,
        d = cs(i, t, n),
        u.memoizedState = u.baseState = d),
        d
    }
    function ls(e, t, n) {
        return us(is(), e, t, n)
    }
    function ds(e) {
        var t = rs();
        return "function" === typeof e && (e = e()),
        t.memoizedState = t.baseState = e,
        e = (e = t.queue = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: os,
            lastRenderedState: e
        }).dispatch = ws.bind(null, Wo, e),
        [t.memoizedState, e]
    }
    function hs(e, t, n, r) {
        return e = {
            tag: e,
            create: t,
            destroy: n,
            deps: r,
            next: null
        },
        null === (t = Wo.updateQueue) ? (t = {
            lastEffect: null
        },
        Wo.updateQueue = t,
        t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next,
        n.next = e,
        e.next = r,
        t.lastEffect = e),
        e
    }
    function fs(e) {
        return e = {
            current: e
        },
        rs().memoizedState = e
    }
    function ps() {
        return is().memoizedState
    }
    function gs(e, t, n, r) {
        var i = rs();
        Wo.flags |= e,
        i.memoizedState = hs(1 | t, n, void 0, void 0 === r ? null : r)
    }
    function ms(e, t, n, r) {
        var i = is();
        r = void 0 === r ? null : r;
        var o = void 0;
        if (null !== $o) {
            var s = $o.memoizedState;
            if (o = s.destroy,
            null !== r && ts(r, s.deps))
                return void hs(t, n, o, r)
        }
        Wo.flags |= e,
        i.memoizedState = hs(1 | t, n, o, r)
    }
    function ys(e, t) {
        return gs(516, 4, e, t)
    }
    function vs(e, t) {
        return ms(516, 4, e, t)
    }
    function bs(e, t) {
        return ms(4, 2, e, t)
    }
    function _s(e, t) {
        return "function" === typeof t ? (e = e(),
        t(e),
        function() {
            t(null)
        }
        ) : null !== t && void 0 !== t ? (e = e(),
        t.current = e,
        function() {
            t.current = null
        }
        ) : void 0
    }
    function Ss(e, t, n) {
        return n = null !== n && void 0 !== n ? n.concat([e]) : null,
        ms(4, 2, _s.bind(null, t, e), n)
    }
    function Os() {}
    function Ts(e, t) {
        var n = is();
        t = void 0 === t ? null : t;
        var r = n.memoizedState;
        return null !== r && null !== t && ts(t, r[1]) ? r[0] : (n.memoizedState = [e, t],
        e)
    }
    function Is(e, t) {
        var n = is();
        t = void 0 === t ? null : t;
        var r = n.memoizedState;
        return null !== r && null !== t && ts(t, r[1]) ? r[0] : (e = e(),
        n.memoizedState = [e, t],
        e)
    }
    function xs(e, t) {
        var n = Vi();
        qi(98 > n ? 98 : n, (function() {
            e(!0)
        }
        )),
        qi(97 < n ? 97 : n, (function() {
            var n = Ko.transition;
            Ko.transition = 1;
            try {
                e(!1),
                t()
            } finally {
                Ko.transition = n
            }
        }
        ))
    }
    function ws(e, t, n) {
        var r = oc()
          , i = sc(e)
          , o = {
            lane: i,
            action: n,
            eagerReducer: null,
            eagerState: null,
            next: null
        }
          , s = t.pending;
        if (null === s ? o.next = o : (o.next = s.next,
        s.next = o),
        t.pending = o,
        s = e.alternate,
        e === Wo || null !== s && s === Wo)
            Zo = Jo = !0;
        else {
            if (0 === e.lanes && (null === s || 0 === s.lanes) && null !== (s = t.lastRenderedReducer))
                try {
                    var a = t.lastRenderedState
                      , c = s(a, n);
                    if (o.eagerReducer = s,
                    o.eagerState = c,
                    sr(c, a))
                        return
                } catch (u) {}
            ac(e, i, r)
        }
    }
    var Ms = {
        readContext: to,
        useCallback: es,
        useContext: es,
        useEffect: es,
        useImperativeHandle: es,
        useLayoutEffect: es,
        useMemo: es,
        useReducer: es,
        useRef: es,
        useState: es,
        useDebugValue: es,
        useDeferredValue: es,
        useTransition: es,
        useMutableSource: es,
        useOpaqueIdentifier: es,
        unstable_isNewReconciler: !1
    }
      , As = {
        readContext: to,
        useCallback: function(e, t) {
            return rs().memoizedState = [e, void 0 === t ? null : t],
            e
        },
        useContext: to,
        useEffect: ys,
        useImperativeHandle: function(e, t, n) {
            return n = null !== n && void 0 !== n ? n.concat([e]) : null,
            gs(4, 2, _s.bind(null, t, e), n)
        },
        useLayoutEffect: function(e, t) {
            return gs(4, 2, e, t)
        },
        useMemo: function(e, t) {
            var n = rs();
            return t = void 0 === t ? null : t,
            e = e(),
            n.memoizedState = [e, t],
            e
        },
        useReducer: function(e, t, n) {
            var r = rs();
            return t = void 0 !== n ? n(t) : t,
            r.memoizedState = r.baseState = t,
            e = (e = r.queue = {
                pending: null,
                dispatch: null,
                lastRenderedReducer: e,
                lastRenderedState: t
            }).dispatch = ws.bind(null, Wo, e),
            [r.memoizedState, e]
        },
        useRef: fs,
        useState: ds,
        useDebugValue: Os,
        useDeferredValue: function(e) {
            var t = ds(e)
              , n = t[0]
              , r = t[1];
            return ys((function() {
                var t = Ko.transition;
                Ko.transition = 1;
                try {
                    r(e)
                } finally {
                    Ko.transition = t
                }
            }
            ), [e]),
            n
        },
        useTransition: function() {
            var e = ds(!1)
              , t = e[0];
            return fs(e = xs.bind(null, e[1])),
            [e, t]
        },
        useMutableSource: function(e, t, n) {
            var r = rs();
            return r.memoizedState = {
                refs: {
                    getSnapshot: t,
                    setSnapshot: null
                },
                source: e,
                subscribe: n
            },
            us(r, e, t, n)
        },
        useOpaqueIdentifier: function() {
            if (jo) {
                var e = !1
                  , t = function(e) {
                    return {
                        $$typeof: F,
                        toString: e,
                        valueOf: e
                    }
                }((function() {
                    throw e || (e = !0,
                    n("r:" + (zr++).toString(36))),
                    Error(s(355))
                }
                ))
                  , n = ds(t)[1];
                return 0 === (2 & Wo.mode) && (Wo.flags |= 516,
                hs(5, (function() {
                    n("r:" + (zr++).toString(36))
                }
                ), void 0, null)),
                t
            }
            return ds(t = "r:" + (zr++).toString(36)),
            t
        },
        unstable_isNewReconciler: !1
    }
      , Es = {
        readContext: to,
        useCallback: Ts,
        useContext: to,
        useEffect: vs,
        useImperativeHandle: Ss,
        useLayoutEffect: bs,
        useMemo: Is,
        useReducer: ss,
        useRef: ps,
        useState: function() {
            return ss(os)
        },
        useDebugValue: Os,
        useDeferredValue: function(e) {
            var t = ss(os)
              , n = t[0]
              , r = t[1];
            return vs((function() {
                var t = Ko.transition;
                Ko.transition = 1;
                try {
                    r(e)
                } finally {
                    Ko.transition = t
                }
            }
            ), [e]),
            n
        },
        useTransition: function() {
            var e = ss(os)[0];
            return [ps().current, e]
        },
        useMutableSource: ls,
        useOpaqueIdentifier: function() {
            return ss(os)[0]
        },
        unstable_isNewReconciler: !1
    }
      , Cs = {
        readContext: to,
        useCallback: Ts,
        useContext: to,
        useEffect: vs,
        useImperativeHandle: Ss,
        useLayoutEffect: bs,
        useMemo: Is,
        useReducer: as,
        useRef: ps,
        useState: function() {
            return as(os)
        },
        useDebugValue: Os,
        useDeferredValue: function(e) {
            var t = as(os)
              , n = t[0]
              , r = t[1];
            return vs((function() {
                var t = Ko.transition;
                Ko.transition = 1;
                try {
                    r(e)
                } finally {
                    Ko.transition = t
                }
            }
            ), [e]),
            n
        },
        useTransition: function() {
            var e = as(os)[0];
            return [ps().current, e]
        },
        useMutableSource: ls,
        useOpaqueIdentifier: function() {
            return as(os)[0]
        },
        unstable_isNewReconciler: !1
    }
      , Ns = S.ReactCurrentOwner
      , Rs = !1;
    function Ps(e, t, n, r) {
        t.child = null === e ? To(t, null, n, r) : Oo(t, e.child, n, r)
    }
    function Ds(e, t, n, r, i) {
        n = n.render;
        var o = t.ref;
        return eo(t, i),
        r = ns(e, t, n, r, o, i),
        null === e || Rs ? (t.flags |= 1,
        Ps(e, t, r, i),
        t.child) : (t.updateQueue = e.updateQueue,
        t.flags &= -517,
        e.lanes &= ~i,
        ea(e, t, i))
    }
    function Fs(e, t, n, r, i, o) {
        if (null === e) {
            var s = n.type;
            return "function" !== typeof s || Lc(s) || void 0 !== s.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Uc(n.type, null, r, t, t.mode, o)).ref = t.ref,
            e.return = t,
            t.child = e) : (t.tag = 15,
            t.type = s,
            ks(e, t, s, r, i, o))
        }
        return s = e.child,
        0 === (i & o) && (i = s.memoizedProps,
        (n = null !== (n = n.compare) ? n : cr)(i, r) && e.ref === t.ref) ? ea(e, t, o) : (t.flags |= 1,
        (e = Vc(s, r)).ref = t.ref,
        e.return = t,
        t.child = e)
    }
    function ks(e, t, n, r, i, o) {
        if (null !== e && cr(e.memoizedProps, r) && e.ref === t.ref) {
            if (Rs = !1,
            0 === (o & i))
                return t.lanes = e.lanes,
                ea(e, t, o);
            0 !== (16384 & e.flags) && (Rs = !0)
        }
        return Vs(e, t, n, r, o)
    }
    function js(e, t, n) {
        var r = t.pendingProps
          , i = r.children
          , o = null !== e ? e.memoizedState : null;
        if ("hidden" === r.mode || "unstable-defer-without-hiding" === r.mode)
            if (0 === (4 & t.mode))
                t.memoizedState = {
                    baseLanes: 0
                },
                gc(t, n);
            else {
                if (0 === (1073741824 & n))
                    return e = null !== o ? o.baseLanes | n : n,
                    t.lanes = t.childLanes = 1073741824,
                    t.memoizedState = {
                        baseLanes: e
                    },
                    gc(t, e),
                    null;
                t.memoizedState = {
                    baseLanes: 0
                },
                gc(t, null !== o ? o.baseLanes : n)
            }
        else
            null !== o ? (r = o.baseLanes | n,
            t.memoizedState = null) : r = n,
            gc(t, r);
        return Ps(e, t, i, n),
        t.child
    }
    function Ls(e, t) {
        var n = t.ref;
        (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 128)
    }
    function Vs(e, t, n, r, i) {
        var o = hi(n) ? li : ci.current;
        return o = di(t, o),
        eo(t, i),
        n = ns(e, t, n, r, o, i),
        null === e || Rs ? (t.flags |= 1,
        Ps(e, t, n, i),
        t.child) : (t.updateQueue = e.updateQueue,
        t.flags &= -517,
        e.lanes &= ~i,
        ea(e, t, i))
    }
    function Us(e, t, n, r, i) {
        if (hi(n)) {
            var o = !0;
            mi(t)
        } else
            o = !1;
        if (eo(t, i),
        null === t.stateNode)
            null !== e && (e.alternate = null,
            t.alternate = null,
            t.flags |= 2),
            go(t, n, r),
            yo(t, n, r, i),
            r = !0;
        else if (null === e) {
            var s = t.stateNode
              , a = t.memoizedProps;
            s.props = a;
            var c = s.context
              , u = n.contextType;
            "object" === typeof u && null !== u ? u = to(u) : u = di(t, u = hi(n) ? li : ci.current);
            var l = n.getDerivedStateFromProps
              , d = "function" === typeof l || "function" === typeof s.getSnapshotBeforeUpdate;
            d || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (a !== r || c !== u) && mo(t, s, r, u),
            no = !1;
            var h = t.memoizedState;
            s.state = h,
            co(t, r, s, i),
            c = t.memoizedState,
            a !== r || h !== c || ui.current || no ? ("function" === typeof l && (ho(t, n, l, r),
            c = t.memoizedState),
            (a = no || po(t, n, a, r, h, c, u)) ? (d || "function" !== typeof s.UNSAFE_componentWillMount && "function" !== typeof s.componentWillMount || ("function" === typeof s.componentWillMount && s.componentWillMount(),
            "function" === typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount()),
            "function" === typeof s.componentDidMount && (t.flags |= 4)) : ("function" === typeof s.componentDidMount && (t.flags |= 4),
            t.memoizedProps = r,
            t.memoizedState = c),
            s.props = r,
            s.state = c,
            s.context = u,
            r = a) : ("function" === typeof s.componentDidMount && (t.flags |= 4),
            r = !1)
        } else {
            s = t.stateNode,
            io(e, t),
            a = t.memoizedProps,
            u = t.type === t.elementType ? a : Hi(t.type, a),
            s.props = u,
            d = t.pendingProps,
            h = s.context,
            "object" === typeof (c = n.contextType) && null !== c ? c = to(c) : c = di(t, c = hi(n) ? li : ci.current);
            var f = n.getDerivedStateFromProps;
            (l = "function" === typeof f || "function" === typeof s.getSnapshotBeforeUpdate) || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (a !== d || h !== c) && mo(t, s, r, c),
            no = !1,
            h = t.memoizedState,
            s.state = h,
            co(t, r, s, i);
            var p = t.memoizedState;
            a !== d || h !== p || ui.current || no ? ("function" === typeof f && (ho(t, n, f, r),
            p = t.memoizedState),
            (u = no || po(t, n, u, r, h, p, c)) ? (l || "function" !== typeof s.UNSAFE_componentWillUpdate && "function" !== typeof s.componentWillUpdate || ("function" === typeof s.componentWillUpdate && s.componentWillUpdate(r, p, c),
            "function" === typeof s.UNSAFE_componentWillUpdate && s.UNSAFE_componentWillUpdate(r, p, c)),
            "function" === typeof s.componentDidUpdate && (t.flags |= 4),
            "function" === typeof s.getSnapshotBeforeUpdate && (t.flags |= 256)) : ("function" !== typeof s.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
            "function" !== typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 256),
            t.memoizedProps = r,
            t.memoizedState = p),
            s.props = r,
            s.state = p,
            s.context = c,
            r = u) : ("function" !== typeof s.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
            "function" !== typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 256),
            r = !1)
        }
        return qs(e, t, n, r, o, i)
    }
    function qs(e, t, n, r, i, o) {
        Ls(e, t);
        var s = 0 !== (64 & t.flags);
        if (!r && !s)
            return i && yi(t, n, !1),
            ea(e, t, o);
        r = t.stateNode,
        Ns.current = t;
        var a = s && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
        return t.flags |= 1,
        null !== e && s ? (t.child = Oo(t, e.child, null, o),
        t.child = Oo(t, null, a, o)) : Ps(e, t, a, o),
        t.memoizedState = r.state,
        i && yi(t, n, !0),
        t.child
    }
    function Qs(e) {
        var t = e.stateNode;
        t.pendingContext ? pi(0, t.pendingContext, t.pendingContext !== t.context) : t.context && pi(0, t.context, !1),
        Eo(e, t.containerInfo)
    }
    var Bs, Gs, zs, Hs = {
        dehydrated: null,
        retryLane: 0
    };
    function Ks(e, t, n) {
        var r, i = t.pendingProps, o = Po.current, s = !1;
        return (r = 0 !== (64 & t.flags)) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & o)),
        r ? (s = !0,
        t.flags &= -65) : null !== e && null === e.memoizedState || void 0 === i.fallback || !0 === i.unstable_avoidThisFallback || (o |= 1),
        si(Po, 1 & o),
        null === e ? (void 0 !== i.fallback && Uo(t),
        e = i.children,
        o = i.fallback,
        s ? (e = Ys(t, e, o, n),
        t.child.memoizedState = {
            baseLanes: n
        },
        t.memoizedState = Hs,
        e) : "number" === typeof i.unstable_expectedLoadTime ? (e = Ys(t, e, o, n),
        t.child.memoizedState = {
            baseLanes: n
        },
        t.memoizedState = Hs,
        t.lanes = 33554432,
        e) : ((n = Qc({
            mode: "visible",
            children: e
        }, t.mode, n, null)).return = t,
        t.child = n)) : (e.memoizedState,
        s ? (i = $s(e, t, i.children, i.fallback, n),
        s = t.child,
        o = e.child.memoizedState,
        s.memoizedState = null === o ? {
            baseLanes: n
        } : {
            baseLanes: o.baseLanes | n
        },
        s.childLanes = e.childLanes & ~n,
        t.memoizedState = Hs,
        i) : (n = Ws(e, t, i.children, n),
        t.memoizedState = null,
        n))
    }
    function Ys(e, t, n, r) {
        var i = e.mode
          , o = e.child;
        return t = {
            mode: "hidden",
            children: t
        },
        0 === (2 & i) && null !== o ? (o.childLanes = 0,
        o.pendingProps = t) : o = Qc(t, i, 0, null),
        n = qc(n, i, r, null),
        o.return = e,
        n.return = e,
        o.sibling = n,
        e.child = o,
        n
    }
    function Ws(e, t, n, r) {
        var i = e.child;
        return e = i.sibling,
        n = Vc(i, {
            mode: "visible",
            children: n
        }),
        0 === (2 & t.mode) && (n.lanes = r),
        n.return = t,
        n.sibling = null,
        null !== e && (e.nextEffect = null,
        e.flags = 8,
        t.firstEffect = t.lastEffect = e),
        t.child = n
    }
    function $s(e, t, n, r, i) {
        var o = t.mode
          , s = e.child;
        e = s.sibling;
        var a = {
            mode: "hidden",
            children: n
        };
        return 0 === (2 & o) && t.child !== s ? ((n = t.child).childLanes = 0,
        n.pendingProps = a,
        null !== (s = n.lastEffect) ? (t.firstEffect = n.firstEffect,
        t.lastEffect = s,
        s.nextEffect = null) : t.firstEffect = t.lastEffect = null) : n = Vc(s, a),
        null !== e ? r = Vc(e, r) : (r = qc(r, o, i, null)).flags |= 2,
        r.return = t,
        n.return = t,
        n.sibling = r,
        t.child = n,
        r
    }
    function Xs(e, t) {
        e.lanes |= t;
        var n = e.alternate;
        null !== n && (n.lanes |= t),
        Zi(e.return, t)
    }
    function Js(e, t, n, r, i, o) {
        var s = e.memoizedState;
        null === s ? e.memoizedState = {
            isBackwards: t,
            rendering: null,
            renderingStartTime: 0,
            last: r,
            tail: n,
            tailMode: i,
            lastEffect: o
        } : (s.isBackwards = t,
        s.rendering = null,
        s.renderingStartTime = 0,
        s.last = r,
        s.tail = n,
        s.tailMode = i,
        s.lastEffect = o)
    }
    function Zs(e, t, n) {
        var r = t.pendingProps
          , i = r.revealOrder
          , o = r.tail;
        if (Ps(e, t, r.children, n),
        0 !== (2 & (r = Po.current)))
            r = 1 & r | 2,
            t.flags |= 64;
        else {
            if (null !== e && 0 !== (64 & e.flags))
                e: for (e = t.child; null !== e; ) {
                    if (13 === e.tag)
                        null !== e.memoizedState && Xs(e, n);
                    else if (19 === e.tag)
                        Xs(e, n);
                    else if (null !== e.child) {
                        e.child.return = e,
                        e = e.child;
                        continue
                    }
                    if (e === t)
                        break e;
                    for (; null === e.sibling; ) {
                        if (null === e.return || e.return === t)
                            break e;
                        e = e.return
                    }
                    e.sibling.return = e.return,
                    e = e.sibling
                }
            r &= 1
        }
        if (si(Po, r),
        0 === (2 & t.mode))
            t.memoizedState = null;
        else
            switch (i) {
            case "forwards":
                for (n = t.child,
                i = null; null !== n; )
                    null !== (e = n.alternate) && null === Do(e) && (i = n),
                    n = n.sibling;
                null === (n = i) ? (i = t.child,
                t.child = null) : (i = n.sibling,
                n.sibling = null),
                Js(t, !1, i, n, o, t.lastEffect);
                break;
            case "backwards":
                for (n = null,
                i = t.child,
                t.child = null; null !== i; ) {
                    if (null !== (e = i.alternate) && null === Do(e)) {
                        t.child = i;
                        break
                    }
                    e = i.sibling,
                    i.sibling = n,
                    n = i,
                    i = e
                }
                Js(t, !0, n, null, o, t.lastEffect);
                break;
            case "together":
                Js(t, !1, null, null, void 0, t.lastEffect);
                break;
            default:
                t.memoizedState = null
            }
        return t.child
    }
    function ea(e, t, n) {
        if (null !== e && (t.dependencies = e.dependencies),
        Da |= t.lanes,
        0 !== (n & t.childLanes)) {
            if (null !== e && t.child !== e.child)
                throw Error(s(153));
            if (null !== t.child) {
                for (n = Vc(e = t.child, e.pendingProps),
                t.child = n,
                n.return = t; null !== e.sibling; )
                    e = e.sibling,
                    (n = n.sibling = Vc(e, e.pendingProps)).return = t;
                n.sibling = null
            }
            return t.child
        }
        return null
    }
    function ta(e, t) {
        if (!jo)
            switch (e.tailMode) {
            case "hidden":
                t = e.tail;
                for (var n = null; null !== t; )
                    null !== t.alternate && (n = t),
                    t = t.sibling;
                null === n ? e.tail = null : n.sibling = null;
                break;
            case "collapsed":
                n = e.tail;
                for (var r = null; null !== n; )
                    null !== n.alternate && (r = n),
                    n = n.sibling;
                null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
            }
    }
    function na(e, t, n) {
        var r = t.pendingProps;
        switch (t.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return null;
        case 1:
            return hi(t.type) && fi(),
            null;
        case 3:
            return Co(),
            oi(ui),
            oi(ci),
            zo(),
            (r = t.stateNode).pendingContext && (r.context = r.pendingContext,
            r.pendingContext = null),
            null !== e && null !== e.child || (Qo(t) ? t.flags |= 4 : r.hydrate || (t.flags |= 256)),
            null;
        case 5:
            Ro(t);
            var o = Ao(Mo.current);
            if (n = t.type,
            null !== e && null != t.stateNode)
                Gs(e, t, n, r),
                e.ref !== t.ref && (t.flags |= 128);
            else {
                if (!r) {
                    if (null === t.stateNode)
                        throw Error(s(166));
                    return null
                }
                if (e = Ao(xo.current),
                Qo(t)) {
                    r = t.stateNode,
                    n = t.type;
                    var a = t.memoizedProps;
                    switch (r[Kr] = t,
                    r[Yr] = a,
                    n) {
                    case "dialog":
                        xr("cancel", r),
                        xr("close", r);
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        xr("load", r);
                        break;
                    case "video":
                    case "audio":
                        for (e = 0; e < Sr.length; e++)
                            xr(Sr[e], r);
                        break;
                    case "source":
                        xr("error", r);
                        break;
                    case "img":
                    case "image":
                    case "link":
                        xr("error", r),
                        xr("load", r);
                        break;
                    case "details":
                        xr("toggle", r);
                        break;
                    case "input":
                        ee(r, a),
                        xr("invalid", r);
                        break;
                    case "select":
                        r._wrapperState = {
                            wasMultiple: !!a.multiple
                        },
                        xr("invalid", r);
                        break;
                    case "textarea":
                        ce(r, a),
                        xr("invalid", r)
                    }
                    for (var u in Te(n, a),
                    e = null,
                    a)
                        a.hasOwnProperty(u) && (o = a[u],
                        "children" === u ? "string" === typeof o ? r.textContent !== o && (e = ["children", o]) : "number" === typeof o && r.textContent !== "" + o && (e = ["children", "" + o]) : c.hasOwnProperty(u) && null != o && "onScroll" === u && xr("scroll", r));
                    switch (n) {
                    case "input":
                        $(r),
                        re(r, a, !0);
                        break;
                    case "textarea":
                        $(r),
                        le(r);
                        break;
                    case "select":
                    case "option":
                        break;
                    default:
                        "function" === typeof a.onClick && (r.onclick = Fr)
                    }
                    r = e,
                    t.updateQueue = r,
                    null !== r && (t.flags |= 4)
                } else {
                    switch (u = 9 === o.nodeType ? o : o.ownerDocument,
                    e === de && (e = fe(n)),
                    e === de ? "script" === n ? ((e = u.createElement("div")).innerHTML = "<script><\/script>",
                    e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = u.createElement(n, {
                        is: r.is
                    }) : (e = u.createElement(n),
                    "select" === n && (u = e,
                    r.multiple ? u.multiple = !0 : r.size && (u.size = r.size))) : e = u.createElementNS(e, n),
                    e[Kr] = t,
                    e[Yr] = r,
                    Bs(e, t),
                    t.stateNode = e,
                    u = Ie(n, r),
                    n) {
                    case "dialog":
                        xr("cancel", e),
                        xr("close", e),
                        o = r;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        xr("load", e),
                        o = r;
                        break;
                    case "video":
                    case "audio":
                        for (o = 0; o < Sr.length; o++)
                            xr(Sr[o], e);
                        o = r;
                        break;
                    case "source":
                        xr("error", e),
                        o = r;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        xr("error", e),
                        xr("load", e),
                        o = r;
                        break;
                    case "details":
                        xr("toggle", e),
                        o = r;
                        break;
                    case "input":
                        ee(e, r),
                        o = Z(e, r),
                        xr("invalid", e);
                        break;
                    case "option":
                        o = oe(e, r);
                        break;
                    case "select":
                        e._wrapperState = {
                            wasMultiple: !!r.multiple
                        },
                        o = i({}, r, {
                            value: void 0
                        }),
                        xr("invalid", e);
                        break;
                    case "textarea":
                        ce(e, r),
                        o = ae(e, r),
                        xr("invalid", e);
                        break;
                    default:
                        o = r
                    }
                    Te(n, o);
                    var l = o;
                    for (a in l)
                        if (l.hasOwnProperty(a)) {
                            var d = l[a];
                            "style" === a ? Se(e, d) : "dangerouslySetInnerHTML" === a ? null != (d = d ? d.__html : void 0) && me(e, d) : "children" === a ? "string" === typeof d ? ("textarea" !== n || "" !== d) && ye(e, d) : "number" === typeof d && ye(e, "" + d) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (c.hasOwnProperty(a) ? null != d && "onScroll" === a && xr("scroll", e) : null != d && _(e, a, d, u))
                        }
                    switch (n) {
                    case "input":
                        $(e),
                        re(e, r, !1);
                        break;
                    case "textarea":
                        $(e),
                        le(e);
                        break;
                    case "option":
                        null != r.value && e.setAttribute("value", "" + Y(r.value));
                        break;
                    case "select":
                        e.multiple = !!r.multiple,
                        null != (a = r.value) ? se(e, !!r.multiple, a, !1) : null != r.defaultValue && se(e, !!r.multiple, r.defaultValue, !0);
                        break;
                    default:
                        "function" === typeof o.onClick && (e.onclick = Fr)
                    }
                    Lr(n, r) && (t.flags |= 4)
                }
                null !== t.ref && (t.flags |= 128)
            }
            return null;
        case 6:
            if (e && null != t.stateNode)
                zs(0, t, e.memoizedProps, r);
            else {
                if ("string" !== typeof r && null === t.stateNode)
                    throw Error(s(166));
                n = Ao(Mo.current),
                Ao(xo.current),
                Qo(t) ? (r = t.stateNode,
                n = t.memoizedProps,
                r[Kr] = t,
                r.nodeValue !== n && (t.flags |= 4)) : ((r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[Kr] = t,
                t.stateNode = r)
            }
            return null;
        case 13:
            return oi(Po),
            r = t.memoizedState,
            0 !== (64 & t.flags) ? (t.lanes = n,
            t) : (r = null !== r,
            n = !1,
            null === e ? void 0 !== t.memoizedProps.fallback && Qo(t) : n = null !== e.memoizedState,
            r && !n && 0 !== (2 & t.mode) && (null === e && !0 !== t.memoizedProps.unstable_avoidThisFallback || 0 !== (1 & Po.current) ? 0 === Na && (Na = 3) : (0 !== Na && 3 !== Na || (Na = 4),
            null === wa || 0 === (134217727 & Da) && 0 === (134217727 & Fa) || dc(wa, Aa))),
            (r || n) && (t.flags |= 4),
            null);
        case 4:
            return Co(),
            null === e && Mr(t.stateNode.containerInfo),
            null;
        case 10:
            return Ji(t),
            null;
        case 17:
            return hi(t.type) && fi(),
            null;
        case 19:
            if (oi(Po),
            null === (r = t.memoizedState))
                return null;
            if (a = 0 !== (64 & t.flags),
            null === (u = r.rendering))
                if (a)
                    ta(r, !1);
                else {
                    if (0 !== Na || null !== e && 0 !== (64 & e.flags))
                        for (e = t.child; null !== e; ) {
                            if (null !== (u = Do(e))) {
                                for (t.flags |= 64,
                                ta(r, !1),
                                null !== (a = u.updateQueue) && (t.updateQueue = a,
                                t.flags |= 4),
                                null === r.lastEffect && (t.firstEffect = null),
                                t.lastEffect = r.lastEffect,
                                r = n,
                                n = t.child; null !== n; )
                                    e = r,
                                    (a = n).flags &= 2,
                                    a.nextEffect = null,
                                    a.firstEffect = null,
                                    a.lastEffect = null,
                                    null === (u = a.alternate) ? (a.childLanes = 0,
                                    a.lanes = e,
                                    a.child = null,
                                    a.memoizedProps = null,
                                    a.memoizedState = null,
                                    a.updateQueue = null,
                                    a.dependencies = null,
                                    a.stateNode = null) : (a.childLanes = u.childLanes,
                                    a.lanes = u.lanes,
                                    a.child = u.child,
                                    a.memoizedProps = u.memoizedProps,
                                    a.memoizedState = u.memoizedState,
                                    a.updateQueue = u.updateQueue,
                                    a.type = u.type,
                                    e = u.dependencies,
                                    a.dependencies = null === e ? null : {
                                        lanes: e.lanes,
                                        firstContext: e.firstContext
                                    }),
                                    n = n.sibling;
                                return si(Po, 1 & Po.current | 2),
                                t.child
                            }
                            e = e.sibling
                        }
                    null !== r.tail && Li() > Va && (t.flags |= 64,
                    a = !0,
                    ta(r, !1),
                    t.lanes = 33554432)
                }
            else {
                if (!a)
                    if (null !== (e = Do(u))) {
                        if (t.flags |= 64,
                        a = !0,
                        null !== (n = e.updateQueue) && (t.updateQueue = n,
                        t.flags |= 4),
                        ta(r, !0),
                        null === r.tail && "hidden" === r.tailMode && !u.alternate && !jo)
                            return null !== (t = t.lastEffect = r.lastEffect) && (t.nextEffect = null),
                            null
                    } else
                        2 * Li() - r.renderingStartTime > Va && 1073741824 !== n && (t.flags |= 64,
                        a = !0,
                        ta(r, !1),
                        t.lanes = 33554432);
                r.isBackwards ? (u.sibling = t.child,
                t.child = u) : (null !== (n = r.last) ? n.sibling = u : t.child = u,
                r.last = u)
            }
            return null !== r.tail ? (n = r.tail,
            r.rendering = n,
            r.tail = n.sibling,
            r.lastEffect = t.lastEffect,
            r.renderingStartTime = Li(),
            n.sibling = null,
            t = Po.current,
            si(Po, a ? 1 & t | 2 : 1 & t),
            n) : null;
        case 23:
        case 24:
            return mc(),
            null !== e && null !== e.memoizedState !== (null !== t.memoizedState) && "unstable-defer-without-hiding" !== r.mode && (t.flags |= 4),
            null
        }
        throw Error(s(156, t.tag))
    }
    function ra(e) {
        switch (e.tag) {
        case 1:
            hi(e.type) && fi();
            var t = e.flags;
            return 4096 & t ? (e.flags = -4097 & t | 64,
            e) : null;
        case 3:
            if (Co(),
            oi(ui),
            oi(ci),
            zo(),
            0 !== (64 & (t = e.flags)))
                throw Error(s(285));
            return e.flags = -4097 & t | 64,
            e;
        case 5:
            return Ro(e),
            null;
        case 13:
            return oi(Po),
            4096 & (t = e.flags) ? (e.flags = -4097 & t | 64,
            e) : null;
        case 19:
            return oi(Po),
            null;
        case 4:
            return Co(),
            null;
        case 10:
            return Ji(e),
            null;
        case 23:
        case 24:
            return mc(),
            null;
        default:
            return null
        }
    }
    function ia(e, t) {
        try {
            var n = ""
              , r = t;
            do {
                n += H(r),
                r = r.return
            } while (r);
            var i = n
        } catch (o) {
            i = "\nError generating stack: " + o.message + "\n" + o.stack
        }
        return {
            value: e,
            source: t,
            stack: i
        }
    }
    function oa(e, t) {
        try {
            console.error(t.value)
        } catch (n) {
            setTimeout((function() {
                throw n
            }
            ))
        }
    }
    Bs = function(e, t) {
        for (var n = t.child; null !== n; ) {
            if (5 === n.tag || 6 === n.tag)
                e.appendChild(n.stateNode);
            else if (4 !== n.tag && null !== n.child) {
                n.child.return = n,
                n = n.child;
                continue
            }
            if (n === t)
                break;
            for (; null === n.sibling; ) {
                if (null === n.return || n.return === t)
                    return;
                n = n.return
            }
            n.sibling.return = n.return,
            n = n.sibling
        }
    }
    ,
    Gs = function(e, t, n, r) {
        var o = e.memoizedProps;
        if (o !== r) {
            e = t.stateNode,
            Ao(xo.current);
            var s, a = null;
            switch (n) {
            case "input":
                o = Z(e, o),
                r = Z(e, r),
                a = [];
                break;
            case "option":
                o = oe(e, o),
                r = oe(e, r),
                a = [];
                break;
            case "select":
                o = i({}, o, {
                    value: void 0
                }),
                r = i({}, r, {
                    value: void 0
                }),
                a = [];
                break;
            case "textarea":
                o = ae(e, o),
                r = ae(e, r),
                a = [];
                break;
            default:
                "function" !== typeof o.onClick && "function" === typeof r.onClick && (e.onclick = Fr)
            }
            for (d in Te(n, r),
            n = null,
            o)
                if (!r.hasOwnProperty(d) && o.hasOwnProperty(d) && null != o[d])
                    if ("style" === d) {
                        var u = o[d];
                        for (s in u)
                            u.hasOwnProperty(s) && (n || (n = {}),
                            n[s] = "")
                    } else
                        "dangerouslySetInnerHTML" !== d && "children" !== d && "suppressContentEditableWarning" !== d && "suppressHydrationWarning" !== d && "autoFocus" !== d && (c.hasOwnProperty(d) ? a || (a = []) : (a = a || []).push(d, null));
            for (d in r) {
                var l = r[d];
                if (u = null != o ? o[d] : void 0,
                r.hasOwnProperty(d) && l !== u && (null != l || null != u))
                    if ("style" === d)
                        if (u) {
                            for (s in u)
                                !u.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}),
                                n[s] = "");
                            for (s in l)
                                l.hasOwnProperty(s) && u[s] !== l[s] && (n || (n = {}),
                                n[s] = l[s])
                        } else
                            n || (a || (a = []),
                            a.push(d, n)),
                            n = l;
                    else
                        "dangerouslySetInnerHTML" === d ? (l = l ? l.__html : void 0,
                        u = u ? u.__html : void 0,
                        null != l && u !== l && (a = a || []).push(d, l)) : "children" === d ? "string" !== typeof l && "number" !== typeof l || (a = a || []).push(d, "" + l) : "suppressContentEditableWarning" !== d && "suppressHydrationWarning" !== d && (c.hasOwnProperty(d) ? (null != l && "onScroll" === d && xr("scroll", e),
                        a || u === l || (a = [])) : "object" === typeof l && null !== l && l.$$typeof === F ? l.toString() : (a = a || []).push(d, l))
            }
            n && (a = a || []).push("style", n);
            var d = a;
            (t.updateQueue = d) && (t.flags |= 4)
        }
    }
    ,
    zs = function(e, t, n, r) {
        n !== r && (t.flags |= 4)
    }
    ;
    var sa = "function" === typeof WeakMap ? WeakMap : Map;
    function aa(e, t, n) {
        (n = oo(-1, n)).tag = 3,
        n.payload = {
            element: null
        };
        var r = t.value;
        return n.callback = function() {
            Ba || (Ba = !0,
            Ga = r),
            oa(0, t)
        }
        ,
        n
    }
    function ca(e, t, n) {
        (n = oo(-1, n)).tag = 3;
        var r = e.type.getDerivedStateFromError;
        if ("function" === typeof r) {
            var i = t.value;
            n.payload = function() {
                return oa(0, t),
                r(i)
            }
        }
        var o = e.stateNode;
        return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function() {
            "function" !== typeof r && (null === za ? za = new Set([this]) : za.add(this),
            oa(0, t));
            var e = t.stack;
            this.componentDidCatch(t.value, {
                componentStack: null !== e ? e : ""
            })
        }
        ),
        n
    }
    var ua = "function" === typeof WeakSet ? WeakSet : Set;
    function la(e) {
        var t = e.ref;
        if (null !== t)
            if ("function" === typeof t)
                try {
                    t(null)
                } catch (n) {
                    Pc(e, n)
                }
            else
                t.current = null
    }
    function da(e, t) {
        switch (t.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
            return;
        case 1:
            if (256 & t.flags && null !== e) {
                var n = e.memoizedProps
                  , r = e.memoizedState;
                t = (e = t.stateNode).getSnapshotBeforeUpdate(t.elementType === t.type ? n : Hi(t.type, n), r),
                e.__reactInternalSnapshotBeforeUpdate = t
            }
            return;
        case 3:
            return void (256 & t.flags && Qr(t.stateNode.containerInfo));
        case 5:
        case 6:
        case 4:
        case 17:
            return
        }
        throw Error(s(163))
    }
    function ha(e, t, n) {
        switch (n.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
            if (null !== (t = null !== (t = n.updateQueue) ? t.lastEffect : null)) {
                e = t = t.next;
                do {
                    if (3 === (3 & e.tag)) {
                        var r = e.create;
                        e.destroy = r()
                    }
                    e = e.next
                } while (e !== t)
            }
            if (null !== (t = null !== (t = n.updateQueue) ? t.lastEffect : null)) {
                e = t = t.next;
                do {
                    var i = e;
                    r = i.next,
                    0 !== (4 & (i = i.tag)) && 0 !== (1 & i) && (Cc(n, e),
                    Ec(n, e)),
                    e = r
                } while (e !== t)
            }
            return;
        case 1:
            return e = n.stateNode,
            4 & n.flags && (null === t ? e.componentDidMount() : (r = n.elementType === n.type ? t.memoizedProps : Hi(n.type, t.memoizedProps),
            e.componentDidUpdate(r, t.memoizedState, e.__reactInternalSnapshotBeforeUpdate))),
            void (null !== (t = n.updateQueue) && uo(n, t, e));
        case 3:
            if (null !== (t = n.updateQueue)) {
                if (e = null,
                null !== n.child)
                    switch (n.child.tag) {
                    case 5:
                        e = n.child.stateNode;
                        break;
                    case 1:
                        e = n.child.stateNode
                    }
                uo(n, t, e)
            }
            return;
        case 5:
            return e = n.stateNode,
            void (null === t && 4 & n.flags && Lr(n.type, n.memoizedProps) && e.focus());
        case 6:
        case 4:
        case 12:
            return;
        case 13:
            return void (null === n.memoizedState && (n = n.alternate,
            null !== n && (n = n.memoizedState,
            null !== n && (n = n.dehydrated,
            null !== n && St(n)))));
        case 19:
        case 17:
        case 20:
        case 21:
        case 23:
        case 24:
            return
        }
        throw Error(s(163))
    }
    function fa(e, t) {
        for (var n = e; ; ) {
            if (5 === n.tag) {
                var r = n.stateNode;
                if (t)
                    "function" === typeof (r = r.style).setProperty ? r.setProperty("display", "none", "important") : r.display = "none";
                else {
                    r = n.stateNode;
                    var i = n.memoizedProps.style;
                    i = void 0 !== i && null !== i && i.hasOwnProperty("display") ? i.display : null,
                    r.style.display = _e("display", i)
                }
            } else if (6 === n.tag)
                n.stateNode.nodeValue = t ? "" : n.memoizedProps;
            else if ((23 !== n.tag && 24 !== n.tag || null === n.memoizedState || n === e) && null !== n.child) {
                n.child.return = n,
                n = n.child;
                continue
            }
            if (n === e)
                break;
            for (; null === n.sibling; ) {
                if (null === n.return || n.return === e)
                    return;
                n = n.return
            }
            n.sibling.return = n.return,
            n = n.sibling
        }
    }
    function pa(e, t) {
        if (bi && "function" === typeof bi.onCommitFiberUnmount)
            try {
                bi.onCommitFiberUnmount(vi, t)
            } catch (o) {}
        switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
            if (null !== (e = t.updateQueue) && null !== (e = e.lastEffect)) {
                var n = e = e.next;
                do {
                    var r = n
                      , i = r.destroy;
                    if (r = r.tag,
                    void 0 !== i)
                        if (0 !== (4 & r))
                            Cc(t, n);
                        else {
                            r = t;
                            try {
                                i()
                            } catch (o) {
                                Pc(r, o)
                            }
                        }
                    n = n.next
                } while (n !== e)
            }
            break;
        case 1:
            if (la(t),
            "function" === typeof (e = t.stateNode).componentWillUnmount)
                try {
                    e.props = t.memoizedProps,
                    e.state = t.memoizedState,
                    e.componentWillUnmount()
                } catch (o) {
                    Pc(t, o)
                }
            break;
        case 5:
            la(t);
            break;
        case 4:
            va(e, t)
        }
    }
    function ga(e) {
        e.alternate = null,
        e.child = null,
        e.dependencies = null,
        e.firstEffect = null,
        e.lastEffect = null,
        e.memoizedProps = null,
        e.memoizedState = null,
        e.pendingProps = null,
        e.return = null,
        e.updateQueue = null
    }
    function ma(e) {
        return 5 === e.tag || 3 === e.tag || 4 === e.tag
    }
    function ya(e) {
        e: {
            for (var t = e.return; null !== t; ) {
                if (ma(t))
                    break e;
                t = t.return
            }
            throw Error(s(160))
        }
        var n = t;
        switch (t = n.stateNode,
        n.tag) {
        case 5:
            var r = !1;
            break;
        case 3:
        case 4:
            t = t.containerInfo,
            r = !0;
            break;
        default:
            throw Error(s(161))
        }
        16 & n.flags && (ye(t, ""),
        n.flags &= -17);
        e: t: for (n = e; ; ) {
            for (; null === n.sibling; ) {
                if (null === n.return || ma(n.return)) {
                    n = null;
                    break e
                }
                n = n.return
            }
            for (n.sibling.return = n.return,
            n = n.sibling; 5 !== n.tag && 6 !== n.tag && 18 !== n.tag; ) {
                if (2 & n.flags)
                    continue t;
                if (null === n.child || 4 === n.tag)
                    continue t;
                n.child.return = n,
                n = n.child
            }
            if (!(2 & n.flags)) {
                n = n.stateNode;
                break e
            }
        }
        r ? function e(t, n, r) {
            var i = t.tag
              , o = 5 === i || 6 === i;
            if (o)
                t = o ? t.stateNode : t.stateNode.instance,
                n ? 8 === r.nodeType ? r.parentNode.insertBefore(t, n) : r.insertBefore(t, n) : (8 === r.nodeType ? (n = r.parentNode).insertBefore(t, r) : (n = r).appendChild(t),
                null !== (r = r._reactRootContainer) && void 0 !== r || null !== n.onclick || (n.onclick = Fr));
            else if (4 !== i && null !== (t = t.child))
                for (e(t, n, r),
                t = t.sibling; null !== t; )
                    e(t, n, r),
                    t = t.sibling
        }(e, n, t) : function e(t, n, r) {
            var i = t.tag
              , o = 5 === i || 6 === i;
            if (o)
                t = o ? t.stateNode : t.stateNode.instance,
                n ? r.insertBefore(t, n) : r.appendChild(t);
            else if (4 !== i && null !== (t = t.child))
                for (e(t, n, r),
                t = t.sibling; null !== t; )
                    e(t, n, r),
                    t = t.sibling
        }(e, n, t)
    }
    function va(e, t) {
        for (var n, r, i = t, o = !1; ; ) {
            if (!o) {
                o = i.return;
                e: for (; ; ) {
                    if (null === o)
                        throw Error(s(160));
                    switch (n = o.stateNode,
                    o.tag) {
                    case 5:
                        r = !1;
                        break e;
                    case 3:
                    case 4:
                        n = n.containerInfo,
                        r = !0;
                        break e
                    }
                    o = o.return
                }
                o = !0
            }
            if (5 === i.tag || 6 === i.tag) {
                e: for (var a = e, c = i, u = c; ; )
                    if (pa(a, u),
                    null !== u.child && 4 !== u.tag)
                        u.child.return = u,
                        u = u.child;
                    else {
                        if (u === c)
                            break e;
                        for (; null === u.sibling; ) {
                            if (null === u.return || u.return === c)
                                break e;
                            u = u.return
                        }
                        u.sibling.return = u.return,
                        u = u.sibling
                    }
                r ? (a = n,
                c = i.stateNode,
                8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : n.removeChild(i.stateNode)
            } else if (4 === i.tag) {
                if (null !== i.child) {
                    n = i.stateNode.containerInfo,
                    r = !0,
                    i.child.return = i,
                    i = i.child;
                    continue
                }
            } else if (pa(e, i),
            null !== i.child) {
                i.child.return = i,
                i = i.child;
                continue
            }
            if (i === t)
                break;
            for (; null === i.sibling; ) {
                if (null === i.return || i.return === t)
                    return;
                4 === (i = i.return).tag && (o = !1)
            }
            i.sibling.return = i.return,
            i = i.sibling
        }
    }
    function ba(e, t) {
        switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
            var n = t.updateQueue;
            if (null !== (n = null !== n ? n.lastEffect : null)) {
                var r = n = n.next;
                do {
                    3 === (3 & r.tag) && (e = r.destroy,
                    r.destroy = void 0,
                    void 0 !== e && e()),
                    r = r.next
                } while (r !== n)
            }
            return;
        case 1:
            return;
        case 5:
            if (null != (n = t.stateNode)) {
                r = t.memoizedProps;
                var i = null !== e ? e.memoizedProps : r;
                e = t.type;
                var o = t.updateQueue;
                if (t.updateQueue = null,
                null !== o) {
                    for (n[Yr] = r,
                    "input" === e && "radio" === r.type && null != r.name && te(n, r),
                    Ie(e, i),
                    t = Ie(e, r),
                    i = 0; i < o.length; i += 2) {
                        var a = o[i]
                          , c = o[i + 1];
                        "style" === a ? Se(n, c) : "dangerouslySetInnerHTML" === a ? me(n, c) : "children" === a ? ye(n, c) : _(n, a, c, t)
                    }
                    switch (e) {
                    case "input":
                        ne(n, r);
                        break;
                    case "textarea":
                        ue(n, r);
                        break;
                    case "select":
                        e = n._wrapperState.wasMultiple,
                        n._wrapperState.wasMultiple = !!r.multiple,
                        null != (o = r.value) ? se(n, !!r.multiple, o, !1) : e !== !!r.multiple && (null != r.defaultValue ? se(n, !!r.multiple, r.defaultValue, !0) : se(n, !!r.multiple, r.multiple ? [] : "", !1))
                    }
                }
            }
            return;
        case 6:
            if (null === t.stateNode)
                throw Error(s(162));
            return void (t.stateNode.nodeValue = t.memoizedProps);
        case 3:
            return void ((n = t.stateNode).hydrate && (n.hydrate = !1,
            St(n.containerInfo)));
        case 12:
            return;
        case 13:
            return null !== t.memoizedState && (La = Li(),
            fa(t.child, !0)),
            void _a(t);
        case 19:
            return void _a(t);
        case 17:
            return;
        case 23:
        case 24:
            return void fa(t, null !== t.memoizedState)
        }
        throw Error(s(163))
    }
    function _a(e) {
        var t = e.updateQueue;
        if (null !== t) {
            e.updateQueue = null;
            var n = e.stateNode;
            null === n && (n = e.stateNode = new ua),
            t.forEach((function(t) {
                var r = Fc.bind(null, e, t);
                n.has(t) || (n.add(t),
                t.then(r, r))
            }
            ))
        }
    }
    function Sa(e, t) {
        return null !== e && (null === (e = e.memoizedState) || null !== e.dehydrated) && (null !== (t = t.memoizedState) && null === t.dehydrated)
    }
    var Oa = Math.ceil
      , Ta = S.ReactCurrentDispatcher
      , Ia = S.ReactCurrentOwner
      , xa = 0
      , wa = null
      , Ma = null
      , Aa = 0
      , Ea = 0
      , Ca = ii(0)
      , Na = 0
      , Ra = null
      , Pa = 0
      , Da = 0
      , Fa = 0
      , ka = 0
      , ja = null
      , La = 0
      , Va = 1 / 0;
    function Ua() {
        Va = Li() + 500
    }
    var qa, Qa = null, Ba = !1, Ga = null, za = null, Ha = !1, Ka = null, Ya = 90, Wa = [], $a = [], Xa = null, Ja = 0, Za = null, ec = -1, tc = 0, nc = 0, rc = null, ic = !1;
    function oc() {
        return 0 !== (48 & xa) ? Li() : -1 !== ec ? ec : ec = Li()
    }
    function sc(e) {
        if (0 === (2 & (e = e.mode)))
            return 1;
        if (0 === (4 & e))
            return 99 === Vi() ? 1 : 2;
        if (0 === tc && (tc = Pa),
        0 !== zi.transition) {
            0 !== nc && (nc = null !== ja ? ja.pendingLanes : 0),
            e = tc;
            var t = 4186112 & ~nc;
            return 0 === (t &= -t) && (0 === (t = (e = 4186112 & ~e) & -e) && (t = 8192)),
            t
        }
        return e = Vi(),
        0 !== (4 & xa) && 98 === e ? e = Vt(12, tc) : e = Vt(e = function(e) {
            switch (e) {
            case 99:
                return 15;
            case 98:
                return 10;
            case 97:
            case 96:
                return 8;
            case 95:
                return 2;
            default:
                return 0
            }
        }(e), tc),
        e
    }
    function ac(e, t, n) {
        if (50 < Ja)
            throw Ja = 0,
            Za = null,
            Error(s(185));
        if (null === (e = cc(e, t)))
            return null;
        Qt(e, t, n),
        e === wa && (Fa |= t,
        4 === Na && dc(e, Aa));
        var r = Vi();
        1 === t ? 0 !== (8 & xa) && 0 === (48 & xa) ? hc(e) : (uc(e, n),
        0 === xa && (Ua(),
        Bi())) : (0 === (4 & xa) || 98 !== r && 99 !== r || (null === Xa ? Xa = new Set([e]) : Xa.add(e)),
        uc(e, n)),
        ja = e
    }
    function cc(e, t) {
        e.lanes |= t;
        var n = e.alternate;
        for (null !== n && (n.lanes |= t),
        n = e,
        e = e.return; null !== e; )
            e.childLanes |= t,
            null !== (n = e.alternate) && (n.childLanes |= t),
            n = e,
            e = e.return;
        return 3 === n.tag ? n.stateNode : null
    }
    function uc(e, t) {
        for (var n = e.callbackNode, r = e.suspendedLanes, i = e.pingedLanes, o = e.expirationTimes, a = e.pendingLanes; 0 < a; ) {
            var c = 31 - Bt(a)
              , u = 1 << c
              , l = o[c];
            if (-1 === l) {
                if (0 === (u & r) || 0 !== (u & i)) {
                    l = t,
                    kt(u);
                    var d = Ft;
                    o[c] = 10 <= d ? l + 250 : 6 <= d ? l + 5e3 : -1
                }
            } else
                l <= t && (e.expiredLanes |= u);
            a &= ~u
        }
        if (r = jt(e, e === wa ? Aa : 0),
        t = Ft,
        0 === r)
            null !== n && (n !== Ri && Oi(n),
            e.callbackNode = null,
            e.callbackPriority = 0);
        else {
            if (null !== n) {
                if (e.callbackPriority === t)
                    return;
                n !== Ri && Oi(n)
            }
            15 === t ? (n = hc.bind(null, e),
            null === Di ? (Di = [n],
            Fi = Si(Mi, Gi)) : Di.push(n),
            n = Ri) : 14 === t ? n = Qi(99, hc.bind(null, e)) : n = Qi(n = function(e) {
                switch (e) {
                case 15:
                case 14:
                    return 99;
                case 13:
                case 12:
                case 11:
                case 10:
                    return 98;
                case 9:
                case 8:
                case 7:
                case 6:
                case 4:
                case 5:
                    return 97;
                case 3:
                case 2:
                case 1:
                    return 95;
                case 0:
                    return 90;
                default:
                    throw Error(s(358, e))
                }
            }(t), lc.bind(null, e)),
            e.callbackPriority = t,
            e.callbackNode = n
        }
    }
    function lc(e) {
        if (ec = -1,
        nc = tc = 0,
        0 !== (48 & xa))
            throw Error(s(327));
        var t = e.callbackNode;
        if (Ac() && e.callbackNode !== t)
            return null;
        var n = jt(e, e === wa ? Aa : 0);
        if (0 === n)
            return null;
        var r = n
          , i = xa;
        xa |= 16;
        var o = bc();
        for (wa === e && Aa === r || (Ua(),
        yc(e, r)); ; )
            try {
                Oc();
                break
            } catch (c) {
                vc(e, c)
            }
        if (Xi(),
        Ta.current = o,
        xa = i,
        null !== Ma ? r = 0 : (wa = null,
        Aa = 0,
        r = Na),
        0 !== (Pa & Fa))
            yc(e, 0);
        else if (0 !== r) {
            if (2 === r && (xa |= 64,
            e.hydrate && (e.hydrate = !1,
            Qr(e.containerInfo)),
            0 !== (n = Lt(e)) && (r = _c(e, n))),
            1 === r)
                throw t = Ra,
                yc(e, 0),
                dc(e, n),
                uc(e, Li()),
                t;
            switch (e.finishedWork = e.current.alternate,
            e.finishedLanes = n,
            r) {
            case 0:
            case 1:
                throw Error(s(345));
            case 2:
                xc(e);
                break;
            case 3:
                if (dc(e, n),
                (62914560 & n) === n && 10 < (r = La + 500 - Li())) {
                    if (0 !== jt(e, 0))
                        break;
                    if (((i = e.suspendedLanes) & n) !== n) {
                        oc(),
                        e.pingedLanes |= e.suspendedLanes & i;
                        break
                    }
                    e.timeoutHandle = Ur(xc.bind(null, e), r);
                    break
                }
                xc(e);
                break;
            case 4:
                if (dc(e, n),
                (4186112 & n) === n)
                    break;
                for (r = e.eventTimes,
                i = -1; 0 < n; ) {
                    var a = 31 - Bt(n);
                    o = 1 << a,
                    (a = r[a]) > i && (i = a),
                    n &= ~o
                }
                if (n = i,
                10 < (n = (120 > (n = Li() - n) ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * Oa(n / 1960)) - n)) {
                    e.timeoutHandle = Ur(xc.bind(null, e), n);
                    break
                }
                xc(e);
                break;
            case 5:
                xc(e);
                break;
            default:
                throw Error(s(329))
            }
        }
        return uc(e, Li()),
        e.callbackNode === t ? lc.bind(null, e) : null
    }
    function dc(e, t) {
        for (t &= ~ka,
        t &= ~Fa,
        e.suspendedLanes |= t,
        e.pingedLanes &= ~t,
        e = e.expirationTimes; 0 < t; ) {
            var n = 31 - Bt(t)
              , r = 1 << n;
            e[n] = -1,
            t &= ~r
        }
    }
    function hc(e) {
        if (0 !== (48 & xa))
            throw Error(s(327));
        if (Ac(),
        e === wa && 0 !== (e.expiredLanes & Aa)) {
            var t = Aa
              , n = _c(e, t);
            0 !== (Pa & Fa) && (n = _c(e, t = jt(e, t)))
        } else
            n = _c(e, t = jt(e, 0));
        if (0 !== e.tag && 2 === n && (xa |= 64,
        e.hydrate && (e.hydrate = !1,
        Qr(e.containerInfo)),
        0 !== (t = Lt(e)) && (n = _c(e, t))),
        1 === n)
            throw n = Ra,
            yc(e, 0),
            dc(e, t),
            uc(e, Li()),
            n;
        return e.finishedWork = e.current.alternate,
        e.finishedLanes = t,
        xc(e),
        uc(e, Li()),
        null
    }
    function fc(e, t) {
        var n = xa;
        xa |= 1;
        try {
            return e(t)
        } finally {
            0 === (xa = n) && (Ua(),
            Bi())
        }
    }
    function pc(e, t) {
        var n = xa;
        xa &= -2,
        xa |= 8;
        try {
            return e(t)
        } finally {
            0 === (xa = n) && (Ua(),
            Bi())
        }
    }
    function gc(e, t) {
        si(Ca, Ea),
        Ea |= t,
        Pa |= t
    }
    function mc() {
        Ea = Ca.current,
        oi(Ca)
    }
    function yc(e, t) {
        e.finishedWork = null,
        e.finishedLanes = 0;
        var n = e.timeoutHandle;
        if (-1 !== n && (e.timeoutHandle = -1,
        qr(n)),
        null !== Ma)
            for (n = Ma.return; null !== n; ) {
                var r = n;
                switch (r.tag) {
                case 1:
                    null !== (r = r.type.childContextTypes) && void 0 !== r && fi();
                    break;
                case 3:
                    Co(),
                    oi(ui),
                    oi(ci),
                    zo();
                    break;
                case 5:
                    Ro(r);
                    break;
                case 4:
                    Co();
                    break;
                case 13:
                case 19:
                    oi(Po);
                    break;
                case 10:
                    Ji(r);
                    break;
                case 23:
                case 24:
                    mc()
                }
                n = n.return
            }
        wa = e,
        Ma = Vc(e.current, null),
        Aa = Ea = Pa = t,
        Na = 0,
        Ra = null,
        ka = Fa = Da = 0
    }
    function vc(e, t) {
        for (; ; ) {
            var n = Ma;
            try {
                if (Xi(),
                Ho.current = Ms,
                Jo) {
                    for (var r = Wo.memoizedState; null !== r; ) {
                        var i = r.queue;
                        null !== i && (i.pending = null),
                        r = r.next
                    }
                    Jo = !1
                }
                if (Yo = 0,
                Xo = $o = Wo = null,
                Zo = !1,
                Ia.current = null,
                null === n || null === n.return) {
                    Na = 1,
                    Ra = t,
                    Ma = null;
                    break
                }
                e: {
                    var o = e
                      , s = n.return
                      , a = n
                      , c = t;
                    if (t = Aa,
                    a.flags |= 2048,
                    a.firstEffect = a.lastEffect = null,
                    null !== c && "object" === typeof c && "function" === typeof c.then) {
                        var u = c;
                        if (0 === (2 & a.mode)) {
                            var l = a.alternate;
                            l ? (a.updateQueue = l.updateQueue,
                            a.memoizedState = l.memoizedState,
                            a.lanes = l.lanes) : (a.updateQueue = null,
                            a.memoizedState = null)
                        }
                        var d = 0 !== (1 & Po.current)
                          , h = s;
                        do {
                            var f;
                            if (f = 13 === h.tag) {
                                var p = h.memoizedState;
                                if (null !== p)
                                    f = null !== p.dehydrated;
                                else {
                                    var g = h.memoizedProps;
                                    f = void 0 !== g.fallback && (!0 !== g.unstable_avoidThisFallback || !d)
                                }
                            }
                            if (f) {
                                var m = h.updateQueue;
                                if (null === m) {
                                    var y = new Set;
                                    y.add(u),
                                    h.updateQueue = y
                                } else
                                    m.add(u);
                                if (0 === (2 & h.mode)) {
                                    if (h.flags |= 64,
                                    a.flags |= 16384,
                                    a.flags &= -2981,
                                    1 === a.tag)
                                        if (null === a.alternate)
                                            a.tag = 17;
                                        else {
                                            var v = oo(-1, 1);
                                            v.tag = 2,
                                            so(a, v)
                                        }
                                    a.lanes |= 1;
                                    break e
                                }
                                c = void 0,
                                a = t;
                                var b = o.pingCache;
                                if (null === b ? (b = o.pingCache = new sa,
                                c = new Set,
                                b.set(u, c)) : void 0 === (c = b.get(u)) && (c = new Set,
                                b.set(u, c)),
                                !c.has(a)) {
                                    c.add(a);
                                    var _ = Dc.bind(null, o, u, a);
                                    u.then(_, _)
                                }
                                h.flags |= 4096,
                                h.lanes = t;
                                break e
                            }
                            h = h.return
                        } while (null !== h);
                        c = Error((K(a.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")
                    }
                    5 !== Na && (Na = 2),
                    c = ia(c, a),
                    h = s;
                    do {
                        switch (h.tag) {
                        case 3:
                            o = c,
                            h.flags |= 4096,
                            t &= -t,
                            h.lanes |= t,
                            ao(h, aa(0, o, t));
                            break e;
                        case 1:
                            o = c;
                            var S = h.type
                              , O = h.stateNode;
                            if (0 === (64 & h.flags) && ("function" === typeof S.getDerivedStateFromError || null !== O && "function" === typeof O.componentDidCatch && (null === za || !za.has(O)))) {
                                h.flags |= 4096,
                                t &= -t,
                                h.lanes |= t,
                                ao(h, ca(h, o, t));
                                break e
                            }
                        }
                        h = h.return
                    } while (null !== h)
                }
                Ic(n)
            } catch (T) {
                t = T,
                Ma === n && null !== n && (Ma = n = n.return);
                continue
            }
            break
        }
    }
    function bc() {
        var e = Ta.current;
        return Ta.current = Ms,
        null === e ? Ms : e
    }
    function _c(e, t) {
        var n = xa;
        xa |= 16;
        var r = bc();
        for (wa === e && Aa === t || yc(e, t); ; )
            try {
                Sc();
                break
            } catch (i) {
                vc(e, i)
            }
        if (Xi(),
        xa = n,
        Ta.current = r,
        null !== Ma)
            throw Error(s(261));
        return wa = null,
        Aa = 0,
        Na
    }
    function Sc() {
        for (; null !== Ma; )
            Tc(Ma)
    }
    function Oc() {
        for (; null !== Ma && !Ti(); )
            Tc(Ma)
    }
    function Tc(e) {
        var t = qa(e.alternate, e, Ea);
        e.memoizedProps = e.pendingProps,
        null === t ? Ic(e) : Ma = t,
        Ia.current = null
    }
    function Ic(e) {
        var t = e;
        do {
            var n = t.alternate;
            if (e = t.return,
            0 === (2048 & t.flags)) {
                if (null !== (n = na(n, t, Ea)))
                    return void (Ma = n);
                if (24 !== (n = t).tag && 23 !== n.tag || null === n.memoizedState || 0 !== (1073741824 & Ea) || 0 === (4 & n.mode)) {
                    for (var r = 0, i = n.child; null !== i; )
                        r |= i.lanes | i.childLanes,
                        i = i.sibling;
                    n.childLanes = r
                }
                null !== e && 0 === (2048 & e.flags) && (null === e.firstEffect && (e.firstEffect = t.firstEffect),
                null !== t.lastEffect && (null !== e.lastEffect && (e.lastEffect.nextEffect = t.firstEffect),
                e.lastEffect = t.lastEffect),
                1 < t.flags && (null !== e.lastEffect ? e.lastEffect.nextEffect = t : e.firstEffect = t,
                e.lastEffect = t))
            } else {
                if (null !== (n = ra(t)))
                    return n.flags &= 2047,
                    void (Ma = n);
                null !== e && (e.firstEffect = e.lastEffect = null,
                e.flags |= 2048)
            }
            if (null !== (t = t.sibling))
                return void (Ma = t);
            Ma = t = e
        } while (null !== t);
        0 === Na && (Na = 5)
    }
    function xc(e) {
        var t = Vi();
        return qi(99, wc.bind(null, e, t)),
        null
    }
    function wc(e, t) {
        do {
            Ac()
        } while (null !== Ka);
        if (0 !== (48 & xa))
            throw Error(s(327));
        var n = e.finishedWork;
        if (null === n)
            return null;
        if (e.finishedWork = null,
        e.finishedLanes = 0,
        n === e.current)
            throw Error(s(177));
        e.callbackNode = null;
        var r = n.lanes | n.childLanes
          , i = r
          , o = e.pendingLanes & ~i;
        e.pendingLanes = i,
        e.suspendedLanes = 0,
        e.pingedLanes = 0,
        e.expiredLanes &= i,
        e.mutableReadLanes &= i,
        e.entangledLanes &= i,
        i = e.entanglements;
        for (var a = e.eventTimes, c = e.expirationTimes; 0 < o; ) {
            var u = 31 - Bt(o)
              , l = 1 << u;
            i[u] = 0,
            a[u] = -1,
            c[u] = -1,
            o &= ~l
        }
        if (null !== Xa && 0 === (24 & r) && Xa.has(e) && Xa.delete(e),
        e === wa && (Ma = wa = null,
        Aa = 0),
        1 < n.flags ? null !== n.lastEffect ? (n.lastEffect.nextEffect = n,
        r = n.firstEffect) : r = n : r = n.firstEffect,
        null !== r) {
            if (i = xa,
            xa |= 32,
            Ia.current = null,
            kr = Yt,
            hr(a = dr())) {
                if ("selectionStart"in a)
                    c = {
                        start: a.selectionStart,
                        end: a.selectionEnd
                    };
                else
                    e: if (c = (c = a.ownerDocument) && c.defaultView || window,
                    (l = c.getSelection && c.getSelection()) && 0 !== l.rangeCount) {
                        c = l.anchorNode,
                        o = l.anchorOffset,
                        u = l.focusNode,
                        l = l.focusOffset;
                        try {
                            c.nodeType,
                            u.nodeType
                        } catch (w) {
                            c = null;
                            break e
                        }
                        var d = 0
                          , h = -1
                          , f = -1
                          , p = 0
                          , g = 0
                          , m = a
                          , y = null;
                        t: for (; ; ) {
                            for (var v; m !== c || 0 !== o && 3 !== m.nodeType || (h = d + o),
                            m !== u || 0 !== l && 3 !== m.nodeType || (f = d + l),
                            3 === m.nodeType && (d += m.nodeValue.length),
                            null !== (v = m.firstChild); )
                                y = m,
                                m = v;
                            for (; ; ) {
                                if (m === a)
                                    break t;
                                if (y === c && ++p === o && (h = d),
                                y === u && ++g === l && (f = d),
                                null !== (v = m.nextSibling))
                                    break;
                                y = (m = y).parentNode
                            }
                            m = v
                        }
                        c = -1 === h || -1 === f ? null : {
                            start: h,
                            end: f
                        }
                    } else
                        c = null;
                c = c || {
                    start: 0,
                    end: 0
                }
            } else
                c = null;
            jr = {
                focusedElem: a,
                selectionRange: c
            },
            Yt = !1,
            rc = null,
            ic = !1,
            Qa = r;
            do {
                try {
                    Mc()
                } catch (w) {
                    if (null === Qa)
                        throw Error(s(330));
                    Pc(Qa, w),
                    Qa = Qa.nextEffect
                }
            } while (null !== Qa);
            rc = null,
            Qa = r;
            do {
                try {
                    for (a = e; null !== Qa; ) {
                        var b = Qa.flags;
                        if (16 & b && ye(Qa.stateNode, ""),
                        128 & b) {
                            var _ = Qa.alternate;
                            if (null !== _) {
                                var S = _.ref;
                                null !== S && ("function" === typeof S ? S(null) : S.current = null)
                            }
                        }
                        switch (1038 & b) {
                        case 2:
                            ya(Qa),
                            Qa.flags &= -3;
                            break;
                        case 6:
                            ya(Qa),
                            Qa.flags &= -3,
                            ba(Qa.alternate, Qa);
                            break;
                        case 1024:
                            Qa.flags &= -1025;
                            break;
                        case 1028:
                            Qa.flags &= -1025,
                            ba(Qa.alternate, Qa);
                            break;
                        case 4:
                            ba(Qa.alternate, Qa);
                            break;
                        case 8:
                            va(a, c = Qa);
                            var O = c.alternate;
                            ga(c),
                            null !== O && ga(O)
                        }
                        Qa = Qa.nextEffect
                    }
                } catch (w) {
                    if (null === Qa)
                        throw Error(s(330));
                    Pc(Qa, w),
                    Qa = Qa.nextEffect
                }
            } while (null !== Qa);
            if (S = jr,
            _ = dr(),
            b = S.focusedElem,
            a = S.selectionRange,
            _ !== b && b && b.ownerDocument && function e(t, n) {
                return !(!t || !n) && (t === n || (!t || 3 !== t.nodeType) && (n && 3 === n.nodeType ? e(t, n.parentNode) : "contains"in t ? t.contains(n) : !!t.compareDocumentPosition && !!(16 & t.compareDocumentPosition(n))))
            }(b.ownerDocument.documentElement, b)) {
                null !== a && hr(b) && (_ = a.start,
                void 0 === (S = a.end) && (S = _),
                "selectionStart"in b ? (b.selectionStart = _,
                b.selectionEnd = Math.min(S, b.value.length)) : (S = (_ = b.ownerDocument || document) && _.defaultView || window).getSelection && (S = S.getSelection(),
                c = b.textContent.length,
                O = Math.min(a.start, c),
                a = void 0 === a.end ? O : Math.min(a.end, c),
                !S.extend && O > a && (c = a,
                a = O,
                O = c),
                c = lr(b, O),
                o = lr(b, a),
                c && o && (1 !== S.rangeCount || S.anchorNode !== c.node || S.anchorOffset !== c.offset || S.focusNode !== o.node || S.focusOffset !== o.offset) && ((_ = _.createRange()).setStart(c.node, c.offset),
                S.removeAllRanges(),
                O > a ? (S.addRange(_),
                S.extend(o.node, o.offset)) : (_.setEnd(o.node, o.offset),
                S.addRange(_))))),
                _ = [];
                for (S = b; S = S.parentNode; )
                    1 === S.nodeType && _.push({
                        element: S,
                        left: S.scrollLeft,
                        top: S.scrollTop
                    });
                for ("function" === typeof b.focus && b.focus(),
                b = 0; b < _.length; b++)
                    (S = _[b]).element.scrollLeft = S.left,
                    S.element.scrollTop = S.top
            }
            Yt = !!kr,
            jr = kr = null,
            e.current = n,
            Qa = r;
            do {
                try {
                    for (b = e; null !== Qa; ) {
                        var T = Qa.flags;
                        if (36 & T && ha(b, Qa.alternate, Qa),
                        128 & T) {
                            _ = void 0;
                            var I = Qa.ref;
                            if (null !== I) {
                                var x = Qa.stateNode;
                                switch (Qa.tag) {
                                case 5:
                                    _ = x;
                                    break;
                                default:
                                    _ = x
                                }
                                "function" === typeof I ? I(_) : I.current = _
                            }
                        }
                        Qa = Qa.nextEffect
                    }
                } catch (w) {
                    if (null === Qa)
                        throw Error(s(330));
                    Pc(Qa, w),
                    Qa = Qa.nextEffect
                }
            } while (null !== Qa);
            Qa = null,
            Pi(),
            xa = i
        } else
            e.current = n;
        if (Ha)
            Ha = !1,
            Ka = e,
            Ya = t;
        else
            for (Qa = r; null !== Qa; )
                t = Qa.nextEffect,
                Qa.nextEffect = null,
                8 & Qa.flags && ((T = Qa).sibling = null,
                T.stateNode = null),
                Qa = t;
        if (0 === (r = e.pendingLanes) && (za = null),
        1 === r ? e === Za ? Ja++ : (Ja = 0,
        Za = e) : Ja = 0,
        n = n.stateNode,
        bi && "function" === typeof bi.onCommitFiberRoot)
            try {
                bi.onCommitFiberRoot(vi, n, void 0, 64 === (64 & n.current.flags))
            } catch (w) {}
        if (uc(e, Li()),
        Ba)
            throw Ba = !1,
            e = Ga,
            Ga = null,
            e;
        return 0 !== (8 & xa) || Bi(),
        null
    }
    function Mc() {
        for (; null !== Qa; ) {
            var e = Qa.alternate;
            ic || null === rc || (0 !== (8 & Qa.flags) ? Ze(Qa, rc) && (ic = !0) : 13 === Qa.tag && Sa(e, Qa) && Ze(Qa, rc) && (ic = !0));
            var t = Qa.flags;
            0 !== (256 & t) && da(e, Qa),
            0 === (512 & t) || Ha || (Ha = !0,
            Qi(97, (function() {
                return Ac(),
                null
            }
            ))),
            Qa = Qa.nextEffect
        }
    }
    function Ac() {
        if (90 !== Ya) {
            var e = 97 < Ya ? 97 : Ya;
            return Ya = 90,
            qi(e, Nc)
        }
        return !1
    }
    function Ec(e, t) {
        Wa.push(t, e),
        Ha || (Ha = !0,
        Qi(97, (function() {
            return Ac(),
            null
        }
        )))
    }
    function Cc(e, t) {
        $a.push(t, e),
        Ha || (Ha = !0,
        Qi(97, (function() {
            return Ac(),
            null
        }
        )))
    }
    function Nc() {
        if (null === Ka)
            return !1;
        var e = Ka;
        if (Ka = null,
        0 !== (48 & xa))
            throw Error(s(331));
        var t = xa;
        xa |= 32;
        var n = $a;
        $a = [];
        for (var r = 0; r < n.length; r += 2) {
            var i = n[r]
              , o = n[r + 1]
              , a = i.destroy;
            if (i.destroy = void 0,
            "function" === typeof a)
                try {
                    a()
                } catch (u) {
                    if (null === o)
                        throw Error(s(330));
                    Pc(o, u)
                }
        }
        for (n = Wa,
        Wa = [],
        r = 0; r < n.length; r += 2) {
            i = n[r],
            o = n[r + 1];
            try {
                var c = i.create;
                i.destroy = c()
            } catch (u) {
                if (null === o)
                    throw Error(s(330));
                Pc(o, u)
            }
        }
        for (c = e.current.firstEffect; null !== c; )
            e = c.nextEffect,
            c.nextEffect = null,
            8 & c.flags && (c.sibling = null,
            c.stateNode = null),
            c = e;
        return xa = t,
        Bi(),
        !0
    }
    function Rc(e, t, n) {
        so(e, t = aa(0, t = ia(n, t), 1)),
        t = oc(),
        null !== (e = cc(e, 1)) && (Qt(e, 1, t),
        uc(e, t))
    }
    function Pc(e, t) {
        if (3 === e.tag)
            Rc(e, e, t);
        else
            for (var n = e.return; null !== n; ) {
                if (3 === n.tag) {
                    Rc(n, e, t);
                    break
                }
                if (1 === n.tag) {
                    var r = n.stateNode;
                    if ("function" === typeof n.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === za || !za.has(r))) {
                        var i = ca(n, e = ia(t, e), 1);
                        if (so(n, i),
                        i = oc(),
                        null !== (n = cc(n, 1)))
                            Qt(n, 1, i),
                            uc(n, i);
                        else if ("function" === typeof r.componentDidCatch && (null === za || !za.has(r)))
                            try {
                                r.componentDidCatch(t, e)
                            } catch (o) {}
                        break
                    }
                }
                n = n.return
            }
    }
    function Dc(e, t, n) {
        var r = e.pingCache;
        null !== r && r.delete(t),
        t = oc(),
        e.pingedLanes |= e.suspendedLanes & n,
        wa === e && (Aa & n) === n && (4 === Na || 3 === Na && (62914560 & Aa) === Aa && 500 > Li() - La ? yc(e, 0) : ka |= n),
        uc(e, t)
    }
    function Fc(e, t) {
        var n = e.stateNode;
        null !== n && n.delete(t),
        0 === (t = 0) && (0 === (2 & (t = e.mode)) ? t = 1 : 0 === (4 & t) ? t = 99 === Vi() ? 1 : 2 : (0 === tc && (tc = Pa),
        0 === (t = Ut(62914560 & ~tc)) && (t = 4194304))),
        n = oc(),
        null !== (e = cc(e, t)) && (Qt(e, t, n),
        uc(e, n))
    }
    function kc(e, t, n, r) {
        this.tag = e,
        this.key = n,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = t,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = r,
        this.flags = 0,
        this.lastEffect = this.firstEffect = this.nextEffect = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function jc(e, t, n, r) {
        return new kc(e,t,n,r)
    }
    function Lc(e) {
        return !(!(e = e.prototype) || !e.isReactComponent)
    }
    function Vc(e, t) {
        var n = e.alternate;
        return null === n ? ((n = jc(e.tag, t, e.key, e.mode)).elementType = e.elementType,
        n.type = e.type,
        n.stateNode = e.stateNode,
        n.alternate = e,
        e.alternate = n) : (n.pendingProps = t,
        n.type = e.type,
        n.flags = 0,
        n.nextEffect = null,
        n.firstEffect = null,
        n.lastEffect = null),
        n.childLanes = e.childLanes,
        n.lanes = e.lanes,
        n.child = e.child,
        n.memoizedProps = e.memoizedProps,
        n.memoizedState = e.memoizedState,
        n.updateQueue = e.updateQueue,
        t = e.dependencies,
        n.dependencies = null === t ? null : {
            lanes: t.lanes,
            firstContext: t.firstContext
        },
        n.sibling = e.sibling,
        n.index = e.index,
        n.ref = e.ref,
        n
    }
    function Uc(e, t, n, r, i, o) {
        var a = 2;
        if (r = e,
        "function" === typeof e)
            Lc(e) && (a = 1);
        else if ("string" === typeof e)
            a = 5;
        else
            e: switch (e) {
            case I:
                return qc(n.children, i, o, t);
            case k:
                a = 8,
                i |= 16;
                break;
            case x:
                a = 8,
                i |= 1;
                break;
            case w:
                return (e = jc(12, n, t, 8 | i)).elementType = w,
                e.type = w,
                e.lanes = o,
                e;
            case C:
                return (e = jc(13, n, t, i)).type = C,
                e.elementType = C,
                e.lanes = o,
                e;
            case N:
                return (e = jc(19, n, t, i)).elementType = N,
                e.lanes = o,
                e;
            case j:
                return Qc(n, i, o, t);
            case L:
                return (e = jc(24, n, t, i)).elementType = L,
                e.lanes = o,
                e;
            default:
                if ("object" === typeof e && null !== e)
                    switch (e.$$typeof) {
                    case M:
                        a = 10;
                        break e;
                    case A:
                        a = 9;
                        break e;
                    case E:
                        a = 11;
                        break e;
                    case R:
                        a = 14;
                        break e;
                    case P:
                        a = 16,
                        r = null;
                        break e;
                    case D:
                        a = 22;
                        break e
                    }
                throw Error(s(130, null == e ? e : typeof e, ""))
            }
        return (t = jc(a, n, t, i)).elementType = e,
        t.type = r,
        t.lanes = o,
        t
    }
    function qc(e, t, n, r) {
        return (e = jc(7, e, r, t)).lanes = n,
        e
    }
    function Qc(e, t, n, r) {
        return (e = jc(23, e, r, t)).elementType = j,
        e.lanes = n,
        e
    }
    function Bc(e, t, n) {
        return (e = jc(6, e, null, t)).lanes = n,
        e
    }
    function Gc(e, t, n) {
        return (t = jc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n,
        t.stateNode = {
            containerInfo: e.containerInfo,
            pendingChildren: null,
            implementation: e.implementation
        },
        t
    }
    function zc(e, t, n) {
        this.tag = t,
        this.containerInfo = e,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.pendingContext = this.context = null,
        this.hydrate = n,
        this.callbackNode = null,
        this.callbackPriority = 0,
        this.eventTimes = qt(0),
        this.expirationTimes = qt(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = qt(0),
        this.mutableSourceEagerHydrationData = null
    }
    function Hc(e, t, n) {
        var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
            $$typeof: T,
            key: null == r ? null : "" + r,
            children: e,
            containerInfo: t,
            implementation: n
        }
    }
    function Kc(e, t, n, r) {
        var i = t.current
          , o = oc()
          , a = sc(i);
        e: if (n) {
            t: {
                if (We(n = n._reactInternals) !== n || 1 !== n.tag)
                    throw Error(s(170));
                var c = n;
                do {
                    switch (c.tag) {
                    case 3:
                        c = c.stateNode.context;
                        break t;
                    case 1:
                        if (hi(c.type)) {
                            c = c.stateNode.__reactInternalMemoizedMergedChildContext;
                            break t
                        }
                    }
                    c = c.return
                } while (null !== c);
                throw Error(s(171))
            }
            if (1 === n.tag) {
                var u = n.type;
                if (hi(u)) {
                    n = gi(n, u, c);
                    break e
                }
            }
            n = c
        } else
            n = ai;
        return null === t.context ? t.context = n : t.pendingContext = n,
        (t = oo(o, a)).payload = {
            element: e
        },
        null !== (r = void 0 === r ? null : r) && (t.callback = r),
        so(i, t),
        ac(i, a, o),
        a
    }
    function Yc(e) {
        if (!(e = e.current).child)
            return null;
        switch (e.child.tag) {
        case 5:
        default:
            return e.child.stateNode
        }
    }
    function Wc(e, t) {
        if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
            var n = e.retryLane;
            e.retryLane = 0 !== n && n < t ? n : t
        }
    }
    function $c(e, t) {
        Wc(e, t),
        (e = e.alternate) && Wc(e, t)
    }
    function Xc(e, t, n) {
        var r = null != n && null != n.hydrationOptions && n.hydrationOptions.mutableSources || null;
        if (n = new zc(e,t,null != n && !0 === n.hydrate),
        t = jc(3, null, null, 2 === t ? 7 : 1 === t ? 3 : 0),
        n.current = t,
        t.stateNode = n,
        ro(t),
        e[Wr] = n.current,
        Mr(8 === e.nodeType ? e.parentNode : e),
        r)
            for (e = 0; e < r.length; e++) {
                var i = (t = r[e])._getVersion;
                i = i(t._source),
                null == n.mutableSourceEagerHydrationData ? n.mutableSourceEagerHydrationData = [t, i] : n.mutableSourceEagerHydrationData.push(t, i)
            }
        this._internalRoot = n
    }
    function Jc(e) {
        return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
    }
    function Zc(e, t, n, r, i) {
        var o = n._reactRootContainer;
        if (o) {
            var s = o._internalRoot;
            if ("function" === typeof i) {
                var a = i;
                i = function() {
                    var e = Yc(s);
                    a.call(e)
                }
            }
            Kc(t, s, e, i)
        } else {
            if (o = n._reactRootContainer = function(e, t) {
                if (t || (t = !(!(t = e ? 9 === e.nodeType ? e.documentElement : e.firstChild : null) || 1 !== t.nodeType || !t.hasAttribute("data-reactroot"))),
                !t)
                    for (var n; n = e.lastChild; )
                        e.removeChild(n);
                return new Xc(e,0,t ? {
                    hydrate: !0
                } : void 0)
            }(n, r),
            s = o._internalRoot,
            "function" === typeof i) {
                var c = i;
                i = function() {
                    var e = Yc(s);
                    c.call(e)
                }
            }
            pc((function() {
                Kc(t, s, e, i)
            }
            ))
        }
        return Yc(s)
    }
    function eu(e, t) {
        var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!Jc(t))
            throw Error(s(200));
        return Hc(e, t, null, n)
    }
    qa = function(e, t, n) {
        var r = t.lanes;
        if (null !== e)
            if (e.memoizedProps !== t.pendingProps || ui.current)
                Rs = !0;
            else {
                if (0 === (n & r)) {
                    switch (Rs = !1,
                    t.tag) {
                    case 3:
                        Qs(t),
                        Bo();
                        break;
                    case 5:
                        No(t);
                        break;
                    case 1:
                        hi(t.type) && mi(t);
                        break;
                    case 4:
                        Eo(t, t.stateNode.containerInfo);
                        break;
                    case 10:
                        r = t.memoizedProps.value;
                        var i = t.type._context;
                        si(Ki, i._currentValue),
                        i._currentValue = r;
                        break;
                    case 13:
                        if (null !== t.memoizedState)
                            return 0 !== (n & t.child.childLanes) ? Ks(e, t, n) : (si(Po, 1 & Po.current),
                            null !== (t = ea(e, t, n)) ? t.sibling : null);
                        si(Po, 1 & Po.current);
                        break;
                    case 19:
                        if (r = 0 !== (n & t.childLanes),
                        0 !== (64 & e.flags)) {
                            if (r)
                                return Zs(e, t, n);
                            t.flags |= 64
                        }
                        if (null !== (i = t.memoizedState) && (i.rendering = null,
                        i.tail = null,
                        i.lastEffect = null),
                        si(Po, Po.current),
                        r)
                            break;
                        return null;
                    case 23:
                    case 24:
                        return t.lanes = 0,
                        js(e, t, n)
                    }
                    return ea(e, t, n)
                }
                Rs = 0 !== (16384 & e.flags)
            }
        else
            Rs = !1;
        switch (t.lanes = 0,
        t.tag) {
        case 2:
            if (r = t.type,
            null !== e && (e.alternate = null,
            t.alternate = null,
            t.flags |= 2),
            e = t.pendingProps,
            i = di(t, ci.current),
            eo(t, n),
            i = ns(null, t, r, e, i, n),
            t.flags |= 1,
            "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof) {
                if (t.tag = 1,
                t.memoizedState = null,
                t.updateQueue = null,
                hi(r)) {
                    var o = !0;
                    mi(t)
                } else
                    o = !1;
                t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null,
                ro(t);
                var a = r.getDerivedStateFromProps;
                "function" === typeof a && ho(t, r, a, e),
                i.updater = fo,
                t.stateNode = i,
                i._reactInternals = t,
                yo(t, r, e, n),
                t = qs(null, t, r, !0, o, n)
            } else
                t.tag = 0,
                Ps(null, t, i, n),
                t = t.child;
            return t;
        case 16:
            i = t.elementType;
            e: {
                switch (null !== e && (e.alternate = null,
                t.alternate = null,
                t.flags |= 2),
                e = t.pendingProps,
                i = (o = i._init)(i._payload),
                t.type = i,
                o = t.tag = function(e) {
                    if ("function" === typeof e)
                        return Lc(e) ? 1 : 0;
                    if (void 0 !== e && null !== e) {
                        if ((e = e.$$typeof) === E)
                            return 11;
                        if (e === R)
                            return 14
                    }
                    return 2
                }(i),
                e = Hi(i, e),
                o) {
                case 0:
                    t = Vs(null, t, i, e, n);
                    break e;
                case 1:
                    t = Us(null, t, i, e, n);
                    break e;
                case 11:
                    t = Ds(null, t, i, e, n);
                    break e;
                case 14:
                    t = Fs(null, t, i, Hi(i.type, e), r, n);
                    break e
                }
                throw Error(s(306, i, ""))
            }
            return t;
        case 0:
            return r = t.type,
            i = t.pendingProps,
            Vs(e, t, r, i = t.elementType === r ? i : Hi(r, i), n);
        case 1:
            return r = t.type,
            i = t.pendingProps,
            Us(e, t, r, i = t.elementType === r ? i : Hi(r, i), n);
        case 3:
            if (Qs(t),
            r = t.updateQueue,
            null === e || null === r)
                throw Error(s(282));
            if (r = t.pendingProps,
            i = null !== (i = t.memoizedState) ? i.element : null,
            io(e, t),
            co(t, r, null, n),
            (r = t.memoizedState.element) === i)
                Bo(),
                t = ea(e, t, n);
            else {
                if ((o = (i = t.stateNode).hydrate) && (ko = Br(t.stateNode.containerInfo.firstChild),
                Fo = t,
                o = jo = !0),
                o) {
                    if (null != (e = i.mutableSourceEagerHydrationData))
                        for (i = 0; i < e.length; i += 2)
                            (o = e[i])._workInProgressVersionPrimary = e[i + 1],
                            Go.push(o);
                    for (n = To(t, null, r, n),
                    t.child = n; n; )
                        n.flags = -3 & n.flags | 1024,
                        n = n.sibling
                } else
                    Ps(e, t, r, n),
                    Bo();
                t = t.child
            }
            return t;
        case 5:
            return No(t),
            null === e && Uo(t),
            r = t.type,
            i = t.pendingProps,
            o = null !== e ? e.memoizedProps : null,
            a = i.children,
            Vr(r, i) ? a = null : null !== o && Vr(r, o) && (t.flags |= 16),
            Ls(e, t),
            Ps(e, t, a, n),
            t.child;
        case 6:
            return null === e && Uo(t),
            null;
        case 13:
            return Ks(e, t, n);
        case 4:
            return Eo(t, t.stateNode.containerInfo),
            r = t.pendingProps,
            null === e ? t.child = Oo(t, null, r, n) : Ps(e, t, r, n),
            t.child;
        case 11:
            return r = t.type,
            i = t.pendingProps,
            Ds(e, t, r, i = t.elementType === r ? i : Hi(r, i), n);
        case 7:
            return Ps(e, t, t.pendingProps, n),
            t.child;
        case 8:
        case 12:
            return Ps(e, t, t.pendingProps.children, n),
            t.child;
        case 10:
            e: {
                r = t.type._context,
                i = t.pendingProps,
                a = t.memoizedProps,
                o = i.value;
                var c = t.type._context;
                if (si(Ki, c._currentValue),
                c._currentValue = o,
                null !== a)
                    if (c = a.value,
                    0 === (o = sr(c, o) ? 0 : 0 | ("function" === typeof r._calculateChangedBits ? r._calculateChangedBits(c, o) : 1073741823))) {
                        if (a.children === i.children && !ui.current) {
                            t = ea(e, t, n);
                            break e
                        }
                    } else
                        for (null !== (c = t.child) && (c.return = t); null !== c; ) {
                            var u = c.dependencies;
                            if (null !== u) {
                                a = c.child;
                                for (var l = u.firstContext; null !== l; ) {
                                    if (l.context === r && 0 !== (l.observedBits & o)) {
                                        1 === c.tag && ((l = oo(-1, n & -n)).tag = 2,
                                        so(c, l)),
                                        c.lanes |= n,
                                        null !== (l = c.alternate) && (l.lanes |= n),
                                        Zi(c.return, n),
                                        u.lanes |= n;
                                        break
                                    }
                                    l = l.next
                                }
                            } else
                                a = 10 === c.tag && c.type === t.type ? null : c.child;
                            if (null !== a)
                                a.return = c;
                            else
                                for (a = c; null !== a; ) {
                                    if (a === t) {
                                        a = null;
                                        break
                                    }
                                    if (null !== (c = a.sibling)) {
                                        c.return = a.return,
                                        a = c;
                                        break
                                    }
                                    a = a.return
                                }
                            c = a
                        }
                Ps(e, t, i.children, n),
                t = t.child
            }
            return t;
        case 9:
            return i = t.type,
            r = (o = t.pendingProps).children,
            eo(t, n),
            r = r(i = to(i, o.unstable_observedBits)),
            t.flags |= 1,
            Ps(e, t, r, n),
            t.child;
        case 14:
            return o = Hi(i = t.type, t.pendingProps),
            Fs(e, t, i, o = Hi(i.type, o), r, n);
        case 15:
            return ks(e, t, t.type, t.pendingProps, r, n);
        case 17:
            return r = t.type,
            i = t.pendingProps,
            i = t.elementType === r ? i : Hi(r, i),
            null !== e && (e.alternate = null,
            t.alternate = null,
            t.flags |= 2),
            t.tag = 1,
            hi(r) ? (e = !0,
            mi(t)) : e = !1,
            eo(t, n),
            go(t, r, i),
            yo(t, r, i, n),
            qs(null, t, r, !0, e, n);
        case 19:
            return Zs(e, t, n);
        case 23:
        case 24:
            return js(e, t, n)
        }
        throw Error(s(156, t.tag))
    }
    ,
    Xc.prototype.render = function(e) {
        Kc(e, this._internalRoot, null, null)
    }
    ,
    Xc.prototype.unmount = function() {
        var e = this._internalRoot
          , t = e.containerInfo;
        Kc(null, e, null, (function() {
            t[Wr] = null
        }
        ))
    }
    ,
    et = function(e) {
        13 === e.tag && (ac(e, 4, oc()),
        $c(e, 4))
    }
    ,
    tt = function(e) {
        13 === e.tag && (ac(e, 67108864, oc()),
        $c(e, 67108864))
    }
    ,
    nt = function(e) {
        if (13 === e.tag) {
            var t = oc()
              , n = sc(e);
            ac(e, n, t),
            $c(e, n)
        }
    }
    ,
    rt = function(e, t) {
        return t()
    }
    ,
    we = function(e, t, n) {
        switch (t) {
        case "input":
            if (ne(e, n),
            t = n.name,
            "radio" === n.type && null != t) {
                for (n = e; n.parentNode; )
                    n = n.parentNode;
                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'),
                t = 0; t < n.length; t++) {
                    var r = n[t];
                    if (r !== e && r.form === e.form) {
                        var i = ei(r);
                        if (!i)
                            throw Error(s(90));
                        X(r),
                        ne(r, i)
                    }
                }
            }
            break;
        case "textarea":
            ue(e, n);
            break;
        case "select":
            null != (t = n.value) && se(e, !!n.multiple, t, !1)
        }
    }
    ,
    Re = fc,
    Pe = function(e, t, n, r, i) {
        var o = xa;
        xa |= 4;
        try {
            return qi(98, e.bind(null, t, n, r, i))
        } finally {
            0 === (xa = o) && (Ua(),
            Bi())
        }
    }
    ,
    De = function() {
        0 === (49 & xa) && (function() {
            if (null !== Xa) {
                var e = Xa;
                Xa = null,
                e.forEach((function(e) {
                    e.expiredLanes |= 24 & e.pendingLanes,
                    uc(e, Li())
                }
                ))
            }
            Bi()
        }(),
        Ac())
    }
    ,
    Fe = function(e, t) {
        var n = xa;
        xa |= 2;
        try {
            return e(t)
        } finally {
            0 === (xa = n) && (Ua(),
            Bi())
        }
    }
    ;
    var tu = {
        Events: [Jr, Zr, ei, Ce, Ne, Ac, {
            current: !1
        }]
    }
      , nu = {
        findFiberByHostInstance: Xr,
        bundleType: 0,
        version: "17.0.2",
        rendererPackageName: "react-dom"
    }
      , ru = {
        bundleType: nu.bundleType,
        version: nu.version,
        rendererPackageName: nu.rendererPackageName,
        rendererConfig: nu.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: S.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(e) {
            return null === (e = Je(e)) ? null : e.stateNode
        },
        findFiberByHostInstance: nu.findFiberByHostInstance || function() {
            return null
        }
        ,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!iu.isDisabled && iu.supportsFiber)
            try {
                vi = iu.inject(ru),
                bi = iu
            } catch (ou) {}
    }
    t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu,
    t.createPortal = eu,
    t.findDOMNode = function(e) {
        if (null == e)
            return null;
        if (1 === e.nodeType)
            return e;
        var t = e._reactInternals;
        if (void 0 === t) {
            if ("function" === typeof e.render)
                throw Error(s(188));
            throw Error(s(268, Object.keys(e)))
        }
        return e = null === (e = Je(t)) ? null : e.stateNode
    }
    ,
    t.flushSync = function(e, t) {
        var n = xa;
        if (0 !== (48 & n))
            return e(t);
        xa |= 1;
        try {
            if (e)
                return qi(99, e.bind(null, t))
        } finally {
            xa = n,
            Bi()
        }
    }
    ,
    t.hydrate = function(e, t, n) {
        if (!Jc(t))
            throw Error(s(200));
        return Zc(null, e, t, !0, n)
    }
    ,
    t.render = function(e, t, n) {
        if (!Jc(t))
            throw Error(s(200));
        return Zc(null, e, t, !1, n)
    }
    ,
    t.unmountComponentAtNode = function(e) {
        if (!Jc(e))
            throw Error(s(40));
        return !!e._reactRootContainer && (pc((function() {
            Zc(null, null, e, !1, (function() {
                e._reactRootContainer = null,
                e[Wr] = null
            }
            ))
        }
        )),
        !0)
    }
    ,
    t.unstable_batchedUpdates = fc,
    t.unstable_createPortal = function(e, t) {
        return eu(e, t, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null)
    }
    ,
    t.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
        if (!Jc(n))
            throw Error(s(200));
        if (null == e || void 0 === e._reactInternals)
            throw Error(s(38));
        return Zc(e, t, n, !1, r)
    }
    ,
    t.version = "17.0.2"
}
, function(e, t, n) {
    "use strict";
    e.exports = n(854)
}
, function(e, t, n) {
    "use strict";
    var r, i, o, s;
    if ("object" === typeof performance && "function" === typeof performance.now) {
        var a = performance;
        t.unstable_now = function() {
            return a.now()
        }
    } else {
        var c = Date
          , u = c.now();
        t.unstable_now = function() {
            return c.now() - u
        }
    }
    if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
        var l = null
          , d = null
          , h = function() {
            if (null !== l)
                try {
                    var e = t.unstable_now();
                    l(!0, e),
                    l = null
                } catch (n) {
                    throw setTimeout(h, 0),
                    n
                }
        };
        r = function(e) {
            null !== l ? setTimeout(r, 0, e) : (l = e,
            setTimeout(h, 0))
        }
        ,
        i = function(e, t) {
            d = setTimeout(e, t)
        }
        ,
        o = function() {
            clearTimeout(d)
        }
        ,
        t.unstable_shouldYield = function() {
            return !1
        }
        ,
        s = t.unstable_forceFrameRate = function() {}
    } else {
        var f = window.setTimeout
          , p = window.clearTimeout;
        if ("undefined" !== typeof console) {
            var g = window.cancelAnimationFrame;
            "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),
            "function" !== typeof g && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")
        }
        var m = !1
          , y = null
          , v = -1
          , b = 5
          , _ = 0;
        t.unstable_shouldYield = function() {
            return t.unstable_now() >= _
        }
        ,
        s = function() {}
        ,
        t.unstable_forceFrameRate = function(e) {
            0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < e ? Math.floor(1e3 / e) : 5
        }
        ;
        var S = new MessageChannel
          , O = S.port2;
        S.port1.onmessage = function() {
            if (null !== y) {
                var e = t.unstable_now();
                _ = e + b;
                try {
                    y(!0, e) ? O.postMessage(null) : (m = !1,
                    y = null)
                } catch (n) {
                    throw O.postMessage(null),
                    n
                }
            } else
                m = !1
        }
        ,
        r = function(e) {
            y = e,
            m || (m = !0,
            O.postMessage(null))
        }
        ,
        i = function(e, n) {
            v = f((function() {
                e(t.unstable_now())
            }
            ), n)
        }
        ,
        o = function() {
            p(v),
            v = -1
        }
    }
    function T(e, t) {
        var n = e.length;
        e.push(t);
        e: for (; ; ) {
            var r = n - 1 >>> 1
              , i = e[r];
            if (!(void 0 !== i && 0 < w(i, t)))
                break e;
            e[r] = t,
            e[n] = i,
            n = r
        }
    }
    function I(e) {
        return void 0 === (e = e[0]) ? null : e
    }
    function x(e) {
        var t = e[0];
        if (void 0 !== t) {
            var n = e.pop();
            if (n !== t) {
                e[0] = n;
                e: for (var r = 0, i = e.length; r < i; ) {
                    var o = 2 * (r + 1) - 1
                      , s = e[o]
                      , a = o + 1
                      , c = e[a];
                    if (void 0 !== s && 0 > w(s, n))
                        void 0 !== c && 0 > w(c, s) ? (e[r] = c,
                        e[a] = n,
                        r = a) : (e[r] = s,
                        e[o] = n,
                        r = o);
                    else {
                        if (!(void 0 !== c && 0 > w(c, n)))
                            break e;
                        e[r] = c,
                        e[a] = n,
                        r = a
                    }
                }
            }
            return t
        }
        return null
    }
    function w(e, t) {
        var n = e.sortIndex - t.sortIndex;
        return 0 !== n ? n : e.id - t.id
    }
    var M = []
      , A = []
      , E = 1
      , C = null
      , N = 3
      , R = !1
      , P = !1
      , D = !1;
    function F(e) {
        for (var t = I(A); null !== t; ) {
            if (null === t.callback)
                x(A);
            else {
                if (!(t.startTime <= e))
                    break;
                x(A),
                t.sortIndex = t.expirationTime,
                T(M, t)
            }
            t = I(A)
        }
    }
    function k(e) {
        if (D = !1,
        F(e),
        !P)
            if (null !== I(M))
                P = !0,
                r(j);
            else {
                var t = I(A);
                null !== t && i(k, t.startTime - e)
            }
    }
    function j(e, n) {
        P = !1,
        D && (D = !1,
        o()),
        R = !0;
        var r = N;
        try {
            for (F(n),
            C = I(M); null !== C && (!(C.expirationTime > n) || e && !t.unstable_shouldYield()); ) {
                var s = C.callback;
                if ("function" === typeof s) {
                    C.callback = null,
                    N = C.priorityLevel;
                    var a = s(C.expirationTime <= n);
                    n = t.unstable_now(),
                    "function" === typeof a ? C.callback = a : C === I(M) && x(M),
                    F(n)
                } else
                    x(M);
                C = I(M)
            }
            if (null !== C)
                var c = !0;
            else {
                var u = I(A);
                null !== u && i(k, u.startTime - n),
                c = !1
            }
            return c
        } finally {
            C = null,
            N = r,
            R = !1
        }
    }
    var L = s;
    t.unstable_IdlePriority = 5,
    t.unstable_ImmediatePriority = 1,
    t.unstable_LowPriority = 4,
    t.unstable_NormalPriority = 3,
    t.unstable_Profiling = null,
    t.unstable_UserBlockingPriority = 2,
    t.unstable_cancelCallback = function(e) {
        e.callback = null
    }
    ,
    t.unstable_continueExecution = function() {
        P || R || (P = !0,
        r(j))
    }
    ,
    t.unstable_getCurrentPriorityLevel = function() {
        return N
    }
    ,
    t.unstable_getFirstCallbackNode = function() {
        return I(M)
    }
    ,
    t.unstable_next = function(e) {
        switch (N) {
        case 1:
        case 2:
        case 3:
            var t = 3;
            break;
        default:
            t = N
        }
        var n = N;
        N = t;
        try {
            return e()
        } finally {
            N = n
        }
    }
    ,
    t.unstable_pauseExecution = function() {}
    ,
    t.unstable_requestPaint = L,
    t.unstable_runWithPriority = function(e, t) {
        switch (e) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            e = 3
        }
        var n = N;
        N = e;
        try {
            return t()
        } finally {
            N = n
        }
    }
    ,
    t.unstable_scheduleCallback = function(e, n, s) {
        var a = t.unstable_now();
        switch ("object" === typeof s && null !== s ? s = "number" === typeof (s = s.delay) && 0 < s ? a + s : a : s = a,
        e) {
        case 1:
            var c = -1;
            break;
        case 2:
            c = 250;
            break;
        case 5:
            c = 1073741823;
            break;
        case 4:
            c = 1e4;
            break;
        default:
            c = 5e3
        }
        return e = {
            id: E++,
            callback: n,
            priorityLevel: e,
            startTime: s,
            expirationTime: c = s + c,
            sortIndex: -1
        },
        s > a ? (e.sortIndex = s,
        T(A, e),
        null === I(M) && e === I(A) && (D ? o() : D = !0,
        i(k, s - a))) : (e.sortIndex = c,
        T(M, e),
        P || R || (P = !0,
        r(j))),
        e
    }
    ,
    t.unstable_wrapCallback = function(e) {
        var t = N;
        return function() {
            var n = N;
            N = t;
            try {
                return e.apply(this, arguments)
            } finally {
                N = n
            }
        }
    }
}
, function(e, t) {
    e.exports = Array.isArray || function(e) {
        return "[object Array]" == Object.prototype.toString.call(e)
    }
}
, function(e, t, n) {
    "use strict";
    var r = n(857);
    function i() {}
    function o() {}
    o.resetWarningCache = i,
    e.exports = function() {
        function e(e, t, n, i, o, s) {
            if (s !== r) {
                var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw a.name = "Invariant Violation",
                a
            }
        }
        function t() {
            return e
        }
        e.isRequired = e;
        var n = {
            array: e,
            bigint: e,
            bool: e,
            func: e,
            number: e,
            object: e,
            string: e,
            symbol: e,
            any: e,
            arrayOf: t,
            element: e,
            elementType: e,
            instanceOf: t,
            node: e,
            objectOf: t,
            oneOf: t,
            oneOfType: t,
            shape: t,
            exact: t,
            checkPropTypes: o,
            resetWarningCache: i
        };
        return n.PropTypes = n,
        n
    }
}
, function(e, t, n) {
    "use strict";
    e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
}
, function(e, t, n) {
    "use strict";
    n.r(t);
    n(449),
    n(452),
    n(453),
    n(458),
    n(459),
    n(463),
    n(472),
    n(473),
    n(474),
    n(475),
    n(476),
    n(477),
    n(478),
    n(479),
    n(480),
    n(481),
    n(482),
    n(483),
    n(484),
    n(485),
    n(486),
    n(487),
    n(488),
    n(491),
    n(492),
    n(493),
    n(494),
    n(495),
    n(496),
    n(497),
    n(498),
    n(499),
    n(501),
    n(502),
    n(503),
    n(504),
    n(505),
    n(506),
    n(507),
    n(508),
    n(509),
    n(510),
    n(511),
    n(512),
    n(513),
    n(516),
    n(517),
    n(518),
    n(519),
    n(520),
    n(521),
    n(522),
    n(524),
    n(525),
    n(526),
    n(529),
    n(531),
    n(533),
    n(534),
    n(535),
    n(536),
    n(537),
    n(538),
    n(540),
    n(541),
    n(542),
    n(543),
    n(544),
    n(545),
    n(546),
    n(547),
    n(548),
    n(549),
    n(550),
    n(551),
    n(552),
    n(553),
    n(554),
    n(555),
    n(556),
    n(557),
    n(558),
    n(559),
    n(560),
    n(561),
    n(562),
    n(563),
    n(564),
    n(565),
    n(567),
    n(568),
    n(570),
    n(571),
    n(572),
    n(573),
    n(574),
    n(575),
    n(576),
    n(577),
    n(578),
    n(579),
    n(581),
    n(585),
    n(591),
    n(341);
    var r = n(342)
      , i = n(82);
    function o(e) {
        const t = e.storeConfig;
        if (t)
            if (t.pluginRecord && t.pluginRecord.types)
                if (e.builder)
                    if (e.hasCustomizedPlugin) {
                        if (e.mainStore)
                            return void e.dispatchInit();
                        e.createStore()
                    } else
                        e.customizePlugin();
                else
                    e.initBuilder();
            else
                t.pluginRecord = e.CoreBuilder.preparePluginRecord(t.pluginRecord);
        else
            e.createStoreConfig();
        i.b.schedule(o, 0, e)
    }
    var s = n(227);
    s.a.create = function(e) {
        return e.init || (e.init = o),
        new this(e,!1)
    }
    ;
    const a = s.a.prototype;
    a.doInit = function() {
        return this.isLoading ? this.hasQueuedReload = !0 : (this.initBegin(),
        i.b.schedule(this.options.init, 0, this)),
        this
    }
    ,
    a.defaultInit = o,
    a.subscribeToAction = function(e) {
        return e.meta.subscribe(),
        e.meta.mainActionMeta.subscribe({
            complete: () => this.initComplete()
        }),
        this
    }
    ;
    var c = n(58)
      , u = n(365)
      , l = n(15)
      , d = n(46)
      , h = n(6)
      , f = n(23);
    const p = {
        [l.h]: d.d,
        [l.m]: -1e3,
        [l.j]: d.d,
        [l.n]: !0,
        [h.k]: void 0,
        [h.h]: void 0,
        [h.f]: void 0,
        [h.j]: void 0,
        [h.i]: void 0,
        [h.g]: void 0,
        [h.d]: void 0,
        [h.a]: void 0,
        [h.l]: void 0,
        [h.e]: void 0,
        [h.b]: void 0,
        [l.a]: "*",
        isMatch: () => !0
    }
      , g = {
        [l.h]: d.e,
        [l.m]: 1e3,
        [l.j]: d.e,
        [l.n]: !1,
        [h.k]: void 0,
        [h.h]: void 0,
        [h.f]: void 0,
        [h.j]: void 0,
        [h.i]: void 0,
        [h.g]: void 0,
        [h.d]: void 0,
        [h.a]: void 0,
        [h.l]: void 0,
        [h.e]: void 0,
        [h.b]: void 0,
        [l.a]: "*",
        isMatch: () => !0
    }
      , m = {}
      , y = {};
    function v(e, t, n, r) {
        return !0 === t ? (m[e] || (m[e] = v(e, f.c, 50, "defaultTrxCompleteAnchor_" + e)),
        m[e]) : (r || (r = "defaultTrxCompleteAnchor_" + e),
        t || (t = f.c),
        "number" !== typeof n && (n = 50),
        {
            [l.h]: r,
            [l.j]: "defaultTrxCompleteAnchor",
            [l.l]: "@isomorix/store",
            [l.i]: "store/logic/transactions",
            [l.m]: n,
            [l.n]: !0,
            [l.k]: t,
            [l.a]: e,
            [l.r]: {
                [h.b]: t
            }
        })
    }
    function b(e, t, n, r) {
        return !0 === t ? (y[e] || (y[e] = b(e, f.f, -1e3, "defaultTrxPrepareAnchor_" + e)),
        y[e]) : (r || (r = "defaultTrxPrepareAnchor_" + e),
        t || (t = f.f),
        "number" !== typeof n && (n = -1e3),
        {
            [l.h]: r,
            [l.j]: "defaultTrxPrepareAnchor",
            [l.l]: "@isomorix/store",
            [l.i]: "store/logic/transactions",
            [l.m]: n,
            [l.n]: !0,
            [l.k]: t,
            [l.a]: e,
            [l.r]: {
                [h.k]: t
            }
        })
    }
    const _ = {};
    var S = n(26)
      , O = n(22)
      , T = n(147)
      , I = n(1)
      , x = n(79);
    class w extends O.a {
        constructor(e, t, n, r) {
            super(),
            this.op = e,
            this.opState = t,
            this.nxtLogic = n,
            this.thisArg = r
        }
        _complete() {
            const {opState: e, nxtLogic: t, thisArg: n} = this;
            this.opState = void 0,
            this.nxtLogic = void 0,
            this.thisArg = void 0;
            const {actions: r, observers: i} = e;
            e.actions = void 0,
            e.observers = void 0;
            const o = "function" === typeof t ? t : t[this.op];
            t[I.c] ? o.call(n, r, i, ...t[I.c]) : o.call(n, r, i),
            this.unsubscribe()
        }
    }
    function M(e, t, n, r) {
        return n[I.c] ? n[t.op].call(r, e, t, ...n[I.c]) : n[t.op].call(r, e, t)
    }
    function A(e, t, n, r, i, o) {
        const s = t.op;
        let a, c;
        if (!0 !== i) {
            const e = t.getState(!0);
            e ? (a = e[i]) || (e[i] = a = {}) : (a = {},
            t.setState({
                [i]: a
            }, !0))
        } else
            (a = this.batchState) || (this.batchState = a = {});
        (c = a[s]) || (a[s] = c = {}),
        c.actions ? (c.actions.push(e),
        c.observers.push(t)) : (c.actions = [e],
        c.observers = [t],
        o.subscribe(new w(s,c,n,r)))
    }
    const E = (e, t, n, r, i) => {
        i || (i = "batchState");
        const o = n ? (e => new S.a(t => {
            setTimeout( () => t.complete(), e)
        }
        ))(n) : Object(T.b)();
        r || (r = t);
        const s = [e = "function" === typeof e ? Object(x.f)(e) : e, e[I.A] || e, i, o]
          , a = {
            [I.m]: e[I.m],
            [I.q]: e[I.q],
            [I.v]: e[I.v],
            [I.c]: s,
            [I.a]: e[I.a],
            [I.x]: !1,
            [I.p]: e[I.p],
            [I.u]: e[I.u]
        };
        for (let c of t)
            r.indexOf(c) < 0 ? a[c] = M : a[c] = A;
        return a
    }
    ;
    var C = n(78)
      , N = n(1003)
      , R = n(1020)
      , P = n(52)
      , D = n(11);
    class F {
        constructor(e, t, n) {
            this.headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            },
            t && (this.headers["Api-Key"] = t),
            this.method = "POST",
            this.credentials = "include",
            this.url = e,
            this.batch = n
        }
        execute(e, t) {
            return Object(C.a)(fetch(this.url, {
                method: this.method,
                headers: this.headers,
                body: JSON.stringify(e),
                credentials: this.credentials
            })).pipe(Object(D.b)(), Object(N.a)(n => {
                if (t) {
                    if (t > 5)
                        throw n;
                    t++
                } else
                    t = 1;
                return Object(D.c)().pipe(Object(R.a)(1500 * t), Object(P.a)( () => this.execute(e, t)))
            }
            ))
        }
    }
    var k = window.WebSocket
      , j = n(1012)
      , L = n(1e3)
      , V = n(31)
      , U = n(121)
      , q = n(185)
      , Q = n(101);
    function B(e, t, n) {
        void 0 === e && (e = 0);
        var r = -1;
        return Object(q.a)(t) ? r = Number(t) < 1 ? 1 : Number(t) : Object(Q.a)(t) && (n = t),
        Object(Q.a)(n) || (n = i.a),
        new S.a((function(t) {
            var i = Object(q.a)(e) ? e : +e - n.now();
            return n.schedule(G, i, {
                index: 0,
                period: r,
                subscriber: t
            })
        }
        ))
    }
    function G(e) {
        var t = e.index
          , n = e.period
          , r = e.subscriber;
        if (r.next(t),
        !r.closed) {
            if (-1 === n)
                return r.complete();
            e.index = t + 1,
            this.schedule(e, n)
        }
    }
    var z = n(1007)
      , H = n(190)
      , K = n(14)
      , Y = n(72)
      , W = n(57);
    function $(e, t) {
        return "function" === typeof t ? function(n) {
            return n.pipe($((function(n, r) {
                return Object(C.a)(e(n, r)).pipe(Object(Y.a)((function(e, i) {
                    return t(n, e, r, i)
                }
                )))
            }
            )))
        }
        : function(t) {
            return t.lift(new X(e))
        }
    }
    var X = function() {
        function e(e) {
            this.project = e
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new J(e,this.project))
        }
        ,
        e
    }()
      , J = function(e) {
        function t(t, n) {
            var r = e.call(this, t) || this;
            return r.project = n,
            r.index = 0,
            r
        }
        return K.a(t, e),
        t.prototype._next = function(e) {
            var t, n = this.index++;
            try {
                t = this.project(e, n)
            } catch (r) {
                return void this.destination.error(r)
            }
            this._innerSub(t)
        }
        ,
        t.prototype._innerSub = function(e) {
            var t = this.innerSubscription;
            t && t.unsubscribe();
            var n = new W.a(this)
              , r = this.destination;
            r.add(n),
            this.innerSubscription = Object(W.c)(e, n),
            this.innerSubscription !== n && r.add(this.innerSubscription)
        }
        ,
        t.prototype._complete = function() {
            var t = this.innerSubscription;
            t && !t.closed || e.prototype._complete.call(this),
            this.unsubscribe()
        }
        ,
        t.prototype._unsubscribe = function() {
            this.innerSubscription = void 0
        }
        ,
        t.prototype.notifyComplete = function() {
            this.innerSubscription = void 0,
            this.isStopped && e.prototype._complete.call(this)
        }
        ,
        t.prototype.notifyNext = function(e) {
            this.destination.next(e)
        }
        ,
        t
    }(W.b)
      , Z = n(868)
      , ee = n(1005)
      , te = n(278)
      , ne = n(276);
    const re = B(1e4);
    const ie = ne.a - 1e4;
    var oe = n(875);
    const se = {
        _doConnect: function() {
            this._connectSub && (this._connectSub.unsubscribe(),
            this._connectSub = void 0);
            const e = () => {
                if (this.isClosed)
                    return Object(D.c)();
                if (this.ws && this.ws.close(1e3, "Timeout"),
                !this.isWindowVisible)
                    return console.log("TRY CONNECT... BUT WINDOW IS NOT VISIBLE. WAITING"),
                    this.windowVisibility$.pipe(Object(H.a)( () => this.isWindowVisible), Object(te.a)(), Object(P.a)(e));
                console.log("TRY CONNECT (WINDOW VISIBLE)");
                const r = new this.WebSocket(this.url,this.wsProtocol);
                return this.ws = r,
                r.addEventListener("open", this.handleOpen),
                r.addEventListener("close", this.handleClose),
                r.addEventListener("error", this.handleError),
                r.addEventListener("message", this.handleMessage),
                re.pipe(t, n)
            }
              , t = $( () => (this.ws && (this.ws.close(1e3, "Timeout"),
            this.ws = void 0),
            B(2e3)))
              , n = $(e)
              , r = e().pipe(Object(Z.a)(this._connect$), Object(ee.a)( () => {
                this._connectSub === r && (this._connectSub = void 0)
            }
            )).subscribe();
            this._connectSub = r
        },
        connect: function() {
            return this._connect$ ? this._connect$ : this.isClosing ? Object(D.c)() : this.isConnected ? Object(V.a)(this) : (console.log("CONNECTING..."),
            this._connect$ = new U.a,
            this.connectRetries = 0,
            this._doConnect(),
            this._connect$.asObservable())
        },
        connectionReady: function() {
            const e = this.observersMap;
            if (this.keepAliveSub && this.keepAliveSub.unsubscribe(),
            this.keepAliveSub = Object(z.a)(8e3).subscribe( () => {
                this.isConnected && Date.now() - this.lastMsgSentAt >= ie && this.send(ne.b.KEEP_ALIVE)
            }
            ),
            e.size) {
                let t;
                console.log(">>>> RESUMING SUBSCRIPTIONS/OPERATIONS");
                for (const [n,r] of e)
                    ({wsMsg: t} = r),
                    this.send(t.type, t.payload, n, r)
            }
            const t = this.unsentQueue;
            if (t.length) {
                this.unsentQueue = [],
                console.log("SENDING UNSENT QUEUE");
                for (const e of t)
                    this.send(e.type, e.payload, e.id, e.observer)
            }
        },
        destroy: function() {
            if (this.isClosed)
                return;
            this.isClosing = !0,
            this.isClosed = !0,
            this.windowVisibility$ && (this.windowVisibility$.complete(),
            this.windowVisibility$ = void 0,
            window.removeEventListener("visibilitychange", this.windowVisibilityListener),
            this.windowVisibilityListener = void 0),
            this._connectSub && (this._connectSub.unsubscribe(),
            this._connectSub = void 0),
            this.keepAliveSub && (this.keepAliveSub.unsubscribe(),
            this.keepAliveSub = void 0),
            this.ws && (this.ws.close(1e3),
            this.ws = void 0);
            const e = this.observersMap;
            if (e.size) {
                for (const [,t] of e)
                    t.complete();
                e.clear()
            }
            this._connect$ && (this._connect$.complete(),
            this._connect$ = void 0),
            this.observersMap = void 0
        },
        execute: function(e, t, n) {
            return new S.a(r => {
                const i = Object(oe.b)();
                return this.send(n ? ne.b.AI_START : ne.b.GQL_START, e, i, r),
                () => {
                    this.observersMap.get(i) === r && (this.observersMap.delete(i),
                    t && this.send(ne.b.GQL_STOP, void 0, i))
                }
            }
            )
        },
        handleClose: function(e) {
            if (console.log("GOT handleClose(), event = ", JSON.stringify({
                code: e.code,
                reason: e.reason,
                wasClean: e.wasClean
            }, null, 2)),
            this.ws = void 0,
            this.keepAliveSub && (this.keepAliveSub.unsubscribe(),
            this.keepAliveSub = void 0),
            this.isClosing)
                this.destroy();
            else
                switch (e.code) {
                case 1006:
                case 1007:
                case 1011:
                default:
                    setTimeout( () => {
                        this.isClosing || this.ws || this.connect()
                    }
                    , 3e3)
                }
        },
        handleError: function(e) {},
        handleMessage: function(e) {
            const t = e.data;
            let n;
            try {
                n = JSON.parse(t)
            } catch (i) {
                return void console.warn("GOT BAD WEB SOCKET MESSAGE: ", e)
            }
            const r = this.observersMap.get(n.id);
            switch (this.lastMsgReceivedAt = Date.now(),
            n.type) {
            case ne.b.GQL_DATA:
            case ne.b.AI_DATA:
                r && r.next(n.payload);
                break;
            case ne.b.GQL_COMPLETE:
            case ne.b.AI_COMPLETE:
                r && (r.complete(),
                this.observersMap.delete(n.id));
                break;
            case ne.b.KEEP_ALIVE:
                this.send(ne.b.KEEP_ALIVE_ACK);
                break;
            case ne.b.GQL_ERROR:
            case ne.b.AI_ERROR:
                r && (r.error(n.payload),
                this.observersMap.delete(n.id));
                break;
            case ne.b.CONNECTION_ACK:
                console.log(">>> GOT WEBSOCKET CONNECTION ACK"),
                this.connectionReady()
            }
        },
        handleOpen: function() {
            if (this.ws) {
                if (this._connect$) {
                    const e = this._connect$;
                    this._connect$ = void 0,
                    e.next(this),
                    e.complete()
                }
                this.send(ne.b.CONNECTION_INIT)
            }
        },
        send: function(e, t, n, r) {
            const i = {
                type: e,
                payload: t,
                id: n
            };
            if (r && (this.observersMap.set(n, r),
            r.wsMsg = i),
            this.isConnected)
                return this.lastMsgSentAt = Date.now(),
                void this.ws.send(JSON.stringify(i));
            r ? (r.wsMsg = {
                ...i
            },
            i.observer = r) : this.unsentQueue.push(i),
            this.connect()
        }
    };
    class ae {
        constructor(e, t) {
            t && (e += "?apiKey=".concat(t)),
            this.isClosed = !1,
            this.isClosing = !1,
            this.lastMsgSentAt = 0,
            this.lastMsgReceivedAt = 0,
            this.observersMap = new Map,
            this.unsentQueue = [],
            this.lastMsgAt = Date.now(),
            this.url = e,
            this.wsProtocol = j.a.GRAPHQL_WS,
            this.WebSocket = k,
            this.ws = void 0,
            this.keepAliveSub = void 0,
            this.OPEN = k.OPEN,
            this.CLOSED = k.CLOSED,
            this.CONNECTING = k.CONNECTING,
            this.CLOSING = k.CLOSING,
            this.handleOpen = this.handleOpen.bind(this),
            this.handleClose = this.handleClose.bind(this),
            this.handleError = this.handleError.bind(this),
            this.handleMessage = this.handleMessage.bind(this),
            this.isWindowVisible = !0,
            "undefined" !== typeof window && "undefined" !== typeof document && (this.windowVisibility$ = new U.a,
            this.isWindowVisible = "visible" === document.visibilityState,
            this.windowVisibilityListener = () => {
                if (this.isClosed)
                    return;
                const e = "hidden" !== document.visibilityState;
                e !== this.isWindowVisible && (this.isWindowVisible = e,
                this.windowVisibility$.next(e))
            }
            ,
            window.addEventListener("visibilitychange", this.windowVisibilityListener))
        }
        get isConnected() {
            return !(!this.ws || this.ws.readyState !== this.OPEN)
        }
        get isConnecting() {
            return !!this._connect$
        }
    }
    Object(L.a)(ae, se);
    let ce = (e, t) => !("undefined" === typeof window || !window.__PRELOAD_STATE__ || !window.__PRELOAD_STATE__.__CONNECTIONS__) && (window.__PRELOAD_STATE__.__CONNECTIONS__[e] = t,
    !0);
    ce = () => !1;
    class ue {
        constructor(e, t, n) {
            this.isClosed = !1,
            this.httpUrl = e,
            this.wsUrl = e.replace(/^http/, "ws"),
            this.apiKey = t,
            this.batchMs = !1,
            this.httpClient = new F(e,t,this.batchMs),
            this.wsClient = void 0,
            this.connectionMethod = () => this
        }
        updateUrl(e) {
            return this.httpUrl = e,
            this.wsUrl = e.replace(/^http/, "ws"),
            this.wsClient && (this.wsClient.destroy(),
            this.wsClient = void 0),
            ce(u.a.GRAPHQL, e),
            this
        }
        getWsClient() {
            return this.wsClient || (this.wsClient = new ae(this.wsUrl,this.apiKey))
        }
        query(e) {
            return (this.wsClient || this.httpClient).execute(e)
        }
        mutation(e) {
            return (this.wsClient || this.httpClient).execute(e)
        }
        subscribe(e, t) {
            const n = this.subscription(e).subscribe(t);
            return () => n.unsubscribe()
        }
        subscription(e) {
            return this.getWsClient().execute(e, !0)
        }
        destroy() {
            this.isClosed || (this.isClosed = !0,
            this.wsClient && (this.wsClient.destroy(),
            this.wsClient = void 0))
        }
    }
    const le = n(139).a.init().setActionType(c.n);
    var de = n(107)
      , he = n(0)
      , fe = n(279);
    const pe = {
        MAIN_QUERY: "MAIN_QUERY",
        GROUPED_QUERY: "GROUPED_QUERY",
        VF_QUERY: "VF_QUERY",
        INCLUDE_VF_QUERY: "INCLUDE_VF_QUERY"
    }
      , ge = {
        PAYLOAD: "PAYLOAD",
        RECORDS: "RECORDS",
        RECORDS_RESULTS: "RECORDS_RESULTS"
    }
      , me = {
        OBJECT_RESP: "object",
        ARRAY_RESP: "array",
        SINGLE_RESP: "single"
    }
      , ye = {
        GET: "get",
        FIND: "find",
        FETCH: "fetch",
        FETCH_RAW: "fetchRaw",
        FETCH_DIRECT: "fetchDirect",
        SUBSCRIBE: "subscribe",
        LOCAL_SUBSCRIBE: "localSubscribe"
    };
    var ve = n(377);
    function be(e) {
        let t, n = e.not || !1, r = e.ownQuery;
        for (; r && !r.isIncludeQuery && (t = r.parentQueryArg); )
            t.not && (n = !n),
            r = r.parent;
        return n
    }
    function _e(e, t) {
        if ("number" === typeof t) {
            const n = e[t];
            return n || !1
        }
        {
            const n = e.indexOf(t);
            if (n < 0)
                return !1;
            if (t.argIdx !== n)
                throw new Error("Unable to remove/replace the argument in query Args Array. There is a mismatch between the arg's index in the Array and the value of the argument's `argIdx` property. This means the Args Array is unstable and will produce potentially erroneous results for the Query.");
            return t
        }
    }
    function Se(e, t) {
        const n = e.ancestorArgs
          , r = t.ancestorArgs;
        if (!n || !r)
            return null;
        for (let i = 0; i < n.length; i++)
            if (n[i] !== r[i])
                return n[i - 1];
        return null
    }
    const Oe = (e, t, n) => {
        for (; n > t; ) {
            if ("or" === e[n].join)
                return !1;
            n--
        }
        return !0
    }
    ;
    function Te(e, t, n) {
        const r = n.query.queryArgs
          , i = t.ancestorArgs
          , o = e.ancestorArgs;
        let s = i[i.indexOf(n) + 1].argIdx
          , a = o[o.indexOf(n) + 1].argIdx;
        return s < a ? Oe(r, s, a) : Oe(r, a, s)
    }
    function Ie(e, t) {
        if (e.modelName !== t.modelName || e.isQueryInPath(t) || t.isQueryInPath(e))
            return !1;
        const n = Se(e, t);
        return n ? Te(e, t, n) : !e.isNestedVFGroup && !t.isNestedVFGroup
    }
    function xe(e, t) {
        let n, r;
        if (Object(he.M)(e)) {
            if (n = e.ownQuery,
            r = t.ownQuery,
            n === r)
                return e.argsGroupIdx === t.argsGroupIdx
        } else
            n = e.query,
            r = t.query;
        if (n.modelName !== r.modelName || n.isQueryInPath(r) || r.isQueryInPath(n))
            return !1;
        const i = Se(n, r);
        return !i || Te(n, r, i)
    }
    function we(e, t, n) {
        const r = _e(e, t);
        if (!r)
            return !1;
        const i = r[he.q];
        return i !== he.d && i !== he.b || n.deRegisterSibling(r.query),
        r
    }
    class Me extends Array {
        constructor(e, t) {
            super(),
            this.controller = e,
            this.siblingGroupIdx = t
        }
        _registerSibling(e) {
            const t = this.length;
            let n, r, i, o = 0;
            for (i of this)
                Ie(i, e) && (n = i.ownSiblingsIdx,
                n ? n.push(t) : i.ownSiblingsIdx = [t],
                r ? r.push(o) : r = [o]),
                o++;
            this.push(e),
            e.siblingQueriesIdx = t,
            e.ownSiblingsIdx = r,
            e.siblingQueries = this,
            e.siblingQueriesGroupIdx = this.siblingGroupIdx
        }
        registerSibling(e) {
            this.controller.registerSibling(e)
        }
        _deRegisterSibling(e) {
            const t = this.indexOf(e);
            if (t < 0)
                return;
            let n, r, i, o, s;
            for (s of this)
                if (n = s.ownSiblingsIdx,
                n)
                    for (o = n.length,
                    r = 0; r < o; )
                        i = n[r],
                        i === t ? (n.splice(r, 1),
                        o--) : (i > t && (n[r] = i - 1),
                        r++);
            this.splice(t, 1);
            const a = e.queryArgs;
            if (a) {
                let e, t;
                for (e of a)
                    t = e[he.q],
                    t !== he.d && t !== he.b || this._deRegisterSibling(e.query)
            }
        }
        deRegisterSibling(e) {
            this.controller.deRegisterSibling(e)
        }
    }
    class Ae extends Array {
        constructor(e) {
            super(),
            this.query = e
        }
        registerSibling(e) {
            const t = e.topLevelQueryArg.argsGroupIdx;
            let n = this[t];
            n ? n.indexOf(e) < 0 && n._registerSibling(e) : (this[t] = n = new Me(this,t),
            n._registerSibling(e))
        }
        deRegisterSibling(e) {
            const t = e.topLevelQueryArg;
            if (t) {
                const {argsGroupIdx: n} = t
                  , r = this[n];
                r && r._deRegisterSibling(e)
            }
        }
        static init(e) {
            return new this(e)
        }
    }
    class Ee extends Array {
        constructor(e, t) {
            super(),
            this.controller = e,
            this.siblingGroupIdx = t
        }
        _registerSibling(e) {
            const t = this.length;
            let n, r, i, o = 0;
            for (i of this)
                xe(i, e) && (n = i.ownSiblingsIdx,
                n ? n.push(t) : i.ownSiblingsIdx = [t],
                r ? r.push(o) : r = [o]),
                o++;
            this.push(e),
            e.siblingQueriesIdx = t,
            e.ownSiblingsIdx = r,
            e.siblingQueries = this,
            e.siblingQueriesGroupIdx = this.siblingGroupIdx
        }
        registerSibling(e) {
            this.controller.registerSibling(e)
        }
    }
    class Ce extends Array {
        constructor(e) {
            super(),
            this.query = e
        }
        registerSibling(e) {
            let t = e.ownQuery.topLevelQueryArg;
            t || (t = e);
            const n = t.argsGroupIdx;
            let r = this[n];
            r ? r.indexOf(e) < 0 && r._registerSibling(e) : (r = new Ee(this,n),
            this[n] = r,
            r._registerSibling(e))
        }
    }
    const Ne = e => class extends e {
        constructor(e) {
            super(e),
            this.siblingQueries = void 0,
            this.siblingQueriesIdx = void 0,
            this.ownSiblingsIdx = void 0,
            this.siblingQueriesGroupIdx = void 0
        }
        convertToGroupedQuery(e, t) {
            return e ? (this.siblingQueries && this.siblingQueries.deRegisterSibling(this),
            super.convertToGroupedQuery(e, t)) : (this.trackSiblings(!1),
            super.convertToGroupedQuery())
        }
        mergeQuery(e, t) {
            return this.siblingQueries && this.siblingQueries.deRegisterSibling(this),
            super.mergeQuery(e, t)
        }
        removeArg(e) {
            if (!this.siblingQueries)
                return super.removeArg(e);
            const t = this.queryArgs;
            if (t) {
                const n = we(t, e, this.siblingQueries);
                return !!n && t.removeArg(n)
            }
            return !1
        }
        replaceArg(e, t) {
            if (!this.siblingQueries)
                return super.replaceArg(e, t);
            const n = this.queryArgs;
            if (n) {
                const r = we(n, e, this.siblingQueries);
                return !!r && n.replaceArg(r, t)
            }
            return !1
        }
        setAsVFQuery(e) {
            return super.setAsVFQuery(e),
            this.isTrackingSiblings && this.registerSibling(this),
            this
        }
        setAsGroupedQuery(e) {
            return super.setAsGroupedQuery(e),
            this.isTrackingSiblings && this.registerSibling(this),
            this
        }
        registerSibling(e) {
            let t = this.siblingQueries;
            t ? t.registerSibling(e) : this.parentMethodsMap.registerSibling ? this.parent.registerSibling(e) : (this.siblingQueries = t = Ae.init(this),
            t.registerSibling(e))
        }
        trackSiblings(e, t) {
            if (!t) {
                if (this.parentMethodsMap.registerSibling)
                    return void this.parent.trackSiblings(e);
                if (!1 === e)
                    return void (this._isTrackingSiblings && (this._isTrackingSiblings = !1,
                    this.siblingQueries = void 0,
                    this.ownSiblingsIdx = void 0,
                    this._ancestorArgs = void 0));
                if (this.isTrackingSiblings)
                    return;
                this._isTrackingSiblings = !0
            }
            const n = this.queryArgs;
            if (!n)
                return;
            let r, i, o = this.siblingQueries;
            if (t)
                for (let s of n)
                    (r = s.query) && (o.registerSibling(r),
                    r.trackSiblings(!0, !0));
            else
                for (i of n)
                    (r = i.query) && (o || (this.siblingQueries = o = Ae.init(this)),
                    o.registerSibling(r),
                    r.trackSiblings(!0, !0))
        }
        parseSiblingArgs(e) {
            if (!Array.isArray(e))
                throw new Error("parseSiblingArgs expects an Array of args. Got: " + e);
            let t;
            for (t of e)
                t.siblingQueriesIdx = void 0,
                t.ownSiblingsIdx = void 0,
                t.siblingQueries = void 0,
                t.siblingQueriesGroupIdx = void 0;
            const n = new Ce(this);
            for (t of e)
                n.registerSibling(t);
            return n
        }
        isQueryInPath(e) {
            if (e === this)
                return !1;
            let t = this.parent;
            for (; t; ) {
                if (t === e)
                    return !0;
                t = t.parent
            }
            return !1
        }
        destroy(e) {
            this.siblingQueries = void 0,
            this.ownSiblingsIdx = void 0,
            this._ancestorArgs = void 0,
            super.destroy(e)
        }
        get ancestorArgs() {
            let {_ancestorArgs: e} = this;
            if (e || this.isIncludeQuery || this.isRootQuery)
                return e;
            let t, n = this.parentQueryArg;
            for (this._ancestorArgs = e = []; n && (e.unshift(n),
            t = n.ownQuery,
            !t.isIncludeQuery); )
                n = t.parentQueryArg;
            return e
        }
        get topLevelQueryArg() {
            if (this.isIncludeQuery)
                return null;
            const {parent: e} = this;
            if (e) {
                let t = e.topLevelQueryArg;
                return null === t && (t = e.queryArgs[this.parentQueryArgIdx]),
                t
            }
            return null
        }
        get isNestedVFGroup() {
            if ("VF_QUERY" !== this.instanceType)
                return !1;
            let e = this.parent;
            for (; e; ) {
                if ("VF_QUERY" === e.instanceType)
                    return !0;
                e = e.isIncludeQuery ? void 0 : e.parent
            }
            return !1
        }
        get parent() {
            return this._parent
        }
        set parent(e) {
            e !== this._parent && (this._ancestorArgs = void 0),
            this._parent = e
        }
        get isTrackingSiblings() {
            return this.parentMethodsMap.registerSibling ? this.parent.isTrackingSiblings : this._isTrackingSiblings
        }
    }
    ;
    const Re = {
        initAsClone: function(e) {
            return this.query = e.query.clone(this.ownQuery, this.argIdx),
            this
        },
        createQueryInstance: function() {
            return this.ownQuery.createGroupedInstance(this)
        },
        checkRecord: function(e, t, n) {
            return this.not ? !this.query.checkRecord(e, t, n) : this.query.checkRecord(e, t, n)
        },
        updateArg: function(e, t, n, r) {
            return this.query && this.query.updateArgs(e, t, n, r),
            this
        },
        isDifferentThan: function(e) {
            if (!Object(he.K)(e) || this.not !== e.not || this.join !== e.join)
                return !0;
            const {query: t} = this
              , {query: n} = e;
            return t && n ? t.isDifferentThan(n) : !(!t && !n)
        },
        destroy: function() {
            this.queryArgs = void 0,
            this.value = void 0,
            this.query && (this.query.destroy(),
            this.query = void 0)
        }
    };
    function Pe(e) {
        class t extends e {
        }
        return Object(he.z)(t, he.b, he.q),
        Object(L.a)(t, Re),
        t
    }
    const De = {
        CONCAT: "concat",
        DECREMENT: "decrement",
        INCREMENT: "increment",
        MERGE: "merge",
        MERGE_DEEP: "merge_deep",
        MERGE_NONEXISTENT: "merge_nonexistent",
        MERGE_NONEXISTENT_DEEP: "merge_nonexistent_deep"
    }
      , Fe = {};
    for (let jR in De)
        Fe[De[jR]] = "".concat(jR);
    let ke;
    ke = {};
    var je = n(399)
      , Le = n(864)
      , Ve = n(378)
      , Ue = n.n(Ve);
    const qe = () => !0
      , Qe = (e, t) => {
        if (!e || !t)
            return !(!e && !t);
        if (e.length !== t.length)
            return !0;
        for (let n = 0; n < e.length; n++)
            if (e[n] !== t[n])
                return !0;
        return !1
    }
    ;
    const Be = (e, t, n) => {
        const r = e.valueParam ? n[e.valueParam] : e.value;
        if ("in" === e.op) {
            for (let e = 0; e < r.length; e++)
                r[e] = r[e] + t;
            return r
        }
        return r + t
    }
    ;
    const Ge = {
        init: function() {
            const e = this.queryArgs.query;
            this.valueParam = e.getValueParam(this.value) || null,
            this.isRegex = !1;
            const {op: t} = this;
            if (this.valueParam)
                switch (e.validateParam(this.valueParam, 'key:value argument for field "'.concat(this.key, '"')),
                e.queryHasVariables = !0,
                t) {
                case "like":
                    this.fn = Object(je.a)(this.not),
                    this.isRegex = !0;
                    break;
                case "rlike":
                    this.fn = Object(je.b)(this.not),
                    this.isRegex = !0;
                    break;
                case "isNull":
                case "exists":
                    this.fn = Object(je.d)(t, this.not);
                    break;
                default:
                    this.fn = this.isGeoPoint ? qe : Object(je.d)(t, this.not)
                }
            else {
                if (null === this.value)
                    "exists" !== t && (this.op = "isNull");
                else if ("like" === t)
                    this.value = Object(je.c)(this.value),
                    this.value.__likeExp || (this.op = "rlike"),
                    this.isRegex = !0;
                else if ("rlike" === t)
                    this.value = Object(je.e)(this.value),
                    this.isRegex = !0;
                else if ("in" === t && 1 === this.value.length)
                    this.value = this.value[0],
                    this.op = "=";
                else if (this.isGeoPoint)
                    return this.fn = qe,
                    this;
                this.fn = Object(je.d)(this.op, this.not),
                this.value = this.parseValue(this.value)
            }
            return this
        },
        initAsClone: function(e) {
            return this.valueParam = e.valueParam,
            this.fn = e.fn,
            this.isRegex = e.isRegex,
            this.isGeoPoint = e.isGeoPoint,
            this.valueParam && (this.queryArgs.query.queryHasVariables = !0),
            this
        },
        isDifferentThan: function(e) {
            return !Object(he.M)(e) || this.not !== e.not || this.join !== e.join || this.op !== e.op || this.key !== e.key || Qe(this.path, e.path) || this.valueParam !== e.valueParam || (n = e,
            !(t = this).valueParam && ("in" === t.op ? Qe(t.getComparisonValue(t.value), n.getComparisonValue(n.value)) : "like" === t.op || "rlike" === t.op ? t.value.toString() !== n.value.toString() : t.getComparisonValue(t.value) !== n.getComparisonValue(n.value)));
            var t, n
        },
        checkRecord: function(e, t, n) {
            return this.fn(this.getComparisonValue(this.valueParam ? this.parseValue(t[this.valueParam]) : this.value), this.getComparisonValue(this.path ? Object(Le.a)(this.path, e) : e[this.key], !0))
        },
        updateArg: function(e, t, n, r) {
            let {[this.key]: i} = t;
            const {valueParam: o} = this;
            if ("undefined" === typeof i || o && !n)
                return this;
            const s = e && e[this.key];
            if (s)
                if ("increment" === s)
                    i = Be(this, i, n);
                else if ("decrement" === s)
                    i = Be(this, -1 * i, n);
                else {
                    if (!this.path)
                        throw new Error('Unable to update KeyValueArg for field "'.concat(this.key, '" on Model "').concat(this.queryArgs.query.modelName, '": The dataType ').concat(e[this.key], " clones the Object, and the comparison is made by reference since no path is associated with this KeyValue ar, and therefore no match would ever be found. Only ").concat("increment", " and ").concat("decrement", " data types can be provided when a path is not assigned to the KeyValue arg."));
                    if (a = this.path,
                    !(c = t) || !("string" === typeof a ? Object.prototype.hasOwnProperty.call(c, a) : Ue()(a, c)))
                        return this
                }
            var a, c;
            return r && (this.not = !1),
            this.isRegex && (this.isRegex = !1,
            this.op = "=",
            this.fn = Object(je.d)(this.op, this.not)),
            this.path && (i = Object(Le.a)(this.path, t)),
            null === i ? "isNull" !== this.op && (this.op = "isNull",
            this.fn = this.fn = Object(je.d)(this.op, this.not)) : "isNull" === this.op ? (this.op = "=",
            this.fn = Object(je.d)(this.op, this.not)) : "in" !== this.op || Array.isArray(i) || (i = [i]),
            o ? n[o] = this.parseValue(i) : this.value = this.parseValue(i),
            this
        },
        parseValue: function(e) {
            return e
        },
        destroy: function() {
            this.queryArgs = void 0,
            this.value = void 0,
            this.fn = void 0
        },
        getComparisonValue: function(e, t) {
            return e
        }
    };
    function ze(e) {
        class t extends e {
        }
        return Object(he.z)(t, he.c, he.q),
        Object(L.a)(t, Ge),
        t
    }
    const He = {
        VFName: {
            get() {
                return this._VFName
            },
            set(e) {
                this._VFName = e
            },
            configurable: !0
        }
    }
      , Ke = {
        checkRecord: () => !0
    };
    const Ye = {
        initAsClone: function(e) {
            return this.VFName = e.VFName,
            this.query = e.query ? e.query.clone(this.ownQuery, this.argIdx) : void 0,
            this
        },
        createQueryInstance: function() {
            const e = this.ownQuery
              , t = e.constructor.init(e.model[this.VFName]);
            return this.query = t,
            t.setAsVFQuery(this),
            t
        },
        getRefs: function(e, t) {
            return e[this.VFName]
        },
        checkRecord: function(e, t, n) {
            const r = this.getRefs(e, n);
            if ("exists" === this.op)
                return r ? !this.not : this.not;
            if (null === this.value)
                return null === r;
            if (r) {
                if (this.isMany) {
                    let e = !1;
                    const i = this.query.queryArgs || Ke;
                    if (this.not) {
                        for (let o in r)
                            if (!i.checkRecord(r[o], t, n)) {
                                e = !0;
                                break
                            }
                    } else
                        for (let o in r)
                            if (i.checkRecord(r[o], t, n)) {
                                e = !0;
                                break
                            }
                    return e
                }
                return this.not ? !this.query.checkRecord(r, t, n) : this.query.checkRecord(r, t, n)
            }
            return !1
        },
        updateArg: function(e, t, n, r) {
            return t[this.VFName] && this.query.updateArgs(e && e[this.VFName] || null, t[this.VFName], n, r),
            this
        },
        isDifferentThan: function(e) {
            if (!Object(he.Y)(e) || this.not !== e.not || this.join !== e.join || this.VFName !== e.VFName)
                return !0;
            const {query: t} = this
              , {query: n} = e;
            return t && n ? t.isDifferentThan(n) : !(!t && !n)
        },
        destroy: function() {
            this.queryArgs = void 0,
            this.query && (this.query.destroy(),
            this.query = void 0)
        }
    }
      , We = {
        ...He,
        key: {
            get() {
                return this.VFName
            },
            set(e) {
                this.VFName = e
            }
        }
    };
    function $e(e) {
        class t extends e {
        }
        return Object.defineProperties(t.prototype, We),
        Object(he.z)(t, he.d, he.q),
        Object(L.a)(t, Ye),
        t
    }
    class Xe {
        constructor(e, t, n, r, i, o, s, a, c) {
            this.queryArgs = e,
            this.not = t || !1,
            this.join = n || !1,
            this.op = r,
            this.key = i,
            this.value = o,
            this.path = s || null,
            c ? (this.argIdx = c.argIdx,
            this.argsGroupIdx = c.argsGroupIdx,
            this.isSelected = c.isSelected,
            c.id && (this.id = c.id),
            e.query.replaceArg(c, this)) : (this.argIdx = e.push(this) - 1,
            0 === this.argIdx ? this.join = !1 : "or" === n && e.incrementArgsGroupIdx(),
            this.argsGroupIdx = e.argsGroupIdx,
            this.isSelected = !1,
            a && (this.id = a))
        }
        init() {
            return this
        }
        initAsClone(e) {
            return this
        }
        createNewInstance(e) {
            return new this.constructor(this.queryArgs,this.not,this.join,this.op,this.key,this.value,this.path,this.id,e ? this : void 0)
        }
        getMethodName(e) {
            const t = "" !== e ? e : this.join;
            let n = t ? "".concat(t, "Where") : "where";
            switch (this.not && (n += "Not"),
            this.op) {
            case "in":
                return "".concat(n, "In");
            case "exists":
                return "".concat(n, "Exists");
            default:
                return n
            }
        }
        get ownQuery() {
            return this.queryArgs.query
        }
        clone(e, t) {
            return "undefined" === typeof t && (t = this.join),
            new this.constructor(e,this.not,t,this.op,this.key,this.value,this.path,this.id).initAsClone(this)
        }
        removed() {
            this.destroy()
        }
        replaced(e) {
            this.destroy()
        }
        destroy() {}
    }
    const Je = Pe(Xe)
      , Ze = ze(Xe)
      , et = $e(Xe);
    const tt = (e, t) => null === t ? "exists" === e ? e : "isNull" : "object" === typeof t && Array.isArray(t) ? "in" : e;
    class nt extends Array {
        constructor(e) {
            super(),
            this.query = e,
            this.argsGroupIdx = 0,
            this.indexedArgsVerified = !1
        }
    }
    nt.GroupedQueryArg = Je,
    nt.VFQueryArg = et,
    nt.KeyValueArg = Ze;
    const rt = {
        addKeyValueArg: function(e, t, n, r, i, o) {
            return new this.constructor.KeyValueArg(this,e,t,n,r,i,o).init()
        },
        addVFArgFromObject: function(e, t, n, r, i) {
            const o = new this.constructor.VFQueryArg(this,e,t,n,r);
            o.createQueryInstance()._addQueryArg(i, n, void 0, !1, void 0),
            o.init()
        },
        addVFArgFromMethod: function(e, t, n, r, i, o) {
            const s = new this.constructor.VFQueryArg(this,e,t,n,r)
              , a = s.createQueryInstance();
            o ? i.call(o, a) : i(a),
            s.init()
        },
        addVFArgFromQuery: function(e, t, n, r, i) {
            const o = new this.constructor.VFQueryArg(this,e,t,n,r);
            o.createQueryInstance().buildFromQuery(i),
            o.init()
        },
        addVFArgFromValue: function(e, t, n, r, i) {
            const o = new this.constructor.VFQueryArg(this,e,t,n,r,i);
            if (null !== i)
                throw new Error("Invalid VF where argument.");
            const s = o.createQueryInstance();
            "exists" === n ? s.whereExists(s.primaryKey) : s.whereNull(s.primaryKey),
            o.init()
        },
        addGroupedArgFromMethod: function(e, t, n, r, i) {
            const o = new this.constructor.GroupedQueryArg(this,e,t,n);
            let s = o.createQueryInstance();
            return i ? r.call(i, s) : r(s),
            s.hasQueryArgs ? (o.init(),
            o) : (this.splice(o.argIdx, 1),
            o.destroy(),
            !1)
        },
        addArgsFromObject: function(e, t, n, r) {
            const i = Object.keys(r);
            let o = i.length;
            if (r._OPERATOR_ && Object(je.i)(r._OPERATOR_) && (n = r._OPERATOR_,
            i.splice(i.indexOf("_OPERATOR_"), 1),
            o--),
            r._PATH_) {
                let s = r._PATH_;
                if (o > 2)
                    throw i.splice(i.indexOf("_PATH_"), 1),
                    new Error("If _PATH_ is provided, only 1 KeyValueArg can be provided in the Object. Got: ".concat(i.join(", ")));
                const a = "_PATH_" === i[0] ? i[1] : i[0];
                s[0] !== a && (s = [a, ...s]),
                this.query._addQueryArg(s, tt(n, r[a]), r[a], e, t)
            } else {
                let s, a, c, u = 0;
                for ("or" === t && o > 1 ? (a = new this.constructor.GroupedQueryArg(this,e,t,"="),
                s = a.createQueryInstance(),
                t = void 0,
                e = !1) : s = this.query; u < o; )
                    1 !== u || t || (t = "and"),
                    c = r[i[u]],
                    s._addQueryArg(i[u], tt(n, c), c, e, t),
                    u++;
                a && a.init()
            }
        },
        addGroupedQueryArg: function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
              , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "=";
            if (t)
                this.length || (t = null);
            else if (this.length)
                throw new Error('The join param ("and", "or") was not provided to the addGroupedQueryArg method and there are already existing arguments for the query. Unable to create the new instance.');
            return new this.constructor.GroupedQueryArg(this,e,t,n).init()
        },
        addGroupedArgFromQuery: function(e, t, n, r) {
            if (r.hasQueryArgs) {
                const i = new this.constructor.GroupedQueryArg(this,e,t,n);
                return i.createQueryInstance().buildFromQuery(r),
                i.init(),
                i
            }
            this.query.buildFromQuery(r)
        },
        clone: function(e) {
            const t = e.getOrInitQueryArgs();
            let n;
            for (n of this)
                n.clone(t);
            return t
        },
        checkRecord: function(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
              , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.length;
            if (!e)
                return !1;
            if (0 === i)
                return !0;
            let o = this[r].argsGroupIdx;
            if (o === this[i - 1].argsGroupIdx) {
                for (; r < i; ) {
                    if (!this[r].checkRecord(e, t, n))
                        return !1;
                    r++
                }
                return !0
            }
            {
                let s, a = !0;
                for (; r < i; ) {
                    if (s = this[r],
                    s.argsGroupIdx !== o) {
                        if (a)
                            return !0;
                        o++,
                        a = s.checkRecord(e, t, n)
                    } else
                        a && (a = s.checkRecord(e, t, n));
                    r++
                }
                return a
            }
        },
        destroy: function() {
            if (this.query) {
                let e;
                for (e of this)
                    e.destroy();
                const t = this.query;
                t.queryArgs === this && (t.queryHasVFArg = !1,
                t.queryArgs = void 0),
                this.query = void 0
            }
        },
        doesQueryHaveVF: function(e) {
            let t, n, r = !1;
            for (t of this)
                if (n = t[he.q],
                n === he.d) {
                    if (t.VFName === e && t.query.queryArgs) {
                        r = !0;
                        break
                    }
                } else if (n === he.b && t.query && (r = t.query.doesQueryHaveVF(e)))
                    break;
            return r
        },
        isDifferentThan: function(e) {
            const {length: t} = this;
            if (e.length !== t || e.argsGroupIdx !== this.argsGroupIdx)
                return !0;
            let n, r;
            for (let i = 0; i < t; i++)
                if (n = this[i],
                r = e[i],
                n.isDifferentThan(r))
                    return !0;
            return !1
        },
        merge: function(e) {
            let t = 0
              , n = e.length;
            if (!n)
                return this;
            for (this.length ? e[t].clone(this, "or") : e[t].clone(this),
            t++; t < n; )
                e[t].clone(this),
                t++;
            return this
        },
        removeArg: function(e) {
            const t = _e(this, e);
            if (!t)
                return !1;
            const n = t.argIdx;
            let r, i = n + 1, o = this.length;
            const s = this[i]
              , {argsGroupIdx: a, join: c} = t;
            if ("or" === c && (!s || s.argsGroupIdx !== a) || !c && s && s.argsGroupIdx !== a)
                for (this.decrementArgsGroupIdx(t); i < o; )
                    r = this[i],
                    r.argIdx--,
                    r.argsGroupIdx--,
                    i++;
            else
                for (; i < o; )
                    r = this[i],
                    r.argIdx--,
                    i++;
            return 0 === n && s && (s.join = !1),
            this.splice(n, 1),
            t.removed(),
            !0
        },
        replaceArg: function(e, t) {
            const n = _e(this, e);
            if (!n)
                return !1;
            if (t.join !== n.join || t.argIdx !== n.argIdx || t.argsGroupIdx !== n.argsGroupIdx || t.not !== n.not)
                throw new Error("Cannot replace argument. The replacement argument must have the same join, argIdx, not, and argsGroupIdx properties as the argument it is replacing. It does not.");
            return this[n.argIdx] = t,
            n.replaced(t),
            !0
        },
        updateArgs: function(e, t, n, r) {
            let i;
            for (i of this)
                i.updateArg(e, t, n, r)
        },
        incrementArgsGroupIdx: function() {
            this.argsGroupIdx++
        },
        decrementArgsGroupIdx: function(e) {
            this.argsGroupIdx--
        }
    }
      , it = {
        init: function(e) {
            return new this(e)
        }
    };
    Object(L.a)(nt, rt, it),
    Object(he.z)(nt, he.a, he.q);
    const ot = e => {
        if (Object(he.T)(e))
            return "addVFArgFromQuery";
        if (null !== e)
            switch (typeof e) {
            case "function":
                return "addVFArgFromMethod";
            case "object":
                return "addVFArgFromObject"
            }
        return "addVFArgFromValue"
    }
    ;
    function st(e, t) {
        if (!t)
            return !1;
        let n, r;
        for (let i of t)
            if (r = i[he.q],
            r === he.c) {
                if (!e || i.key === e)
                    return !0
            } else if (r === he.b && (n = i.query) && st(e, n.queryArgs))
                return !0;
        return !1
    }
    const at = {
        fields: !0,
        virtualFields: !0,
        ifNotSelected: !1,
        combineKeyValueArgs: !1,
        markAsSelected: !1,
        keepIncludeArgs: !1
    };
    function ct(e, t) {
        if (!e)
            return t || at;
        if (e.__validated)
            return e;
        t || (t = at);
        for (let n in t)
            "undefined" === typeof e[n] && (e[n] = t[n]);
        return e.__validated = !0,
        e
    }
    const ut = ct({
        fields: !1
    });
    const lt = ct({
        fields: !0,
        virtualFields: !0,
        ifNotSelected: !1,
        combineKeyValueArgs: !0,
        markAsSelected: !0,
        keepIncludeArgs: !1
    });
    const dt = {
        _addQueryArg: function(e, t, n, r, i, o) {
            if (this.parentMethodsMap.addQueryArg)
                return this.parent._addQueryArg(e, t, n, r, i, o),
                this;
            const s = this.getOrInitQueryArgs();
            if (0 === s.length)
                i = void 0;
            else if (!i)
                throw new Error('Use orWhere, andWhere, etc. (or the "not"/"in" variations) when chaining more than 1 where clause together.');
            let a, c, u, l, d = null;
            switch (Object(he.T)(e) ? a = "query" : "object" === (a = typeof e) && Array.isArray(e) && (d = e.length > 1 ? e : null,
            e = e[0],
            a = "string"),
            a) {
            case "string":
                switch (this._getKeyParamType(e)) {
                case "field":
                    if ("undefined" === typeof n)
                        c = "=",
                        u = t;
                    else {
                        if (!Object(je.i)(t))
                            throw new Error("Invalid operator provided for where argument. Got: ".concat(t));
                        c = t,
                        u = n
                    }
                    s.addKeyValueArg(r, i, c, e, u, d);
                    break;
                case "virtualField":
                    if (d) {
                        Object(je.i)(t) ? (c = t,
                        u = n) : (c = "=",
                        u = t);
                        let e = 1;
                        const o = t => {
                            const n = t.getOrInitQueryArgs();
                            switch (t._getKeyParamType(d[e++])) {
                            case "field":
                                e !== d.length ? n.addKeyValueArg(r, !1, c, d[e - 1], u, d.slice(e - 1)) : n.addKeyValueArg(r, !1, c, d[e - 1], u);
                                break;
                            case "virtualField":
                                e !== d.length ? n.addVFArgFromMethod(!1, !1, "=", d[e - 1], o) : n[ot(u)](r, !1, c, d[e - 1], u);
                                break;
                            default:
                                throw new Error('The path: "'.concat(d.join(", "), '" contains invalid entry "').concat(d[e - 1], '" that is not a valid field or virtual field starting from the "').concat(this.modelName, '" model.'))
                            }
                        }
                        ;
                        return s.addVFArgFromMethod(!1, i, "=", d[0], o),
                        this
                    }
                    if ("string" === typeof t) {
                        if (c = t,
                        !Object(je.i)(c))
                            throw new Error("Invalid operator provided for virtual field argument: ".concat(e, ". If the 2nd argument is a string, it must be a valid operator. Got: ").concat(c));
                        u = n,
                        l = o
                    } else
                        "string" === typeof n ? (c = Object(je.i)(n) ? n : "=",
                        u = t) : (c = "=",
                        u = t,
                        l = n);
                    s[ot(u)](r, i, c, e, u, l);
                    break;
                default:
                    throw new Error('The key "'.concat(e, '" is not a recognized field or virtual field on the "').concat(this.modelName, '" model. Unable to add query argument.'))
                }
                break;
            case "function":
                "string" === typeof t ? (c = Object(je.i)(t) ? t : "=",
                l = n) : (c = "=",
                l = t),
                u = e,
                s.addGroupedArgFromMethod(r, i, c, u, l);
                break;
            case "query":
                c = "string" === typeof t && Object(je.i)(t) ? t : "=",
                u = e,
                s.addGroupedArgFromQuery(r, i, c, u);
                break;
            case "object":
                if (u = e,
                "undefined" === typeof t)
                    c = "=";
                else {
                    if (!Object(je.i)(t))
                        throw new Error("Invalid operator provided as 2nd argument for where argument involving an Object. Got: ".concat(t));
                    c = t
                }
                s.addArgsFromObject(r, i, c, u);
                break;
            default:
                throw new Error("Unknown key/value provided to where argument: ".concat(e))
            }
            return this
        },
        getOrInitQueryArgs: function() {
            return this.queryArgs || (this.queryArgs = this.constructor.Args.init(this))
        },
        addArgsFromQuery: function(e) {
            return e.queryArgs && (this.queryArgs ? !e.hasPermArgs && e.queryHasVFArg && (this.hasPermArgs = !1) : this.hasPermArgs = e.hasPermArgs,
            this.getOrInitQueryArgs().merge(e.queryArgs)),
            this
        },
        areQueryArgsDifferent: function(e) {
            let t = e;
            Object(he.T)(e) && (t = e.queryArgs);
            const n = this.queryArgs;
            return n && t ? n.isDifferentThan(t) : !(!n && !t)
        },
        doesQueryHaveVF: function(e) {
            return !!this.queryHasVFArg && this.queryArgs.doesQueryHaveVF(e)
        },
        doesQueryHaveOwnField: function(e, t) {
            return t ? function e(t, n) {
                if (!n)
                    return !1;
                let r, i, o = !1, s = 0, a = 0;
                for (let c of n) {
                    if (c.argsGroupIdx !== s) {
                        if (!o && a < 2)
                            return !1;
                        s = c.argsGroupIdx,
                        o = !1,
                        a = 0
                    }
                    o || (i = c[he.q],
                    i === he.c ? t && c.key !== t || (o = !0) : i === he.b && (r = c.query) && (e(t, r.queryArgs) ? o = !0 : st(t, r.queryArgs) && a++))
                }
                return o || a > 1
            }(e, this.queryArgs) : st(e, this.queryArgs)
        },
        getArgsMap: function(e, t) {
            const n = this.queryArgs;
            if (e = ct(e),
            !n || !e.fields && !this.queryHasVFArg)
                return t || null;
            let r, i, o, {ifNotSelected: s, markAsSelected: a, fields: c, virtualFields: u, combineKeyValueArgs: l} = e;
            for (r of n)
                if (i = r[he.q],
                s && (r.isSelected || i === he.c && this.isFieldSelected(r.key)))
                    a && (r.isSelected = !0);
                else
                    switch (a && (r.isSelected = !0),
                    i) {
                    case he.b:
                        r.query && (t = r.query.getArgsMap(e, t));
                        break;
                    case he.c:
                        c && (!0 === c || c.indexOf(r.key) > -1) && (t || (t = {}),
                        l ? (o = t[he.c]) ? o.push(r) : t[he.c] = [r] : (o = t[r.key]) ? o.push(r) : t[r.key] = [r]);
                        break;
                    case he.d:
                        u && (!0 === u || u.indexOf(r.VFName) > -1) && (t || (t = {}),
                        (o = t[r.VFName]) ? o.push(r) : t[r.VFName] = [r]);
                        break;
                    default:
                        throw new Error("Unrecognized query argument type. It must " + "be one of: ".concat(he.c, ", ").concat(he.b, ", or ").concat(he.d, ", but got: ").concat(i))
                    }
            return t
        },
        removeArg: function(e) {
            return !!this.queryArgs && this.queryArgs.removeArg(e)
        },
        removeArgs: function(e) {
            let t;
            if (Array.isArray(e))
                for (t of e)
                    t.ownQuery.removeArg(t);
            else {
                let n;
                for (let r in e)
                    if (n = e[r])
                        for (t of n)
                            t.ownQuery.removeArg(t)
            }
            return this
        },
        removeAllVFArgs: function() {
            const e = this.getArgsMap(ut);
            if (e) {
                let t, n;
                for (let r in e)
                    if (n = e[r])
                        for (t of n)
                            t.queryArgs.removeArg(t)
            }
            this.queryHasVFArg = !1;
            const t = this.includeVFs;
            if (t) {
                let e;
                for (let n in t)
                    (e = t[n].query) && e.removeAllVFArgs()
            }
            return this
        },
        replaceArg: function(e, t) {
            return !!this.queryArgs && this.queryArgs.replaceArg(e, t)
        },
        selectAllArgs: function(e) {
            const t = this.getArgsMap(lt)
              , n = this.includeVFs;
            if (n)
                for (let r in n)
                    n[r].selectAllArgs(e);
            if (t) {
                const n = t[he.c];
                if (n)
                    if (this.parentMethodsMap.select) {
                        const e = [];
                        for (let t of n)
                            e.push(t.key);
                        this.select(e)
                    } else
                        for (let e of n)
                            this.select(e.key);
                this.includeFromArgs(t, lt, e)
            }
            return this
        },
        updateArgs: function(e, t, n, r) {
            this.queryArgs && this.queryArgs.updateArgs(e, t, n, r);
            const {includeVFs: i} = this;
            if (i)
                for (let o in i)
                    i[o].updateArgs(e, t, n, r);
            return this
        },
        where: function(e, t, n) {
            return this._addQueryArg(e, t, n, !1, !1)
        },
        whereNull: function(e) {
            return this._addQueryArg(e, "isNull", null, !1, !1)
        },
        orWhereNull: function(e) {
            return this._addQueryArg(e, "isNull", null, !1, "or")
        },
        andWhereNull: function(e) {
            return this._addQueryArg(e, "isNull", null, !1, "and")
        },
        orWhere: function(e, t, n) {
            return this._addQueryArg(e, t, n, !1, "or")
        },
        andWhere: function(e, t, n) {
            return this._addQueryArg(e, t, n, !1, "and")
        },
        whereNot: function(e, t, n) {
            return this._addQueryArg(e, t, n, !0, !1)
        },
        whereNotNull: function(e) {
            return this._addQueryArg(e, "isNull", null, !0, !1)
        },
        orWhereNotNull: function(e) {
            return this._addQueryArg(e, "isNull", null, !0, "or")
        },
        andWhereNotNull: function(e) {
            return this._addQueryArg(e, "isNull", null, !0, "and")
        },
        orWhereNot: function(e, t, n) {
            return this._addQueryArg(e, t, n, !0, "or")
        },
        andWhereNot: function(e, t, n) {
            return this._addQueryArg(e, t, n, !0, "and")
        },
        whereIn: function(e, t) {
            return this._addQueryArg(e, "in", t, !1, !1)
        },
        orWhereIn: function(e, t) {
            return this._addQueryArg(e, "in", t, !1, "or")
        },
        andWhereIn: function(e, t) {
            return this._addQueryArg(e, "in", t, !1, "and")
        },
        whereNotIn: function(e, t) {
            return this._addQueryArg(e, "in", t, !0, !1)
        },
        orWhereNotIn: function(e, t) {
            return this._addQueryArg(e, "in", t, !0, "or")
        },
        andWhereNotIn: function(e, t) {
            return this._addQueryArg(e, "in", t, !0, "and")
        },
        whereExists: function(e, t) {
            return this._addQueryArg(e, "exists", t || null, !1, !1)
        },
        orWhereExists: function(e, t) {
            return this._addQueryArg(e, "exists", t || null, !1, "or")
        },
        andWhereExists: function(e, t) {
            return this._addQueryArg(e, "exists", t || null, !1, "and")
        },
        whereNotExists: function(e, t) {
            return this._addQueryArg(e, "exists", t || null, !0, !1)
        },
        orWhereNotExists: function(e, t) {
            return this._addQueryArg(e, "exists", t || null, !0, "or")
        },
        andWhereNotExists: function(e, t) {
            return this._addQueryArg(e, "exists", t || null, !0, "and")
        }
    };
    function ht(e, t) {
        if (!t.directives)
            return e;
        const {directives: n, directiveDefaults: r} = t;
        for (let i in n)
            e.addDirective(i, n[i], r && r[i]);
        return e
    }
    var ft = n(47)
      , pt = n.n(ft);
    function gt(e, t) {
        const {directives: n} = e;
        if (n) {
            if (t) {
                const {directiveVariables: r, directiveDefaults: i} = e;
                for (let e in n)
                    !1 !== t(e, pt.a) && (this.directives || (this.directives = {}),
                    n[e] ? (this.directives[e] = pt()(n[e]),
                    r && r[e] && (this.directiveVariables || (this.directiveVariables = {},
                    this.directiveDefaults = {}),
                    this.directiveVariables[e] = pt()(r[e]),
                    this.directiveDefaults[e] = pt()(i[e]))) : this.directives[e] = n[e])
            } else
                this.directives = pt()(n),
                this.directiveVariables = pt()(e.directiveVariables),
                this.directiveDefaults = pt()(e.directiveDefaults);
            this.directiveVariables && (Object(he.T)(this) ? this.queryHasVariables = !0 : this.query.queryHasVariables = !0)
        }
    }
    var mt = n(99)
      , yt = n.n(mt);
    function vt(e, t) {
        const {directives: n} = e
          , {directives: r} = t;
        if (n && r) {
            let i, o;
            for (let e in n)
                if (({[e]: i} = n),
                ({[e]: o} = r),
                i && o) {
                    if (!yt()(i, o))
                        return !0
                } else if (!o)
                    return !0;
            return !yt()(e.directiveVariables, t.directiveVariables) || !yt()(e.directiveDefaults, t.directiveDefaults)
        }
        return !(!n && !r)
    }
    var bt = n(135)
      , _t = n.n(bt);
    const St = e => Object(he.W)(e) ? e.query.modelName : e.modelName
      , Ot = (e, t, n, r, i, o, s) => {
        try {
            if (e.isList)
                if (Array.isArray(n)) {
                    const {type: i} = e
                      , o = new Array(n.length);
                    for (let e = 0; e < n.length; e++)
                        o[e] = i.parseValue(n[e]);
                    r[t] = o
                } else
                    n = e.type.parseValue(n),
                    r[t] = [n];
            else
                r[t] = e.type.parseValue(n)
        } catch (a) {
            null !== n || e.notNullable ? (i || (i = {}),
            i[t] = 'The default value provided for the directive arg "'.concat(t, '" (directive: "').concat(o, '") on the query for model "').concat(St(s), '"'),
            i[t] += null === n ? " cannot be null." : " is not valid: ".concat(a.message)) : r[t] = null
        }
        return i
    }
    ;
    function Tt(e, t, n) {
        const r = this.definedDirectives[e];
        if (!r)
            throw new Error('The directive "'.concat(e, '" is not a defined directive for the "').concat(St(this), '" model. The defined directives are: ').concat(Object.keys(this.definedDirectives).join(", "), "."));
        const i = r.args;
        if (!i)
            return this.directives ? this.directives[e] || (this.directives[e] = {}) : this.directives = {
                [e]: {}
            },
            null;
        let o, s, a, c, u, l, d, h = void 0;
        if (this.directives)
            if (this.directives[e]) {
                if (!t)
                    return null;
                o = _t()(this.directives[e], t),
                this.directives[e] = o,
                a = this.directiveVariables && this.directiveVariables[e],
                s = this.directiveDefaults && this.directiveDefaults[e]
            } else
                o = {},
                this.directives[e] = o;
        else
            o = {},
            this.directives = {
                [e]: o
            };
        if (!t) {
            t = {};
            for (let e in i)
                t[e] = void 0
        }
        for (let f in t)
            (c = i[f]) ? (({defaultValue: l} = c),
            "undefined" === typeof (u = t[f]) ? "undefined" === typeof o[f] && (null === l && c.notNullable ? (h || (h = {}),
            h[f] = 'The arg "'.concat(f, '" for directive "').concat(e, '" on the query for model "').concat(St(this), '" is required when using the directive.')) : o[f] = l) : (d = this.getValueParam(u)) ? (a || (a = {},
            this.directiveVariables ? this.directiveVariables[e] = a : this.directiveVariables = {
                [e]: a
            }),
            a[f] = d,
            o[f] = d,
            s || (s = {},
            this.directiveDefaults ? this.directiveDefaults[e] = s : this.directiveDefaults = {
                [e]: s
            }),
            n && "undefined" !== typeof (u = n[f]) ? h = Ot(c, f, u, s, h, e, this) : "undefined" === typeof (u = s[f]) && (null === l && c.notNullable ? (h || (h = {}),
            h[f] = 'A param ("'.concat(d, '") was provided for the arg "').concat(f, '" for directive "').concat(e, '" on the query for model "').concat(St(this), '". This arg is required, and a default fallback value was not provided to use if the variable is not provided at execution.')) : s[f] = l)) : h = Ot(c, f, u, o, h, e, this)) : (h || (h = {}),
            h[f] = 'The arg "'.concat(f, '" for directive "').concat(e, '" on the query for model "').concat(St(this), '" is not a valid arg for the directive. The valid arguments are: ').concat(Object.keys(i).join(", "), "."));
        return h
    }
    const It = (e, t) => {
        let n = e.originalQuery || e.query;
        return n && n.pluckPathVFs && (e[t] = n.getPluckResults(e[t], e.variables)),
        e
    }
      , xt = e => e.records ? It(e, "records") : e
      , wt = {
        RECORDS_RESULTS: {
            object: e => e.recordsResults ? (e.formattedResponse = e.recordsResults,
            It(e, "formattedResponse"),
            e.formattedResponse) : (e.formattedResponse = null,
            null),
            array: e => e.recordsResults ? (e.formattedResponse = Object.values(e.recordsResults),
            It(e, "formattedResponse"),
            e.formattedResponse) : (e.formattedResponse = null,
            null),
            single: e => e.recordsResults ? (e.formattedResponse = Object.values(e.recordsResults)[0],
            It(e, "formattedResponse"),
            e.formattedResponse) : (e.formattedResponse = null,
            null)
        },
        RECORDS: {
            object: e => e.records ? (e.formattedResponse = e.records,
            It(e, "formattedResponse"),
            e.formattedResponse) : (e.formattedResponse = null,
            null),
            array: e => e.records ? (e.formattedResponse = Object.values(e.records),
            It(e, "formattedResponse"),
            e.formattedResponse) : (e.formattedResponse = null,
            null),
            single: e => e.records ? (e.formattedResponse = Object.values(e.records)[0],
            It(e, "formattedResponse"),
            e.formattedResponse) : (e.formattedResponse = null,
            null)
        },
        PAYLOAD: {
            object: xt,
            array: xt,
            single: xt
        }
    };
    const Mt = {
        get: function(e, t, n) {
            let r, i, o, s, a, c, u;
            e && (r = e.query,
            i = e.originalQuery,
            a = e.variables,
            c = e.records,
            t || ({responseFormat: t, responseFormatType: n} = e)),
            t ? "RECORDS_RESULTS" === t && (u = r.RecordResult) : (t = "RECORDS",
            n = "object");
            let l, d = null;
            const h = "single" === n;
            if (c) {
                if (r && i && i.isDifferentThan(r, !0)) {
                    o = i.queryArgs;
                    for (let t in c)
                        s = c[t],
                        o && !o.checkRecord(s, a) || (l = u ? u.build(i, a, s, e) : s,
                        d ? d[t] = l : d = {
                            [t]: l
                        })
                } else if (u) {
                    r = i || r || this;
                    const e = {};
                    for (let t in c)
                        e[t] = u.build(r, a, c[t])
                }
            } else {
                r = i || r || this,
                o = r.queryArgs,
                c = this.getState(e);
                for (let t in c)
                    if (s = c[t],
                    (!o || o.checkRecord(s, a)) && (l = u ? u.build(r, a, s, e) : s,
                    d ? d[t] = l : d = {
                        [t]: l
                    },
                    h))
                        break
            }
            return e ? ("RECORDS_RESULTS" === t ? e.recordsResults = d : e.records = d,
            function(e) {
                return e.formattedResponse = wt[e.responseFormat][e.responseFormatType](e),
                e.formattedResponse
            }(e)) : d
        },
        getAll: function(e) {
            return this.get(e, "RECORDS_RESULTS", "object", !1)
        },
        getAllArray: function(e) {
            return this.get(e, "RECORDS_RESULTS", "array")
        },
        getAllRecords: function(e) {
            return this.get(e, "RECORDS", "object")
        },
        getAllRecordsArray: function(e) {
            return this.get(e, "RECORDS", "array")
        },
        getOne: function(e) {
            return this.get(e, "RECORDS_RESULTS", "single")
        },
        getOneRecord: function(e) {
            return this.get(e, "RECORDS", "single")
        }
    }
      , At = e => "string" === typeof e && ":" === e.charAt(0) ? e.substring(1) : void 0;
    class Et {
        constructor(e, t) {
            this.query = e,
            this.alias = void 0,
            this.directives = void 0,
            this.directiveVariables = void 0,
            this.directiveDefaults = void 0,
            t && (this.id = t)
        }
        static init(e) {
            return new this(e)
        }
        isDifferentThan(e) {
            return this.name !== e.name || this.alias !== e.alias || vt(this, e)
        }
        clone(e) {
            const t = new this.constructor(e);
            return t.name = this.name,
            t.alias = this.alias,
            this.id && (t.id = this.id),
            gt.call(t, this),
            t
        }
        merge(e) {
            return this.directives && e.directives && ht(this, e),
            e.alias && (this.alias = e.alias),
            this
        }
        getValueParam(e) {
            const t = At(e);
            return t && (this.query.queryHasVariables = !0),
            t
        }
        field(e, t) {
            return this.name = e,
            this.useAlias(t),
            this
        }
        key(e, t) {
            return this.field(e, t)
        }
        addDirective(e, t, n) {
            const r = Tt.call(this, e, t, n);
            if (r)
                throw new Error(Object.values(r).join("\n"));
            return this
        }
        useAlias(e) {
            return this.alias = e ? this.query.validateAlias(e, 'select field "'.concat(this.name, '"')) : null,
            this
        }
        destroy() {
            this.query = void 0,
            this.directives = void 0,
            this.directiveVariables = void 0,
            this.directiveDefaults = void 0
        }
        get realName() {
            return this.name
        }
        get bestName() {
            return this.alias || this.name
        }
        get definedDirectives() {
            return this.query.definedDirectives
        }
    }
    function Ct(e, t) {
        return e.isVFGroup && (t ? t.unshift(e.parentQueryArg.VFName) : t = [e.parentQueryArg.VFName]),
        t
    }
    function Nt(e, t) {
        if (!e || !t)
            return e;
        let n = t.length;
        for (; n > 0 && e; )
            n--,
            e = e.parent;
        return e
    }
    Object(he.z)(Et, he.w, he.q);
    const Rt = {
        addSelectFromQuery: function(e) {
            const {querySelect: t} = e;
            if (t)
                if (this.querySelect || !this.isRootQuery && !this.isIncludeQuery)
                    this.mergeSelect(t);
                else if (!this.isVFGroup) {
                    const e = {};
                    this.querySelect = e;
                    for (let n in t)
                        e[n] = t[n].clone(this)
                }
            return e.queryCalc && (this.queryCalc ? this.queryCalc.mergeMethods(e.queryCalc) : this.isRootQuery && (this.queryCalc = e.queryCalc.clone(this))),
            this
        },
        isSelectDifferent: function(e) {
            const t = e.querySelect
              , n = this.querySelect;
            if (n && t) {
                let e, r;
                for (let i in n)
                    if (e = n[i],
                    r = t[i],
                    e && r) {
                        if (e.isDifferentThan(r))
                            return !0
                    } else if (!r)
                        return !0
            } else if (n || t)
                return !0;
            return this.queryCalc && e.queryCalc ? this.queryCalc.isDifferentThan(e.queryCalc) : !(!this.queryCalc && !e.queryCalc)
        },
        _selectSingle: function(e, t, n) {
            const r = Object(he.W)(e) ? "Field" : typeof e;
            let i, o;
            switch (r) {
            case "function":
                i = t.init(this),
                e(i),
                ({name: o} = i),
                this.modelHasField(o) && (n ? n[o] = i : this.querySelect = n = {
                    [o]: i
                });
                break;
            case "string":
                this.modelHasField(e) && (n ? (({[e]: i} = n),
                i || (i = t.init(this),
                i.name = e,
                n[e] = i)) : (i = t.init(this),
                i.name = e,
                this.querySelect = n = {
                    [e]: i
                }));
                break;
            case "Field":
                o = e.name,
                n ? (i = n[o],
                i ? i.merge(e) : n[o] = e.clone(this)) : this.querySelect = n = {
                    [o]: e.clone(this)
                };
                break;
            case "object":
                let s;
                for (o in e)
                    s = e[o],
                    this.modelHasField(o) && (n ? ({[o]: i} = n) : this.querySelect = n = {},
                    i ? i.alias = s : (i = t.init(this),
                    i.name = o,
                    i.alias = s,
                    n[o] = i));
                break;
            default:
                throw new Error("Unknown value type. Expected string, object or function. Got: " + r)
            }
            return n
        },
        select: function(e, t) {
            if (this.parentMethodsMap.select)
                return this.parent.select(e, Ct(this, t)),
                this;
            if (!this.queryCalc) {
                if (t)
                    return this.includeAtPath(t, t => t.addSelect(Array.isArray(e) ? e : [e]), void 0, !0),
                    this;
                {
                    let t = this.querySelect;
                    const n = this.constructor.SelectField;
                    if (Array.isArray(e))
                        for (let r of e)
                            t = this._selectSingle(r, n, t);
                    else
                        this._selectSingle(e, n, t);
                    return this
                }
            }
            {
                const {queryCalc: n} = this
                  , r = typeof e;
                switch (r) {
                case "string":
                    return n.addMethod("field", t ? [...t, e] : e, e),
                    this;
                case "object":
                    if (Array.isArray(e))
                        for (let r of e)
                            n.addMethod("field", t ? [...t, r] : r, r);
                    else
                        for (let r in e)
                            n.addMethod("field", t ? [...t, e[r]] : e[r], r);
                    return this;
                case "function":
                    return n.addMethod("field", e),
                    this;
                default:
                    throw new Error("Invalid type provided to select() for `arg` parameter. Expected `string`, `Array`, `Object`, or `function`. Got: ".concat(r))
                }
            }
        },
        selectDistinct: function(e, t) {
            return this.getOrInitQueryCalc().distinct(!0),
            this.select(e, t)
        },
        mergeSelect: function(e, t) {
            if (!e)
                return this;
            if (this.parentMethodsMap.select)
                this.parent.mergeSelect(e, Ct(this, t));
            else if (t)
                this.includeAtPath(t, (e => t => {
                    let n = t.query;
                    n || (n = t.createQueryInstance()),
                    n.mergeSelect(e)
                }
                )(e), void 0, !0);
            else {
                let {querySelect: t} = this;
                const n = this.constructor.SelectField;
                if (t)
                    for (let r in e)
                        this._selectSingle(e[r], n, t);
                else {
                    this.querySelect = t = {};
                    for (let n in e)
                        t[n] = e[n].clone(this)
                }
            }
            return this
        },
        isFieldSelected: function(e, t) {
            if (this.parentMethodsMap.select)
                return this.parent.isFieldSelected(e, Ct(this, t));
            if (t) {
                let n, r, i = this;
                for (let e of t)
                    if (!(n = i.includeVFs) || !(r = n[e]) || !(i = r.query))
                        return !1;
                return !(!i.querySelect || !i.querySelect[e])
            }
            return !(!this.querySelect || !this.querySelect[e])
        },
        removeAllFieldAliases: function(e) {
            if (this.parentMethodsMap.select)
                return this.parent.removeAllFieldAliases(e),
                this;
            const {querySelect: t} = this;
            if (t) {
                const e = this.pagination && this.pagination.getOrderBy();
                if (e) {
                    const n = this.fields;
                    let r;
                    for (const i of e) {
                        if (({path: r} = i),
                        r.length > 1 || n[r[0]])
                            continue;
                        const e = r[0];
                        for (const n in t)
                            if (t[n].alias === e) {
                                r[0] = n;
                                break
                            }
                    }
                }
                for (const n in t)
                    t[n].alias && (t[n].alias = void 0)
            }
            if (e || !this.includeVFs)
                return this;
            const {includeVFs: n} = this;
            let r;
            for (let i in n)
                (r = n[i].query) && r.removeAllFieldAliases();
            return this
        },
        hasFieldAliases: function(e) {
            if (this.parentMethodsMap.select)
                return this.parent.hasFieldAliases(e);
            if (this.querySelect) {
                const {querySelect: e} = this;
                for (let t in e)
                    if (e[t].alias)
                        return !0
            }
            if (e || !this.includeVFs)
                return !1;
            const {includeVFs: t} = this;
            let n;
            for (let r in t)
                if ((n = t[r].query) && n.hasFieldAliases())
                    return !0;
            return !1
        },
        deSelect: function(e, t, n) {
            if (this.parentMethodsMap.select)
                return !0 === n && (n = [!0]),
                this.parent.deSelect(e, t, Ct(this, n)),
                this;
            if (n && !0 !== n) {
                let r = !1;
                "boolean" === typeof n[n.length - 1] && (r = n.pop());
                let i, o = 0, s = this;
                for (; o < n.length; ) {
                    if (!(i = s.includeVFs) || !i[n[o]] || !(s = i[n[o]].query))
                        return this;
                    o++
                }
                return s.deSelect(e, t, r),
                this
            }
            const r = this.querySelect;
            if (!r)
                return this;
            const i = Array.isArray(e) ? e : [e];
            let o;
            if (t)
                for (let s in r)
                    i.indexOf(s) > -1 && (o || (o = {}),
                    o[s] = r[s]);
            else
                for (let s in r)
                    i.indexOf(s) < 0 && (o || (o = {}),
                    o[s] = r[s]);
            if (this.querySelect = o,
            !0 === n && this.includeVFs) {
                const {includeVFs: e} = this;
                let r;
                for (let o in e)
                    (r = e[o].query) && r.deSelect(i, t, n)
            }
            return this
        },
        addFieldDirective: function(e, t, n, r) {
            if (this.parentMethodsMap.select)
                this.parent.addFieldDirective(e, t, n, r);
            else if (this.queryCalc) {
                const {queryCalc: i} = this;
                for (let o of i)
                    if (o.bestName === e)
                        return o.addDirective(t, n, r),
                        this
            } else {
                let {querySelect: i} = this;
                i || (this.querySelect = i = {});
                let {[e]: o} = i;
                if (!o && (this.select(e),
                ({[e]: o} = i),
                !o))
                    return this;
                Tt.call(o, t, n, r)
            }
            return this
        },
        aliasField: function(e, t) {
            if (this.parentMethodsMap.select)
                this.parent.aliasField(e, t);
            else {
                const {querySelect: n} = this;
                if (n) {
                    const {[e]: r} = n;
                    r ? r.alias = t : this.select({
                        [e]: t
                    })
                } else
                    this.select({
                        [e]: t
                    })
            }
            return this
        }
    };
    const Pt = {
        updateArgs: function(e, t, n, r) {
            return this.query && t[this.VFName] && this.query.updateArgs(e && e[this.VFName] || null, t[this.VFName], n, r),
            this
        },
        destroy: function(e) {
            this.query && (this.query.destroy(e),
            this.query = void 0),
            this.ownQuery = void 0
        },
        isDifferentThan: function(e) {
            return !Object(he.L)(e) || this.VFName !== e.VFName || (this.query && e.query ? this.query.isDifferentThan(e.query) : !(!this.query && !e.query))
        }
    }
      , Dt = {
        init: function(e, t) {
            return new this(e,t)
        }
    }
      , Ft = {
        ...He,
        argIdx: {
            get() {
                return this.VFName
            },
            set: void 0
        }
    };
    class kt {
        constructor(e, t) {
            this.ownQuery = e,
            this.VFName = t
        }
    }
    Object(he.z)(kt, he.o, he.q),
    Object(L.a)(kt, Pt, Dt),
    Object.defineProperties(kt.prototype, Ft);
    const jt = {
        fields: !0,
        virtualFields: !0,
        ifNotSelected: !1,
        combineKeyValueArgs: !0,
        markAsSelected: !1,
        keepIncludeArgs: !0
    };
    const Lt = {
        includeAtPath: function(e, t, n, r, i) {
            if (this.parentMethodsMap.include)
                return this.parent.includeAtPath(e, t, n, r, i),
                this;
            "undefined" === typeof i && (i = 0);
            const o = this.getOrInitIncludeVF(e[i], n);
            return o && o.includeAtPath(e, t, n, r, i + 1),
            this
        },
        includeAllAtPath: function(e, t, n, r, i) {
            if (this.parentMethodsMap.include)
                return this.parent.includeAllAtPath(e, t, n, r, i),
                this;
            "undefined" === typeof i && (i = 0);
            const o = this.getOrInitIncludeVF(e[i], n);
            return o && o.includeAllAtPath(e, t, n, r, i + 1),
            this
        },
        includeFromArgs: function(e, t, n, r, i, o) {
            if (this.parentMethodsMap.include)
                return this.parent.includeFromArgs(e, t, n, r, Ct(this, i)),
                this;
            let s;
            if (s = e ? "string" === typeof e ? this.getArgsMap({
                fields: !1,
                virtualFields: [e]
            }) : e : this.getArgsMap({
                fields: !1
            }),
            !s)
                return this;
            if (t = ct(t, jt),
            n && !r && (r = n),
            i)
                this.includeAllAtPath(i, ( (e, t, n, r) => i => i.includeFromArgs(e, t, n, r))(s, t, n, r), Nt(n, i));
            else {
                let e, i, a;
                for (let c in s)
                    c === he.c || !(i = s[c]) || o && !(a = o[c]) || (e = this.getOrInitIncludeVF(c, n)) && e.addFromVFArgs(i, t, n, r, a)
            }
            return this
        },
        includeFromQuery: function(e, t, n, r) {
            if (this.parentMethodsMap.include)
                this.parent.includeFromQuery(e, t, n, Ct(this, r));
            else if (r)
                n = Nt(n, r),
                r.push(e),
                this.includeAtPath(r, (e, n) => e.addFromQuery(t, n), n, !0);
            else {
                this.getOrInitIncludeVF(e, n).addFromQuery(t, n)
            }
            return this
        },
        includeFromInclude: function(e, t, n, r) {
            return this.parentMethodsMap.include ? this.parent.includeFromInclude(e, t, n, Ct(this, r)) : r ? (n = Nt(n, r),
            r.push(e),
            this.includeAtPath(r, (e => (t, n) => t.merge(e, n))(t), n, !0)) : this.getOrInitIncludeVF(e, n).merge(t, n),
            this
        },
        includeFields: function(e, t, n, r) {
            return this.parentMethodsMap.include ? (this.parent.includeFields(e, t, n, Ct(this, r)),
            this) : r ? (n = Nt(n, r),
            r.push(e),
            this.includeAtPath(r, (e => (t, n) => {
                t.addSelect(e, n)
            }
            )(t), n, !0),
            this) : (this.getOrInitIncludeVF(e, n).addSelect(t, n),
            n ? n.query : this)
        },
        include: function(e, t, n, r, i) {
            if (this.parentMethodsMap.include)
                this.parent.include(e, t, n, r, Ct(this, i));
            else if (i) {
                if (n) {
                    const e = t;
                    t = t => e.call(n, t)
                }
                r = Nt(r, i),
                i.push(e),
                this.includeAtPath(i, t, r)
            } else {
                const i = this.getOrInitIncludeVF(e, r);
                if (!i)
                    throw new Error('The Model "'.concat(this.modelName, '" does not define the VirtualField "').concat(e, '". Only defined VirtualFields can be included in a Query.'));
                t ? i.addFromFn(t, n, r) : i.query || i.createQueryInstance(r)
            }
            return this
        },
        removeInclude: function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (this.parentMethodsMap.include)
                return this.parent.removeInclude(e),
                this;
            const n = this.includeVFs;
            if (n && n[e]) {
                const {[e]: r, ...i} = n;
                t || r.destroy(),
                this.includeVFs = i
            }
            return this
        },
        mergeIncludes: function(e) {
            if (e) {
                if (this.parentMethodsMap.include)
                    return this.parent.mergeIncludes(e),
                    this;
                let t;
                for (let n in e)
                    t = e[n],
                    this.getOrInitIncludeVF(t.VFName).merge(t)
            }
            return this
        },
        areIncludesDifferent: function(e, t) {
            const n = e.includeVFs
              , r = this.includeVFs;
            if (n && r) {
                let e;
                for (let i in r)
                    if (e = n[i],
                    !e || r[i].isDifferentThan(e, t))
                        return !0;
                return !1
            }
            return !(!n && !r)
        },
        addIncludesFromQuery: function(e) {
            const t = e.includeVFs;
            if (t)
                if (this.includeVFs || this.isGroupedQuery)
                    this.mergeIncludes(t);
                else if (!this.isVFGroup) {
                    const e = {};
                    this.includeVFs = e;
                    for (let n in t)
                        t[n].clone(this, e)
                }
            return this
        }
    }
      , Vt = /^[A-Za-z]\w*$/;
    function Ut(e, t, n) {
        if (Vt.test(e))
            return;
        let r = "The ".concat(n ? "alias" : "param", ' "').concat(e, '" ');
        throw t && (r += "associated with ".concat(t, " ")),
        r += "is invalid. ".concat(n ? "Aliases" : "Params", " must start with an upper or lowercase letter, followed by only letters, numbers, or underscores."),
        new Error(r)
    }
    class qt {
        constructor(e) {
            this.directives = void 0,
            this.directiveVariables = void 0,
            this.directiveDefaults = void 0,
            this.instanceType = e,
            this.includeVFs = void 0,
            this.queryArgs = void 0,
            this.querySelect = void 0,
            this.queryCalc = void 0,
            this.queryHaving = void 0,
            this._noDestroy = !1
        }
        static initNewInstance(e, t, n, r) {
            const i = new this(e);
            switch (e) {
            case "MAIN_QUERY":
                i.model = t.model,
                i.queryName = t.queryName,
                i.persistentId = t.persistentId,
                i.parent = n,
                i.parentQueryArgIdx = r;
                break;
            case "GROUPED_QUERY":
                i.setAsGroupedQuery(n.queryArgs[r]);
                break;
            case "INCLUDE_VF_QUERY":
                i.model = t.model,
                i.queryName = t.queryName,
                i.setAsIncludeVF(n.includeVFs[r]);
                break;
            case "VF_QUERY":
                i.queryName = t.queryName,
                i.model = t.model,
                i.setAsVFQuery(n.queryArgs[r]);
                break;
            default:
                throw new Error("Unrecognized instanceType. Got: " + e)
            }
            return i
        }
        createNewInstance(e, t, n) {
            return e || (e = this.instanceType,
            t = this.parent,
            n = this.parentQueryArgIdx),
            this.constructor.initNewInstance(e, this, t, n)
        }
        clone(e, t, n) {
            let {instanceType: r} = this;
            if (e)
                if ("undefined" === typeof t) {
                    if ("undefined" === typeof (t = this.parentQueryArgIdx))
                        throw new Error("Missing required parentQueryArgIdx.")
                } else
                    n && (r = n);
            else
                r = "MAIN_QUERY";
            const i = this.createNewInstance(r, e, t);
            return i.buildFromQuery(this),
            i
        }
        maybeConvertToGroupedQuery() {
            return this.queryArgs && this.queryArgs.argsGroupIdx > 0 ? this.convertToGroupedQuery() : this
        }
        convertToGroupedQuery(e, t) {
            if (!e)
                return this.queryArgs && this.queryArgs.convertToGroupedQuery(),
                this;
            "undefined" === typeof t && (t = this.parentQueryArgIdx);
            const n = this.createNewInstance(this.instanceType, e, t).where(this).addRecursiveFromQuery(this);
            return this.destroy(),
            n
        }
        addDirectivesFromQuery(e) {
            return this.directives ? ht(this, e) : gt.call(this, e),
            this
        }
        buildFromQuery(e, t) {
            if (this.addSelectFromQuery(e),
            t) {
                t.query = this,
                t.originalQuery = e;
                const n = e.includeVFs;
                if (n) {
                    const e = {};
                    this.includeVFs = e;
                    for (let r in n)
                        n[r].clone(this, e, t)
                }
            } else
                this.addIncludesFromQuery(e),
                this.queryAlias = e.queryAlias;
            return this.addPaginationFromQuery(e, t),
            this.addArgsFromQuery(e),
            this.addHavingFromQuery(e),
            this.addDirectivesFromQuery(e),
            this.addRecursiveFromQuery(e),
            this
        }
        buildFromQueryExcept(e, t) {
            switch (t) {
            case "select":
            case "querySelect":
                t = "select";
                break;
            case "queryArgs":
                t = "args";
                break;
            case "includeVFs":
                t = "includes";
                break;
            case "queryHaving":
                t = "having";
                break;
            case "recursion":
            case "recursive":
                t = "recursive"
            }
            return "select" !== t && this.addSelectFromQuery(e),
            "includes" !== t && this.addIncludesFromQuery(e),
            "pagination" !== t && this.addPaginationFromQuery(e),
            "directives" !== t && this.addDirectivesFromQuery(e),
            "args" !== t && this.addArgsFromQuery(e),
            "having" !== t && this.addHavingFromQuery(e),
            "recursive" !== t && this.addRecursiveFromQuery(e),
            this
        }
        buildAsArgsQuery(e, t) {
            const n = this.addSelectFromQuery(e).addPaginationFromQuery(e, t).addDirectivesFromQuery(e);
            if (!t)
                return console.warn("NO PAYLOAD."),
                n.addArgsFromQuery(e);
            const r = n.model.schema.permRecRead;
            if (r && "function" === typeof r.buildQuery && !r.buildQuery(t.userRole, n))
                return console.log("GOT NULL."),
                null;
            console.log("read = ", r),
            r && (n.andWhereNot("_perm_rec_read_", "never"),
            t.userRole || n.andWhereNot("_perm_rec_read_", "any_user"));
            const i = e.queryArgs;
            return i && i.length ? n.queryArgs ? n.andWhere(t => t.addArgsFromQuery(e)) : n.addArgsFromQuery(e) : n
        }
        mergeQuery(e, t) {
            const {instanceType: n, parentQueryArg: r} = this
              , i = r ? this.createNewInstance(n, r.ownQuery, r.argIdx) : this.createNewInstance(n);
            return "and" === t ? i.where(this).andWhere(e) : i.where(this).orWhere(e),
            i.addRecursiveFromQuery(e),
            this.destroy(),
            i
        }
        setAsVFQuery(e) {
            return this.instanceType = "VF_QUERY",
            this.parent = e.ownQuery,
            this.parentQueryArgIdx = e.argIdx,
            e.query = this,
            this.parent.queryHasVFArg = !0,
            this
        }
        setAsIncludeVF(e) {
            return this.instanceType = "INCLUDE_VF_QUERY",
            this.parent = e.ownQuery,
            this.parentQueryArgIdx = e.argIdx,
            e.query = this,
            this
        }
        setAsGroupedQuery(e) {
            return this.instanceType = "GROUPED_QUERY",
            this.parent = e.ownQuery,
            this.parentQueryArgIdx = e.argIdx,
            e.query = this,
            this
        }
        createGroupedInstance(e) {
            return this.createNewInstance("GROUPED_QUERY", this, e.argIdx)
        }
        getChildQueryArg(e, t) {
            if (t && e.parent !== this)
                return;
            const n = e.instanceType;
            if ("INCLUDE_VF_QUERY" === n)
                return this.includeVFs ? this.includeVFs[e.parentQueryArgIdx] : void 0;
            if ("GROUPED_QUERY" === n || "VF_QUERY" === n)
                return this.queryArgs ? this.queryArgs[e.parentQueryArgIdx] : void 0;
            throw new Error("A query that is a valid child type must be provided to the getChildQueryArg() method in order to obtain the argument on the parent that is managing the child query. Got: " + n)
        }
        getClosestIncludeOrMainQuery() {
            const e = this.instanceType;
            return "INCLUDE_VF_QUERY" === e || "MAIN_QUERY" === e ? this : this.parent.getClosestIncludeOrMainQuery()
        }
        getQueryPath(e) {
            let t = this.parentQueryArg;
            for (; t; )
                t.VFName && (e ? e.unshift(t.VFName) : e = [t.VFName]),
                t = t.ownQuery.parentQueryArg;
            return e
        }
        getRootQuery() {
            let e = this
              , t = e.parent;
            for (; t; )
                e = t,
                t = e.parent;
            return e
        }
        getValueParam(e) {
            const t = At(e);
            return t && (this.queryHasVariables = !0),
            t
        }
        modelHasField(e) {
            return !0
        }
        areDirectivesDifferent(e) {
            return vt(this, e)
        }
        isDifferentThan(e, t, n) {
            return this.areQueryArgsDifferent(e) || this.areIncludesDifferent(e) || this.areDirectivesDifferent(e) || this.isRecursiveDifferentThan(e) || !t && (this.isSelectDifferent(e) || this.isQueryHavingDifferent(e) || this.isQueryPaginationDifferent(e, n))
        }
        isQueryHavingDifferent(e) {
            return this.queryHaving && e.queryHaving ? this.queryHaving.isDifferentThan(e.queryHaving) : !(!this.queryHaving && !e.queryHaving)
        }
        isQueryPaginationDifferent(e, t) {
            return this.pagination && e.pagination ? this.pagination.isDifferentThan(e.pagination, t) : !(!this.pagination && !e.pagination)
        }
        addDirective(e, t, n) {
            if (this.parentMethodsMap.addDirective)
                this.parent.addDirective(e, t, n);
            else {
                const r = Tt.call(this, e, t, n);
                if (r)
                    throw new Error(Object.values(r).join("\n"))
            }
            return this
        }
        useAlias(e) {
            return this.parentMethodsMap.useAlias ? this.parent.useAlias(e) : this.queryAlias = e ? this.validateAlias(e) : void 0,
            this
        }
        validateAlias(e, t) {
            return function(e, t) {
                Ut(e, t, !0)
            }(e, t),
            e
        }
        validateParam(e, t) {
            return function(e, t) {
                Ut(e, t, !1)
            }(e, t),
            e
        }
        checkRecord(e, t, n, r, i) {
            return !this.queryArgs || this.queryArgs.checkRecord(e, t, n, r, i)
        }
        filterRecords(e, t, n, r, i) {
            if (e) {
                if (this.queryArgs) {
                    let o = null;
                    const s = this.queryArgs;
                    for (const a in e)
                        s.checkRecord(e[a], t, n, r, i) && (o || (o = {}),
                        o[a] = e[a]);
                    return o
                }
                return {
                    ...e
                }
            }
            return null
        }
        noDestroy(e) {
            return this._noDestroy = "boolean" !== typeof e || e,
            this
        }
        destroy(e) {
            if (this.closed)
                return;
            this.closed = !0,
            this.closeRecursiveProps();
            const t = this.queryArgs
              , n = this.includeVFs
              , r = this.querySelect;
            if (t && (this.queryArgs = void 0,
            t.destroy()),
            n)
                for (let i in n)
                    n[i].destroy();
            if (r)
                for (let i in r)
                    r[i].destroy();
            this.queryCalc && (this.queryCalc.destroy(),
            this.queryCalc = void 0),
            this.directives = void 0,
            this.directiveVariables = void 0,
            this.directiveDefaults = void 0,
            this.includeVFs = void 0,
            this.querySelect = void 0,
            this.model = void 0,
            this.parentPropsMap = void 0,
            this.parentMethodsMap = void 0,
            this.parent = void 0
        }
        get RecordResult() {
            return this.constructor.RecordResult
        }
        get parent() {
            return this._parent
        }
        set parent(e) {
            this._parent = e
        }
        get queryHasVariables() {
            return this._queryHasVariables
        }
        set queryHasVariables(e) {
            this._queryHasVariables = e,
            e && this.parent && (this.parent.queryHasVariables = !0)
        }
        get queryHasVFArg() {
            return this._queryHasVFArg
        }
        set queryHasVFArg(e) {
            this._queryHasVFArg = e,
            e && this.parentPropsMap.queryHasVFArg && (this.parent.queryHasVFArg = !0)
        }
        get parentQueryArg() {
            const {parent: e} = this;
            if (e) {
                const t = this.instanceType;
                if ("GROUPED_QUERY" === t || "VF_QUERY" === t)
                    return e.queryArgs[this.parentQueryArgIdx];
                if ("INCLUDE_VF_QUERY" === t)
                    return e.includeVFs[this.parentQueryArgIdx];
                throw new Error("Unrecognized instanceType. Cannot retrieve the parentQueryArg.")
            }
        }
        get instanceType() {
            return this._instanceType
        }
        set instanceType(e) {
            this._instanceType = e,
            this.parentPropsMap = this.constructor.parentPropsConfig[e],
            this.parentMethodsMap = this.constructor.parentMethodsConfig[e]
        }
        get isRootQuery() {
            return "MAIN_QUERY" === this.instanceType
        }
        get isGroupedQuery() {
            return "GROUPED_QUERY" === this.instanceType
        }
        get isVFGroup() {
            return "VF_QUERY" === this.instanceType
        }
        get isIncludeQuery() {
            return "INCLUDE_VF_QUERY" === this.instanceType
        }
        get queryName() {
            return this.parentPropsMap.queryName ? this.parent.queryName : this._queryName
        }
        set queryName(e) {
            this.parentPropsMap.queryName ? this.parent.queryName || (this.parent.queryName = e) : this._queryName = e
        }
        get hasQueryArgs() {
            return !(!this.queryArgs || !this.queryArgs.length)
        }
    }
    function Qt(e) {
        return e || (e = qt),
        function(e) {
            for (let t in Lt)
                e.prototype[t] = Lt[t];
            return e
        }(function(e) {
            for (let t in Rt)
                e.prototype[t] = Rt[t];
            return e
        }(function(e) {
            for (let t in Mt)
                e.prototype[t] = Mt[t];
            return e
        }(function(e) {
            class t extends e {
            }
            for (let n in dt)
                t.prototype[n] = dt[n];
            return t
        }(e))))
    }
    qt.Args = nt,
    qt.SelectField = Et,
    qt.IncludeVF = kt,
    qt.RecordResult = void 0,
    qt.parentPropsConfig = void 0,
    qt.parentMethodsConfig = void 0,
    Object(he.z)(qt, he.t, he.q);
    const Bt = "param"
      , Gt = "query"
      , zt = "values"
      , Ht = "default"
      , Kt = "param"
      , Yt = "query"
      , Wt = "function";
    const $t = {
        _getKeyParamType: function(e) {
            return this.fields[e] ? "field" : this.virtualFields[e] ? "virtualField" : void 0
        },
        getModelsInArgs: function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
              , t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            const r = this.queryArgs;
            let i;
            if (r) {
                n || (n = {});
                const e = this.modelName;
                let o, s;
                for (o of r)
                    s = o[he.q],
                    s === he.c ? n[e] || (n[e] = t ? this.model.getMainInstance() : this.model) : s === he.b ? n = o.query.getModelsInArgs(!1, t, n) : s === he.d && (i = o.query,
                    n[i.modelName] = t ? i.model.getMainInstance() : i.model,
                    n = i.getModelsInArgs(!1, t, n))
            }
            if (e) {
                const r = this.includeVFs;
                if (r)
                    for (let o in r)
                        (i = r[o].query) && (n || (n = {}),
                        n[i.modelName] = t ? i.model.getMainInstance() : i.model,
                        i.getModelsInArgs(e, t, n))
            }
            return n
        },
        getVFsInArgs: function(e) {
            if (!this.queryHasVFArg)
                return e || null;
            const t = this.queryArgs;
            if (!t || t.length < 1)
                return e || null;
            let n, r;
            for (n of (e || (e = {}),
            t))
                (r = n.query) && (n[he.q] === he.d ? e[n.VFName] = n.VF : r.getVFsInArgs(e));
            return e
        },
        mapPkChanges: function(e, t, n) {
            const {queryArgs: r} = this;
            if (r) {
                let i;
                for (i of r)
                    i.mapPkChanges(e, t, n)
            }
            if (!this.recursiveVF)
                return this;
            let i;
            switch (this.recursiveStartValueType) {
            case Bt:
                if (!n || !(i = n[this.recursiveStartValue]))
                    return this;
                break;
            case zt:
                i = this.recursiveStartValue;
                break;
            default:
                return this
            }
            for (let o = 0; o < i.length; o++)
                e[i[o]] && (i[o] = e[i[o]]);
            return this
        },
        resolve: function(e, t) {
            const n = this.queryArgs;
            if (n) {
                e || (e = this.preparePayload());
                let r = n.results;
                return r || (r = n.buildConstraints(),
                r) ? (t ? r.resolveKnownRecords(e, t) : r.resolve(e),
                e) : (e.isDeterministic = !1,
                e.maybeDeterministic = !1,
                e)
            }
            return e ? (e.isDeterministic = !1,
            e.maybeDeterministic = !1,
            e) : null
        }
    };
    var Xt = n(120)
      , Jt = n(54);
    const Zt = Object(P.a)(e => e)
      , en = Object(Jt.c)()
      , tn = Object(Jt.e)()
      , nn = Object(Jt.e)(!0);
    function rn(e, t, n, r) {
        if (!t) {
            let n = "Unable to observe the ".concat(e, " op because an action was not provided.");
            throw !1 === t && (n += " A value of false was provided, which most likely means there wasn't any logic that matched for the action when the store dispatched the action. Therefore the store returned false. Ensure that an action is returned before attempting to observe an op on the action, or be certain there is logic that will match for the action."),
            new Error(n)
        }
        return new S.a(i => {
            i.next(( (e, t, n, r) => {
                const i = t.meta;
                return "boolean" !== typeof n && (n = !0),
                "boolean" !== typeof r && (r = !0),
                i.closed ? Object(V.a)(t) : i.willEmitOp(e) ? Object(Jt.g)(e) ? !n || r || i.trxOp !== e || i.isPendingTrxOp ? i.pipeTrxOps(an(e, n, r)) : Object(V.a)(t) : !n || r || i.op !== e || i.isPendingOp ? i.pipeOps(an(e, n, r)) : Object(V.a)(t) : Object(Jt.g)(e, !0) || Object(Jt.f)(e, !0) ? Object(V.a)(t) : Xt.a
            }
            )(e, t, n, r)),
            i.complete()
        }
        ).pipe(Zt)
    }
    function on(e, t) {
        return rn(e, t, !1, !0)
    }
    function sn(e, t) {
        return rn(e, t, !0, !1)
    }
    function an(e) {
        let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
          , n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        const r = Object(Jt.g)(e, !0);
        if (!r && !Object(Jt.f)(e, !0))
            throw new Error("Expected op to be an ACTION_OP or TRX_OP (and not an error op), but got: " + e);
        return i => i.lift(new cn(e,r,t,n))
    }
    class cn {
        constructor(e, t, n, r) {
            this.op = e,
            this.isTrxOp = t,
            this.onBegin = n,
            this.andComplete = r
        }
        call(e, t) {
            return t.subscribe(new un(e,this.op,this.isTrxOp,this.onBegin,this.andComplete))
        }
    }
    class un extends O.a {
        constructor(e, t, n, r, i) {
            super(e),
            this.op = t,
            this.isTrxOp = n,
            this.onBegin = r,
            this.andComplete = i,
            n || (this.opsIdxMap = en,
            this.opIdx = en[t])
        }
        _next(e) {
            let t, n;
            if (this.isTrxOp) {
                this.opsIdxMap || (this.opsIdxMap = e.meta.isCommitOnlyTrx ? nn : tn,
                this.opIdx = this.opsIdxMap[this.op]);
                const r = e.meta.trxOp;
                t = r === h.m ? this.opIdx : this.opsIdxMap[r],
                n = e.meta.isPendingTrxOp
            } else
                t = e.meta.op === f.a ? this.opIdx : this.opsIdxMap[e.meta.op],
                n = e.meta.isPendingOp;
            t > this.opIdx ? (this.destination.next(e),
            this.complete()) : t === this.opIdx && (n ? this.onBegin && (this.destination.next(e),
            this.andComplete || this.complete()) : (this.destination.next(e),
            this.complete()))
        }
    }
    class ln extends O.a {
        constructor(e) {
            super(),
            this.__mutation = e
        }
        _next(e) {
            this.__mutation.isComplete || this.__mutation.commitOnly(!1)
        }
        _error(e) {
            this.unsubscribe()
        }
        unsubscribe() {
            super.unsubscribe(),
            this.__mutation = void 0
        }
    }
    const dn = (e, t) => e.isCommitOnly ? e : (on(f.e, t).subscribe(new ln(e)),
    e.commitOnly(!0));
    function hn(e) {
        for (; e.parent; )
            e = e.parent;
        return e
    }
    function fn(e) {
        const t = (e = hn(e)).bestMeta;
        if (t)
            return t.closed ? t.mainDispatchId : t.dispatchId;
        {
            if (e.mutation)
                return e.mutation.mainDispatchId;
            if (e.dispatchId)
                return e.dispatchId;
            let t = e.model;
            return t && !t.__closed || e.query && (t = e.query.model) && !t.__closed ? t.__dispatchId : void 0
        }
    }
    function pn(e, t) {
        let n = e[t];
        if ("undefined" !== typeof n)
            return n;
        let {parent: r} = e;
        for (; r && (n = r[t],
        "undefined" === typeof n); )
            ({parent: r} = r);
        return n
    }
    const gn = (e, t, n) => {
        n.query = e.query,
        n.parent = t,
        n.VF = e.VF,
        n.isServer = t.isServer,
        n.variables = t.variables,
        n.graphqlContext = t.graphqlContext
    }
    ;
    function mn(e, t, n) {
        const r = t.children;
        let i;
        return r ? (i = r[e.VFName],
        i ? i.query && i.VF || gn(e, t, i) : n || (i = {},
        gn(e, t, i),
        r[e.VFName] = i)) : n || (i = {},
        gn(e, t, i),
        t.children = {
            [e.VFName]: i
        }),
        i
    }
    function yn(e, t, n) {
        e[t] = n;
        const r = e.children;
        if (r)
            for (let i in r)
                yn(r[i], t, n);
        return e
    }
    function vn(e, t, n) {
        e.responseFormat = t,
        e.responseFormatType = n;
        const r = e.children;
        if (r)
            for (let i in r)
                vn(r[i], t, n);
        return e
    }
    function bn(e) {
        return e.isDeterministic = !0,
        e.maybeDeterministic = !0,
        e.filterResults = !1,
        e.records = null,
        e.isLocalOnly = !0,
        e
    }
    function _n(e, t, n) {
        const {records: r} = t;
        if (!r)
            return null;
        let {recordsResults: i} = t;
        const o = e.queryArgs;
        if (o && Sn(e, t)) {
            const {variables: e} = t;
            for (let s in r)
                o.checkRecord(r[s], e) && (i = On(s, r[s], t, n, i))
        } else if (n)
            for (let s in r)
                i = On(s, r[s], t, n, i);
        else
            i = r;
        return i
    }
    const Sn = (e, t) => {
        if ("boolean" === typeof t.filterResults)
            return t.filterResults;
        let n;
        if (t.linkedPayload)
            n = t.linkedPayload.query;
        else {
            if (!t.originalQuery)
                return !1;
            n = t.query
        }
        if (e.isIncludeQuery && n.isIncludeQuery) {
            const t = e.parentQueryArg.getGroupedQuery()
              , r = n.parentQueryArg.getGroupedQuery();
            return !(!t && !r || t && r && !t.areQueryArgsDifferent(r)) || e.areDirectivesDifferent(n)
        }
        return e.areQueryArgsDifferent(n) || e.areDirectivesDifferent(n)
    }
    ;
    function On(e, t, n, r, i) {
        return n.permRecField && !t[n.permRecField](n.userRole, n, t) || (r ? !i && (i = {}) || !i[e] ? i[e] = r.buildParsedSelect(t, n.parsedSelect, n.forSubscription) : i[e].__updateParsedSelect(n.parsedSelect, n.forSubscription) : i ? i[e] = t : i = {
            [e]: t
        }),
        i
    }
    const Tn = {
        addToOptimisticMutationResult: function(e, t, n) {
            const r = this.query;
            if (!r.queryHasVFArg)
                return e;
            const i = r.queryArgs;
            if (!i.checkRecord(t, n))
                return e;
            for (let o of i)
                e = o.addToOptimisticMutationResult(e, t, n)
        },
        convertM2MArgsToThroughArgs: function(e) {
            this.query && this.query.convertM2MArgsToThroughArgs(e)
        },
        convertPathArgsToFullPathArgs: function(e) {
            this.query && this.query.convertPathArgsToFullPathArgs(e)
        },
        extractVariables: function(e, t, n) {
            const r = this.query;
            return r && r.queryHasVariables ? r.extractVariables(e, t, n) : n
        },
        getWithIndex: function(e, t, n, r) {
            const {startIdx: i, stopIdx: o} = this;
            if (o - 1 === 1)
                return this.query.queryArgs.get(t, n, r);
            const s = this.query.queryArgs.get(t);
            if (!s)
                return r;
            const {argIdx: a} = this
              , c = t.variables
              , u = this.queryArgs;
            let l, d;
            for (let h in s) {
                for (l = s[h],
                d = i; d < o; ) {
                    if (d !== a && !u[d].checkRecord(l, c)) {
                        l = null;
                        break
                    }
                    d++
                }
                l && (r = On(l.__ID, l, t, n, r))
            }
            return r
        },
        mapPkChanges: function(e, t, n) {
            this.query && this.query.mapPkChanges(e, t, n)
        },
        removed: function() {
            "number" === typeof this.startIdx && this.queryArgs.invalidateIndexedArgs(this),
            this.destroy()
        },
        replaced: function(e) {
            "number" === typeof this.startIdx && this.queryArgs.invalidateIndexedArgs(this, e),
            this.destroy()
        },
        setArgsStartStopIdx: function(e, t) {
            this.startIdx = e,
            this.stopIdx = t
        }
    };
    var In = n(3)
      , xn = n(1004);
    const wn = Ge.init
      , Mn = Ge.initAsClone
      , An = Ge.destroy
      , En = {
        "=": !0,
        in: !0,
        isNull: !0
    };
    const Cn = (e, t, n, r, i) => {
        const o = e.__ID;
        if (!n.forSubscription && i && i[o])
            return On(o, e, n, r, i);
        const {stopIdx: s, argIdx: a} = t
          , c = t.queryArgs
          , u = n.variables;
        let l = t.startIdx;
        for (; l < s; ) {
            if (l !== a && !c[l].checkRecord(e, u))
                return i;
            l++
        }
        return On(o, e, n, r, i)
    }
      , Nn = (e, t, n, r) => {
        const {stopIdx: i, queryArgs: o} = e
          , {forSubscription: s, variables: a} = t;
        let c, u;
        return (l, d) => {
            if (u = l.__ID,
            s || !r || !r[u])
                for (c = e.startIdx; c < i; ) {
                    if (c !== d && !o[c].checkRecord(l, a))
                        return r;
                    c++
                }
            return r = On(u, l, t, n, r)
        }
    }
    ;
    const Rn = {
        addToOptimisticMutationResult: function(e, t, n) {
            return e
        },
        convertM2MArgsToThroughArgs: function() {},
        convertPathArgsToFullPathArgs: function() {},
        destroy: function() {
            this.secondaryIndexedArg && (this.secondaryIndexedArg = void 0),
            An.call(this),
            this.fieldType = void 0
        },
        extractVariables: function(e, t, n) {
            const r = this.valueParam;
            if (!r)
                return n;
            n || (n = {});
            const i = this.key;
            let o, s = n[r];
            if (t) {
                if ("in" !== this.op)
                    throw new Error("An Array of records was provided to extract the variables for the Query, but the KeyValueArg for field " + i + " only expects a single value. Unable to extract variables.");
                for (let t of e)
                    "undefined" !== typeof (o = t[i]) && (s ? s.indexOf(o) < 0 && s.push(o) : n[r] = s = [o])
            } else
                "undefined" !== typeof (o = e[i]) && ("in" === this.op ? (s = n[r]) ? s.indexOf(o) < 0 && s.push(o) : n[r] = [o] : n[r] = o);
            return n
        },
        getRealValue: function(e, t) {
            const n = this.valueParam ? this.isRegex ? "like" === this.op ? Object(je.c)(e[this.valueParam]) : Object(je.e)(e[this.valueParam]) : this.parseValue(e[this.valueParam]) : this.value;
            if ("in" === this.op) {
                t || (t = []);
                for (let e of n)
                    t.indexOf(e) < 0 && t.push(e);
                return t
            }
            return t ? (t.indexOf(n) < 0 && t.push(n),
            t) : n
        },
        getWithIndex: function(e, t, n, r) {
            let i, o = this.getRealValue(t.variables);
            if (this.indexName === In.f) {
                let s;
                if (i = e.getState(),
                "in" === this.op) {
                    const e = Nn(this, t, n, r)
                      , a = this.argIdx;
                    for (let t of o)
                        (s = i[t]) && (r = e(s, a))
                } else
                    (s = i[o]) && (r = Cn(s, this, t, n, r));
                return r
            }
            const s = e.getIndex(this.indexName)
              , a = s.storeConfig;
            if (!a.includeNull && (null === o || "in" === this.op && o.indexOf(null) > -1)) {
                const o = -1;
                i = e.getState();
                const s = Nn(this, t, n, r);
                for (let e in i)
                    r = s(i[e], o);
                return r
            }
            i = s.getState();
            const c = this.argIdx;
            if (null !== o && a.unique)
                if ("in" === this.op) {
                    let e;
                    for (let s of o)
                        if (i[s])
                            if (e || (e = Nn(this, t, n, r)),
                            null === s) {
                                const t = i[s].getState();
                                for (let n in t)
                                    r = e(t[n], c)
                            } else
                                r = e(i[s], c)
                } else
                    i[o] && (r = Cn(i[o], this, t, n, r));
            else if ("in" === this.op) {
                let e, s, a;
                for (let u of o)
                    if (s = i[u])
                        for (a in e || (e = Nn(this, t, n, r)),
                        s = s.getState(),
                        s)
                            r = e(s[a], c)
            } else if (i[o]) {
                const e = Nn(this, t, n, r)
                  , s = i[o].getState();
                for (let t in s)
                    r = e(s[t], c)
            }
            return r
        },
        getComparisonValue: function(e, t) {
            return null === e || this.path || this.isRegex ? e : t || "in" !== this.op ? this.fieldType.getComparisonValue(e) : this.fieldType.getComparisonValueMany(e)
        },
        init: function() {
            return this.fieldType = this.queryArgs.query.fields[this.key].type,
            this.isGeoPoint = this.fieldType.baseName === xn.m,
            wn.call(this),
            this.initConstraint()
        },
        initAsClone: function(e) {
            return this.fieldType = e.fieldType,
            Mn.call(this, e),
            this.constraintName = e.constraintName,
            this.indexName = e.indexName,
            this
        },
        initConstraint: function() {
            if (this.constraintName = void 0,
            !this.not && !this.path && !this.isRegex && "undefined" !== typeof this.value && En[this.op]) {
                const e = this.queryArgs.query.model;
                this.constraintName = e.fieldsToConstraintName[this.key],
                this.indexName = e.fieldsToIndexName[this.key],
                this.indexName && this.indexName !== In.f && !this.valueParam && (null === this.value || "in" === this.op && this.value.indexOf(null) > -1) && !e.getIndex(this.indexName).storeConfig.includeNull && (this.indexName = void 0)
            }
            return this
        },
        mapPkChanges: function(e, t, n) {
            if (this.key !== t)
                return;
            let r;
            if (this.valueParam) {
                if (!n || !(r = n[this.valueParam]))
                    return
            } else
                r = this.value;
            if ("in" === this.op) {
                const t = r;
                for (let n = 0; n < t.length; n++)
                    r = t[n],
                    e[r] && (t[n] = e[r])
            } else
                e[r] && (this.valueParam ? n[this.valueParam] = e[r] : this.value = e[r])
        },
        parseConstraint: function(e, t, n, r, i, o) {
            if (!this.constraintName)
                return !1;
            if (n)
                n.addParentArg(this, this.constraintName);
            else {
                const e = t[this.constraintName];
                e && e.addArg(this, r)
            }
            if (o) {
                let e;
                const {constraintName: t} = this;
                for (let n of o)
                    e = i[n].queryArgs,
                    e && e.results && e.results.addSiblingArg(this, t)
            }
            return !0
        },
        parseValue: function(e) {
            if (null === e || this.isRegex || "undefined" === typeof e)
                return e;
            if ("in" === this.op) {
                const n = this.fieldType;
                let r;
                for (let i = 0; i < e.length; i++)
                    try {
                        e[i] = n.parseValue(e[i])
                    } catch (t) {
                        r || (r = []),
                        r.push("".concat(e[i], ": ").concat(t.message))
                    }
                if (r) {
                    let t;
                    if (Array.isArray(e))
                        throw t = new Error("The query for model ".concat(this.queryArgs.query.modelName, " contains argument `").concat(this.getMethodName(), '("').concat(this.key, '", ...)` that contains ').concat(r.length, " invalid value(s):\n  - ").concat(r.join("\n  - "))),
                        t;
                    throw t = new Error("The query for model ".concat(this.queryArgs.query.modelName, " contains argument `").concat(this.getMethodName(), '("').concat(this.key, '", ...)`, which means the values must be an Array of values. Got ').concat(e)),
                    t.location = "QueryKeyValueArg",
                    t
                }
                return e
            }
            try {
                e = this.fieldType.parseValue(e)
            } catch (t) {
                const n = new Error("The query for model ".concat(this.queryArgs.query.modelName, " contains argument `").concat(this.getMethodName(), '("').concat(this.key, '", ...)` that provided a value for the field that is invalid, ').concat(e, ": ").concat(t.message));
                throw n.location = "QueryKeyValueArg",
                n
            }
            return e
        },
        setArgsStartStopIdx: function(e, t) {
            this.startIdx = e,
            this.stopIdx = t,
            this.secondaryIndexedArg && (this.secondaryIndexedArg.setArgsStartStopIdx(e, t),
            "undefined" === typeof e && (this.secondaryIndexedArg = void 0))
        },
        setSecondaryIndexedArg: function(e) {
            let t = this.secondaryIndexedArg;
            if (t)
                if (e) {
                    const n = t.indexName;
                    this.ownQuery.model.determineBestIndex(n, e.indexName) === n ? t.setSecondaryIndexedArg(e) : (e.setSecondaryIndexedArg(t),
                    this.secondaryIndexedArg = e)
                } else
                    this.secondaryIndexedArg = null,
                    t.setSecondaryIndexedArg(null);
            else
                this.secondaryIndexedArg = e
        },
        removed: function() {
            this.indexName && this.queryArgs.invalidateIndexedArgs(this),
            this.destroy()
        },
        replaced: function(e) {
            this.indexName && this.queryArgs.invalidateIndexedArgs(this, e),
            this.destroy()
        }
    }
      , Pn = {
        field: {
            get() {
                return this.queryArgs.query.fields[this.key]
            },
            set: void 0
        }
    };
    const Dn = {
        extractVariables: function(e, t, n) {
            const r = this.query;
            if (!r || !r.queryHasVariables)
                return n;
            const i = this.VF
              , o = i.VFName;
            let s;
            if (t) {
                let t = void 0;
                if (i.isMany)
                    for (let n of e)
                        (s = n[o]) && (t ? t.push(...Object.values(s)) : t = Object.values(s));
                else
                    for (let n of e)
                        (s = n[o]) && (t || (t = [])) && t.push(s);
                t && (n = r.extractVariables(t, !0, n))
            } else
                (s = e[o]) && (n = i.isMany ? r.extractVariables(Object.values(s), !0, n) : r.extractVariables(s, !1, n));
            return n
        }
    }
      , Fn = {
        VFName: {
            get() {
                return this._VFName
            },
            set(e) {
                if (!this._VFName || e !== this._VFName) {
                    this._VFName = e;
                    const t = this.ownQuery.virtualFields[e];
                    if (!t)
                        throw new Error("The Virtual Field with name " + e + " is not a valid Virtual Field for model " + this.ownQuery.modelName);
                    const n = Object(he.L)(this);
                    t.ownFieldVFPath && (n ? this.ownQuery.queryHasPathInclude = !0 : this.ownQuery.queryHasPathArg = !0),
                    t.isManyToMany && (n ? this.ownQuery.queryHasM2MInclude = !0 : this.ownQuery.queryHasM2MArg = !0),
                    this.VF = t
                }
            }
        },
        isMany: {
            get() {
                return this.VF.isMany
            },
            set: void 0
        },
        isRefModel: {
            get() {
                return this.VF.isRefModel
            },
            set: void 0
        },
        ownFieldName: {
            get() {
                return this.VF.ownFieldName
            },
            set: void 0
        },
        ownRefFieldName: {
            get() {
                return this.VF.ownRefFieldName
            },
            set: void 0
        },
        isComputed: {
            get() {
                return this.VF.isComputed
            },
            set: void 0
        }
    };
    const kn = {
        ...Dn,
        createQueryInstance: function() {
            const e = this.VF.ownRefModel
              , t = e.query(this.VF.isMany ? e.schema.queryManyOp : e.schema.queryOneOp);
            return this.query = t,
            t.setAsVFQuery(this),
            t
        },
        getRefs: function(e, t) {
            return Object(he.U)(e) ? this.VF.get(e, t) : e[this.VFName]
        },
        getRealValue: function(e, t) {
            const n = this.result
              , {VF: {ownFieldName: r}} = this
              , {records: i, pkValues: o} = n;
            let s, a = 0, c = !t;
            for (let u of o)
                s = i[u],
                c ? 0 === a ? t = s[r] : (c = !1,
                (t = [t]).push(s[r])) : t.push(s[r]),
                a++;
            return t
        },
        addToOptimisticMutationResult: function(e, t, n) {
            const r = this.query
              , i = this.VF
              , o = i.get(t)
              , s = r.queryAlias || i.VFName;
            let a = e[s];
            if (o) {
                const e = r.queryArgs
                  , t = r.RecordResult;
                if (this.isMany) {
                    let s, {keyBy: c} = i;
                    if (c || (c = i.ownRefModelPk),
                    e)
                        for (let i in o)
                            s = o[i],
                            e.checkRecord(s, n) && (a || (a = {}),
                            a[s[c]] = t.buildForMutation(r, n, s));
                    else
                        for (let e in o)
                            s = o[e],
                            a || (a = {}),
                            a[s[c]] = t.buildForMutation(r, n, s)
                } else
                    e && !e.checkRecord(o, n) || (a = t.buildForMutation(r, n, o))
            }
            return e[s] = a || null,
            e
        },
        convertM2MArgsToThroughArgs: function(e) {
            const t = this.VF;
            if (!t.isManyToMany)
                return void (e || this.query.convertM2MArgsToThroughArgs());
            if (e && e !== t.bestVFName)
                return;
            const n = this.createNewInstance(!0);
            n.VFName = t.ownModelThroughVF.bestVFName;
            const r = n.createQueryInstance().where(t.ownRefModelThroughVF.modelVFName, this.query);
            r.queryHasM2MArg && r.convertM2MArgsToThroughArgs(),
            this.destroy()
        },
        convertPathArgsToFullPathArgs: function(e) {
            const t = this.VF
              , n = t.ownFieldFullVFPath;
            if (!n)
                return void (e || this.query.convertPathArgsToFullPathArgs());
            if (e && t.bestVFName !== e)
                return;
            const r = this.createNewInstance(!0);
            let i = n[0];
            const o = i.bestVFName;
            r.VFName = o;
            const s = r.createQueryInstance();
            if (1 === n.length)
                s.where(o, this.query);
            else {
                let e, t = n[1], r = 1;
                e = o => (i = t,
                r++,
                t = n[r],
                o.where(i.bestVFName, t ? e : this.query)),
                e(s),
                e = void 0,
                i = void 0,
                t = void 0
            }
            s.queryHasPathArg && s.convertPathArgsToFullPathArgs(),
            this.destroy()
        },
        mapPkChanges: function(e, t, n) {},
        replaced: function(e) {}
    }
      , jn = {
        ...Fn
    }
      , Ln = Object(L.a)(Pe(Xe), Tn)
      , Vn = Object(L.a)(ze(Xe), Rn);
    Object.defineProperties(Vn.prototype, Pn);
    const Un = Object(L.a)($e(Xe), kn);
    Object.defineProperties(Un.prototype, jn);
    const qn = (e, t, n, r) => e.secondaryIndexedArg ? Gn(e.secondaryIndexedArg, t, n, r) : void 0;
    function Qn(e, t, n, r) {
        if (!e)
            return n[t] ? null : void 0;
        if (e.value.cacheComplete) {
            if (e.size) {
                const t = e.getState();
                r || (r = []);
                for (let e in t)
                    r.push(t[e]);
                return r
            }
            return null
        }
    }
    function Bn(e, t, n) {
        if (!t)
            return t;
        if (!t.length)
            return null;
        let {startIdx: r, stopIdx: i} = e;
        if (i - r === 1)
            return t;
        {
            const o = e.queryArgs;
            let s, a, c, u = 0, l = t.length;
            for (; r < i; ) {
                if (s = o[r],
                s[he.q] === he.c)
                    if (u = 0,
                    s.constraintName)
                        for (; u < l; )
                            a = t[u],
                            s.checkRecord(t[u], n) ? u++ : (t.splice(u, 1),
                            l--);
                    else
                        for (c = s.key; u < l; ) {
                            if (a = t[u],
                            "undefined" === typeof a[c])
                                return;
                            s.checkRecord(a, n) ? u++ : (t.splice(u, 1),
                            l--)
                        }
                r++
            }
            return t.length ? t : null
        }
    }
    function Gn(e, t, n, r) {
        n || (n = e.ownQuery.model);
        const i = e.getRealValue(t);
        if (e.indexName === In.f)
            return function(e, t, n, r, i) {
                const o = r.notExists;
                let s;
                if (Array.isArray(t)) {
                    for (let a of t)
                        if (null !== a)
                            if (s = r.get(a))
                                i || (i = []),
                                i.push(s);
                            else if (!o[a])
                                return qn(e, n, r, i);
                    return i ? Bn(e, i, n) : null
                }
                return (s = r.get(t)) ? (i || (i = []),
                i.push(s),
                Bn(e, i, n)) : o[t] ? null : qn(e, n, r, i)
            }(e, i, t, n, r);
        {
            const o = n.getIndex(e.indexName)
              , s = o.storeConfig
              , a = s.notExists;
            return s.unique ? function(e, t, n, r, i, o, s) {
                const a = n.value;
                let c;
                if (Array.isArray(t)) {
                    for (let n of t)
                        if (null === n) {
                            if (c = Qn(a.get(n), n, r, s),
                            void 0 === c)
                                return qn(e, i, o, s);
                            null !== c && (s = c)
                        } else if (c = a.get(n))
                            s || (s = []),
                            s.push(c);
                        else if (!r[n])
                            return qn(e, i, o, s);
                    return s ? Bn(e, s, i) : null
                }
                return null === t ? (c = Qn(a.get(t), t, r, s),
                void 0 === c ? qn(e, i, o, s) : (null !== c && (s = c),
                s ? Bn(e, s, i) : null)) : (c = a.get(t)) ? (s || (s = []),
                s.push(c),
                Bn(e, s, i)) : r[t] ? null : qn(e, i, o, s)
            }(e, i, o, a, t, n, r) : function(e, t, n, r, i, o, s) {
                const a = n.value;
                let c;
                if (Array.isArray(t))
                    for (let u of t) {
                        if (c = Qn(a.get(u), u, r, s),
                        void 0 === c)
                            return qn(e, i, o, s);
                        null !== c && (s = c)
                    }
                else {
                    if (c = Qn(a.get(t), t, r, s),
                    void 0 === c)
                        return qn(e, i, o, s);
                    null !== c && (s = c)
                }
                return Bn(e, s, i)
            }(e, i, o, a, t, n, r)
        }
    }
    function zn(e, t, n) {
        if (this.VFsResults) {
            const {VFsResults: r} = this;
            this.pkValues = t,
            this.records = n;
            const i = fn(e);
            let o, s, a, c = !0;
            for (a of r)
                if (o = a.query.parentQueryArg.VF,
                s = o.checkCacheMissingForResolve(t, n, i),
                s ? !0 !== s && (c = a.resolveKnownRecords(e, s)) : c = a.resolve(e),
                !c)
                    break;
            return this.records = null,
            c ? (this.results.addPkValues(t),
            !0) : (this.isDeterministic = !1,
            !1)
        }
        return this.results.addPkValues(t),
        !0
    }
    function Hn(e, t, n, r, i) {
        if (!i)
            return !0;
        let o, s = !0;
        for (; n < r; ) {
            if (o = e[n],
            o[he.q] === he.c && !o.constraintName) {
                if ("undefined" === typeof i[o.key])
                    return;
                if (!(s = o.checkRecord(i, t)))
                    return s
            }
            n++
        }
        return s
    }
    function Kn(e, t, n, r, i) {
        let o;
        for (; n < r; ) {
            if (o = e[n],
            o[he.q] === he.c) {
                if (!o.constraintName && "undefined" === typeof i[o.key])
                    return;
                if (!o.checkRecord(i, t))
                    return !1
            }
            n++
        }
        return !0
    }
    var Yn = n(33);
    class Wn {
        constructor(e, t, n, r) {
            this._isDeterministic = !0,
            this._maybeDeterministic = !0,
            this.results = e,
            this.resultsIdx = e.length,
            this.constraints = t,
            this.startIdx = n,
            this.stopIdx = r,
            this.hasOwnConstraintKey = void 0,
            this.hasNonConstraintKey = !1,
            this.VFsResults = void 0,
            this.pkValues = void 0,
            this.indexedArg = null,
            this.constraintName = void 0
        }
        get query() {
            return this.results.query
        }
        get model() {
            return this.results.query.model
        }
        addSiblingArg(e, t) {
            const n = this.constraints[t];
            n && n.addSiblingArg(e)
        }
        addParentArg(e, t) {
            const n = this.constraints[t];
            n && n.addParentArg(e)
        }
        addToSibling(e) {
            this.constraints.addToSibling(e)
        }
        resolve(e, t, n) {
            if (!this.maybeDeterministic)
                return !1;
            const r = this.resolveHashes(e, t);
            return r ? this.resolveRecords(e, t, n, r) : this.resolveWithIndex(e, t, n)
        }
        resolveWithIndex(e, t, n, r) {
            let i = this.indexedArg;
            if (!i || r && i.indexName === this.constraintName && !(i = i.secondaryIndexedArg))
                return r && (Yn.a.checkinSet(r),
                this.pkValues = void 0),
                this.isDeterministic = !1,
                !1;
            {
                const o = Yn.a.checkoutArray();
                let s;
                const a = Gn(i, e.variables, t, o);
                return void 0 === a ? s = !1 : null === a ? s = !0 : (r ? r.clear() : r = Yn.a.checkoutSet(),
                function(e, t, n) {
                    let r, i;
                    for (r of e)
                        i = r.__ID,
                        t.add(i),
                        n[i] = r
                }(o, r, n),
                s = !r.size || zn.call(this, e, r, n)),
                Yn.a.checkinArray(o),
                r && (Yn.a.checkinSet(r),
                this.pkValues = void 0),
                this.isDeterministic = s,
                s
            }
        }
        resolveConstraint() {
            let e = this.constraintName;
            return null === e ? null : e ? this.constraints[e] : this.constraints.getCompleteConstraint(this)
        }
        resolveHashes(e, t, n) {
            if (!n && !(n = this.resolveConstraint()))
                return;
            const r = e.variables;
            let i, o, s = this.hasOwnConstraintKey;
            if (1 === n.totalCount)
                if (o = [],
                i = n.values[n.fields[0]],
                Array.isArray(i)) {
                    let e = i[0];
                    if (1 === i.length)
                        e[he.q] === he.d && (s = !0),
                        e.getRealValue(r, o);
                    else
                        for (e of i)
                            e.getRealValue(r, o)
                } else
                    i.getRealValue(r, o),
                    s = !0;
            else {
                const e = n.values
                  , a = n.fields
                  , c = n.valuesMap;
                let u, l, d;
                for (d of a)
                    if (i = e[d],
                    Array.isArray(i))
                        if (l = i[0],
                        1 === i.length)
                            l[he.q] === he.d && (s = !0),
                            c[d] = l.getRealValue(r);
                        else
                            for (l of (c[d] = u = [],
                            i))
                                l.getRealValue(r, u);
                    else
                        c[d] = i.getRealValue(r),
                        s = !0;
                o = t.getIndex(n.constraintName).value.createIndexKeyValues(c, !0)
            }
            return this.hasOwnConstraintKey = s || !1,
            this.hashes = o,
            o
        }
        resolveRecords(e, t, n, r) {
            const i = Yn.a.checkoutSet()
              , o = e.variables
              , {hasOwnConstraintKey: s, hasNonConstraintKey: a, startIdx: c, stopIdx: u, query: {queryArgs: l}} = this;
            let d, h, f, p, g, m = !1, y = !0;
            if (this.constraintName === In.f)
                m = !0,
                f = t.getState(),
                p = t.notExists;
            else {
                const e = t.getIndex(this.constraintName);
                f = e.getState(),
                p = e.storeConfig.notExists
            }
            e: for (let v of r)
                if (null === v) {
                    if (m)
                        continue;
                    const e = f.null;
                    if (e && e.value.cacheComplete) {
                        if (e.size) {
                            const t = e.getState();
                            for (let e in t) {
                                if (g = t[e],
                                a) {
                                    if (d = Hn(l, o, c, u, g),
                                    !1 === d)
                                        continue;
                                    if (void 0 === d) {
                                        y = !1;
                                        break e
                                    }
                                }
                                h = g.__ID,
                                i.add(h),
                                n[h] = g
                            }
                        }
                    } else if (s && (!e || !p.null)) {
                        y = !1;
                        break
                    }
                } else if (g = f[v]) {
                    if (a) {
                        if (d = Hn(l, o, c, u, g),
                        void 0 === d) {
                            y = !1;
                            break
                        }
                        if (!1 === d)
                            continue
                    }
                    h = g.__ID,
                    i.add(h),
                    n[h] = g
                } else if (s && !p[v]) {
                    y = !1;
                    break
                }
            return y ? (i.size && (y = zn.call(this, e, i, n)),
            Yn.a.checkinSet(i),
            this.pkValues = void 0,
            y) : this.resolveWithIndex(e, t, n, i)
        }
        resolveKnownRecords(e, t, n) {
            const {query: {queryArgs: r}, startIdx: i, stopIdx: o} = this
              , {variables: s} = e
              , a = Yn.a.checkoutSet();
            let c, u;
            for (let l in t)
                if (c = t[l],
                u = Kn(r, s, i, o, c),
                u)
                    a.add(l),
                    n[l] = c;
                else if (void 0 === u) {
                    this.isDeterministic = !1;
                    break
                }
            return this.isDeterministic && a.size && zn.call(this, e, a, n),
            Yn.a.checkinSet(a),
            this.pkValues = void 0,
            this.isDeterministic
        }
        destroy() {
            this.closed || (this.closed = !0,
            this.constraints.checkin(),
            this.hashes && (this.hashes = void 0),
            this.indexedArg && (this.indexedArg = void 0),
            this.constraints = void 0,
            this.results = void 0,
            this.VFsResults = void 0)
        }
        get maybeDeterministic() {
            return this._maybeDeterministic
        }
        set maybeDeterministic(e) {
            this._maybeDeterministic && (this._maybeDeterministic = !1,
            this.results.maybeDeterministic = !1,
            this._isDeterministic = !1)
        }
        get isDeterministic() {
            return this._isDeterministic
        }
        set isDeterministic(e) {
            !1 === e && this._isDeterministic && (this._isDeterministic = !1,
            this.results.isDeterministic = !1)
        }
    }
    class $n extends Array {
        constructor(e, t) {
            super(),
            this._maybeDeterministic = !0,
            this._isDeterministic = !0,
            this.results = e,
            this.resultsIdx = t,
            this.hasNonConstraintKey = !1,
            this.VFsResults = void 0
        }
        get query() {
            return this.results.query
        }
        get parentResult() {
            return this.results.parentResult
        }
        createGroupResults(e) {
            const t = this.results.constructor.init(e, this);
            return this.push(t),
            t
        }
        addSiblingArg(e, t) {}
        addParentArg(e, t) {
            let n;
            for (n of this)
                n.addParentArg(e, t)
        }
        addToSibling(e) {}
        setStartAndStopIdx(e, t) {
            this.startIdx = e,
            this.stopIdx = t
        }
        resolve(e, t, n) {
            let r, i, o;
            for (r of (this.pkValues = o = Yn.a.checkoutSet(),
            this.records = n,
            this))
                if (!(i = r.resolve(e, t, n)))
                    break;
            if (!i || !o.size)
                return Yn.a.checkinSet(o),
                this.pkValues = void 0,
                this.records = void 0,
                i;
            const {variables: s} = e;
            if (this.hasNonConstraintKey) {
                const {query: {queryArgs: e}, startIdx: t, stopIdx: r} = this;
                let a;
                for (let c of o)
                    if (a = Hn(e, s, t, r, n[c]),
                    !a) {
                        if (void 0 === a) {
                            this.isDeterministic = i = !1;
                            break
                        }
                        o.delete(c)
                    }
            }
            return i && o.size ? i = zn.call(this, e, o, n) : this.records = null,
            Yn.a.checkinSet(o),
            this.pkValues = void 0,
            i
        }
        resolveKnownRecords(e, t, n) {
            let r, i = !0;
            const o = Yn.a.checkoutSet();
            for (r of (this.pkValues = o,
            this.records = n,
            this))
                if (i = r.resolveKnownRecords(e, t, n),
                !i) {
                    this.isDeterministic = !1;
                    break
                }
            if (!i || !o.size)
                return Yn.a.checkinSet(o),
                this.pkValues = void 0,
                this.records = null,
                i;
            const {variables: s} = e
              , {query: {queryArgs: a}, startIdx: c, stopIdx: u} = this;
            let l;
            for (let d of o)
                if (l = Kn(a, s, c, u, n[d]),
                !l) {
                    if (void 0 === l) {
                        this.isDeterministic = i = !1;
                        break
                    }
                    o.delete(d)
                }
            return i && o.size ? i = zn.call(this, e, o, n) : this.records = null,
            Yn.a.checkinSet(o),
            this.pkValues = void 0,
            i
        }
        addPkValues(e) {
            if (e) {
                const {pkValues: t} = this;
                for (let n of e)
                    t.add(n)
            }
        }
        destroy() {
            if (!this.closed) {
                this.closed = !0;
                for (let e of this)
                    e.destroy();
                this.VFsResults = void 0,
                this.results = void 0
            }
        }
        get maybeDeterministic() {
            return this._maybeDeterministic
        }
        set maybeDeterministic(e) {
            !1 === e && this._maybeDeterministic && (this._maybeDeterministic = !1,
            this.results.maybeDeterministic = !1,
            this._isDeterministic = !1)
        }
        get isDeterministic() {
            return this._isDeterministic
        }
        set isDeterministic(e) {
            !1 === e && this._isDeterministic && (this._isDeterministic = !1,
            this.results.isDeterministic = !1)
        }
    }
    function Xn(e) {
        if (!this.maybeDeterministic)
            return e.maybeDeterministic = !1,
            e.isDeterministic = !1,
            !1;
        e.maybeDeterministic = !0;
        const t = e.query.getBestModel(e)
          , n = {};
        let r;
        for (r of this)
            if (!r.resolve(e, t, n)) {
                this.isDeterministic = !1;
                break
            }
        return this.isDeterministic ? Zn.call(this, e, this.pkValues, n) : (e.isDeterministic = !1,
        !1)
    }
    function Jn(e, t) {
        e.maybeDeterministic = !0;
        const n = {};
        let r;
        for (r of this)
            if (!r.resolveKnownRecords(e, t, n)) {
                this.isDeterministic = !1;
                break
            }
        return this.isDeterministic ? Zn.call(this, e, this.pkValues, n) : (e.isDeterministic = !1,
        !1)
    }
    function Zn(e, t, n) {
        const r = this.query;
        let i = null;
        if (t.size > 0) {
            const {variables: o} = e
              , s = r.queryArgs;
            let a;
            for (let e of t)
                a = n[e],
                !a || s && !s.checkRecord(a, o) ? t.delete(e) : i ? i[e] = a : i = {
                    [e]: a
                }
        }
        return e.records = i,
        e.isDeterministic = !0,
        r.checkRecordsForMissingSelect(e),
        !0
    }
    const {MAIN_QUERY: er, GROUPED_QUERY: tr, VF_QUERY: nr, INCLUDE_VF_QUERY: rr} = pe
      , ir = {
        [er]: Xn,
        [tr]: function(e, t, n) {
            let r;
            for (r of this)
                if (!r.resolve(e, t, n)) {
                    this.isDeterministic = !1;
                    break
                }
            return this.pkValues.size > 0 && this.parentResult.addPkValues(this.pkValues),
            this.isDeterministic
        },
        [nr]: function(e) {
            const t = this.query.model.getBestInstance(fn(e))
              , n = {};
            let r;
            for (r of this)
                if (!r.resolve(e, t, n)) {
                    this.isDeterministic = !1;
                    break
                }
            return this.isDeterministic
        },
        [rr]: function(e) {
            const t = e.parent;
            if (t && t.records) {
                const {records: n} = t
                  , r = Object.keys(n)
                  , i = e.VF.checkCacheMissingForResolve(r, n, fn(e));
                return !0 === i ? (e.isDeterministic = !0,
                e.records = null,
                e.recordsResults = null,
                e.missingSelect = null,
                !0) : i ? Jn.call(this, e, i) : Xn.call(this, e)
            }
            return Xn.call(this, e)
        }
    }
      , or = {
        [tr]: function(e, t, n) {
            let r;
            for (r of this)
                if (!r.resolveKnownRecords(e, t, n)) {
                    this.isDeterministic = !1;
                    break
                }
            return !!this.isDeterministic && (this.pkValues.size > 0 && this.parentResult.addPkValues(this.pkValues),
            !0)
        },
        [nr]: function(e, t) {
            const n = {};
            let r;
            for (r of this)
                if (!r.resolveKnownRecords(e, t, n)) {
                    this.isDeterministic = !1;
                    break
                }
            return this.isDeterministic
        },
        [rr]: Jn
    };
    class sr extends Array {
        constructor(e, t) {
            super(),
            this.query = e.query,
            this.parentResult = t,
            this._maybeDeterministic = !0,
            this._isDeterministic = !0
        }
        static init(e, t) {
            return new this(e,t)
        }
        resolve(e, t, n) {
            return this._resolveOrResolveKnownRecords(e, t, n, !1)
        }
        _resolveOrResolveKnownRecords(e, t, n, r) {
            let i;
            return this.pkValues = Yn.a.checkoutSet(),
            this._isDeterministic = !0,
            i = r ? or[this.query.instanceType].call(this, e, t, n) : ir[this.query.instanceType].call(this, e, t, n),
            Yn.a.checkinSet(this.pkValues),
            this.pkValues = void 0,
            i
        }
        resolveKnownRecords(e, t, n) {
            return this._resolveOrResolveKnownRecords(e, t, n, !0)
        }
        createResult(e, t, n) {
            const r = new Wn(this,e,t,n);
            return this.push(r),
            r
        }
        createGroupedResult() {
            const e = new $n(this,this.length);
            return this.push(e),
            e
        }
        addSiblingArg(e, t) {
            let n;
            for (n of this)
                n.addSiblingArg(e, t)
        }
        addParentArg(e, t) {
            if (this.query.modelName === e.ownQuery.modelName) {
                let n;
                for (n of this)
                    n.addParentArg(e, t)
            }
        }
        addToSibling(e) {
            let t;
            for (t of this)
                t.addToSibling(e)
        }
        addPkValues(e) {
            if (e) {
                const {pkValues: t} = this;
                for (let n of e)
                    t.add(n)
            }
        }
        destroy() {
            if (!this.closed) {
                this.closed = !0;
                for (let e of this)
                    e.destroy();
                this.query = void 0,
                this.parentResult = void 0
            }
        }
        get maybeDeterministic() {
            return this._maybeDeterministic
        }
        set maybeDeterministic(e) {
            this._maybeDeterministic && (this._maybeDeterministic = !1,
            this.parentResult && (this.parentResult.maybeDeterministic = !1),
            this._isDeterministic = !1)
        }
        get isDeterministic() {
            return this._isDeterministic
        }
        set isDeterministic(e) {
            !1 === e && this._isDeterministic && (this._isDeterministic = !1,
            this.parentResult && (this.parentResult.isDeterministic = !1))
        }
    }
    const ar = (e, t) => {
        if (!t && (!e || !e.queryArgs || !e.queryHasVariables))
            return !1;
        const {queryArgs: n} = e;
        for (let r of n)
            if (r[he.q] !== he.c) {
                if (ar(r.query, !1))
                    return !0
            } else if (r.valueParam)
                return !0;
        return !1
    }
    ;
    const cr = {
        buildConstraints: function(e, t) {
            if (0 === this.length)
                return null;
            const {query: n} = this
              , {isGroupedQuery: r, isVFGroup: i} = n
              , o = n.model.QueryConstraints.checkout();
            if (r || i) {
                const {ownSiblingsIdx: s} = n;
                if (i ? (o.addVFQueryParentArg(this),
                this.results = sr.init(this, e)) : (t && o.populate(t),
                this.results = e.createGroupResults(this)),
                s) {
                    let e;
                    const t = n.siblingQueries;
                    for (let n of s)
                        ({queryArgs: e} = t[n]),
                        e && e.results && e.results.addToSibling(o)
                }
                this._buildConstraints(this.results, o, !1, r, i)
            } else
                n.trackSiblings(),
                this.results = sr.init(this),
                this._buildConstraints(this.results, o, !0, !1, !1);
            return this.results
        },
        _buildConstraints: function(e, t, n, r, i) {
            const o = this.query
              , s = this.getIndexedArgs()
              , {isIncludeQuery: a, siblingQueries: c, ownSiblingsIdx: u, model: l} = o;
            let d, h, f, p, g, m, y, v, b, _ = 0, S = 0, O = 0, T = this[0], I = null;
            for (; T; )
                if (h = T[he.q],
                h === he.b ? (b = T.query.queryArgs) && (I || (I = v = e.createGroupedResult()),
                b.buildConstraints(I, i ? t : void 0)) : h === he.d ? g = !0 : T.constraintName ? p = !0 : f = !0,
                _++,
                T = this[_],
                !T || T.argsGroupIdx !== O) {
                    if (d = _,
                    y = s ? s[O] : null,
                    I)
                        v.setStartAndStopIdx(S, d);
                    else if (p || !n)
                        v = e.createResult(t, S, d);
                    else {
                        if (!a && !y)
                            return t.checkin(),
                            e.destroy(),
                            this.results = null,
                            !1;
                        v = e.createResult(t, S, d)
                    }
                    if (v.indexedArg = y,
                    v.hasNonConstraintKey = f,
                    O++,
                    p || g) {
                        for (_ = S,
                        v.VFsResults = m = g ? [] : void 0; _ < d; )
                            T = this[_],
                            h = T[he.q],
                            h === he.c ? T.parseConstraint(o, t, I, r, c, u) : h === he.d && (b = T.query.queryArgs) && (b.buildConstraints(v),
                            T.result = v,
                            m.push(b.results)),
                            _++;
                        if (_ = d,
                        T = this[d],
                        !I && p) {
                            if (!t.getCompleteConstraint(v) && n && !a && !y)
                                return t.checkin(),
                                e.destroy(),
                                this.results = null,
                                console.log("NOT maybeDeterministic, no complete constraint or index for " + this.query.modelName),
                                !1;
                            null === v.constraintName && (v.constraintName = void 0)
                        }
                    }
                    T && (t = l.QueryConstraints.checkout().populate(t),
                    I = null,
                    v = null,
                    S = d,
                    p = !1,
                    f = !1,
                    g = !1)
                }
            return !0
        },
        destroy: function() {
            if (this.query) {
                let e;
                for (e of this)
                    e.destroy();
                const t = this.query;
                t.queryArgs === this && (t.queryHasVFArg = !1,
                t.queryArgs = void 0),
                this.query = void 0,
                this.indexedArgs && Yn.a.checkinArray(this.indexedArgs)
            }
        },
        convertToGroupedQuery: function() {
            this.invalidateIndexedArgs(),
            this.results && (this.results.destroy(),
            this.results = void 0);
            const e = this.query;
            e.queryArgs = void 0;
            const t = e.getOrInitQueryArgs().addGroupedQueryArg().createQueryInstance();
            return e.queryHasVFArg && (t.queryHasVFArg = !0),
            t.queryArgs = this,
            ar(t, !0) && (t.queryHasVariables = !0),
            this.query = t,
            e.queryArgs
        },
        get: function(e, t, n) {
            n || (n = null);
            const r = this.getIndexedArgs(!0)
              , i = this.query.getBestModel(e);
            if (r) {
                let o;
                for (o of r)
                    n = o.getWithIndex(i, e, t, n)
            } else {
                const r = i.getState()
                  , {variables: o} = e;
                for (let i in r)
                    this.checkRecord(r[i], o) && (n = On(i, r[i], e, t, n))
            }
            return n
        },
        getIndexedArgs: function(e) {
            let t = this.indexedArgs;
            if (this.indexedArgsVerified && (0 === this.length || t && "undefined" !== typeof t[this.argsGroupIdx]))
                return e && this.hasMissingIndex ? null : this.indexedArgs;
            this.indexedArgsVerified = !0;
            const n = this.query.model;
            let r;
            if (t) {
                for (r of this)
                    r[he.q] === he.b ? (r.startIdx = void 0,
                    r.stopIdx = void 0) : r[he.q] === he.c && r.indexName && (r.startIdx = void 0,
                    r.stopIdx = void 0,
                    r.secondaryIndexedArg = void 0);
                t.length = 0
            } else
                t = Yn.a.checkoutArray();
            let i, o, s, a = !1, c = 0, u = 0, l = 0, d = 0, h = !1, f = void 0;
            for (r of this)
                if (i = r[he.q],
                i === he.b ? h = !0 : i === he.c && r.indexName && (f ? n.determineBestIndex(f.indexName, r.indexName) === r.indexName ? (t[d] = r,
                r.setSecondaryIndexedArg(f),
                f = r) : f.setSecondaryIndexedArg(r) : (t[d] = r,
                f = r)),
                l++,
                !(o = this[l]) || o.argsGroupIdx !== d) {
                    if (!f && h)
                        for (c = u; c < l; ) {
                            if (r = this[c],
                            i = r[he.q],
                            i === he.b && (s = r.query.queryArgs) && s.getIndexedArgs(!0)) {
                                f = r,
                                t[d] = r;
                                break
                            }
                            c++
                        }
                    f ? f.setArgsStartStopIdx(u, l) : (t[d] = null,
                    a = !0),
                    f = null,
                    u = l,
                    h = !1,
                    d++
                }
            return this.hasMissingIndex = a,
            this.indexedArgs = t,
            e && a ? null : t
        },
        invalidateIndexedArgs: function(e, t, n) {
            if (this.indexedArgsVerified) {
                const n = this.query;
                n.isGroupedQuery && n.parent.queryArgs.invalidateIndexedArgs(e, t, !0),
                this.indexedArgsVerified = !1
            }
        },
        incrementArgsGroupIdx: function() {
            this.indexedArgsVerified && this.invalidateIndexedArgs(),
            this.argsGroupIdx++
        },
        decrementArgsGroupIdx: function(e) {
            this.indexedArgsVerified && this.invalidateIndexedArgs(e),
            this.argsGroupIdx--
        },
        extractVariables: function(e, t, n) {
            let r;
            for (r of this)
                n = r.extractVariables(e, t, n);
            return n
        }
    }
      , ur = function(e) {
        class t extends e {
        }
        return t.VFQueryArg = Un,
        t.GroupedQueryArg = Ln,
        t.KeyValueArg = Vn,
        Object(L.a)(t, cr),
        t
    }(nt)
      , {MAIN_QUERY: lr, INCLUDE_VF_QUERY: dr, VF_QUERY: hr, GROUPED_QUERY: fr} = pe
      , pr = {
        model: !1,
        queryName: !1,
        queryHasVFArg: !1,
        dispatchId: !1,
        virtualFields: !1,
        fields: !1,
        modelName: !1,
        primaryKey: !1,
        method: !1,
        variables: !1,
        queryHasPathArg: !1,
        queryHasM2MArg: !1,
        pagination: !1
    }
      , gr = {
        select: !1,
        include: !1,
        addQueryArg: !1,
        addDirective: !1,
        useAlias: !1,
        registerSibling: !1,
        get: !1,
        find: !1,
        fetch: !1,
        subscribe: !1,
        set: !1,
        useRecords: !1,
        values: !1
    }
      , mr = {
        ...pr,
        model: !1,
        queryName: !1,
        queryHasVFArg: !0,
        dispatchId: !0,
        method: !0,
        variables: !0,
        queryHasPathArg: !0,
        queryHasM2MArg: !0,
        pagination: !0
    }
      , yr = {
        ...gr,
        include: !0,
        select: !0,
        registerSibling: !0,
        get: !0,
        find: !0,
        fetch: !0,
        subscribe: !0,
        set: !1,
        useRecords: !1,
        values: !1
    }
      , vr = {
        ...pr,
        dispatchId: !0,
        method: !0,
        variables: !0
    }
      , br = {
        ...gr
    }
      , _r = {
        [lr]: pr,
        [fr]: {
            model: !0,
            queryName: !0,
            queryHasVFArg: !0,
            dispatchId: !0,
            virtualFields: !0,
            fields: !0,
            modelName: !0,
            primaryKey: !0,
            method: !0,
            variables: !0,
            queryHasPathArg: !0,
            queryHasM2MArg: !0,
            pagination: !0
        },
        [hr]: mr,
        [dr]: vr
    }
      , Sr = {
        [lr]: gr,
        [fr]: {
            select: !0,
            include: !0,
            addQueryArg: !1,
            addDirective: !0,
            useAlias: !0,
            registerSibling: !0,
            get: !0,
            find: !0,
            fetch: !0,
            subscribe: !0,
            set: !0,
            useRecords: !0,
            values: !0
        },
        [hr]: yr,
        [dr]: br
    };
    var Or = n(74);
    function Tr() {
        if (!this.isDeterministic) {
            const {resp: e} = this;
            if (e && e.length) {
                const t = this.query.getBestModel(this)
                  , n = t.getState()
                  , r = t.primaryKey
                  , i = {};
                for (let o of e)
                    i[o[r]] = n[o[r]];
                this.records = i,
                this.filterResults = !1
            } else
                this.records = null
        }
        return this.query.get(this)
    }
    function Ir(e, t) {
        return e.query.isRootQuery ? t ? t.pipe(Object(Y.a)(Tr, e)) : Object(V.a)(e.query.get(e)) : t ? t.pipe(Object(Or.a)(e)) : Object(V.a)(e)
    }
    function xr(e) {
        const t = e.query.includeVFs;
        if (!t)
            return e;
        const n = e.records;
        if (!n)
            return e;
        let r, i, o, s, a;
        for (let c in t)
            if (r = t[c],
            (i = r.VF.ownModelCacheMissingFieldName) && (!(s = r.getGroupedQueryArg()) || !s.query || !s.query.queryArgs)) {
                for (o in n)
                    n[o][i] = !1;
                if (r.VF.isRefModel && (a = r.VF.manyToManyVF) && r.query && r.query.includeVFs && (r = r.query.includeVFs[a.ownRefModelThroughVFName]) && (i = a.ownModelCacheMissingFieldName) && (!(s = r.getGroupedQueryArg()) || !s.query || !s.query.queryArgs))
                    for (o in n)
                        n[o][i] = !1
            }
        return e
    }
    var wr = n(297);
    const Mr = (e, t) => {
        let n;
        return t || (e.action = null),
        e.query.prepareIncludes(e) && (n = e.query.executeIncludes(e, !0)) ? t ? (n.push(t.meta.asObservable()),
        n = Object(wr.a)(n)) : n = n.length > 1 ? Object(wr.a)(n) : n[0] : t && (n = t.meta.asObservable()),
        Ir(e, n)
    }
      , Ar = (e, t) => Object(P.a)( () => ( (e, t) => (e.isDeterministic = !0,
    e.maybeDeterministic = void 0,
    e.filterResults = !1,
    console.log("ARGS QUERY RESP = ", t),
    e.records = t.records,
    e.permRecField = null,
    console.log("RECS = ", e.records),
    Mr(e)))(e, t));
    function Er(e, t, n) {
        if (!e.directives)
            return !n || ("boolean" === typeof n.shouldInclude ? n.shouldInclude : (n.shouldInclude = !0,
            !0));
        if (n && "boolean" === typeof n.shouldInclude)
            return n.shouldInclude;
        const {directives: r} = e;
        let i = !0;
        if (r.skip) {
            const {directiveVariables: n} = e;
            if (n && n.skip) {
                const r = n.skip.if;
                i = t && t.hasOwnProperty(r) ? !t[r] : !e.directiveDefaults.skip.if
            } else
                i = !r.skip.if
        }
        if (i && r.include) {
            const {directiveVariables: n} = e;
            if (n && n.include) {
                const r = n.include.if;
                i = t && t.hasOwnProperty(r) ? t[r] : e.directiveDefaults.include.if
            } else
                i = r.include.if
        }
        return n && (n.shouldInclude = i),
        i
    }
    const Cr = e => {
        const t = e.query.getBestModel(e).dispatch(c.p, e, fn(e), "ifExists");
        return e.query.setPayloadAction(e, t),
        t
    }
      , Nr = {
        [ye.FIND]: e => (!1 !== e.maybeDeterministic && "undefined" === typeof e.isDeterministic && e.query.resolve(e),
        e.isDeterministic ? e.missingSelect ? Mr(e, Cr(e)) : Mr(e) : Ir(e, Cr(e).meta.asObservable())),
        [ye.FETCH]: e => Ir(e, Cr(e).meta.asObservable())
    };
    function Rr(e) {
        if (!(e => !!Er(e.query, e.variables, e) || (e.records = void 0,
        e.isDeterministic = !0,
        e.maybeDeterministic = void 0,
        !1))(e))
            return Ir(e);
        const t = (e => {
            if (!e.permCheck || e.permQueryFor || e.isDeterministic)
                return e;
            const t = e.query;
            if (t.isRootQuery && !t.model.permPluginQueryCheck(e.userRole, e))
                return t.permDenied(e),
                null;
            if (!e.isServer)
                return e;
            const n = t.checkQueryPerm(e);
            console.log("BEFORE PERM ARGS = ", t.toGraphql({}));
            const r = !1 === n ? null : t.addPermArgs(e);
            return r ? (e.permCheck = !1,
            e.permRecField = null,
            console.log("AFTER PERM ARGS = ", t.toGraphql({})),
            e) : (e.recordsResults = null,
            e.records = null,
            e.isDeterministic = !0,
            e.maybeDeterministic = !0,
            e)
        }
        )(e);
        return t ? t === e ? Nr[e.method](e) : Nr[e.method](t).pipe(Ar(e, t)) : Ir(e)
    }
    const Pr = (e, t) => "undefined" !== typeof e.originalQuery && (!t || e.originalQuery !== e.query || !1 === e.originalQuery);
    const Dr = e => (e.resp && e.query.pluckPathVFs && !e.query.pluckPathVFs.length && (e.resp = e.query.getPluckResults(e.resp, e.variables)),
    e)
      , Fr = Object(Y.a)(e => {
        let t = e.resp;
        if (!t)
            return e;
        if (e.extensions = t.extensions,
        !t.data) {
            let e = "An error occurred attempting to fetchDirect:\n";
            const n = t.errors && t.errors[0];
            throw n ? "string" === typeof n ? e += n : n.message ? e += n.message : e += "(Unknown Error Format)" : e += "(No error message available)",
            new Error(e)
        }
        {
            const n = t.data[e.query.queryName];
            t = n ? Array.isArray(n) ? e.responseFormatType === me.SINGLE_RESP ? n[0] || null : n : e.responseFormatType !== me.SINGLE_RESP ? [n] : n : n
        }
        if (e.resp = t,
        e.query.queryCalc)
            t = e;
        else if (t) {
            const n = e.query.model.fields
              , r = t[0];
            let i, o;
            for (let e in r)
                if (i = n[e])
                    for (o of t)
                        i.validate(o);
            t = Dr(e)
        } else
            t = Dr(e);
        return e.query.maybeDestroy(e),
        t
    }
    );
    function kr(e) {
        return e.model.executeDirectQuery(e).pipe(Fr)
    }
    const {RECORDS_RESULTS: jr, RECORDS: Lr} = ge
      , {SINGLE_RESP: Vr, OBJECT_RESP: Ur, ARRAY_RESP: qr} = me
      , Qr = (e, t, n, r, i) => e.parentMethodsMap[i] ? e.parent[i](t, n, r) : e.queryCalc ? e.fetchRaw(t) : (t = e.preparePayload(t, n, r, i),
    e.recursiveVF ? t.method === ye.FETCH ? Rr(t) : e.findFetchRecursive(t) : Rr(t));
    const Br = {
        getClosestParentDispatch: function(e) {
            let t = e.parent;
            if (!t)
                return;
            let n = t.action;
            if (n)
                return n;
            for (; t = t.parent; )
                if (t.action) {
                    n = t.action;
                    break
                }
            return n
        },
        cloneForExecute: function(e, t) {
            if (!e)
                return this;
            if (Pr(e, t))
                return e.query;
            const n = e.parent;
            let r;
            if (n) {
                if (r = n.query.cloneForExecute(n, t),
                Pr(e, t))
                    return e.query;
                if (n.originalQuery === n.query)
                    return e.originalQuery = this,
                    this
            } else {
                if (!t && e.responseFormat !== ge.RECORDS_RESULTS)
                    return e.originalQuery = this,
                    this;
                r = this.parent
            }
            return this.createNewInstance(this.instanceType, r, this.parentQueryArgIdx).buildFromQuery(this, e),
            e.query
        },
        find: function(e, t, n) {
            return Qr(this, e, t, n, ye.FIND)
        },
        findOne: function(e) {
            return this.find(e, jr, Vr)
        },
        findOneRecord: function(e) {
            return this.find(e, Lr, Vr)
        },
        findAll: function(e) {
            return this.find(e, jr, Ur)
        },
        findAllArray: function(e) {
            return this.find(e, jr, qr)
        },
        findAllRecords: function(e) {
            return this.find(e, Lr, Ur)
        },
        findAllRecordsArray: function(e) {
            return this.find(e, Lr, qr)
        },
        fetch: function(e, t, n) {
            return Qr(this, e, t, n, ye.FETCH)
        },
        fetchOne: function(e) {
            return this.fetch(e, jr, Vr)
        },
        fetchOneDirect: function(e) {
            return this.fetchDirect(e, ge.RECORDS_RESULTS, me.SINGLE_RESP)
        },
        fetchOneRecord: function(e) {
            return this.fetch(e, Lr, Vr)
        },
        fetchAll: function(e) {
            return this.fetch(e, jr, Ur)
        },
        fetchAllDirect: function(e) {
            return this.fetchDirect(e, ge.RECORDS_RESULTS, me.ARRAY_RESP)
        },
        fetchAllRecords: function(e) {
            return this.fetch(e, Lr, Ur)
        },
        fetchAllRecordsArray: function(e) {
            return this.fetch(e, Lr, qr)
        },
        fetchAllArray: function(e) {
            return this.fetch(e, jr, qr)
        },
        fetchRaw: function(e) {
            return (e = this.preparePayload(e, ge.PAYLOAD, me.OBJECT_RESP, ye.FETCH_RAW)).model || (e.model = this.model),
            this.recursiveVF ? this.findFetchRecursive(e) : kr(e)
        },
        fetchDirect: function(e, t, n) {
            return e && e.__didPrepare || (e = this.preparePayload(e, t, n, ye.FETCH_DIRECT)),
            e.model || (e.model = this.model.mainModel),
            kr(e)
        },
        fetchDirectWithStep: function(e, t, n) {
            return e.step = t,
            e.stepCount = n,
            this.fetchDirect(e)
        }
    };
    var Gr = n(131);
    const {RECORDS_RESULTS: zr, PAYLOAD: Hr} = ge
      , {ARRAY_RESP: Kr, OBJECT_RESP: Yr, SINGLE_RESP: Wr} = me;
    const $r = {
        getForParent: function(e) {
            if (!1 === e.originalQuery)
                return !1;
            const t = e.originalQuery || e.query;
            if (e.linkedPayload && (e.records = e.linkedPayload.records),
            null === e.records)
                return null;
            if (!Er(t, e.variables, e))
                return !1;
            let n;
            return this.parseSelect(e),
            e.records ? (n = _n(t, e, t.RecordResult),
            e.recordsResults = n,
            this.getIncludesResults(e),
            t.parentQueryArg.mergeQueryResults(e)) : (n = function(e, t) {
                const n = t.parent.recordsResults
                  , {VF: r, variables: i} = t
                  , o = r.isMany
                  , s = o && r.keyBy
                  , a = e.queryAlias || r.VFName
                  , {RecordResult: c, queryArgs: u, primaryKey: l} = e
                  , d = r.getIndex(fn(t));
                let h, f, p, g, m, y = t.recordsResults;
                for (let v in n)
                    if (h = n[v],
                    p = h[a] || null,
                    g = r.getWithIndex(d, h.__record)) {
                        if (o)
                            for (m in g)
                                u && !u.checkRecord(g[m], i) || (p = On(m, g[m], t, c, p),
                                p && p[m] && (y || (y = {}),
                                f = s ? g[m][l] : m,
                                y[f] = p[m]));
                        else
                            u && !u.checkRecord(g, i) || (f = g[l],
                            y = On(f, g, t, c, y),
                            y && (p = y[f] || null));
                        h[a] = p
                    } else
                        h[a] = p;
                return y
            }(t, e),
            e.recordsResults = n,
            n && this.getIncludesResults(e)),
            n
        },
        get: function(e, t, n) {
            if (this.parentMethodsMap.get)
                return this.parent.get(e, t, n);
            if (!this.isRootQuery)
                return this.getForParent(e);
            if (e && e.__didPrepare) {
                if (this.recursiveVF)
                    return this.getRecursive(e);
                t ? n || (n = Yr) : ({responseFormat: t, responseFormatType: n} = e)
            } else {
                if (e = this.preparePayload(e, t, n),
                this.recursiveVF)
                    return this.getRecursive(e);
                ({responseFormat: t, responseFormatType: n} = e)
            }
            if (null === e.records) {
                const r = e.originalQuery || e.query
                  , i = wt[t][n](e);
                return r.maybeDestroy(e),
                i
            }
            const r = e.originalQuery || e.query;
            if (!Er(r, e.variables, e))
                return r.maybeDestroy(e),
                wt[t][n](e);
            const {queryCalc: i} = r;
            let o;
            if (t === zr)
                if (o = r.RecordResult,
                i) {
                    if (!r.includeVFs && i.hasFieldPathArg && r.queryHasVFArg) {
                        const t = i.getFieldPathArgsTopLevelVFNames();
                        t && r.includeFromArgs(r.getArgsMap({
                            fields: !1,
                            virtualFields: t
                        }), void 0, e)
                    }
                } else
                    r.parseSelect(e);
            let s, a = null;
            if (e.records)
                a = _n(r, e, o);
            else if (r.queryArgs)
                a = r.queryArgs.get(e, o, o ? e.recordsResults : null);
            else if (o) {
                const t = r.getState(e);
                a = e.recordsResults || null;
                for (let n in t)
                    a = On(n, t[n], e, o, a)
            } else {
                const t = this.getBestModel(e);
                t.size && (a = {
                    ...t.getState()
                })
            }
            if (o ? (e.recordsResults = a,
            a && r.getIncludesResults(e)) : e.records = a,
            i)
                s = i.getResult(e),
                e.formattedResponse = s,
                t === Hr && (s = e);
            else if (t !== Hr && e.mutationType === Gr.a && e.data) {
                s = wt[t][Yr](e);
                const r = e.isServer && e.extensions && e.extensions.pkMap;
                if (n === Kr) {
                    const t = e.data
                      , n = [];
                    let i, o = !1;
                    for (let e of t)
                        e && (i = s[e.__ID]) ? n.push(i) : (n.push(null),
                        o = !0);
                    if (o && r)
                        for (let e in r)
                            (!(i = s[r[e]]) || n.indexOf(i) < 0) && (r[e] = null);
                    s = n,
                    e.formattedResponse = s
                } else {
                    if (r)
                        for (let e in r)
                            s && s[r[e]] || (r[e] = null);
                    s && n === Wr && (e.formattedResponse = Object.values(s)[0])
                }
            } else
                s = wt[t][n](e);
            return r.maybeDestroy(e),
            s
        },
        getIncludesResults: function(e) {
            const t = (e.originalQuery || e.query).includeVFs;
            if (t) {
                const n = e.children
                  , r = e.linkedPayload ? e.linkedPayload.children : void 0;
                let i;
                for (let e in t)
                    i = n[e],
                    r && (i.linkedPayload = r[e]),
                    !1 !== i.originalQuery && t[e].query.getForParent(i)
            }
            return e
        }
    };
    var Xr = n(361)
      , Jr = n(178)
      , Zr = n(9)
      , ei = n(17)
      , ti = n(32)
      , ni = n(1021)
      , ri = n(287)
      , ii = n(20);
    function oi(e, t) {
        const n = Object(ii.a)(e, null === t || void 0 === t ? void 0 : t.in);
        return n.setHours(23, 59, 59, 999),
        n
    }
    function si(e, t) {
        const n = Object(ii.a)(e, null === t || void 0 === t ? void 0 : t.in);
        return n.setDate(1),
        n.setHours(0, 0, 0, 0),
        n
    }
    var ai = n(42);
    function ci(e, t, n) {
        const r = Object(ii.a)(e, null === n || void 0 === n ? void 0 : n.in);
        if (isNaN(t))
            return Object(ai.a)((null === n || void 0 === n ? void 0 : n.in) || e, NaN);
        if (!t)
            return r;
        const i = r.getDate()
          , o = Object(ai.a)((null === n || void 0 === n ? void 0 : n.in) || e, r.getTime());
        o.setMonth(r.getMonth() + t + 1, 0);
        return i >= o.getDate() ? o : (r.setFullYear(o.getFullYear(), o.getMonth(), i),
        r)
    }
    function ui(e, t, n) {
        return Object(ai.a)((null === n || void 0 === n ? void 0 : n.in) || e, +Object(ii.a)(e) + t)
    }
    function li(e, t, n) {
        return ci(e, 12 * t, n)
    }
    var di = n(381);
    function hi(e, t) {
        const n = Object(ii.a)(e, null === t || void 0 === t ? void 0 : t.in)
          , r = n.getFullYear();
        return n.setFullYear(r + 1, 0, 0),
        n.setHours(23, 59, 59, 999),
        n
    }
    function fi(e, t) {
        const n = Object(ii.a)(e, null === t || void 0 === t ? void 0 : t.in)
          , r = n.getMonth();
        return n.setFullYear(n.getFullYear(), r + 1, 0),
        n.setHours(23, 59, 59, 999),
        n
    }
    function pi(e, t, n) {
        const r = Object(ii.a)(e, null === n || void 0 === n ? void 0 : n.in);
        return isNaN(t) ? Object(ai.a)((null === n || void 0 === n ? void 0 : n.in) || e, NaN) : t ? (r.setDate(r.getDate() + t),
        r) : r
    }
    function gi(e, t, n) {
        return pi(e, 7 * t, n)
    }
    var mi = n(102)
      , yi = n(91);
    function vi(e, t) {
        var n, r, i, o, s, a, c, u;
        const l = Object(yi.a)()
          , d = null !== (n = null !== (r = null !== (i = null !== (o = null === t || void 0 === t ? void 0 : t.weekStartsOn) && void 0 !== o ? o : null === t || void 0 === t || null === (s = t.locale) || void 0 === s || null === (a = s.options) || void 0 === a ? void 0 : a.weekStartsOn) && void 0 !== i ? i : l.weekStartsOn) && void 0 !== r ? r : null === (c = l.locale) || void 0 === c || null === (u = c.options) || void 0 === u ? void 0 : u.weekStartsOn) && void 0 !== n ? n : 0
          , h = Object(ii.a)(e, null === t || void 0 === t ? void 0 : t.in)
          , f = h.getDay()
          , p = 6 + (f < d ? -7 : 0) - (f - d);
        return h.setDate(h.getDate() + p),
        h.setHours(23, 59, 59, 999),
        h
    }
    var bi = n(71);
    function _i(e, t, n) {
        return ui(e, t * bi.c, n)
    }
    function Si(e, t) {
        const n = Object(ii.a)(e, null === t || void 0 === t ? void 0 : t.in);
        return n.setMinutes(0, 0, 0),
        n
    }
    function Oi(e, t) {
        const n = Object(ii.a)(e, null === t || void 0 === t ? void 0 : t.in);
        return n.setMinutes(59, 59, 999),
        n
    }
    function Ti(e, t, n) {
        const r = Object(ii.a)(e, null === n || void 0 === n ? void 0 : n.in);
        return r.setTime(r.getTime() + t * bi.d),
        r
    }
    function Ii(e, t) {
        const n = Object(ii.a)(e, null === t || void 0 === t ? void 0 : t.in);
        return n.setSeconds(0, 0),
        n
    }
    function xi(e, t) {
        const n = Object(ii.a)(e, null === t || void 0 === t ? void 0 : t.in);
        return n.setSeconds(59, 999),
        n
    }
    function wi(e, t, n) {
        return ui(e, 1e3 * t, n)
    }
    var Mi = n(137);
    Date.prototype.stdTimezoneOffset = function() {
        const e = new Date(this.getFullYear(),0,1)
          , t = new Date(this.getFullYear(),6,1);
        return Math.max(e.getTimezoneOffset(), t.getTimezoneOffset())
    }
    ,
    Date.prototype.isDstObserved = function() {
        return this.getTimezoneOffset() < this.stdTimezoneOffset()
    }
    ;
    const Ai = function() {
        let e = "Etc/GMT";
        const t = t => t && t !== e ? Object(Mi.c)(new Date, t) : new Date
          , n = (t, n) => n && n !== e ? Object(Mi.b)(t, n) : t;
        try {
            e = Intl.DateTimeFormat().resolvedOptions().timeZone
        } catch (a) {}
        const r = (e, r) => (i, o) => {
            const s = t(o)
              , a = s.getDay();
            return a > e ? s.setDate(s.getDate() - (a - e)) : a < e && s.setDate(s.getDate() + (e - a)),
            s.setDate(s.getDate() + 7 * i),
            n(r ? Object(ri.a)(s) : !1 === r ? oi(s) : s, o)
        }
          , i = (e, r) => (r && e--,
        (r, i) => {
            let o = si(ci(t(i), r));
            const s = e * (Object(ni.a)(o) / 4) * 864e5;
            return n(ui(o, s), i)
        }
        )
          , o = {
            [Jr.a.X_YEAR]: (e, r) => n(li(t(r), e), r),
            [Jr.a.X_YEAR_BEGIN]: (e, r) => n(Object(di.a)(li(t(r), e)), r),
            [Jr.a.X_YEAR_END]: (e, r) => n(hi(li(t(r), e)), r),
            [Jr.a.X_MONTH]: (e, r) => n(ci(t(r), e), r),
            [Jr.a.X_MONTH_BEGIN]: (e, r) => n(si(ci(t(r), e)), r),
            [Jr.a.X_MONTH_END]: (e, r) => n(fi(ci(t(r), e)), r),
            [Jr.a.X_WEEK]: (e, r) => n(gi(t(r), e), r),
            [Jr.a.X_WEEK_BEGIN]: (e, r) => n(Object(mi.a)(gi(t(r), e)), r),
            [Jr.a.X_WEEK_END]: (e, r) => n(vi(gi(t(r), e)), r),
            [Jr.a.X_DAY]: (e, r) => n(pi(t(r), e), r),
            [Jr.a.X_DAY_BEGIN]: (e, r) => n(Object(ri.a)(pi(t(r), e)), r),
            [Jr.a.X_DAY_END]: (e, r) => n(oi(pi(t(r), e)), r),
            [Jr.a.X_HOUR]: (e, r) => n(_i(t(r), e), r),
            [Jr.a.X_HOUR_BEGIN]: (e, r) => n(Si(_i(t(r), e)), r),
            [Jr.a.X_HOUR_END]: (e, r) => n(Oi(_i(t(r), e)), r),
            [Jr.a.X_MINUTE]: (e, r) => n(Ti(t(r), e), r),
            [Jr.a.X_MINUTE_BEGIN]: (e, r) => n(Ii(Ti(t(r), e)), r),
            [Jr.a.X_MINUTE_END]: (e, r) => n(xi(Ti(t(r), e)), r),
            [Jr.a.X_SECOND]: (e, r) => n(wi(t(r), e), r)
        };
        o[Jr.a.X_MONTH_WEEK_1_BEGIN] = o[Jr.a.X_MONTH_BEGIN],
        o[Jr.a.X_MONTH_WEEK_1_END] = i(1, !1),
        o[Jr.a.X_MONTH_WEEK_4_BEGIN] = i(4, !0),
        o[Jr.a.X_MONTH_WEEK_4_END] = o[Jr.a.X_MONTH_END];
        for (let c = 2; c < 4; c++)
            o[Jr.a["X_MONTH_WEEK_".concat(c, "_BEGIN")]] = i(c, !0),
            o[Jr.a["X_MONTH_WEEK_".concat(c, "_END")]] = i(c, !1);
        const s = ["SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY"];
        for (let c = 0; c < 7; c++)
            o[Jr.a["X_".concat(s[c])]] = r(c),
            o[Jr.a["X_".concat(s[c], "_BEGIN")]] = r(c, !0),
            o[Jr.a["X_".concat(s[c], "_END")]] = r(c, !1);
        return o
    }()
      , Ei = /^\d{10,13}$/;
    function Ci(e, t, n, r) {
        return Ai[e] ? "number" !== typeof t || Ei.test(t) ? r && t instanceof Date ? t.toISOString() : t : (t = Ai[e](t, n),
        r ? t.toISOString() : t) : t
    }
    function Ni(e, t, n) {
        return Ei.test(t) ? t : Ai[e](t, n)
    }
    const Ri = Ai;
    function Pi(e, t) {
        if (Jr.b[e])
            return 0;
        if (t.DATE_TIME_TYPE)
            switch (t.DATE_TIME_TYPE) {
            case xn.B.TIMESTAMP:
                return Date.now();
            case xn.B.TIMESTAMP_SECONDS:
                return Math.round(Date.now() / 1e3);
            case xn.B.DATE_TIME:
                return (new Date).toISOString();
            case xn.B.DATE:
                const e = (new Date).toISOString();
                return e.substring(0, e.indexOf("T"));
            case xn.B.TIME:
                const t = (new Date).toISOString();
                return t.substring(t.indexOf("T") + 1);
            default:
                return null
            }
        else
            switch (t.KIND) {
            case ei.a.INT:
                return t.baseName === xn.B.MODEL_ID ? null : t.min > 0 ? t.min : t.max < 0 ? t.max : 0;
            case ei.a.BOOLEAN:
                return !1;
            default:
                return null
            }
    }
    const Di = (e, t, n) => {
        const r = Fi(e)
          , i = e.types.get(r);
        if (!i) {
            if (n)
                throw new Error("The `".concat(r, '` has not been defined, unable to use recursive filter "').concat(t, '"'));
            return null
        }
        const o = i.getInternalValue(t);
        if (o)
            return o;
        if (n)
            throw new Error('The recursive filter "'.concat(t, '" is not registered in the `').concat(r, "`. Unable to use recursive filter."));
        return null
    }
      , Fi = e => e.model.schema.getRecursiveQueryFilterEnumName()
      , ki = {
        [Yt]: (e, t) => e.query.recursiveFilterValue.checkRecord(t, e.variables),
        [Wt]: (e, t, n) => e.query.recursiveFilterValue(e, t, n),
        [Ht]: () => !0,
        [Kt]: (e, t, n) => e.variables[e.query.recursiveFilterValue](e, t, n)
    };
    function ji(e) {
        if (e.query.recursiveFilterType !== Kt)
            return;
        const {query: {recursiveFilterValue: t}, variables: n} = e;
        if (!n || !n[t])
            throw new Error('The variable "'.concat(t, '" representing the recursive filter function was not provided.'));
        e.query.recursiveFilter = Di(e.query, t, !0)
    }
    var Li = n(382);
    const {ENUM: Vi} = ei.a
      , Ui = (e, t, n) => 'Invalid graphql value for field "'.concat(t, '" on model "').concat(e.modelName, '". Expected ').concat(n.toString(), ", got: undefined")
      , qi = (e, t) => {
        for (let n of t)
            if (n.name === e)
                return !0;
        return !1
    }
      , Qi = (e, t, n) => {
        if ("orderBy" === e) {
            const e = []
              , {orderBy: n} = t;
            let r;
            for (let t of n)
                r = {
                    path: Object(Zr.e)(t.path),
                    type: Object(Zr.c)(t.type)
                },
                t.nulls && (r.nulls = Object(Zr.c)(t.nulls)),
                e.push(r);
            return Object(Zr.e)(e)
        }
        let r, i, o;
        switch (e) {
        case "limit":
            i = t.limitParam,
            r = t.getLimit(n),
            o = "number" === typeof t.limit ? t.limit : void 0;
            break;
        case "offset":
            i = t.offsetParam,
            r = t.getOffset(n),
            o = "number" === t.offset ? t.offset : void 0;
            break;
        default:
            throw new Error('Unrecognized pagination key: "'.concat(e, '". Expected "limit", "offset", or "orderBy".'))
        }
        return Array.isArray(n) && (qi(i, n) || n.push({
            name: i,
            type: Object(Zr.j)(xn.p),
            defaultValue: o
        }),
        r = Object(Zr.k)(i)),
        Object(Zr.b)(r)
    }
      , Bi = e => e.VFName
      , Gi = e => e.isDistinct ? "".concat(e.methodName, "Distinct") : e.methodName
      , zi = e => {
        if (!e.path)
            return [e.name];
        const t = e.path.map(Bi);
        return t.push(e.name),
        t
    }
    ;
    function Hi(e, t) {
        const n = e.length
          , r = new Array(n)
          , i = Array.isArray(t);
        let o, s, a, c = 0;
        for (; c < n; ) {
            switch (o = e[c],
            s = Object(he.B)(o),
            s) {
            case he.g:
                a = {
                    field: Object(Zr.e)(zi(o))
                };
                break;
            case he.h:
                a = {
                    group: Object(Zr.e)(Hi(o, t))
                };
                break;
            case he.m:
                i && o.valueParam ? (qi(o.valueParam, t) || t.push({
                    name: o.valueParam,
                    type: Object(Zr.j)(o.query.model.types.get(Xr.a.QUERY_CALC_VALUE).toString())
                }),
                a = {
                    value: Object(Zr.k)(o.valueParam)
                }) : a = {
                    value: o.getRealValue(t)
                };
                break;
            case he.f:
                a = {
                    [Gi(o)]: Object(Zr.e)(Hi(o, t))
                };
                break;
            default:
                throw new Error("Unrecognized calc arg: ".concat(s))
            }
            o.op && (a.operator = o.op),
            r[c] = Object(Zr.g)(a),
            c++
        }
        return r
    }
    function Ki(e, t, n) {
        const {queryArgs: r, fields: i} = e
          , o = r ? r.length : void 0
          , s = Array.isArray(t);
        let a, c, u;
        if (o) {
            let n, o;
            a = [];
            let l, d, h, f, p, g, m = !1;
            for (n of r) {
                if (Object(he.Y)(n)) {
                    if (!n.VF.ownModelVFApiRead) {
                        a.length && "or" === n.join && (m = "or");
                        continue
                    }
                    g = n.getMethodName(m),
                    p = "exists" === n.op ? {
                        [n.VFName]: null,
                        _OPERATOR_: Object(Zr.c)(Object(je.g)("exists"))
                    } : {
                        [n.VFName]: Object(Zr.e)(Ki(n.query, t, !0))
                    }
                } else if (Object(he.K)(n)) {
                    if (g = "".concat(n.getMethodName(m), "Group"),
                    p = Ki(n.query, t, !0),
                    !p) {
                        a.length && "or" === n.join && (m = "or");
                        continue
                    }
                } else {
                    if (g = n.getMethodName(m),
                    ({key: l} = n),
                    !(o = i[l]) || !o.apiRead) {
                        a.length && "or" === n.join && (m = "or");
                        continue
                    }
                    if (({op: d, value: h, valueParam: f} = n),
                    p = void 0,
                    u = o.type,
                    f && s)
                        qi(f, t) || t.push({
                            name: f,
                            type: "in" === d ? Object(Zr.d)(u.toString()) : Object(Zr.j)(u.toString())
                        }),
                        c = Object(Zr.k)(f);
                    else if (Jr.b[f]) {
                        if (c = t[f],
                        "string" !== typeof c)
                            throw new Error(Ui(e, l, u))
                    } else if ("like" === d || "rlike" === d)
                        f && (h = n.getRealValue(t),
                        ({op: d} = n)),
                        p = {
                            [l]: null,
                            _OPERATOR_: Object(Zr.c)(d),
                            _VALUE_EXPRESSION_: "like" === d ? h.__likeExp : h.toString()
                        };
                    else if (f && (h = t[f]),
                    "in" === d) {
                        if (h.indexOf(void 0) > -1)
                            throw new Error(Ui(e, l, u));
                        c = Object(Zr.e)(u.serializeMany(h), u.KIND === Vi)
                    } else {
                        if ("undefined" === typeof h)
                            throw new Error(Ui(e, l, u));
                        c = u.KIND === Vi ? Object(Zr.c)(u.serialize(h)) : u.serialize(h)
                    }
                    p || (d = Object(je.g)(d),
                    p = {
                        [l]: c
                    },
                    "eq" !== d && (p._OPERATOR_ = Object(Zr.c)(d))),
                    n.path && (p._PATH_ = Object(Zr.e)(n.path)),
                    p = Object(Zr.g)(p)
                }
                a.push({
                    [g]: p
                }),
                m = ""
            }
            a.length || (a = void 0)
        }
        if (n)
            return a;
        const {pagination: l, queryHaving: d, recursiveVF: h} = e;
        if (!l && !d && !h)
            return a ? {
                query: a
            } : void 0;
        const f = a ? {
            query: a
        } : {};
        if (l && (l.hasLimit && (f.limit = Qi("limit", l, t)),
        l.hasOffset && (f.offset = Qi("offset", l, t)),
        l.hasOrderBy && (f.orderBy = Qi("orderBy", l, t))),
        d && d.length && (f.havingArgs = function e(t, n) {
            const r = t.length
              , i = Array.isArray(n)
              , o = new Array(r);
            let s, a, c, u = 0;
            for (; u < r; ) {
                switch (s = t[u],
                a = s.join ? "".concat(s.join, "Having") : "having",
                s.not && (a += "Not"),
                s.op) {
                case "in":
                    a += "In";
                    break;
                case "exists":
                    a += "Exists"
                }
                Object(he.I)(s) ? (a += "Group",
                c = {
                    [a]: Object(Zr.e)(e(s, n))
                }) : (c = {
                    [Gi(s)]: Object(Zr.e)(Hi(s, n))
                },
                "=" !== s.op && (c.operator = Object(Zr.c)(Object(je.g)(s.op))),
                "exists" !== s.op && "isNull" !== s.op && (i && s.compareValueParam ? (qi(s.compareValueParam, n) || n.push({
                    name: s.compareValueParam,
                    type: "in" === s.op ? Object(Zr.d)(s.compareValueType.toString()) : Object(Zr.j)(s.compareValueType.toString())
                }),
                c.value = Object(Zr.k)(s.compareValueParam)) : (c.value = s.getRealValue(n),
                "in" === s.op && (c.value = Object(Zr.e)(c.value)))),
                c = {
                    [a]: Object(Zr.g)(c)
                }),
                o[u] = Object(Zr.g)(c),
                u++
            }
            return o
        }(d, t)),
        !h || !h.VFName || !h.ownModelVFApiRead)
            return f;
        const p = {
            on: Object(Zr.c)(h.VFName)
        };
        switch (e.recursiveUntilFound && (p.untilFound = Object(Zr.b)(!0)),
        e.recursiveStartValueInclude && (p.includeStart = Object(Zr.b)(!0)),
        e.recursiveStartValueType) {
        case zt:
            p.startValue = Object(Zr.e)(e.model.IDType.serializeMany(e.recursiveStartValue));
            break;
        case Gt:
            p.startQuery = Ki(e.recursiveStartValue, t);
            break;
        case Bt:
            s ? (qi(e.recursiveStartValue, t) || t.push({
                name: e.recursiveStartValue,
                type: Object(Zr.d)(e.model.IDType.toString())
            }),
            p.startValue = Object(Zr.k)(e.recursiveStartValue)) : p.startValue = Object(Zr.e)(e.model.IDType.serializeMany(t[e.recursiveStartValue]));
            break;
        default:
            throw console.log("query = ", e),
            new Error('Unrecognized `recursiveStartValueType` on query for model "'.concat(e.modelName, '": ').concat(e.recursiveStartValueType))
        }
        return e.recursiveFilterType === Ht ? (f.recurse = Object(Zr.g)(p),
        f) : (e.recursiveFilterType === Yt ? p.filterQuery = Object(Zr.e)(Ki(e.recursiveFilterValue, t, !0)) : (u = e.types.get(Fi(e))) && (e.recursiveFilterType !== Kt ? p.filter = Object(Zr.c)(u.serialize(e.recursiveFilterValue)) : s ? (qi(e.recursiveFilterValue, t) || t.push({
            name: e.recursiveFilterValue,
            type: u.toString()
        }),
        p.filter = Object(Zr.k)(e.recursiveFilterValue)) : p.filter = Object(Zr.c)(u.serialize(t[e.recursiveFilterValue]))),
        f.recurse = Object(Zr.g)(p),
        f)
    }
    function Yi(e, t, n) {
        if (!e)
            return t;
        let r, i;
        t || (t = []);
        for (let o in e)
            i = e[o],
            r = i.VF,
            r.ownModelVFApiRead && (i.query ? t.push(Zi(i.query, r.bestVFName, n, i.getGraphqlArgsQuery())) : t.push({
                name: r.bestVFName
            }));
        return t
    }
    const Wi = (e, t, n) => null === e || "undefined" === typeof e ? null : n ? Object(Zr.e)(t.serializeMany(e), t.KIND === Vi) : t.KIND === Vi ? Object(Zr.c)(t.serialize(e)) : t.serialize(e)
      , $i = {
        [Gr.a]: "apiCreate",
        [Gr.c]: "apiUpdate",
        [Gr.b]: "apiDelete"
    }
      , Xi = (e, t) => (e.isMutation && e.mutation && e.mutationType === Gr.c && e.mutation && e.mutation.isHistoryUpdateDisabled && (t || (t = []),
    t.push({
        name: fe.a.DISABLE_HISTORY_UPDATE,
        args: {}
    })),
    t)
      , Ji = (e, t, n) => {
        const {directives: r} = n || e;
        if (!r)
            return n ? void 0 : Xi(e);
        const {directiveVariables: i, directiveDefaults: o, definedDirectives: s} = n || e
          , a = []
          , c = Array.isArray(t)
          , u = n || !e.isMutation ? "apiRead" : $i[e.mutationType] || "apiRead";
        let l, d, h, f, p, g, m, y, v;
        for (let b in r)
            if (s[b][u])
                if (l = s[b].args,
                h = r[b],
                l) {
                    for (f in d = {},
                    g = i && i[b],
                    m = o && o[b],
                    h)
                        p = h[f],
                        ({type: y, isList: v} = l[f]),
                        g && g[f] ? c ? (qi(p, t) || t.push({
                            name: p,
                            type: v ? Object(Zr.d)(y.toString()) : Object(Zr.j)(y.toString()),
                            defaultValue: Jr.b[p] ? Ci(p, m[f], null, !0) : Wi(m[f], y, v)
                        }),
                        d[f] = Object(Zr.k)(p)) : Jr.b[p] ? d[f] = t[p] : d[f] = Wi(t[p], y, v) : d[f] = Wi(p, y, v);
                    a.push({
                        name: b,
                        args: d
                    })
                } else
                    a.push({
                        name: b,
                        args: h
                    });
        return n ? a : Xi(e, a)
    }
    ;
    function Zi(e, t, n, r) {
        const {querySelect: i, queryCalc: o, includeVFs: s} = e;
        let a, c = void 0;
        if (o)
            c = function(e, t, n) {
                const {queryCalc: r} = e;
                if (!r)
                    return t;
                let i, o;
                t || (t = []);
                for (let s of r)
                    o = s.methodName,
                    i = "field" === o ? [{
                        name: "arg",
                        value: Object(Zr.e)(zi(s[0]))
                    }] : [{
                        name: "args",
                        value: Object(Zr.e)(Hi(s, n))
                    }],
                    t.push({
                        name: s.isDistinct ? "".concat(s.methodName, "Distinct") : s.methodName,
                        directives: Ji(e, n, s),
                        alias: s.alias,
                        args: i
                    });
                return t
            }(e, c, n),
            c = Yi(s, c, n);
        else if (i) {
            c = [];
            const {fields: t} = e;
            let r;
            for (let o in i)
                t[o].apiRead && (r = i[o],
                a = Ji(e, n, r),
                c.push({
                    name: o,
                    directives: a,
                    alias: r.alias
                }));
            c = Yi(s, c, n)
        } else
            c = Yi(s, c, n);
        let u = function(e, t) {
            const n = Ki(e, t);
            if (!n)
                return;
            const r = [];
            for (let i in n)
                r.push({
                    name: i,
                    value: n[i]
                });
            return r
        }(r || e, n);
        if (e.isMutation) {
            let {graphqlPayload: t} = e;
            t && (u || (u = []),
            "string" === typeof t ? (n.push({
                name: "payload",
                type: e.mutationType === ti.d.CREATE && e.model.schema.createManyOp === e.mutationName ? Object(Zr.d)(t) : Object(Zr.j)(t),
                defaultValue: null
            }),
            u.push({
                name: "payload",
                value: Object(Zr.k)("payload")
            })) : u.push({
                name: "payload",
                value: t
            }),
            (t = e.graphqlPayloadTypes) && ("string" === typeof t ? (n.push({
                name: "payloadTypes",
                type: Object(Zr.j)(t),
                defaultValue: null
            }),
            u.push({
                name: "payloadTypes",
                value: Object(Zr.k)("payloadTypes")
            })) : u.push({
                name: "payloadTypes",
                value: t
            })))
        }
        return a = Ji(e, n),
        {
            name: t,
            args: u,
            selections: c,
            directives: a,
            alias: e.queryAlias
        }
    }
    function eo(e, t, n, r) {
        let i, o;
        if (e.queryHasVariables && !n && (n = []),
        "Subscription" === r) {
            if (({queryName: i} = e),
            e.queryCalc)
                i = e.model.schema.subscribeCalcOp;
            else if (i) {
                const t = e.model.schema;
                switch (i) {
                case t.queryOneOp:
                case t.subscribeOneOp:
                    i = t.subscribeOneOp;
                    break;
                default:
                    i = t.subscribeManyOp
                }
            } else
                i = e.model.schema.subscribeManyOp;
            e.queryName = i,
            o = Object(Zr.i)({
                name: i,
                selections: [Zi(e, i, n)],
                variables: Array.isArray(n) ? n : void 0
            })
        } else if ("Mutation" === r) {
            if (!(i = e.mutationName))
                throw new Error("Unable to encode query for model ".concat(e.modelName, " as a graphql Mutation because it does not define a `mutationName`."));
            o = Object(Zr.f)({
                name: i,
                selections: [Zi(e, i, n)],
                variables: Array.isArray(n) ? n : void 0
            })
        } else {
            ({queryName: i} = e);
            const t = e.model.schema;
            if (i)
                if (e.queryCalc)
                    i = t.queryCalcOp;
                else
                    switch (i) {
                    case t.queryOneOp:
                    case t.queryManyOp:
                        break;
                    default:
                        i = t.queryManyOp
                    }
            else
                i = e.queryCalc ? t.queryCalcOp : t.queryManyOp;
            e.queryName = i,
            o = Object(Zr.h)({
                name: i,
                selections: [Zi(e, i, n)],
                variables: Array.isArray(n) ? n : void 0
            })
        }
        return t ? !0 === t ? Object(de.a)(Object(Zr.a)([o])) : Object(Li.a)(Object(de.a)(Object(Zr.a)([o])), t) : Object(Zr.a)([o])
    }
    var to = n(865)
      , no = n(286)
      , ro = n(1018);
    const io = {
        avg: !0,
        avgDistinct: !0,
        calc: !0,
        concat: !0,
        count: !0,
        countDistinct: !0,
        count_weekdays: !0,
        count_workdays: !0,
        field: !0,
        min: !0,
        max: !0,
        median: !0,
        stdDev: !0,
        sum: !0,
        sumDistinct: !0,
        variance: !0
    }
      , oo = {
        avg: !0,
        calc: !1,
        concat: !1,
        count: !0,
        count_weekdays: !1,
        count_workdays: !1,
        field: !1,
        min: !1,
        max: !1,
        median: !1,
        stdDev: !1,
        sum: !0,
        variance: !1
    }
      , so = {
        avg: !0,
        avgDistinct: !0,
        calc: !0,
        concat: !1,
        count: !1,
        countDistinct: !1,
        count_weekdays: !1,
        count_workdays: !1,
        field: !1,
        min: !1,
        max: !1,
        median: !0,
        stdDev: !0,
        sum: !0,
        sumDistinct: !0,
        variance: !0
    }
      , ao = function() {
        const e = {};
        for (let t in so)
            e[t] = !1;
        return e.count_weekdays = !0,
        e.count_workdays = !0,
        e
    }()
      , co = {}
      , uo = {};
    for (let jR in io)
        co[jR] = !1,
        uo[jR] = !0;
    co.calc = !0,
    co.concat = !0,
    uo.calc = !1,
    uo.concat = !1,
    uo.count_weekdays = !1,
    uo.count_workdays = !1,
    uo.field = !1;
    const lo = e => !0 === oo[e]
      , ho = e => !0 === io[e]
      , fo = e => {
        return t = e.name.value,
        ":".concat(t);
        var t
    }
      , po = e => t => So(t, e, !0)
      , go = {
        whereGroup: "where",
        whereNotGroup: "whereNot",
        orWhereGroup: "orWhere",
        orWhereNotGroup: "orWhereNot",
        andWhereGroup: "andWhere",
        andWhereNotGroup: "andWhereNot",
        whereExistsGroup: "whereExists",
        whereNotExistsGroup: "whereNotExists",
        orWhereExistsGroup: "orWhereExists",
        orWhereNotExistsGroup: "orWhereNotExists",
        andWhereExistsGroup: "andWhereExists",
        andWhereNotExistsGroup: "andWhereNotExists",
        havingGroup: "having",
        havingNotGroup: "havingNot",
        orHavingGroup: "orHaving",
        orHavingNotGroup: "orHavingNot",
        andHavingGroup: "andHaving",
        andHavingNotGroup: "andHavingNot",
        havingExistsGroup: "havingExists",
        havingNotExistsGroup: "havingNotExists",
        orHavingExistsGroup: "orHavingExists",
        orHavingNotExistsGroup: "orHavingNotExists",
        andHavingExistsGroup: "andHavingExists",
        andHavingNotExistsGroup: "andHavingNotExists"
    }
      , mo = (e, t) => {
        const n = Object.keys(t);
        let {name: r} = e;
        return r || (r = "myQuery"),
        'More than 1 "where/orWhere/(etc)" method found in a single query argument. Add additional methods as separate entries in the arguments list instead. Ex: '.concat(r, "(query: [ { ").concat(n[0], ": {} }, { ").concat(n[1], ": {} }, ... ]). Instead, got ").concat(r, "(query: [ { ").concat(n[0], ": {}, ").concat(n[1], ": {} }, ... ]).")
    }
      , yo = (e, t) => {
        let n, r, i, o, s;
        for (let a of t)
            for (n in r = 0,
            o = a.operator || null,
            a)
                if ("operator" !== n) {
                    if (r > 1)
                        throw new Error("More than 1 calc method argument provided in single Object.");
                    switch (i = a[n],
                    n) {
                    case "field":
                        e.field(i, o);
                        break;
                    case "value":
                        e.value(i, o);
                        break;
                    case "group":
                        e.group(e => yo(e, i), o);
                        break;
                    default:
                        if (!ho(n))
                            throw new Error("Unrecognized calc method argument: ".concat(n));
                        n.endsWith("Distinct") ? (s = !0,
                        n = n.replace("Distinct", "")) : s = !1,
                        e.method(n, e => yo(e, i), o, s)
                    }
                    r++
                }
    }
      , vo = e => t => {
        for (let n of e)
            _o(t, n)
    }
      , bo = (e, t, n, r) => {
        let i, o, s, a, c = 0;
        for (let u in t)
            if ("operator" !== u && "value" !== u) {
                if (0 !== c)
                    throw new Error("Only 1 having method should be provided.");
                if (!ho(u))
                    throw new Error("Unrecognized");
                o = t[u],
                a = t.operator ? Object(je.f)(t.operator) : "=",
                "field" !== u ? (u.endsWith("Distinct") ? (s = !0,
                i = u.replace("Distinct", "")) : (s = !1,
                i = u),
                e.getOrInitQueryHaving().addArg(i, e => yo(e, o), a, t.value, s, n, r),
                c++) : (e.getOrInitQueryHaving().addArg(u, o[0].field, a, t.value, !1, n, r),
                c++)
            }
    }
      , _o = (e, t) => {
        let n, r, i = 0;
        for (let o in t) {
            if (0 !== i)
                throw new Error("Only 1 having argument should be provided per Object.");
            if (go[o])
                e[go[o]](vo(t[o])),
                i++;
            else {
                switch (n = o.charAt(0),
                n) {
                case "o":
                    r = "or";
                    break;
                case "a":
                    r = "and";
                    break;
                default:
                    r = null
                }
                bo(e, t[o], o.indexOf("Not") > -1, r),
                i++
            }
        }
        return e
    }
    ;
    function So(e, t, n) {
        let r;
        if (n)
            r = t;
        else if (t.ID) {
            const {ID: n} = t;
            Array.isArray(n) ? e.whereIn(e.primaryKey, n) : e.where(e.primaryKey, n)
        } else
            r = t.query;
        if (r && r.length > 0) {
            const {virtualFields: t} = e;
            let n, i, o, s, a;
            for (let c of r)
                for (s in a = 0,
                c) {
                    if (1 === a)
                        throw new Error(mo(e, c));
                    if (i = go[s])
                        e = e[i](po(c[s]));
                    else if (c[s]._VALUE_EXPRESSION_) {
                        let t;
                        for (n in ({_VALUE_EXPRESSION_: t, ...o} = c[s]),
                        o)
                            "_OPERATOR_" !== n && "_PATH_" !== n && (o[n] = t);
                        e = e[s](o)
                    } else {
                        for (n in o = c[s],
                        o)
                            "_OPERATOR_" === n ? o[n] = Object(je.f)(o[n]) : "_PATH_" !== n && o[n] && t[n] && (o[n] = po(o[n]));
                        e = e[s](o)
                    }
                    a++
                }
        }
        if ("number" === typeof t.limit && e.limit(t.limit),
        "number" === typeof t.offset && e.offset(t.offset),
        t.recurse) {
            const n = t.recurse;
            e.recurseOn(n.on, n.filter ? n.filter : n.filterQuery ? e => So(e, n.filterQuery, !0) : void 0, !0 === n.untilFound),
            n.startValue ? n.includeStart ? e.startWith(n.startValue) : e.startFrom(n.startValue) : n.startQuery && (n.includeStart ? e.startWith(e => So(e, n.startQuery)) : e.startFrom(e => So(e, n.startQuery)))
        }
        const i = t.orderBy;
        if (i)
            for (let o of i)
                e.orderBy(o.path, o.type, o.nulls);
        return t.havingArgs ? function(e, t) {
            const {havingArgs: n} = t;
            if (!n || !n.length)
                return e;
            for (let r of n)
                _o(e, r);
            return e
        }(e, t) : e
    }
    const Oo = (e, t, n, r) => {
        if (!t || t.length < 1)
            return e;
        const {variableDefinitions: i, variableValues: o} = n
          , s = r && "string" !== typeof r;
        let a, c, u, l, d, h, f, p, g, m;
        for (let y of t)
            if (({name: {value: a}, arguments: c} = y),
            a !== fe.a.DISABLE_HISTORY_UPDATE) {
                for (u of (f = {},
                p = void 0,
                c))
                    ({name: {value: l}, value: d} = u),
                    i && Object(to.c)(d) ? (m = d.name.value,
                    h = ":" + m,
                    g = Object(to.a)(m, i),
                    "undefined" !== typeof g && (p ? p[l] = g.defaultValue.value : p = {
                        [l]: g.defaultValue.value
                    }),
                    f[l] = h) : Object(no.e)(f, u.name, u.value, o);
                r ? s ? r.addDirective(a, f, p) : e.addFieldDirective(r, a, f, p) : e = e.addDirective(a, f, p)
            } else
                e.isMutation && e.mutationType === ti.d.UPDATE && e.mutation.disableHistoryUpdate();
        return e
    }
      , To = (e, t, n, r, i) => {
        const o = t.arguments;
        if (!o || !o.length)
            return e;
        const {variableValues: s, variableDefinitions: a} = n;
        let c;
        if (a && a.length)
            c = fo;
        else if (s) {
            let t;
            for (let n in s)
                Jr.b[n] && "number" === typeof s[n] && ("undefined" === typeof t && (t = e.getTimeZone(i) || null),
                s[n] = Ci(n, s[n], t))
        }
        const u = {};
        let l;
        if (r) {
            for (let e of o)
                l = e.name && e.name.value,
                "args" !== l && "arg" !== l || (c ? u[l] = Object(no.d)(e.value, c) : Object(no.e)(u, e.name, e.value, s));
            return u
        }
        for (let d of o)
            switch (l = d.name && d.name.value,
            l) {
            case "query":
            case "havingArgs":
                if (!Object(to.b)(d.value))
                    continue;
            case "limit":
            case "offset":
            case "orderBy":
            case "recurse":
                c ? u[l] = Object(no.d)(d.value, c) : Object(no.e)(u, d.name, d.value, s)
            }
        return So(e, u)
    }
    ;
    function Io(e, t, n) {
        const {name: {value: r}, alias: i, selectionSet: o, directives: s} = t;
        return o ? e = e.include(r, e => (e = xo(e = To(e, t, n), o, n),
        e = Oo(e, s, n),
        i && e.useAlias(i.value),
        e)) : (e = e.select(r),
        e = Oo(e, s, n, r),
        i && e.aliasField(r, i.value)),
        e
    }
    function xo(e, t, n) {
        const {selections: r} = t;
        if (e.queryCalc) {
            const {queryCalc: t} = e;
            let i, o, s, a, c;
            for (let u of r)
                if (Object(no.c)(u)) {
                    if (({name: {value: i}, alias: s, directives: c} = u),
                    !ho(i))
                        throw new Error("Unrecognized calc method: ".concat(i));
                    s = s ? s.value : i,
                    (o = i.endsWith("Distinct")) && (i = i.replace("Distinct", "")),
                    t.addMethod(i, t => {
                        t.useAlias(s).distinct(o),
                        Oo(e, c, n, t),
                        a = To(e, u, n, !0),
                        "field" === i ? t.field(a.arg) : yo(t, a.args)
                    }
                    )
                }
            return e.isMutation && e.convertCalcToSelect(),
            e
        }
        for (let i of r) {
            if (!Object(no.c)(i))
                throw new Error("Parsing fragments not setup yet.");
            e = Io(e, i, n)
        }
        return e
    }
    function wo(e, t, n, r) {
        const i = n.fieldName || n.name.value
          , o = e.model.schema;
        i !== o.queryCalcOp && i !== o.subscribeCalcOp || e.getOrInitQueryCalc(),
        t.directives && (e = Oo(e, t.directives, n)),
        e.isMutation && e.mutationType === ti.d.CREATE || (e = To(e, t, n, !1, r)),
        t.selectionSet && (e = xo(e, t.selectionSet, n));
        const {name: {value: s}, alias: a} = t;
        return e.queryName = s,
        a && e.useAlias(a.value),
        e
    }
    const Mo = {
        toGraphql: function(e, t) {
            return eo(this, e, t)
        },
        toGraphqlSubscription: function(e, t) {
            return eo(this, e, t, "Subscription")
        },
        fromGraphqlArgs: function(e) {
            return So(this, e),
            this
        },
        fromGraphqlRootQuery: function(e, t) {
            return wo(this, e.fieldNodes[0], e, t),
            this
        },
        fromGraphqlRootMutation: function(e) {
            return wo(this, e.fieldNodes[0], e),
            this
        },
        fromGraphql: function(e, t) {
            return function(e, t, n) {
                "string" === typeof t && (t = Object(ro.a)(t));
                const r = Object(no.b)(t);
                if (!r)
                    throw new Error("Invalid graphql Document.");
                const {selectionSet: {selections: i}} = r;
                for (let o of i)
                    wo(e, o, r, n)
            }(this, e, t),
            this
        }
    }
      , Ao = (e, t) => {
        if (e.length !== t.length)
            return !0;
        for (let n = 0; n < e.length; n++)
            if (e[n] !== t[n])
                return !0;
        return !1
    }
    ;
    class Eo {
        constructor(e, t, n) {
            if (this.query = e,
            this.limitParam = t || "limit",
            this.offsetParam = n || "offset",
            e.isIncludeQuery) {
                const r = e.parentQueryArg.VF;
                t || (this.limitParam = Object(ve.c)(this.limitParam, r.VFName)),
                n || (this.offsetParam = Object(ve.c)(this.offsetParam, r.VFName))
            }
            e.queryHasVariables = !0
        }
        merge(e) {
            e.hasLimit && (this.limit = e.limit,
            this.limitParam = e.limitParam),
            e.hasOffset && (this.offset = e.offset,
            this.offsetParam = e.offsetParam);
            const {orderBy: t} = e;
            if (t)
                if (this.orderBy)
                    for (let n of t)
                        this.addOrderBy(n.path, n.type);
                else
                    this.orderBy = [...e.orderBy];
            return this
        }
        clone(e) {
            const t = new this.constructor(e);
            for (let n in this)
                switch (n) {
                case "query":
                case "pages":
                    continue;
                case "orderBy":
                    t[n] = this[n] ? [...this[n]] : null;
                    break;
                default:
                    t[n] = this[n]
                }
            return t
        }
        getLimit(e) {
            return e && "number" === typeof e[this.limitParam] ? e[this.limitParam] : this.limit
        }
        setLimit(e) {
            return this.hasLimit || (this.defaultLimit = e),
            this.limit = e,
            this
        }
        getOffset(e) {
            return e && "number" === typeof e[this.offsetParam] ? e[this.offsetParam] : this.offset
        }
        setOffset(e) {
            return this.hasOffset || (this.defaultOffset = e),
            this.offset = e,
            this
        }
        getOrderBy() {
            return this.orderBy
        }
        addOrderBy(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc"
              , n = arguments.length > 2 ? arguments[2] : void 0;
            const r = Array.isArray(e) ? e : [e];
            let {orderBy: i} = this;
            if (i) {
                for (let e of i)
                    if (!Ao(e.path, r))
                        return e.type !== t && (e.type = t),
                        e.nulls !== n && (e.nulls = n),
                        this;
                i.push({
                    path: r,
                    type: t,
                    nulls: n
                })
            } else
                this.orderBy = [{
                    path: r,
                    type: t,
                    nulls: n
                }];
            return this
        }
        setOrderBy(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc"
              , n = arguments.length > 2 ? arguments[2] : void 0;
            return this.orderBy = null,
            this.addOrderBy(e, t, n)
        }
        isDifferentThan(e, t) {
            if (Object(he.B)(e) !== he.u)
                return !0;
            if (!t && (this.limit !== e.limit || this.offset !== e.offset || this.limitParam !== e.limitParam || this.offsetParam !== e.offsetParam))
                return !0;
            const {orderBy: n} = this
              , r = e.orderBy;
            if (!n || !r)
                return !(!n && !r);
            for (let s = 0; s < n; s++)
                if (i = n[s],
                o = r[s],
                i.type !== o.type || i.nulls !== o.nulls || Ao(i.path, o.path))
                    return !0;
            var i, o;
            return !1
        }
        destroy() {
            this.query = void 0,
            this.limit = void 0,
            this.offset = void 0
        }
        get hasLimit() {
            return !0
        }
        get hasOffset() {
            return !0
        }
        get hasOrderBy() {
            return !!this.orderBy
        }
    }
    Object(he.z)(Eo, he.u);
    const Co = {
        _updatePagination: function(e, t, n, r) {
            if (this.parentPropsMap.pagination)
                this.parent._updatePagination(e, t, n);
            else
                switch (e) {
                case "limit":
                    this.getOrInitPagination().setLimit(t);
                    break;
                case "offset":
                    this.getOrInitPagination().setOffset(t);
                    break;
                case "orderBy":
                    this.getOrInitPagination().addOrderBy(t, n, r);
                    break;
                default:
                    throw new Error("Unknown pagination key: " + e + '. Expected "limit", "offset", or "orderBy".')
                }
            return this
        },
        limit: function(e) {
            return this._updatePagination("limit", e),
            this
        },
        offset: function(e) {
            return this._updatePagination("offset", e),
            this
        },
        orderBy: function(e, t, n) {
            return this._updatePagination("orderBy", e, t, n),
            this
        },
        getOrInitPagination: function() {
            return this.pagination || (this.pagination = new Eo(this))
        },
        addPaginationFromQuery: function(e, t) {
            if (this.parentPropsMap.pagination)
                this.parent.addPaginationFromQuery(e, t);
            else {
                let t = e.pagination;
                t && (this.pagination ? this.pagination.merge(t) : this.pagination = t.clone(this))
            }
            return this
        },
        mergePagination: function(e) {
            return this.parentPropsMap.pagination ? this.parent.mergePagination(e) : e && (this.pagination ? this.pagination.merge(e) : this.pagination = e.clone(this)),
            this
        }
    }
      , No = {
        hasLimit: {
            get() {
                return !!this.pagination && this.pagination.hasLimit
            },
            set: void 0,
            configurable: !0
        },
        hasOffset: {
            get() {
                return !!this.pagination && this.pagination.hasOffset
            },
            set: void 0,
            configurable: !0
        },
        hasOrderBy: {
            get() {
                return !!this.pagination && this.pagination.hasOrderBy
            },
            set: void 0,
            configurable: !0
        }
    };
    var Ro = n(97);
    const {LOCAL_SUBSCRIBE: Po, SUBSCRIBE: Do} = ye
      , {PAYLOAD: Fo} = ge
      , {OBJECT_RESP: ko} = me
      , jo = (e, t) => ("boolean" !== typeof e.permCheck && (e.permCheck = t ? t.permCheck : "undefined" !== typeof e.userRole),
    e.permCheck ? (t ? ("undefined" === typeof e.userRole && (e.userRole = t.userRole),
    "undefined" === typeof e.permQueryFor && (e.permQueryFor = t.permQueryFor)) : (e.userRole || (e.userRole = null),
    e.permQueryFor || (e.permQueryFor = null)),
    "undefined" === typeof e.permRecField && (e.permRecField = e.query.model.schema.permRecRead ? Ro.a.PERM_REC_READ : null),
    e) : ("undefined" === typeof e.permRecField && (e.permRecField = null),
    e));
    function Lo(e, t, n, r) {
        t ? (e.responseFormat = t,
        e.responseFormatType = n || ko) : e.responseFormat ? e.responseFormatType || (e.responseFormatType = ko) : r ? (e.responseFormat = r.responseFormat,
        e.responseFormatType = r.responseFormatType) : (e.responseFormat = Fo,
        e.responseFormatType = ko)
    }
    const Vo = {
        setPayloadAction: function(e, t, n) {
            const r = e.parent;
            if (n)
                if (r)
                    r.query.setPayloadAction(r, t, !0);
                else {
                    const n = t.meta;
                    e.dispatchId = n.mainDispatchId,
                    e.bestMeta = n,
                    e.setAction && (e.setAction(t),
                    e.setAction = null)
                }
            else {
                if (t.payload !== e)
                    throw new Error("Invalid arguments were provided.");
                {
                    e.action = t;
                    const n = t.meta;
                    e.model = n.pendingInstance,
                    r ? r.query.setPayloadAction(r, t, !0) : (e.dispatchId = n.mainDispatchId,
                    e.bestMeta = n),
                    e.setAction && (e.setAction(t),
                    e.setAction = null)
                }
            }
            return e
        },
        preparePayload: function(e, t, n, r) {
            if (e) {
                let i = e.parent;
                if (i) {
                    if (!i.__didPrepare) {
                        const {__didPrepare: o} = e;
                        if (i.query.preparePayload(i, t, n, r),
                        !o && e.__didPrepare)
                            return e
                    }
                    e.hasAggregate = i.hasAggregate,
                    e.method = r || (e.method || i.method),
                    e.variables = i.variables,
                    e.graphqlContext = i.graphqlContext,
                    e.forSubscription = i.forSubscription,
                    jo(e, i),
                    "boolean" !== typeof e.isLocalOnly && (e.isLocalOnly = i.isLocalOnly || !1),
                    Lo(e, t, n, i),
                    i.children ? i.children[this.parentQueryArgIdx] = e : i.children = {
                        [this.parentQueryArgIdx]: e
                    },
                    e.originalQuery || !1 === e.originalQuery || function(e, t) {
                        const n = t.parent;
                        let r = n.originalQuery;
                        if (r) {
                            const i = r.getChildQueryArg(e);
                            i === e.parentQueryArg ? !1 === t.originalQuery ? t.query = e : (t.originalQuery = e,
                            t.query = n.query.getChildQueryArg(e).query) : i ? (t.originalQuery = i.query,
                            t.query = e) : (t.originalQuery || (t.originalQuery = !1),
                            t.query = e)
                        } else
                            !1 === r ? (t.originalQuery || (t.originalQuery = !1),
                            t.query = e) : (t.originalQuery = void 0,
                            t.query = e)
                    }(this, e)
                } else
                    e.hasAggregate = !!(this.queryHaving || this.queryCalc && this.queryCalc.hasAggregate),
                    e.method = r || (e.method || null),
                    ({method: r} = e),
                    e.graphqlContext = e.graphqlContext || null,
                    "boolean" !== typeof e.forSubscription && (!r || r !== Do && r !== Po ? e.forSubscription = !1 : (e.forSubscription = !0,
                    e.isLocalOnly = r === Po)),
                    "boolean" !== typeof e.isLocalOnly && (e.isLocalOnly = !1),
                    e.originalQuery || !1 === e.originalQuery ? e.query || (e.query = this) : (e.originalQuery = void 0,
                    e.query = this),
                    jo(e),
                    Lo(e, t, n),
                    e.mutation ? e.dispatchId = e.mutation.mainDispatchId : e.dispatchId ? e.dispatchId = this.model._getMainDispatchId(e.dispatchId) : e.model ? e.dispatchId = e.model.__dispatchId : e.dispatchId = this.model.__dispatchId,
                    this.queryHasVariables && (e.variables = this.prepareVariables(e.variables, e) || {})
            } else
                e = {
                    query: this,
                    hasAggregate: !!(this.queryHaving || this.queryCalc && this.queryCalc.hasAggregate),
                    originalQuery: void 0,
                    responseFormat: t || Fo,
                    responseFormatType: n || ko,
                    method: r || null,
                    dispatchId: this.model.__dispatchId,
                    graphqlContext: null,
                    permCheck: !1,
                    permRecField: null
                },
                !r || r !== Do && r !== Po ? (e.forSubscription = !1,
                "boolean" !== typeof e.isLocalOnly && (e.isLocalOnly = !1)) : (e.forSubscription = !0,
                e.isLocalOnly = r === Po),
                this.queryHasVariables && (e.variables = this.prepareVariables(e.variables, e) || {});
            if (e.isServer = this.isServer,
            e.__didPrepare = !0,
            e.query.includeVFs) {
                const i = e.query.includeVFs;
                let o, s = e.children;
                s || (e.children = s = {});
                for (let a in i)
                    o = s[a],
                    (!o || !o.__didPrepare || r && o.method !== r) && (o = i[a].getQueryPayload(e),
                    o.query.preparePayload(o, t, n, r))
            }
            return e
        },
        prepareVariables: function(e, t) {
            if (e) {
                let n, r;
                for (const i in e)
                    Ri[i] && ("number" === typeof e[i] ? (r || (n = this.getTimeZone(t),
                    r = {
                        ...e
                    },
                    t && (t.hasRelativeDateTimeVariable = !0,
                    t.variablesOrig || (t.variablesOrig = e))),
                    r[i] = Ni(i, e[i], n)) : t && (t.hasRelativeDateTimeVariable = !0));
                return r || e
            }
            return null
        }
    };
    var Uo = n(343)
      , qo = n(277);
    const Qo = {
        read: "permRecRead",
        update: "permRecUpdate",
        delete: "permRecDelete"
    }
      , Bo = {
        read: "hasPermRecReadArgs",
        update: "hasPermRecUpdateArgs",
        delete: "hasPermRecDeleteArgs"
    }
      , Go = {
        read: Ro.a.PERM_REC_READ,
        update: Ro.a.PERM_REC_UPDATE,
        delete: Ro.a.PERM_REC_DELETE
    }
      , zo = ["read"]
      , Ho = [];
    let Ko = 0;
    class Yo {
        constructor(e) {
            this.permEnum = e,
            this._set = new Set
        }
        reset(e) {
            return this._set.clear(),
            this.init(e)
        }
        init(e) {
            if (e)
                for (let t of e)
                    this._set.add(t);
            return this
        }
        checkin() {
            return this._set.clear(),
            Ho[Ko] = this,
            Ko++,
            Yo
        }
        getBest(e) {
            return "function" === typeof (e = Uo.a.CURRENT_USER) ? e : this.permEnum.getInternalValue(e) || e
        }
        has(e) {
            return this._set.has(this.getBest(e))
        }
        hasEntityArg() {
            return this._set.has("current_entity")
        }
        add(e) {
            return this._set.add(this.getBest(e))
        }
        delete(e) {
            return this._set.delete(this.getBest(e))
        }
        getValues() {
            return this._set
        }
        [Symbol.iterator]() {
            return this._set[Symbol.iterator]()
        }
    }
    Yo.checkout = function(e, t) {
        return Ko > 1 ? (Ko--,
        Ho[Ko].init(t)) : new this(e.types.get(qo.a.PERMISSION_USER_CAN)).init(t)
    }
    ;
    const Wo = {
        addPermArgs: function(e, t, n) {
            const r = !n;
            let i = this;
            if (!this.isGroupedQuery) {
                t || (t = zo);
                let o, s, a = !1;
                this.isIncludeQuery && (a = !0,
                i = this.parentQueryArg.getGroupedQuery());
                for (let c of t)
                    if (!this[Bo[c]]) {
                        if (o || (o = this.model.schema),
                        this[Bo[c]] = !0,
                        a) {
                            let e = this;
                            for (; e = e.parent; )
                                (s = e.model.schema[Qo[c]]) && (n || (n = Yo.checkout(this)),
                                n.add(s));
                            if (!(s = o[Qo[c]]))
                                continue;
                            i || (i = this.parentQueryArg.getGroupedQuery(!0))
                        } else if (!(s = o[Qo[c]])) {
                            console.log("NO ".concat(c, " permRec method for model ").concat(o.name));
                            continue
                        }
                        if (n || (n = Yo.checkout(this)),
                        !n.has(s)) {
                            if (s.buildQuery && !s.buildQuery(i, e, n))
                                return console.log("GOT NULL FROM buildQuery()"),
                                r && n.checkin(),
                                null;
                            n.add(s)
                        }
                        i.maybeConvertToGroupedQuery().andWhereNot(Go[c], Uo.a.NEVER)
                    }
                if (!o)
                    return this
            }
            if (i && i.queryHasVFArg) {
                const {queryArgs: r} = i;
                let o, s = Yo.checkout(this, n), a = 0;
                for (let i of r)
                    if (o = i.query)
                        switch (i.argsGroupIdx !== a && (a = i.argsGroupIdx,
                        s.reset(n)),
                        Object(he.B)(i)) {
                        case he.d:
                        case he.b:
                            if (!o.addPermArgs(e, t, n))
                                return console.log("GOT NULL FROM CHILD QUERY = ", i),
                                s.checkin(),
                                null
                        }
                s.checkin()
            }
            return r && n && (n.checkin(),
            console.log("query = ", this)),
            this
        },
        checkQueryPerm: function(e, t, n) {
            const {userRole: r} = e;
            let i;
            if (!this.isGroupedQuery) {
                if (i = this.model.schema,
                !i.permRead(r, e, this))
                    return !1;
                const t = this.directives;
                if (t) {
                    const n = this.definedDirectives;
                    let i, o, s, a;
                    for (let c in t) {
                        if (a = n[c],
                        o = a.args,
                        i = t[c],
                        !a.permUse(r, e, i))
                            return !1;
                        if (o)
                            for (s in i)
                                if (!o[s].permUse(r, e, i[s]))
                                    return !1
                    }
                }
            }
            const o = this.queryArgs;
            if (o && o.length) {
                const i = this.fields;
                let s, a;
                for (s of o) {
                    switch (a = s[he.q],
                    a) {
                    case he.c:
                        if (!i[s.key].permRead(r, e, s))
                            return !1;
                        break;
                    case he.b:
                        s.query && (t = s.query.checkQueryPerm(e, t, n));
                        break;
                    case he.d:
                        s.query && (t = s.query.checkQueryPerm(e, t, n || s.VFName))
                    }
                    if (!1 === t)
                        return !1
                }
            }
            if (i) {
                if (!n)
                    return t || !0;
                i.permRecRead && (t ? t.indexOf(n) < 0 && t.push(n) : t = [n])
            }
            return t
        },
        permDenied: function(e, t) {
            const n = e.extensions;
            return n && (n.statusCode = 403,
            n.statusMessage = t || "Permission Denied."),
            bn(e),
            this
        }
    };
    function $o(e, t, n) {
        let r;
        if (Array.isArray(e))
            for (let i of e)
                r = $o(i, t, n);
        else if ("string" !== typeof e)
            r = e;
        else if (!(r = t.virtualFields[e]))
            throw new Error("The virtualField ".concat(e, ' does not exist on the model "').concat(t.modelName, '". Ensure a valid path is provided when using pluck.'));
        return n.push(r),
        r
    }
    const Xo = new Set;
    function Jo(e, t, n) {
        if (n) {
            const n = {};
            let r;
            for (let i in t)
                r = t[i].alias || i,
                n[r] = e[r];
            return n
        }
        let r, i, o = void 0;
        for (let s in t)
            r && (i = {
                [r]: o
            },
            r = void 0),
            i ? i[t[s].alias || s] = e[s] : (r = t[s].alias || s,
            o = e[s]);
        return i || o
    }
    function Zo(e) {
        if (e) {
            let t, n = 0;
            for (let r in e)
                if (t = e[r],
                n++,
                n > 1)
                    break;
            return 1 === n ? t : e
        }
        return e
    }
    const es = e => e && 1 === Object.keys(e).length;
    function ts(e, t, n, r, i, o, s) {
        const a = t[n]
          , c = t[++n];
        let u, l, d;
        if (o && (u = o.queryArgs,
        d = o.querySelect,
        l = c && o.includeVFs ? o.includeVFs[c.bestVFName] : null),
        a.isMany) {
            const o = l ? l.query : null
              , h = a.ownRefModelPk
              , f = c ? c.bestVFName : null;
            let p, g, m = !1, y = !1;
            i ? es(d) && (m = !0) : (y = !0,
            p = !1);
            for (let a in e)
                !(g = e[a]) || u && !u.checkRecord(g, s) || (c || !r && !(r = {}) ? (y || (p = "undefined" !== typeof g[f],
                y = !0),
                g = p ? g[f] : c.get(i ? g.__record : g),
                g && (r = ts(g, t, n, r, p, o, s))) : i ? r[g.__record[h]] = g : r[g[h]] = m ? Jo(g, d) : g);
            return r
        }
        if (u && !u.checkRecord(e, s))
            return r;
        if (c || !r && !(r = {})) {
            if (i) {
                const t = e[c.bestVFName];
                if ("undefined" === typeof t)
                    e = c.get(e.__record),
                    i = !1;
                else {
                    if (!t)
                        return r;
                    e = t
                }
            } else
                e = c.get(e);
            return e ? ts(e, t, n, r, i, l ? l.query : null, s) : r
        }
        return i ? r[e.__record[a.ownRefModelPk]] = e : r[e[a.ownRefModelPk]] = es(d) ? Jo(e, d) : e,
        r
    }
    const ns = {
        pluck: function(e) {
            const t = this.parent;
            if (t) {
                if (this.isIncludeQuery) {
                    const t = this.parentQueryArg;
                    Array.isArray(e) ? e.unshift(t.VFName) : e = [t.VFName]
                }
                t.pluck(e)
            } else
                Array.isArray(e) && 0 !== e.length ? this.pluckPathVFs = function(e, t) {
                    let n, r = t;
                    const i = [];
                    for (let o of e)
                        n = $o(o, r, i),
                        r = n.ownRefModel;
                    return i
                }(e, this.model) : this.pluckPathVFs = [];
            return this
        },
        getPluckResults: function(e, t, n) {
            if (!n && !(n = this.pluckPathVFs))
                return e;
            let r = null
              , i = !1;
            if (0 === n.length) {
                const t = this.querySelect;
                if (!t)
                    return e;
                if (!e)
                    return null;
                if (Array.isArray(e)) {
                    r = [],
                    i = Object(he.V)(e[0]);
                    for (let n of e)
                        Xo.add(Jo(n, t, i));
                    r = [...Xo],
                    Xo.clear()
                } else if ((i = Object(he.V)(e)) || Object(he.U)(e))
                    r = Jo(e, t, i);
                else {
                    let n, o = !1;
                    r = {};
                    for (let s in e)
                        n = e[s],
                        o || (o = !0,
                        i = Object(he.V)(n)),
                        r[s] = Jo(n, t, i)
                }
                return r
            }
            const o = n[0]
              , s = this.includeVFs && this.includeVFs[o.bestVFName];
            let a, c = s ? s.query : null;
            if (Array.isArray(e)) {
                if (Object(he.V)(e[0]))
                    if (c) {
                        const t = o.bestVFName;
                        for (let i of e)
                            (a = i[t]) && (r = ts(a, n, 0, r, !0, null, null))
                    } else
                        for (let t of e)
                            (a = o.get(t.__record)) && (r = ts(a, n, 0, r, !1, null, null));
                else
                    for (let i of e)
                        (a = o.get(i)) && (r = ts(a, n, 0, r, !1, c, t));
                if (!r)
                    return null;
                for (let e in r)
                    Xo.add(r[e]);
                return r = [...Xo],
                Xo.clear(),
                r
            }
            if (Object(he.U)(e))
                return (a = o.get(e)) && (r = ts(a, n, 0, r, !1, c, t)),
                Zo(r);
            if (Object(he.V)(e))
                return c ? (a = e[o.bestVFName]) && (r = ts(a, n, 0, r, !0, null, null)) : (a = o.get(e.__record)) && (r = ts(a, n, 0, r, !1, null, null)),
                Zo(r);
            {
                let s, u, l = !0;
                const d = o.bestVFName;
                for (let h in e)
                    u = e[h],
                    l && (Object(he.V)(u) && (i = !0,
                    s = !!c,
                    c = null),
                    l = !1),
                    s ? (a = u[d]) && (r = ts(a, n, 0, r, !0, null, null)) : (a = o.get(i ? u.__record : u)) && (r = ts(a, n, 0, r, !1, c, t));
                return r
            }
        }
    }
      , rs = (e, t, n) => (n ? n.indexOf(t) < 0 && n.push(t) : n = [t],
    n)
      , is = e => e.records
      , os = (e, t) => {
        e.records ? e.records[t.__ID] = t : e.records = {
            [t.__ID]: t
        }
    }
      , ss = {
        addToPayload: os,
        addToNext: rs,
        getResult: is,
        getNext: (e, t, n) => {
            if (!t)
                return n || null;
            const {query: r} = e;
            for (let i in t)
                n = r.parseRecursiveRespSingle(e, t[i], n);
            return n
        }
        ,
        isRaw: !1,
        isAsync: !0
    }
      , as = (e, t, n) => {
        if (!t)
            return null;
        const {query: r} = e;
        for (let i in t)
            r.parseRecursiveRespSingle(e, t[i], n)
    }
      , cs = {
        [ye.FIND]: ss,
        [ye.FETCH]: ss,
        [ye.FETCH_RAW]: {
            addToPayload: (e, t) => {
                e.resp ? e.resp.push(t) : e.resp = [t]
            }
            ,
            addToNext: rs,
            getResult: e => {
                let {resp: t} = e;
                return t && t.length ? t : null
            }
            ,
            getNext: (e, t, n) => {
                if (!t || !t.length)
                    return n || null;
                const {query: r} = e;
                for (let i of t)
                    n = r.parseRecursiveRespSingle(e, i, n);
                return n
            }
            ,
            isRaw: !0,
            isAsync: !0
        },
        [ye.GET]: {
            addToPayload: os,
            getResult: is,
            isAsync: !1,
            isRaw: !1,
            getNext: as,
            addToNext: (e, t, n) => {
                let r = n.get(t);
                return r ? e.query.recursiveVF.isMany ? as(e, r.getState(), n) : e.query.parseRecursiveRespSingle(e, r, n) : null
            }
        }
    }
      , us = e => cs[e]
      , ls = "recursiveFieldValueInternal"
      , ds = ":".concat(ls)
      , hs = (e, t) => t ? e ? e.indexOf(t) < 0 ? (e.push(t),
    e) : e : [t] : e
      , fs = (e, t) => {
        let n;
        if (e.recursiveStartValueInclude)
            n = e.primaryKey;
        else {
            if (!e.recursiveVF)
                throw new Error("Unless using `startWith()`, the virtual field to recurse on must be set prior to providing record(s) or using a query to retrieve the desired record(s). Otherwise, the correct value cannot be known.");
            n = e.recursiveVF.ownFieldName
        }
        let r = void 0;
        if (Object(he.U)(t))
            r = hs(r, t[n]);
        else {
            let e = 0;
            for (let i in t) {
                if (0 === e) {
                    if (!Object(he.U)(t[i])) {
                        const {records: e} = t;
                        if (e)
                            for (i in e)
                                r = hs(r, e[i][n]);
                        break
                    }
                    e++
                }
                r = hs(r, t[i][n])
            }
        }
        if (!r)
            throw new Error("One or more start values are required to execute a query recursively.");
        return e.recursiveStartValue = r,
        e.recursiveStartValueType = zt,
        e
    }
      , ps = (e, t) => ({
        dispatchId: e.dispatchId,
        mutation: e.mutation,
        model: e.model,
        setAction: e.setAction,
        variables: t || e.variables,
        responseFormat: ge.PAYLOAD,
        responseFormatType: me.OBJECT_RESP
    });
    function gs(e, t) {
        return t && !e.dispatchId && (e.dispatchId = t,
        e.model = e.model.getBestInstance(t),
        e.query.model = e.model),
        e
    }
    const ms = (e, t) => {
        switch (typeof t) {
        case "string":
            const n = At(t);
            return n ? (e.recursiveStartValue = n,
            e.recursiveStartValueType = Bt,
            e.queryHasVariables = !0) : (e.recursiveStartValue = [e.model.IDType.parseValue(t)],
            e.recursiveStartValueType = zt),
            e;
        case "number":
            return e.recursiveStartValue = [e.model.IDType.parseValue(t)],
            e.recursiveStartValueType = zt,
            e;
        case "function":
            const r = e.model.query();
            let i = t(r);
            if (!r.closed)
                return e.recursiveStartValue = r,
                e.recursiveStartValueType = Gt,
                e;
            if (!i)
                throw new Error("Start values are required.");
            return "object" !== typeof i ? ms(e, i) : Array.isArray(i) ? (e.recursiveStartValue = i,
            e.recursiveStartValueType = zt,
            e) : fs(e, i);
        case "boolean":
            throw new Error('Boolean "'.concat(t, '" is not a valid recursive start value.'));
        default:
            if (Object(he.T)(t))
                e.recursiveStartValue = t,
                e.recursiveStartValueType = Gt,
                t.queryHasVariables && (e.queryHasVariables = !0);
            else {
                if (!Array.isArray(t))
                    return fs(e, t);
                {
                    const n = e.model.IDType;
                    for (let e = 0; e < t.length; e++)
                        t[e] = n.parseValue(t[e]);
                    e.recursiveStartValue = t,
                    e.recursiveStartValueType = zt
                }
            }
            return e
        }
    }
      , ys = (e, t) => (t.queryArgs && t.queryArgs.destroy(),
    t.whereIn(e.recursiveVF.otherFieldName, ds),
    t)
      , vs = (e, t, n) => {
        if (!t)
            return null;
        if (e.query.recursiveStartValueInclude)
            return ( (e, t, n) => {
                const {model: r, query: i} = e
                  , o = us(e.method)
                  , s = r.getState();
                if (o.isAsync) {
                    const {primaryKey: o} = r;
                    return n.whereIn(o, t),
                    n[e.method](ps(e)).pipe(Object(Y.a)(t => (gs(e, t.dispatchId),
                    ys(i, n),
                    t)))
                }
                for (let a of t)
                    i.parseRecursiveRespSingle(e, s[a], n);
                return e
            }
            )(e, t, n);
        if (e.method !== ye.GET)
            return ys(e.query, n),
            e.variables[ls] = t,
            n[e.method](ps(e));
        {
            const {addToNext: r} = us(e.method);
            for (let i of t)
                r(e, i, n);
            return e
        }
    }
    ;
    function bs(e, t) {
        const n = e.query;
        switch (n.recursiveStartValueType) {
        case zt:
            return vs(e, n.recursiveStartValue, t);
        case Bt:
            let r = e.variables && e.variables[n.recursiveStartValue];
            if (!r)
                throw new Error('No recursiveStartValue variable provided for "'.concat(n.recursiveStartValue, '".'));
            return Array.isArray(r) || (r = [r]),
            vs(e, r, t);
        case Gt:
            const i = n.recursiveStartValue
              , o = us(e.method);
            if (!o.isAsync)
                return ( (e, t, n, r) => {
                    const {query: i} = e
                      , {records: o} = n.get(ps(e));
                    if (!o)
                        return null;
                    if (i.recursiveStartValueInclude)
                        r.getNext(e, o, t);
                    else {
                        const {ownFieldName: n} = i.recursiveVF
                          , s = r.addToNext;
                        let a;
                        for (let r in o)
                            (a = o[r][n]) && s(e, a, t)
                    }
                    return e
                }
                )(e, t, i, o);
            const s = n.recursiveVF;
            if (!i.queryCalc) {
                i.isFieldSelected(s.ownFieldName) || i.select(s.ownFieldName),
                i.isFieldSelected(s.otherFieldName) || i.select(s.otherFieldName);
                const e = i.primaryKey;
                i.isFieldSelected(e) || i.select(e)
            }
            const a = i[e.method](ps(e));
            return ys(n, t),
            n.recursiveStartValueInclude ? a : a.pipe(Object(P.a)(r => {
                const i = o.getResult(r);
                if (!i)
                    return Object(V.a)(r);
                const {addToNext: s} = o
                  , {ownFieldName: a} = n.recursiveVF;
                let c, u = void 0;
                if (o.isRaw) {
                    for (let t of i)
                        (c = t[a]) && (u = s(e, c, u));
                    if (!u)
                        return r.resp = null,
                        Object(V.a)(r)
                } else {
                    for (let t in i)
                        (c = i[t][a]) && (u = s(e, c, u));
                    if (!u)
                        return r.records = null,
                        Object(V.a)(r)
                }
                return e.variables[ls] = u,
                gs(e, r.dispatchId),
                t[e.method](ps(e))
            }
            ))
        }
    }
    const _s = (e, t, n, r) => (e.closed || (e.model = t,
    e.recursiveVF = n,
    e.recursiveUntilFound = r),
    e);
    const Ss = (e, t) => {
        e.mutation ? e.query.getBestModel(e) : (e.mutation = e.query.model.mutation(fn(e)),
        e.model = e.mutation.model,
        e.dispatchId = e.mutation.mainDispatchId),
        t && t !== e && (t.mutation = e.mutation,
        t.model = e.model,
        t.query.model = e.model,
        t.dispatchId = e.dispatchId)
    }
      , Os = (e, t, n, r, i) => {
        const o = e.responseFormat
          , s = e.method === ye.FETCH_RAW
          , a = e.query
          , c = a.recursiveVF;
        let u;
        return a.recursiveVF = null,
        o === ge.RECORDS_RESULTS ? (e.filterResults = !1,
        u = a.get(e)) : (u = s ? e : wt[o][e.responseFormatType](e),
        a.maybeDestroy(e)),
        _s(a, r, c, i),
        t.destroy(),
        n || !e.mutation ? Object(V.a)(u) : e.mutation.execute().pipe(Object(Or.a)(u))
    }
    ;
    const Ts = {
        addRecursiveFromQuery: function(e) {
            return e.recursiveVF && !this.recursiveVF && this.isRootQuery ? (this.recursiveVF = e.recursiveVF,
            this.recursiveFilter = e.recursiveFilter,
            this.recursiveFilterType = e.recursiveFilterType,
            this.recursiveFilterType === Yt ? (this.recursiveFilterValue = e.recursiveFilterValue.clone(),
            e.recursiveFilterValue.queryHasVariables && (this.queryHasVariables = !0)) : this.recursiveFilterValue = e.recursiveFilterValue,
            this.recursiveUntilFound = e.recursiveUntilFound,
            this.recursiveStartValueType = e.recursiveStartValueType,
            this.recursiveStartValueType === Gt ? (this.recursiveStartValue = e.recursiveStartValue.clone(),
            e.recursiveStartValue.queryHasVariables && (this.queryHasVariables = !0)) : this.recursiveStartValue = e.recursiveStartValue,
            this.recursiveStartValueInclude = e.recursiveStartValueInclude,
            this) : this
        },
        closeRecursiveProps: function() {
            return this.recursiveVF ? (this.recursiveVF = void 0,
            this.recursiveFilterValue && this.recursiveFilterType === Yt && !this.recursiveFilterValue._noDestroy && this.recursiveFilterValue.destroy(),
            this.recursiveFilter = void 0,
            this.recursiveFilterValue = void 0,
            this.recursiveUntilFound = !1,
            this.recursiveStartValue && this.recursiveStartValueType === Gt && !this.recursiveStartValue._noDestroy && this.recursiveStartValue.destroy(),
            this.recursiveStartValue = void 0,
            this.recursiveStartValueType = void 0,
            this.recursiveStartValueInclude = !1,
            this) : this
        },
        getRecursive: function(e) {
            const t = e.query
              , n = t.recursiveVF
              , r = t.model
              , i = t.recursiveUntilFound;
            ji(e),
            e.responseFormatType === me.SINGLE_RESP && (t.recursiveUntilFound = !0),
            t.model = t.getBestModel(e),
            e.method = ye.GET,
            e.records = null,
            bs(e, n.getIndex(e.dispatchId)),
            e.filterResults = !1,
            t.recursiveVF = null;
            const o = t.get(e);
            return _s(t, r, n, i),
            o
        },
        findFetchRecursive: function(e) {
            const {method: t} = e;
            e.variables || (e.variables = {}),
            ji(e);
            const n = e.query
              , r = n.model
              , i = n.recursiveUntilFound;
            e.responseFormatType === me.SINGLE_RESP && (n.recursiveUntilFound = !0);
            const o = function(e) {
                const t = e.method === ye.FETCH_RAW
                  , n = e.query;
                if (t && (n.includeVFs || n.queryHasVFArg || n.queryHaving))
                    throw new Error("".concat(ye.FETCH_RAW, " does not support `includes`, virtual field arguments, or `having` clauses when executing recursively."));
                const r = n.recursiveVF
                  , i = n.clone().noDestroy(!0);
                return n.queryCalc || (i.selectAllArgs().select(n.primaryKey).select(r.ownFieldName).select(r.otherFieldName),
                t || e.method === ye.GET || i.prepareSelect()),
                i.recursiveVF = null,
                i.queryArgs && i.queryArgs.destroy(),
                i
            }(e);
            let s = !!e.mutation;
            const a = us(t);
            if (t === ye.FETCH)
                Ss(e);
            else {
                let r = e.setAction;
                e.setAction = n => {
                    t === ye.FIND ? Ss(n.payload, e) : gs(e, n.meta.mainDispatchId),
                    e.setAction = void 0,
                    r && (r(n),
                    r = void 0)
                }
                ,
                n.getBestModel(e)
            }
            const c = bs(e, o);
            if (null === c)
                return Os(e, o, s, r, i);
            const u = Object(P.a)(n => {
                e.dispatchId || gs(e, n.dispatchId);
                const c = a.getNext(e, a.getResult(n));
                return c ? (e.variables[ls] = c,
                o[t](ps(e)).pipe(u)) : Os(e, o, s, r, i)
            }
            );
            return c.pipe(u)
        },
        isRecursiveDifferentThan: function(e) {
            if (!this.recursiveVF || !e.recursiveVF)
                return !(!this.recursiveVF && !e.recursiveVF);
            if (this.recursiveVF !== e.recursiveVF || this.recursiveFilterType !== e.recursiveFilterType || !!this.recursiveUntilFound !== !!e.recursiveUntilFound || this.recursiveStartValueType !== e.recursiveStartValueType || !!this.recursiveStartValueInclude !== !!e.recursiveStartValueInclude)
                return !0;
            switch (this.recursiveStartValueType) {
            case Bt:
                if (this.recursiveStartValue !== e.recursiveStartValue)
                    return !0;
                break;
            case zt:
                const t = this.recursiveStartValue
                  , n = e.recursiveStartValue;
                if (t.length !== n.length)
                    return !0;
                for (let e = 0; e < t.length; e++)
                    if (t[e] !== n[e])
                        return !0;
                break;
            case Gt:
                if (this.recursiveStartValue.isDifferentThan(e.recursiveStartValue))
                    return !0
            }
            return this.recursiveFilterValue !== e.recursiveFilterValue && (this.recursiveFilterType !== Yt || this.recursiveFilterValue.isDifferentThan(e.recursiveFilterValue))
        },
        recurseOn: function(e, t, n) {
            if (!this.isRootQuery)
                return this;
            if (!e)
                return this.closeRecursiveProps();
            if (this.recursiveVF = this.virtualFields[e],
            !this.recursiveVF)
                throw new Error('The virtual field "'.concat(e, '" is not a recognized virtual field for the ').concat(this.modelName, " model. Unable to use it to `recurseOn()`."));
            if (!this.recursiveVF.isRecursive)
                throw new Error('The virtual field "'.concat(e, '" does not represent a recursive relationship. Unable to use it to `recurseOn()`.'));
            var r;
            return this.recursiveFilterValue = void 0,
            this.recursiveFilterType = Ht,
            "boolean" === typeof t ? this.recursiveUntilFound = t : (t && ( (e, t) => {
                if (Object(he.T)(t))
                    return e.recursiveFilterValue = t,
                    e.recursiveFilterType = Yt,
                    e;
                let n = typeof t;
                if ("string" === n) {
                    const n = At(t);
                    return n ? (e.recursiveFilterValue = n,
                    e.recursiveFilterType = Kt,
                    e) : (e.recursiveFilterValue = Di(e, t, !0),
                    e.recursiveFilterType = Wt,
                    e)
                }
                if ("function" !== n)
                    throw new Error('Expected recursive filter for query on model "'.concat(e.modelName, '" to be a string, function, or query. Got: ').concat(t));
                const r = Di(e, t);
                if (r)
                    return e.recursiveFilterValue = r,
                    e.recursiveFilterType = Wt,
                    e;
                const i = e.model.query();
                t(i),
                e.recursiveFilterValue = i,
                e.recursiveFilterType = Yt,
                i.queryHasVariables && (e.queryHasVariables = !0)
            }
            )(this, t),
            "boolean" === typeof n && (this.recursiveUntilFound = n)),
            this.recursiveFilter = (r = this.recursiveFilterType,
            ki[r]),
            this
        },
        untilFound: function(e) {
            return this.recursiveUntilFound = !1 !== e,
            this
        },
        startWith: function(e) {
            return this.recursiveStartValueInclude = !0,
            ms(this, e)
        },
        startFrom: function(e) {
            return this.recursiveStartValueInclude = !1,
            ms(this, e)
        },
        parseRecursiveRespSingle: function(e, t, n) {
            if (!t)
                return n;
            const r = cs[e.method];
            let i = !1;
            if (this.checkRecord(t, e.variables, e.dispatchId)) {
                if (r.addToPayload(e, t),
                this.recursiveUntilFound)
                    return null;
                i = !0
            } else if (null === n || this.recursiveUntilFound && r.getResult(e))
                return null;
            const o = t[this.recursiveVF.ownFieldName];
            return o && this.recursiveFilter(e, t, i) ? r.addToNext(e, o, n) : n
        }
    };
    const Is = new Set;
    const xs = {
        parseSelect: function(e) {
            if ("undefined" !== typeof e.parsedSelect)
                return e.parsedSelect;
            const {querySelect: t} = this;
            if (e.querySelectHasAlias = !1,
            e.querySelectHasLocalOnly = !1,
            !t)
                return e.parsedSelect = null,
                null;
            const {variables: n, userRole: r, extensions: i, permCheck: o} = e
              , {fields: s} = this;
            let a, c, u;
            for (let l in t)
                a = t[l],
                Er(a, n) && (u = s[l],
                u.isLocalOnly && (e.querySelectHasLocalOnly = !0),
                a.alias && (e.querySelectHasAlias = !0),
                !o || u.permRead(r, e, a) ? c ? c.push(a) : c = [a] : i && (i.permDeniedFields ? i.permDeniedFields.push(l) : i.permDeniedFields = [l]));
            return e.parsedSelect = c || null,
            c
        },
        checkRecordsForMissingSelect: function(e) {
            const {records: t} = e;
            if (!t)
                return e.missingSelect = null,
                null;
            const n = this.parseSelect(e);
            if (!n)
                return e.missingSelect = null,
                null;
            let r, i, o;
            for (let s in t)
                for (i of (o = t[s],
                n))
                    ({name: r} = i),
                    i && "undefined" === typeof o[r] && Is.add(r);
            return Is.size > 0 ? (e.missingSelect = [...Is],
            Is.clear(),
            e.missingSelect) : (e.missingSelect = null,
            null)
        },
        deSelectAll: function(e, t, n) {
            return this.selectAll(e, t, n, !0)
        },
        selectAll: function(e, t, n, r) {
            if (this.parentMethodsMap.select)
                return !0 === n && (n = [!0]),
                this.parent.selectAll(e, t, Ct(this, n), r),
                this;
            if (n && !0 !== n) {
                let i = !1;
                if ("boolean" === typeof n[n.length - 1] && (i = n.pop()),
                r) {
                    let e, t = 0, r = this;
                    for (; t < n.length; ) {
                        if (!(e = r.includeVFs) || !e[n[t]] || !(r = e[n[t]].query))
                            return this;
                        t++
                    }
                }
                return this.includeAtPath(n, ( (e, t, n, r) => i => {
                    let o = i.query;
                    o || (o = i.createQueryInstance()),
                    o.selectAll(e, t, n, r)
                }
                )(e, t, i, r), void 0, !0),
                this
            }
            const {fields: i} = this;
            let {querySelect: o} = this;
            if (!o) {
                if (r)
                    return this;
                o = {},
                this.querySelect = o
            }
            const s = this.constructor.SelectField;
            if (e)
                if (!0 === e ? e = this.model.isServer ? "inDatabase" : "apiRead" : "autoload" === e && (e = this.model.isServer ? "autoloadOnServer" : "autoloadOnClient"),
                "undefined" === typeof t && (t = !0),
                r) {
                    let n = null;
                    for (let r in o)
                        i[r][e] !== t ? (n || (n = {}),
                        n[r] = o[r]) : o[r].destroy();
                    this.querySelect = n
                } else
                    for (let a in i)
                        i[a][e] !== t || o[a] || (o[a] = s.init(this).field(a));
            else if (r) {
                for (let e in o)
                    o[e].destroy();
                this.querySelect = null
            } else
                for (let a in i)
                    o[a] || (o[a] = s.init(this).field(a));
            if (!0 === n && this.includeVFs) {
                const {includeVFs: i} = this;
                let o;
                for (let s in i)
                    (o = i[s].query) && o.selectAll(e, t, n, r)
            }
            return this
        },
        prepareSelect: function(e) {
            let t, n = !1;
            e ? (e.originalQuery || !1 === e.originalQuery || (n = !0),
            t = e.query) : t = this;
            const {model: r, querySelect: i} = t;
            if (i) {
                let o, s;
                for (o in i)
                    if (s = i[o],
                    s.alias) {
                        if (n) {
                            if (t.cloneForExecute(e) !== t)
                                return e.query.prepareSelect(e);
                            n = !1
                        }
                        s.alias = void 0
                    }
                const {autoloadFields: a} = r;
                for (o of a)
                    if (!i[o]) {
                        if (n) {
                            if (t.cloneForExecute(e) !== t)
                                return e.query.prepareSelect(e);
                            n = !1
                        }
                        t.select(o)
                    }
            } else {
                if (n && t.cloneForExecute(e) !== t)
                    return e.query.prepareSelect(e);
                t.selectAll("autoload")
            }
            if (!t.isServer && t.includeVFs) {
                const {includeVFs: n} = t;
                for (let t in n)
                    n[t].prepareSelect(e);
                return e ? e.query : t
            }
            return t
        },
        getOrInitQueryCalc: function() {
            if (!this.queryCalc) {
                this.queryCalc = new this.constructor.CalcSelect(this);
                const e = this.model.schema;
                this.queryName && this.queryName !== e.queryManyOp && this.queryName !== e.queryOneOp || (this.queryName = e.queryCalcOp),
                (this.querySelect || this.includeVFs) && this.queryCalc.addNonAggregatesFromQuery(this)
            }
            return this.queryCalc
        },
        calc: function(e) {
            return this.getOrInitQueryCalc().addMethod("calc", e),
            this
        },
        convertCalcToSelect: function(e, t) {
            if (this.parentMethodsMap.select)
                return this.parent.convertCalcToSelect(e, t),
                this;
            const {queryCalc: n} = this;
            if (!n)
                return this;
            let r;
            return Object(he.T)(e) ? r = e : (t = e,
            r = this),
            r === this && (this.queryCalc = void 0),
            n.convertToSelect(r, t),
            r === this && n.destroy(),
            this
        },
        selectMethod: function(e, t, n, r) {
            return this.getOrInitQueryCalc().addMethod(e, t, n, r),
            this
        },
        selection: function(e, t, n) {
            return this.getOrInitQueryCalc().addMethod("field", e, t, n),
            this
        },
        concat: function(e) {
            return this.getOrInitQueryCalc().addMethod("concat", e),
            this
        },
        count: function(e, t, n) {
            return this.getOrInitQueryCalc().addMethod("count", e, t, n),
            this
        },
        sum: function(e, t, n) {
            return this.getOrInitQueryCalc().addMethod("sum", e, t, n),
            this
        },
        avg: function(e, t, n) {
            return this.getOrInitQueryCalc().addMethod("avg", e, t, n),
            this
        },
        min: function(e, t, n) {
            return this.getOrInitQueryCalc().addMethod("min", e, t, n),
            this
        },
        max: function(e, t, n) {
            return this.getOrInitQueryCalc().addMethod("max", e, t, n),
            this
        },
        median: function(e, t, n) {
            return this.getOrInitQueryCalc().addMethod("median", e, t, n),
            this
        },
        stdDev: function(e, t, n) {
            return this.getOrInitQueryCalc().addMethod("stdDev", e, t, n),
            this
        },
        variance: function(e, t) {
            return this.getOrInitQueryCalc().addMethod("variance", e, t),
            this
        }
    };
    var ws = n(159)
      , Ms = n(231)
      , As = n(222);
    function Es() {
        for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t];
        var n = Number.POSITIVE_INFINITY
          , r = null
          , i = e[e.length - 1];
        return Object(Q.a)(i) ? (r = e.pop(),
        e.length > 1 && "number" === typeof e[e.length - 1] && (n = e.pop())) : "number" === typeof i && (n = e.pop()),
        null === r && 1 === e.length && e[0]instanceof S.a ? e[0] : Object(Ms.a)(n)(Object(As.a)(e, r))
    }
    var Cs = n(122)
      , Ns = n(29);
    const Rs = Object.prototype.propertyIsEnumerable
      , Ps = {
        enumerable: !1,
        configurable: !0,
        writable: !0
    };
    class Ds {
        constructor(e, t) {
            e && (t ? (this.state = t,
            this.size = Object.keys(t).length) : (this.state = {},
            this.size = 0),
            this.changes = void 0,
            this.hasCreate = !1,
            this.hasDelete = !1,
            this.pState = void 0,
            this.pChanges = void 0,
            this.pSize = void 0,
            this.hasPendingDelete = !1,
            this.store = void 0)
        }
        static init(e, t) {
            const n = new this(!0,t && t.state);
            return n.store = e,
            n
        }
        cloneNew() {
            const e = new this.constructor
              , {blacklistPropsCloneNew: t} = this.constructor;
            for (let n in this)
                t[n] || (e[n] = this[n]);
            return e.hasCreate = !1,
            e.hasDelete = !1,
            e
        }
        cloneState() {
            return {
                ...this.state
            }
        }
        getPendingChange(e) {
            return this.pChanges && this.pChanges[e]
        }
        hasPendingChange(e) {
            return !!this.getPendingChange(e)
        }
        isPendingDelete(e) {
            return this.pChanges && this.pChanges[e] === Ns.c
        }
        getPrev(e) {
            const t = this.getPrevState();
            return t ? t[e] : void 0
        }
        resetUndoRedo(e) {
            return this.store.undoStack ? ("redo" !== e && (this.store.undoStack.length = 0),
            "undo" !== e && (this.store.redoStack.length = 0),
            this) : this
        }
        undoable() {
            if (this.isUndoable)
                return this;
            const e = this.store.undoStack;
            return this.isUndoable = !0,
            e ? e[0] === this.state || (e.unshift(this.state),
            this.resetUndoRedo("redo")) : (this.store.undoStack = [this.state],
            this.store.redoStack = []),
            this
        }
        undo() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
            const {store: t} = this
              , n = t.undoStack;
            if (!n)
                return this;
            const r = e - 1
              , i = n[r];
            if (!i)
                return console.log("no new state here somehow..."),
                this;
            const o = t.redoStack;
            let s = 0;
            for (; s <= r; )
                o.push(n[s]),
                s++;
            this.isUndoable || o.push(this.state),
            n.splice(0, r + 1),
            this.setState(i, !0);
            const a = this.cloneNew();
            return this._doCommit(a),
            a.notify(),
            a
        }
        redo() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
            const {store: t} = this
              , n = t.redoStack;
            if (!n)
                return console.log("no redo state..."),
                this;
            const r = n.length - e
              , i = n[r];
            if (!i)
                return this;
            const o = t.undoStack;
            let s = n.length - 1;
            for (; s >= r; )
                o.unshift(n[s]),
                s--;
            n.splice(r);
            const a = this.get("query");
            this.setState(i, !0),
            console.log("queries equal = ", a === i.query);
            const c = this.cloneNew();
            return this._doCommit(c),
            c.notify(),
            console.log("new SV HERE = ", c),
            c
        }
        getFromHistory(e, t) {
            let n = this.getPrev(e);
            if ("undefined" !== typeof n && (!t || null !== n))
                return n;
            const r = this.history;
            if (r) {
                let i = r.length - 1;
                for (; i >= 0; ) {
                    if (n = r[i].state[e],
                    "undefined" !== typeof n && (!t || null !== n))
                        return n;
                    i--
                }
            }
        }
        get(e) {
            return this.pChanges ? this.pChanges[e] === Ns.c ? void 0 : this.pState[e] : this.state[e]
        }
        has(e) {
            return this.pChanges ? this.pChanges[e] !== Ns.c && Rs.call(this.pState, e) : Rs.call(this.state, e)
        }
        set(e, t) {
            let {pState: n, pChanges: r} = this;
            return n || (this.pState = n = this.cloneState(),
            this.pChanges = r = {},
            this.pSize = this.size),
            Rs.call(n, e) ? r[e] !== Ns.b && (r[e] = Ns.h) : (this.pSize++,
            r[e] = r[e] === Ns.c ? Ns.h : Ns.b),
            n[e] = t,
            t
        }
        delete(e) {
            let {pChanges: t} = this;
            if (t) {
                if (t[e] === Ns.c || !Rs.call(this.pState, e))
                    return !1
            } else {
                if (!Rs.call(this.state, e))
                    return !1;
                this.pState = this.cloneState(),
                this.pChanges = t = {},
                this.pSize = this.size
            }
            return this.pSize--,
            this.hasPendingDelete = !0,
            t[e] = Ns.c,
            Object.defineProperty(this.pState, e, Ps),
            !0
        }
        deleteAll() {
            let e, {pState: t} = this;
            t ? ({pChanges: e} = this) : (t = this.state,
            e = {});
            let n = !1;
            for (let r in t)
                e[r] = Ns.c,
                n = !0;
            return this.pState = {},
            this.pSize = 0,
            this.pChanges = e,
            n
        }
        getMutableKeyValue(e, t) {
            let n = this.get(e);
            return n && this.pChanges && this.pChanges[e] || (n = t ? n ? [...n] : [] : n ? {
                ...n
            } : {},
            this.set(e, n)),
            n
        }
        getPendingChangeType(e) {
            return this.pChanges ? this.pChanges[e] : void 0
        }
        _prepareCommitChanges(e) {
            const {pChanges: t} = this;
            let n;
            for (let r in t)
                n = t[r],
                n === Ns.b ? e.hasCreate = !0 : n === Ns.c && (e.hasDelete = !0);
            return e.changes = t,
            e.state = this.hasPendingDelete ? {
                ...this.pState
            } : this.pState,
            e.size = this.pSize,
            e
        }
        deReference() {
            if (this.__isNotifying)
                return void (this.__deReferenceAfterNotify = !0);
            const {deReferenceProps: e} = this.constructor;
            for (let t of e)
                this[t] = void 0
        }
        complete() {
            this.destroy()
        }
        destroy() {
            this.__isNotifying ? this.__destroyAfterNotify = !0 : (this.deReference(),
            this.state = void 0,
            this.changes = void 0)
        }
        _doCommit(e) {
            const {store: t} = this;
            this.pState && (this._prepareCommitChanges(e),
            this.pSize = void 0,
            this.pState = void 0,
            this.pChanges = void 0);
            const {history: n} = t;
            if (n.length < t.maxCacheSize)
                n.push(this);
            else {
                let e = 0;
                n[0].destroy();
                const t = n.length - 1;
                for (; e < t; )
                    n[e] = n[e + 1],
                    e++;
                n[e] = this
            }
            return t.value = e,
            this.deReference(),
            e
        }
        commit() {
            return this.__isNotifying ? (this.__commitAfterNotifying = !0,
            this) : this.pState || this.changes ? this._doCommit(this.cloneNew()) : this
        }
        commitAndNotify(e) {
            const t = this.commit();
            return t === this ? this : (t.runReducers(e),
            t.notify(),
            t)
        }
        runReducers(e) {
            const {store: {reducers: t}} = this;
            if (t)
                for (let n of t)
                    n(this, e)
        }
        notify() {
            this.changes && (this.__isNotifying = !0,
            this.store.next(this),
            this.__isNotifying = !1,
            this.__destroyAfterNotify ? this.destroy() : this.__deReferenceAfterNotify ? this.deReference() : this.__commitAfterNotifying && this.commitAndNotify())
        }
        setState(e, t) {
            const n = this.getState();
            for (let r in e)
                e[r] !== n[r] && this.set(r, e[r]);
            return !0 !== t ? this.commitAndNotify("boolean" === typeof t ? void 0 : t) : this
        }
        get history() {
            return this.store.history
        }
        get prevState() {
            return this.getPrevState()
        }
        getPrevState() {
            if (this.pChanges)
                return this.state;
            {
                const {history: e} = this
                  , t = e[e.length - 1];
                return t ? t.state : void 0
            }
        }
        getState() {
            return this.pState ? this.hasPendingDelete ? (this.pState = {
                ...this.pState
            },
            this.hasPendingDelete = !1,
            this.pState) : this.pState : this.state
        }
    }
    function Fs(e, t) {
        return new js(e,t)
    }
    Ds.deReferenceProps = ["store"],
    Ds.blacklistPropsCloneNew = {
        changes: !0,
        pState: !0,
        pChanges: !0,
        pSize: !0,
        hasPendingDelete: !0,
        isUndoable: !0,
        __isNotifying: !0,
        __deReferenceAfterNotify: !0,
        __destroyAfterNotify: !0,
        __commitAfterNotifying: !0
    },
    Object.defineProperties(Ds.prototype, {
        history: {
            enumerable: !1
        },
        prevState: {
            enumerable: !1
        }
    });
    const ks = Object.prototype.hasOwnProperty;
    class js extends U.a {
        constructor(e, t) {
            super(),
            !1 !== e && this._init(e, t)
        }
        _init(e, t, n) {
            let r, i, o, s, a, c;
            if (this.isMain = !0,
            e && ({Value: r, MainValue: i, mainReducers: o, maxCacheSize: s, reducers: a, storeConfig: c} = e),
            i && (r = i),
            o && (a = o),
            t) {
                if (c) {
                    const e = t.storeConfig;
                    if (e && e !== c)
                        for (let t in e)
                            ks.call(c, t) || (c[t] = e[t])
                } else
                    c = t.storeConfig;
                r || (r = t.value.constructor),
                s || (s = t.maxCacheSize),
                t.reducers && (a = a ? [...a, ...t.reducers] : [...t.reducers])
            }
            c && (this.storeConfig = c),
            this.value = r ? r.init(this, e) : n ? n.init(this, e) : Ds.init(this, e),
            this.maxCacheSize = s || 10,
            this.history = [],
            this.reducers = a
        }
        get(e) {
            return this.closed ? void 0 : this.value.get(e)
        }
        set(e, t) {
            if (!this.closed)
                return this.value.set(e, t)
        }
        getPrev(e) {
            return this.closed ? void 0 : this.value.getPrev(e)
        }
        has(e) {
            return !this.closed && this.value.has(e)
        }
        getState() {
            return this.closed ? void 0 : this.value.getState()
        }
        getPrevState() {
            return this.closed ? void 0 : this.value.getPrevState()
        }
        next(e) {
            this.value = e,
            super.next(e)
        }
        emitComplete() {
            this.closed || (super.complete(),
            this.isStopped = !1)
        }
        complete() {
            this.closed || (super.complete(),
            this.unsubscribe())
        }
        unsubscribe() {
            if (this.closed)
                return;
            super.unsubscribe();
            const e = this.history;
            if (e) {
                for (let t = 0, n = e.length; t < n; t++)
                    e[t].destroy(),
                    e[t] = void 0;
                this.history = void 0
            }
            this.value.complete(),
            this.value = void 0,
            this.reducers && (this.isMain || this.mainStore.pendingReducers !== this.reducers) && (this.reducers.splice(0),
            this.reducers = void 0),
            this.isMain && (this.storeConfig = void 0)
        }
        _addReducers(e, t) {
            let {[t]: n} = this;
            if (n) {
                if (Array.isArray(e)) {
                    let t = !1;
                    for (let r of e)
                        n.indexOf(r) < 0 && (n.push(r),
                        t = !0);
                    return t
                }
                return n.indexOf(e) < 0 && (n.push(e),
                !0)
            }
            return this[t] = Array.isArray(e) ? e : [e],
            !0
        }
        _removeReducers(e, t) {
            const {[t]: n} = this;
            if (n) {
                let t = !1;
                if (Array.isArray(e)) {
                    let r;
                    for (let i of e)
                        r = n.indexOf(i),
                        r > -1 && (n.splice(r, 1),
                        t = !0)
                } else {
                    const r = n.indexOf(e);
                    r > -1 && (n.splice(r, 1),
                    t = !0)
                }
                return t
            }
            return !1
        }
        addReducers(e, t, n) {
            if (!e)
                return !1;
            let {reducers: r} = this;
            return r ? t && r === this.mainStore.pendingReducers ? n : (t || !r || this.isMain || this.mainStore.pendingReducers !== r || (this.reducers = [...r]),
            this._addReducers(e, "reducers")) : (this.reducers = Array.isArray(e) ? e : [e],
            !0)
        }
        removeReducers(e, t, n) {
            let {reducers: r} = this;
            return !!r && (t && r === this.mainStore.pendingReducers ? n : (t || this.isMain || this.mainStore.pendingReducers !== r || (this.reducers = [...r]),
            this._removeReducers(e, "reducers")))
        }
        replaceReducers(e) {
            return this.reducers = e ? Array.isArray(e) ? e : [e] : void 0,
            !0
        }
        get changes() {
            return this.closed ? void 0 : this.value.changes
        }
        get size() {
            return this.closed ? 0 : this.value.size
        }
        getValue() {
            if (this.hasError)
                throw this.thrownError;
            if (this.closed)
                throw new Cs.a;
            return this.value
        }
        get observers() {
            return this._observers || []
        }
        set observers(e) {
            this._observers = e
        }
    }
    Object(he.z)(js, he.r.STATE_STORE);
    const Ls = (e, t, n) => {
        n || (n = {});
        for (let r in e)
            n[r] = t;
        return n
    }
      , Vs = (e, t, n) => {
        const {parsedSelect: r} = n;
        let i, o, s, a, c = null;
        for (i in r)
            a = r[i].name,
            o = e[a],
            s = t[a],
            o !== s && (c || (c = {}),
            c[a] = ws.a.UPDATED);
        if (!n.children)
            return c;
        const {children: u} = n;
        let l;
        for (let d in u)
            o = e[d],
            s = t[d],
            o && s ? (l = Object(he.V)(o) ? Vs(o, s, u[d]) : Us(o, s, u[d]),
            l && (c || (c = {})) && (c[d] = l)) : (o || s) && (c || (c = {}),
            c[d] = o ? ws.a.DELETED : ws.a.CREATED);
        return c
    }
      , Us = (e, t, n) => {
        if (!e || !t)
            return e || t ? e ? Ls(e, ws.a.DELETED) : Ls(t, ws.a.CREATED) : null;
        let r, i, o, s, a = null;
        for (r in e)
            i = e[r],
            (o = t[r]) ? (s = Vs(i, o, n)) && (a || (a = {}),
            a[r] = s) : (a || (a = {}),
            a[r] = ws.a.DELETED);
        for (r in t)
            (i = e[r]) || (a || (a = {}),
            a[r] = ws.a.CREATED);
        return a
    }
    ;
    var qs = n(394)
      , Qs = n(188);
    const Bs = (e, t) => {
        const n = t.mutation;
        return n ? n.switchTo(e) : (t.mutation = e.pluginMutation().commitOnly(!0),
        t.mutation.switchTo(e))
    }
    ;
    const Gs = {
        switchMapRecordsResp: function(e, t) {
            let n = void 0;
            return $(r => {
                if (console.log("RAW SUBSCRIPTION RESP = ", r),
                !r)
                    return null === n ? (console.log("NO RESP, AND ALREADY EMITTED NULL. RETURNING EMPTY"),
                    Xt.a) : (n = null,
                    Object(D.c)());
                const i = {
                    model: e.model,
                    query: e,
                    resp: r
                };
                e.model.Mutation.commitQueryPayload(i, Bs),
                n = i.records ? t ? Object.values(Object(he.D)(i.records))[0] : Object(he.D)(i.records) : null;
                const o = i.mutation;
                return o ? (console.log("PENDING RECORDS = ", i.records),
                console.log("MAIN RECORDS = ", n),
                console.log("MUTATION CHANGES = ", i.mutation),
                o.commitOnly(!1).execute(!0).pipe(Object(Or.a)(n))) : (console.log("NO SUBSCRIPTION, SO NOTHING CHANGED. Still emitting, since it could have already been committed"),
                Object(V.a)(n))
            }
            )
        },
        recordsSubFinalize: function(e, t, n) {
            return Object(ee.a)( () => {
                setTimeout( () => {
                    try {
                        e.query.destroy(e),
                        n || t.destroy()
                    } catch (r) {}
                }
                , 2e3)
            }
            )
        }
    }
      , zs = Object(P.a)(e => {
        if (!e.resp)
            throw new Error("Unable to establish websocket connection.");
        return e.resp
    }
    );
    const Hs = (e, t, n) => {
        let r;
        if (Array.isArray(e)) {
            for (let i of e)
                r = Hs(i, t, n);
            return r
        }
        if ("string" !== typeof e)
            r = e;
        else if (!(r = t.virtualFields[e]))
            throw new Error('The virtualField "'.concat(e, '" does not exist on the model ').concat(t.modelName, ". Unable to determine path."));
        return r.isMany && (n.isMany = !0),
        n.push(r),
        r
    }
    ;
    function Ks(e, t) {
        const n = [];
        n.isMany = !1;
        let r = e;
        for (let i of t)
            r = Hs(i, r, n).ownRefModel;
        return n
    }
    function Ys(e, t) {
        const n = t.length;
        let r, i = 0;
        for (; i < n && (r = e.virtualFields[t[i]]); )
            e = r.otherModel,
            i++;
        return e
    }
    const Ws = (e, t) => {
        const n = t => {
            $s(e, t.modelName, t.fieldName),
            $s(e, t.refModelName, t.refFieldName)
        }
        ;
        return e => {
            e.isManyToMany ? (n(e.ownModelThroughVF),
            n(e.otherModelThroughVF)) : n(e),
            t && (t[e.instanceId] = !0)
        }
    }
      , $s = (e, t, n) => (e[t] ? e[t][n] = !0 : e[t] = {
        [n]: !0
    },
    e)
      , Xs = (e, t, n) => {
        let r, i;
        for (let o of n)
            o.isParent ? Xs(e, t, o) : Object(he.G)(o) && ((r = o.path) && (i || (i = Ws(e, t)),
            r.map(i)),
            $s(e, o.modelName, o.name));
        return e
    }
    ;
    function Js(e, t, n) {
        t || (t = {});
        const {modelName: r} = e;
        let i;
        if (t[r] || (t[r] = {}),
        e.queryArgs) {
            const {queryArgs: o} = e;
            let s;
            for (let e of o)
                s = Object(he.B)(e),
                s === he.c ? $s(t, r, e.key) : (s === he.d && (i || (i = Ws(t, n)),
                i(e.VF)),
                e.query && Js(e.query, t, n))
        }
        if (e.querySelect) {
            const {querySelect: n} = e;
            for (let e in n)
                $s(t, r, e)
        }
        if (e.queryCalc && Xs(t, n, e.queryCalc),
        e.queryHaving && Xs(t, n, e.queryHaving),
        e.includeVFs) {
            const {includeVFs: r} = e;
            let i, o;
            for (let e in r)
                i = r[e],
                o = i.VF,
                $s(t, o.ownModelName, o.ownFieldName),
                $s(t, o.otherModelName, o.otherFieldName),
                n && (n[o.instanceId] = !0),
                i.query && Js(i.query, t, n)
        }
        if (e.pagination && e.pagination.hasOrderBy) {
            const {orderBy: r} = e.pagination
              , {model: s, fields: a} = e
              , c = e.modelName;
            let u, l;
            for (let e of r)
                if (e.path.length > 1) {
                    i || (i = Ws(t, n)),
                    u = [...e.path],
                    l = u.pop();
                    try {
                        u = Ks(s, u),
                        u.map(i),
                        $s(t, u[u.length - 1].otherModelName, l)
                    } catch (o) {}
                } else
                    a[e.path[0]] && $s(t, c, e.path[0])
        }
        return t
    }
    const {SUBSCRIBE: Zs, LOCAL_SUBSCRIBE: ea} = ye
      , {RECORDS: ta, RECORDS_RESULTS: na} = ge
      , {OBJECT_RESP: ra, SINGLE_RESP: ia} = me
      , oa = Object(Y.a)(e => e.size ? Object.values(e.getState()) : null)
      , sa = Object(Y.a)(e => e.size ? Object.values(e.getState())[0] : null)
      , aa = (e, t, n, r) => {
        const i = t.recordsResults
          , o = function(e, t, n) {
            return Us(e, t, n)
        }(e.recordsResults, i, e);
        if (!o)
            return null;
        for (let s in o)
            o[s] === ws.a.DELETED ? n.delete(s) : r ? n.set(s, i[s].__record) : n.set(s, i[s]);
        return o
    }
      , ca = e => {
        const {query: t} = e;
        if (t.queryCalc)
            return;
        t.querySelect || t.selectAll();
        const {children: n} = e;
        if (n)
            for (let r in n)
                ca(n[r])
    }
      , ua = e => {
        const t = {
            recordsResults: e.recordsResults,
            parsedSelect: e.parsedSelect
        };
        e.records = void 0,
        e.recordsResults = void 0,
        e.formattedResponse = void 0;
        const {children: n} = e;
        if (!n)
            return t;
        const r = {};
        t.children = r;
        for (let i in n)
            r[i] = ua(n[i]);
        return t
    }
    ;
    function la(e, t, n, r) {
        if (e && e.__didPrepare ? (e.method !== r && yn(e, "method", r),
        n && e.responseFormatType !== n && vn(e, t, n)) : e = this.preparePayload(e, t, n, r),
        r !== ea)
            return function(e, t) {
                const n = e.query;
                let r = n;
                r.noDestroy(!0);
                const i = r._noDestroy
                  , o = r.model.getMainInstance();
                r.model = o,
                e.variablesOrig && (e.variables = e.variablesOrig);
                const s = e.responseFormatType === me.SINGLE_RESP
                  , a = r.queryCalc && s
                  , c = Object(Y.a)(e => {
                    if (e.errors)
                        throw e.errors[0];
                    const t = e.extensions;
                    if (t && t.statusCode && 200 !== t.statusCode) {
                        const e = new Error("".concat(t.statusMessage || "Status code ".concat(t.statusCode)));
                        throw e.code = t.statusCode,
                        e
                    }
                    let n = e.data;
                    return n && (n = n[r.queryName]) ? a ? n[0] : n : null
                }
                );
                return e.responseFormat === ge.RECORDS ? Object(qs.a)( () => (r = n.cloneForExecute(e, !0).includeM2MThroughRecords(e).prepareSelect(e).noDestroy(),
                e.query = r,
                r.queryName = r.model.schema.subscribeManyOp,
                o.executeSubscription(e))).pipe(zs, c, Gs.switchMapRecordsResp(r, s), Gs.recordsSubFinalize(e, n, i)) : Object(qs.a)( () => o.executeSubscription(e)).pipe(zs, c, i ? Qs.a : Object(ee.a)( () => {
                    setTimeout( () => {
                        r.destroy(e)
                    }
                    , 2e3)
                }
                ))
            }(e);
        ca(e),
        ({responseFormat: t} = e);
        const {pluckPathVFs: i} = this
          , o = t !== na
          , s = this._noDestroy;
        let a, c, u, l = !1;
        const d = Object(H.a)( () => (l = !0,
        !1))
          , h = new S.a(t => {
            c = {
                variables: e.variables
            },
            this.noDestroy().getAll(c);
            let n = this.getModelsInArgs(!0, !0);
            n = this.getModelsInIncludes(!0, !0, n),
            n[this.modelName] = this.model.getMainInstance();
            for (let e in n)
                t.next(n[e]);
            if (!s)
                return () => {
                    this.destroy(c)
                }
        }
        ).pipe(Object(P.a)(e => {
            const t = e.subscribeToPkChanges();
            return t ? Es(e.subscribe(), t.pipe(d)) : e.subscribe()
        }
        ), Object(Y.a)(e => {
            if (!l && !e.__changes)
                return null;
            const {__changesDispatchId: t, __changesEvent: n} = e
              , r = "".concat(t, "_").concat(n);
            if (r === u)
                return null;
            l = !1,
            u = r;
            const i = ua(c);
            this.getAll(c);
            const s = aa(i, c, a.value, o);
            if (!s)
                return null;
            const d = a.value.commit();
            return d.allChanges = s,
            d.dispatchId = t,
            d.event = n,
            d.notify(),
            d
        }
        ));
        let f = new S.a(t => {
            a = Fs();
            let n = !1;
            const i = h.subscribe(e => {
                e && (n = !0,
                t.next(e))
            }
            )
              , {recordsResults: u} = c;
            if (u) {
                const e = a.value;
                for (let t in u)
                    e.set(t, o ? u[t].__record : u[t]);
                e.commit(),
                a.value.allChanges = a.value.changes
            }
            return r === ea ? t.next(a.value) : (this.queryName = void 0,
            this.find({
                variables: e.variables
            }).subscribe( () => {
                n || t.next(a.value)
            }
            )),
            () => {
                i.unsubscribe(),
                a.complete(),
                s || this.destroy(c)
            }
        }
        );
        if (e.responseFormatType === me.OBJECT_RESP) {
            if (i) {
                this.pluckPathVFs = null;
                const {variables: t} = e;
                return f.pipe(Object(Y.a)(e => e.size ? this.getPluckResults(e.getState(), t, i) : null))
            }
            return f
        }
        switch (e.responseFormatType) {
        case me.ARRAY_RESP:
            f = f.pipe(oa);
            break;
        case me.SINGLE_RESP:
            f = f.pipe(sa);
            break;
        default:
            throw new Error("Unrecognized responseFormatType: ".concat(e.responseFormatType))
        }
        if (i) {
            const {variables: t} = e;
            this.pluckPathVFs = null,
            f = f.pipe(Object(Y.a)(e => e ? this.getPluckResults(e, t, i) : null))
        }
        return f
    }
    const da = {
        localSubscribeToAllRecords: function(e) {
            return this.queryName = this.model.schema.subscribeManyOp,
            this.localSubscribe(e, ta, ra)
        },
        subscribe: function(e, t, n) {
            return this.parentMethodsMap.subscribe ? this.parent.subscribe(e, t, n) : la.call(this, e, t, n, Zs)
        },
        localSubscribe: function(e, t, n) {
            return this.parentMethodsMap.subscribe ? this.parent.subscribe(e, t, n) : la.call(this, e, t, n, ea)
        },
        subscribeToOne: function(e) {
            return this.queryName = this.model.schema.subscribeOneOp,
            this.subscribe(e, na, ia)
        },
        localSubscribeToOne: function(e) {
            return this.queryName = this.model.schema.subscribeOneOp,
            this.localSubscribe(e, na, ia)
        },
        subscribeToAll: function(e) {
            return this.queryName = this.model.schema.subscribeManyOp,
            this.subscribe(e, na, ra)
        },
        localSubscribeToAll: function(e) {
            return this.queryName = this.model.schema.subscribeManyOp,
            this.localSubscribe(e, na, ra)
        },
        subscribeToAllRecords: function(e) {
            return this.queryName = this.model.schema.subscribeManyOp,
            this.subscribe(e, ta, ra)
        },
        subscribeToOneRecord: function(e) {
            return this.queryName = this.model.schema.subscribeOneOp,
            this.subscribe(e, ta, ia)
        },
        localSubscribeToOneRecord: function(e) {
            return this.queryName = this.model.schema.subscribeOneOp,
            this.localSubscribe(e, ta, ia)
        }
    };
    function ha(e, t, n) {
        if (t.VF.isManyToMany) {
            return e.getOrInitIncludeVF(t.VF.ownModelThroughVF.bestVFName, n).includeM2MInclude(t, n),
            e.removeInclude(t.VFName),
            e
        }
        {
            const r = t.query;
            return r && r.queryHasM2MInclude && r.includeM2MThroughRecords(t.getQueryPayload(n)),
            e
        }
    }
    const fa = {
        getOrInitIncludeVF: function(e, t) {
            if (this.parentMethodsMap.include)
                return this.parent.getOrInitIncludeVF(e, t);
            const n = this.virtualFields[e];
            if (!n)
                return;
            if (t) {
                t.__didPrepare || this.preparePayload(t);
                let r = t.children;
                r || (t.children = r = {}),
                r[e] || (r[e] = {
                    parent: t,
                    originalQuery: !1,
                    VF: n,
                    variables: t.variables,
                    isServer: t.isServer
                })
            }
            let r, i = this.includeVFs;
            if (i) {
                if (r = i[e])
                    return r
            } else
                this.includeVFs = i = {};
            return r = this.constructor.IncludeVF.init(this, e),
            i[e] = r,
            r
        },
        convertIncludeM2MArgsToThroughArgs: function(e) {
            if (this.parentMethodsMap.include)
                return this.parent.convertIncludeM2MArgsToThroughArgs(e),
                this;
            const t = this.includeVFs;
            if (!t)
                return this;
            if ("string" !== typeof e)
                for (e in t)
                    t[e].convertM2MArgsToThroughArgs();
            else
                t[e] && t[e].convertM2MArgsToThroughArgs();
            return this
        },
        convertM2MArgsToThroughArgs: function(e) {
            if (!this.queryHasM2MArg)
                return this;
            "string" !== typeof e && (e = void 0);
            const t = this.queryArgs;
            if (t && t.length > 0) {
                let n;
                for (n of t)
                    n.convertM2MArgsToThroughArgs(e)
            }
            return e || (this.queryHasM2MArg = !1),
            this
        },
        convertIncludePathArgsToFullPathArgs: function(e) {
            if (this.parentMethodsMap.include)
                return this.parent.convertIncludePathArgsToFullPathArgs(e),
                this;
            const t = this.includeVFs;
            if (!t)
                return this;
            if ("string" !== typeof e)
                for (e in t)
                    t[e].convertPathArgsToFullPathArgs();
            else
                t[e] && t[e].convertPathArgsToFullPathArgs();
            return this
        },
        convertPathArgsToFullPathArgs: function(e) {
            if (!this.queryHasPathArg)
                return this;
            "string" !== typeof e && (e = void 0);
            const t = this.queryArgs;
            if (t && t.length > 0) {
                let n;
                for (n of t)
                    n.convertPathArgsToFullPathArgs(e)
            }
            return e || (this.queryHasPathArg = !1),
            this
        },
        executeIncludes: function(e, t) {
            const n = this.includeVFs;
            let r;
            if (n) {
                let t;
                for (let i in n)
                    (t = n[i].executeQuery(e)) && (r ? r.push(t) : r = [t])
            }
            return t ? r : r ? 1 === r.length ? r[0] : Object(wr.a)(r) : Object(V.a)(null)
        },
        getInclude: function(e, t) {
            if (this.parentMethodsMap.include)
                return this.parent.getInclude(e, t);
            if ("string" === typeof e)
                return this.includeVFs ? this.includeVFs[e] : void 0;
            t || (t = 0);
            const n = e[t];
            t++;
            const r = this.includeVFs ? this.includeVFs[n] : void 0;
            return r ? t === e.length ? r : r.query ? r.query.getInclude(e, t) : void 0 : void 0
        },
        getIncludesMaxDepth: function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            const n = this.includeVFs;
            if (!n)
                return t;
            let r;
            e++;
            for (let i in n)
                (r = n[i].query) && (t = r.getIncludesMaxDepth(e, t));
            return e > t ? e : t
        },
        getModelsInIncludes: function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
              , t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            const r = this.includeVFs;
            if (r) {
                let i, o;
                for (let s in r)
                    (i = r[s].query) && (o = t ? i.model.getMainInstance() : i.model,
                    n ? n[o.modelName] = o : n = {
                        [o.modelName]: o
                    },
                    e && i.getModelsInIncludes(e, t, n))
            }
            return n
        },
        includeAll: function(e, t, n, r) {
            if (this.parentMethodsMap.include)
                return this.parent.includeAll(e, t, n, Ct(this, r)),
                this;
            if (r)
                this.includeAllAtPath(r, ( (e, t) => (n, r) => {
                    let i = n.query;
                    i || (i = n.createQueryInstance(r)),
                    i.includeAll(e, t, n.getQueryPayload(r))
                }
                )(e, t), Nt(n, r), !0);
            else if (e && !0 !== e) {
                const r = this.getOrInitIncludeVF(e, n);
                if (!r) {
                    const t = this.virtualFields
                      , n = [];
                    for (let e in t)
                        t[e].VFName && n.push(e);
                    throw new Error('The virtualField "'.concat(e, '" is not \n        a recognized virtualField on the model "').concat(this.modelName, '". Valid virtual fields include: ').concat(n.join(", ")))
                }
                r.includeAll(t, n)
            } else if (this.virtualFields) {
                const e = this.virtualFields;
                let r, i;
                for (let o in e)
                    (i = e[o].bestVFName) && (r = this.getOrInitIncludeVF(i, n),
                    r.includeAll(t, n))
            }
            return this
        },
        includeAllPaths: function(e) {
            if (this.parentMethodsMap.include)
                return this.parent.includeAllPaths(e),
                this;
            if (!this.queryHasPathInclude)
                return this;
            let t, n, r, i = this.includeVFs;
            for (let o in i)
                t = i[o],
                t.isComputed && (r = t.VF.ownFieldFullVFPathNames,
                this.includeWithFullPath(o, null, e),
                t = this.includeVFs[r[0]]),
                (n = t.query) && n.queryHasPathInclude && n.includeAllPaths(t.getQueryPayload(e));
            return this.queryHasPathInclude = !1,
            this
        },
        includeM2MThroughRecords: function(e, t, n) {
            if (this.parentMethodsMap.include)
                return this.parent.includeM2MThroughRecords(e, t, Ct(this, n)),
                this;
            if (t = function(e, t) {
                return t || (e && "object" === typeof e ? e : null)
            }(e, t),
            "string" !== typeof e && (e = void 0),
            n)
                return t = Nt(t, n),
                this.includeAllAtPath(n, (r = e,
                (e, t) => {
                    let n = e.query;
                    return n || (n = e.createQueryInstance(t)),
                    n.includeM2MThroughRecords(r, e.getQueryPayload(t)),
                    n
                }
                ), t, !0),
                this;
            if (!this.queryHasM2MInclude)
                return this;
            var r;
            let i = this.includeVFs;
            if (e) {
                if (!this.virtualFields[e])
                    throw new Error("The virtual field " + e + " is not associated with the model " + this.modelName + ". Unable to include manyToMany records.");
                {
                    let n = i[e];
                    n && ha(this, n, t)
                }
            } else {
                let e, n = !0;
                for (; n; ) {
                    for (e in this.queryHasM2MInclude = !1,
                    i)
                        ha(this, i[e], t);
                    i = this.includeVFs,
                    n = this.queryHasM2MInclude
                }
            }
            return this
        },
        includeWithFullPath: function(e, t, n, r) {
            if (this.parentMethodsMap.include)
                return this.parent.includeWithFullPath(e, t, n, Ct(this, r)),
                this;
            if (r)
                return this.includeAllAtPath(r, ( (e, t) => (n, r) => {
                    let i = n.query;
                    i || (i = n.createQueryInstance(r)),
                    i.includeWithFullPath(e, t, n.getQueryPayload(r))
                }
                )(e, t), Nt(n, r), !0),
                this;
            const i = this.virtualFields[e];
            if (!i)
                throw new Error("The virtual field ".concat(e, ' does not exist on the model "').concat(this.modelName, '".'));
            const o = this.includeVFs;
            let s = o ? o[e] : void 0;
            s && (s.add(t, n),
            this.removeInclude(e, !0));
            let a = i.ownFieldFullVFPathNames;
            if (this.includeAllAtPath(a, s || t, n),
            s && s.destroy(),
            n) {
                const t = a.length;
                let r = 0
                  , i = n;
                for (; r < t; )
                    i = i.children[a[r]],
                    r++;
                n.children[e].linkedPayload = i
            }
            return this
        },
        isVFIncluded: function(e, t) {
            if (this.parentMethodsMap.include)
                return this.parent.isVFIncluded(e, t);
            const n = this.virtualFields[e];
            if (n) {
                if (this.includeVFs && this.includeVFs[n.VFName])
                    return !0;
                if (t && this.parent) {
                    const e = n.ownRefModelVF;
                    return this.parent.getClosestIncludeOrMainQuery().isVFIncluded(e.VFName || e.instanceId, !0)
                }
                return !1
            }
            return !1
        },
        prepareIncludes: function(e) {
            const t = this.includeVFs;
            if (t) {
                for (let n in t)
                    t[n].prepareQuery(e);
                return !0
            }
            return !1
        }
    };
    var pa = n(140);
    const ga = (e, t) => {
        let n;
        for (; t.isGroupedQuery; )
            n = t.parentQueryArg,
            t = n.queryArgs.query;
        e.indexOf(n) < 0 && Object(pa.a)(n, e, "argsGroupIdx")
    }
      , ma = (e, t, n) => {
        let r = t.query;
        if (r) {
            const i = r.queryArgs;
            i && 1 === i.length && Object(he.K)(i[0]) && (r = i[0].query),
            Object(he.Y)(t) ? e._addQueryArg(t.VFName, r, t.op, be(t), n) : e._addQueryArg(r, t.op, null, be(t), n)
        } else
            e._addQueryArg(t.key, t.op, t.valueParam || t.value, be(t), n)
    }
      , ya = (e, t, n) => {
        let r, i, o;
        if (1 === t.length && (r = t[0],
        i = r.length - 1,
        r[i].argsGroupIdx === i)) {
            for (o of r)
                ma(e, o, "or");
            return
        }
        const s = e => {
            for (r of t)
                if (i = r.length - 1,
                0 === r[i].argsGroupIdx)
                    for (o of r)
                        ma(e, o, "and");
                else
                    e.andWhere(e => {
                        let t = 0;
                        for (o of r)
                            ma(e, o, o.argsGroupIdx === t ? "and" : "or"),
                            ({argsGroupIdx: t} = o)
                    }
                    )
        }
        ;
        n ? s(e) : e.orWhere(s)
    }
    ;
    const va = (e, t) => {
        const {queryArgs: n} = e;
        for (; n[t]; )
            e.removeArg(n[t])
    }
    ;
    const ba = {
        ...Dn,
        _addRecordToValues: function(e, t, n) {
            const r = e[t];
            return "undefined" !== typeof r && null !== r && (n ? n.indexOf(r) < 0 && n.push(r) : n = [r]),
            n || null
        },
        add: function(e, t, n) {
            "function" === typeof e ? n ? e(this, t) : this.addFromFn(e, null, t) : Object(he.L)(e) ? this.merge(e, t) : Object(he.T)(e) ? this.addFromQuery(e, t) : this.addSelect(e, t)
        },
        addFromVFArgs: function(e, t, n, r, i) {
            let o, s, a, c, u, l, d, h, f, p = !1;
            const g = new Array(e.length);
            for (let w = 0; w < e.length; w++)
                if (a = e[w],
                c = a.query,
                u = [],
                g[w] = u,
                s = c.getArgsMap(t)) {
                    if (l || ((l = this.query) ? t.keepIncludeArgs || this.removeGroupedQuery(n, !0) : (l = this.createQueryInstance(n),
                    t.keepIncludeArgs || (this.hasRemovedGroup = !0)),
                    d = this.getQueryPayload(n)),
                    s[he.c]) {
                        d && (d.parentVFArgsPayload = r);
                        const e = s[he.c];
                        let t;
                        for (const n of e)
                            t = n.queryArgs.query,
                            l.select(a.key),
                            t.isGroupedQuery ? ga(u, t) : Object(pa.a)(n, u, "argsGroupIdx");
                        s[he.c] = u
                    }
                    for (const e in s)
                        if (e !== he.c && (h = s[e]) && (!i || i[e]))
                            for (f of (o || (o = {}),
                            o[e] ? o[e].push(...h) : o[e] = [...h],
                            h))
                                f.queryArgs.query.isGroupedQuery ? ga(u, f.queryArgs.query) : Object(pa.a)(f, u, "argsGroupIdx");
                    u.length && (p = !0)
                }
            if (!p)
                return;
            const m = l.parseSiblingArgs(e);
            let y, v, b, _, S, O, T = [];
            for (const w of m)
                if (w)
                    for (a of w)
                        if (u = g[e.indexOf(a)],
                        u.length)
                            if (({ownSiblingsIdx: b, siblingQueriesIdx: _} = a),
                            b) {
                                if (b.length > 0) {
                                    for (y of (u = [u],
                                    b))
                                        S = w[y],
                                        O = S.ownSiblingsIdx,
                                        O.splice(O.indexOf(_), 1),
                                        v = g[e.indexOf(S)],
                                        v.length && u.push(v);
                                    T.push(u)
                                }
                            } else
                                T.push([u]);
            const I = 1 === T.length && !this.getGroupedQueryArg()
              , x = this.getGroupedQuery(!0, n);
            for (u of T)
                ya(x, u, I);
            l.includeFromArgs(o, t, d, r, null, i)
        },
        addFromQuery: function(e, t) {
            let {query: n} = this;
            n ? this.merge(e, t) : this.query = this.createQueryInstance(t).where(e)
        },
        addFromFn: function(e, t, n) {
            let {query: r} = this;
            r ? r.queryArgs ? (r = this.getGroupedQuery(!0, n),
            r.queryArgs ? r.orWhere(e, t) : t ? e.call(t, r) : e(r)) : r.where(e, t) : this.query = this.createQueryInstance(n).where(e, t)
        },
        addSelect: function(e, t) {
            let {query: n} = this;
            n ? t && this.getQueryPayload(t) : this.query = n = this.createQueryInstance(t),
            Array.isArray(e) ? n.select(e) : n.selectAll(e)
        },
        clone: function(e, t, n) {
            const {VFName: r} = this;
            let i, o = t[r];
            if (o)
                return e.includeFromInclude(this.VFName, this, n),
                o;
            if (n) {
                let {children: s} = n;
                if (s ? i = s[r] : n.children = s = {},
                i) {
                    if ("undefined" !== typeof i.originalQuery) {
                        const n = i.query;
                        return o = n.parentQueryArg,
                        t[r] = o,
                        n.parent = e,
                        o
                    }
                } else
                    s[r] = i = {
                        parent: n,
                        variables: n.variables
                    }
            }
            return o = new this.constructor(e,this.VFName),
            o.VF = this.VF,
            o.runBefore = this.runBefore,
            o.hasNestedGroup = this.hasNestedGroup,
            o.hasRemovedGroup = this.hasRemovedGroup,
            o.valueParam = this.valueParam,
            t[r] = o,
            o.query = i ? this.query.cloneForExecute(i) : this.query.clone(o.ownQuery),
            o
        },
        compileWrapperQueryArgValues: function(e) {
            let t = null;
            const n = this.ownFieldName;
            if (e.forSubscription) {
                const r = fn(e)
                  , i = e.parent.queryIndex.getBestStore(r).value;
                if (!i.pSize && !i.size)
                    return t;
                const o = i.getState();
                let s;
                if (i.storeConfig.RecordResult) {
                    const e = this.VF.ownModel.getBestInstance(r).getState();
                    for (let r in o)
                        (s = o[r]) && (s = e[s.__ID]) && (t = this._addRecordToValues(s, n, t))
                } else
                    for (let e in o)
                        (s = o[e]) && (t = this._addRecordToValues(s, n, t))
            } else {
                const {parent: {records: r}} = e;
                if (!r)
                    return t;
                for (let e in r)
                    t = this._addRecordToValues(r[e], n, t)
            }
            return t
        },
        convertM2MArgsToThroughArgs: function() {
            this.query && this.query.convertM2MArgsToThroughArgs()
        },
        convertPathArgsToFullPathArgs: function() {
            this.query && this.query.convertPathArgsToFullPathArgs()
        },
        createQueryInstance: function(e) {
            const t = this.VF.ownRefModel
              , n = t.query(t.schema.queryManyOp);
            if (this.query = n,
            n.setAsIncludeVF(this),
            e) {
                const t = e.children[this.VFName];
                t ? t.query = n : e.children[this.VFName] = {
                    query: n,
                    parent: e,
                    VF: this.VF,
                    originalQuery: !1,
                    isServer: e.isServer,
                    variables: e.variables
                }
            }
            return n
        },
        executeQuery: function(e, t) {
            return this.VF.executeIncludeQuery(t || this.getQueryPayload(e))
        },
        getGraphqlArgsQuery: function() {
            return this.runBefore ? this.query : this.getGroupedQuery()
        },
        getQueryPayload: function(e, t) {
            return e ? mn(this, e, t) : null
        },
        includeAll: function(e, t) {
            let n = this.query;
            if (n) {
                if (this.removeGroupedQuery(t, !0),
                !1 === e || n.querySelect && "undefined" === typeof e)
                    return this
            } else
                this.query = n = this.createQueryInstance(t);
            return !1 !== e && (Array.isArray(e) ? n.select(e) : n.selectAll(e)),
            this
        },
        includeAtPath: function(e, t, n, r, i) {
            if (e[i]) {
                let o;
                this.query ? o = this.getQueryPayload(n) : (this.createQueryInstance(n),
                o = n ? n.children[this.VFName] : void 0),
                this.query.includeAtPath(e, t, o, r, i)
            } else
                this.add(t, n, r)
        },
        includeAllAtPath: function(e, t, n, r, i) {
            if (e[i]) {
                let o;
                this.query ? (o = this.getQueryPayload(n),
                this.removeGroupedQuery(n, !0)) : (this.createQueryInstance(n),
                o = n ? n.children[this.VFName] : void 0),
                this.query.includeAllAtPath(e, t, o, r, i)
            } else
                this.add(t, n, r)
        },
        includeM2MInclude: function(e, t) {
            const n = e.VF
              , r = n.ownRefModelThroughVFName
              , i = e.query
              , o = e.getGroupedQuery()
              , s = o && o.hasQueryArgs;
            let a = this.query
              , c = void 0
              , u = !1
              , l = !1;
            a ? (u = !0,
            c = this.getGroupedQuery(),
            l = c && c.hasQueryArgs) : a = this.createQueryInstance(t);
            const d = this.getQueryPayload(t)
              , h = a.getOrInitIncludeVF(r, d);
            let f = h.query;
            if (f || (f = h.createQueryInstance(d)),
            s && l) {
                if (this.getGroupedQuery(!0, t).orWhere(r, o),
                t) {
                    a.queryArgs[0].query.selectAllArgs(this.getQueryPayload(t))
                }
                f.addSelectFromQuery(i).addDirectivesFromQuery(i).addIncludesFromQuery(i)
            } else
                u ? (l && this.removeGroupedQuery(t),
                h.merge(e, d)) : (s && this.getGroupedQuery(!0, t).orWhere(r, o),
                f.addSelectFromQuery(i).addDirectivesFromQuery(i).addIncludesFromQuery(i));
            if (a.select([a.primaryKey, n.ownModelThroughVF.fieldName, n.ownRefModelThroughVF.fieldName]),
            d) {
                const e = t.children[n.VFName];
                e.linkedPayload = d.children[r],
                e.filterResults = !0,
                d.filterResults = !0,
                d.parentVFArgsPayload = e
            }
        },
        isDifferentThan: function(e, t) {
            if (!Object(he.L)(e) || this.VF !== e.VF)
                return !0;
            const n = this.query
              , {query: r} = e
              , i = this.getGroupedQuery()
              , o = e.getGroupedQuery();
            if (i && o) {
                if (i.isDifferentThan(o))
                    return !0
            } else if (i || o)
                return !0;
            return n.areIncludesDifferent(r) || n.areDirectivesDifferent(r) || !t && n.isSelectDifferent(r)
        },
        getGroupedQuery: function(e, t) {
            const n = this.getGroupedQueryArg(e, t);
            if (!e)
                return n ? n.query : void 0;
            let r = n.query;
            return r ? !this.hasNestedGroup && r.queryArgs && r.queryArgs.length > 1 && (r = r.convertToGroupedQuery(),
            this.hasNestedGroup = !0) : r = n.createQueryInstance(),
            r
        },
        getGroupedQueryArg: function(e, t) {
            let n = this.query;
            if (n) {
                const t = n.queryArgs;
                if (t && Object(he.K)(t[0]))
                    return t[0];
                if (!e)
                    return;
                this.removeWrapperQueryArg()
            } else {
                if (!e)
                    return;
                n = this.createQueryInstance(t)
            }
            return n.getOrInitQueryArgs().addGroupedQueryArg()
        },
        getWrapperQueryArg: function() {
            const e = this.query;
            if (!e || !this.runBefore)
                return;
            const t = e.queryArgs;
            if (t) {
                const [e,n] = t;
                return e ? Object(he.K)(e) ? n || void 0 : e : void 0
            }
        },
        merge: function(e, t) {
            let n, r, i = this.query;
            if (Object(he.T)(e))
                r = e,
                n = r.hasQueryArgs ? r : void 0;
            else {
                if (r = e.query,
                !r)
                    return;
                n = e.getGroupedQuery()
            }
            if (n)
                if (i) {
                    this.getGroupedQueryArg() ? this.getGroupedQuery(!0, t).orWhere(n) : (this.removeWrapperQueryArg(),
                    i.where(n))
                } else
                    this.addFromQuery(n, t),
                    i = this.query;
            else
                i || (i = this.createQueryInstance(t));
            if (i.mergeSelect(r.querySelect).mergeIncludes(r.includeVFs),
            ht(i, r),
            t) {
                const e = this.getQueryPayload(t);
                e.__didPrepare && !r.includeVFs || i.preparePayload(e)
            }
        },
        mergeQueryResults: function(e) {
            this.VF.mergeQueryResults(e)
        },
        prepareQuery: function(e) {
            return this.VF.prepareIncludeQuery(this.getQueryPayload(e))
        },
        prepareSelect: function(e) {
            if (e) {
                const t = this.getQueryPayload(e);
                t.query.prepareSelect(t)
            } else
                this.query.prepareSelect()
        },
        prepareWrapperQueryArg: function(e, t) {
            if (!t && !(t = this.compileWrapperQueryArgValues(e)))
                return this.runBefore && (this.ownQuery.queryHasVariables ? e.variables[this.valueParam] = [] : this.getWrapperQueryArg().value = []),
                t;
            const n = this.ownRefFieldName
              , {query: r, runBefore: i} = this
              , {queryHasVariables: o} = this.ownQuery;
            if (i)
                o ? e.variables[this.valueParam] = t : this.getWrapperQueryArg().value = t;
            else if (this.runBefore = !0,
            o) {
                const i = Object(oe.a)();
                this.valueParam = i,
                r.andWhereIn(n, ":".concat(i)),
                e.variables[i] = t
            } else
                r.andWhereIn(n, t);
            return t
        },
        removeGroupedQuery: function(e, t) {
            if (this.hasRemovedGroup && !t)
                return !1;
            this.hasRemovedGroup = !0;
            const n = this.getGroupedQueryArg();
            if (!n)
                return !1;
            if (this.hasNestedGroup = !1,
            e) {
                this.removeWrapperQueryArg();
                const t = this.getQueryPayload(e);
                t.filterResults = !0,
                this.query.selectAllArgs(t),
                n.queryArgs && this.query.removeArg(n.argIdx)
            } else
                this.query.removeArg(n);
            return !0
        },
        removeWrapperQueryArg: function() {
            const e = this.getWrapperQueryArg();
            return this.runBefore = !1,
            !!e && (this.query.removeArg(e),
            0 === e.argIdx ? this.query.queryArgs.length && va(this.query, 0) : this.query.queryArgs.length > 1 && va(this.query, 1),
            !0)
        },
        selectAllArgs: function(e) {
            let t = this.query;
            t && (this.runBefore && this.removeWrapperQueryArg(),
            t.selectAllArgs(this.getQueryPayload(e)),
            t.select(this.VF.ownRefFieldName))
        }
    };
    const _a = {
        init: function(e, t) {
            const n = new this(e,t);
            return n.runBefore = !1,
            n.hasNestedGroup = !1,
            n
        }
    }
      , Sa = {
        ...Fn,
        argIdx: {
            get() {
                return this.VFName
            }
        }
    };
    const Oa = function(e) {
        class t extends e {
        }
        return Object(L.a)(t, ba, _a),
        Object.defineProperties(t.prototype, Sa),
        t
    }(kt);
    function Ta() {}
    const Ia = {
        get: () => !0,
        set: Ta,
        enumerable: !1
    }
      , xa = {
        get: () => !1,
        set: Ta,
        enumerable: !1
    }
      , wa = {
        get: () => null,
        set: Ta,
        enumerable: !1
    }
      , Ma = {};
    let Aa, Ea;
    function Ca(e) {
        Ma[Object(he.B)(e)] = e
    }
    function Na() {
        this.valuesSet && (Yn.a.checkinSet(this.valuesSet),
        this.valuesSet = void 0)
    }
    function Ra() {
        return this.result
    }
    class Pa {
        constructor(e) {
            this.result = null,
            this.count = 0,
            e ? (this.add = this.addIfDistinct,
            this.valuesSet = Yn.a.checkoutSet()) : this.valuesSet = void 0
        }
        addIfDistinct(e) {
            return this.valuesSet.has(e) || (this.valuesSet.add(e),
            this.result = null === this.result ? e : this.result + e,
            this.count++),
            this
        }
        add(e) {
            return this.result = null === this.result ? e : this.result + e,
            this.count++,
            this
        }
        getResult() {
            return null === this.result ? null : this.result / this.count
        }
        reset() {
            return this.result = null,
            this.count = 0,
            this.valuesSet && this.valuesSet.clear(),
            this
        }
    }
    Pa.prototype.destroy = Na;
    class Da {
        constructor(e) {
            this.result = 0,
            e ? (this.valuesSet = Yn.a.checkoutSet(),
            this.add = this.addIfDistinct) : this.valuesSet = void 0
        }
        addIfDistinct(e) {
            this.valuesSet.has(e) || (this.valuesSet.add(e),
            this.result++)
        }
        add(e) {
            return this.result++,
            this
        }
        reset() {
            return this.result = 0,
            this.valuesSet && this.valuesSet.clear(),
            this
        }
    }
    Da.prototype.getResult = Ra,
    Da.prototype.destroy = Na;
    class Fa {
        constructor() {
            this.result = null
        }
        reset() {
            return this.result = null,
            this
        }
    }
    Fa.prototype.getResult = Ra,
    Fa.prototype.destroy = Na;
    class ka extends Fa {
        add(e) {
            return (null === this.result || e < this.result) && (this.result = e),
            this
        }
        getResult() {
            return this.result
        }
    }
    class ja extends Fa {
        add(e) {
            return (null === this.result || e > this.result) && (this.result = e),
            this
        }
    }
    class La {
        constructor(e) {
            this.result = null,
            this.values = [],
            this.isVariance = e
        }
        add(e) {
            return this.values.push(e),
            this.result = null === this.result ? e : this.result + e,
            this
        }
        getResult() {
            if (null === this.result)
                return null;
            const {values: e} = this
              , t = this.result / e.length;
            let n = 0;
            for (let r of e)
                n += Math.pow(r - t, 2);
            return this.isVariance ? Math.sqrt(n / (e.length - 1)) : Math.sqrt(n / e.length)
        }
        reset() {
            return this.result = null,
            this.values.length = 0,
            this
        }
    }
    La.prototype.destroy = Na;
    class Va {
        constructor(e) {
            this.result = null,
            e ? (this.valuesSet = Yn.a.checkoutSet(),
            this.add = this.addIfDistinct) : this.valuesSet = void 0
        }
        addIfDistinct(e) {
            return this.valuesSet.has(e) || (this.valuesSet.add(e),
            this.result = null === this.result ? e : this.result + e),
            this
        }
        add(e) {
            return this.result = null === this.result ? e : this.result + e,
            this
        }
        reset() {
            return this.result = null,
            this.valuesSet && this.valuesSet.clear(),
            this
        }
    }
    Va.prototype.getResult = Ra,
    Va.prototype.destroy = Na;
    class Ua {
        constructor() {
            this.result = null
        }
        add(e) {
            return this.result = e,
            this
        }
        getResult() {
            return this.result
        }
        reset() {
            return this.result = null,
            this
        }
        destroy() {
            return this.result = null,
            this
        }
    }
    const qa = (e, t) => {
        switch (typeof t) {
        case "boolean":
            return t ? 1 : 0;
        case "string":
            const {methodName: n} = e.calcMethod;
            switch (n) {
            case "concat":
                return t;
            case "min":
            case "max":
                return 1 === e.length && !Object(he.H)(e) && t;
            default:
                return !1
            }
        default:
            return !1
        }
    }
    ;
    function Qa(e, t) {
        let n = this[0].getValue(e, t);
        if (!this[1] && "count" === this.methodName)
            return "undefined" !== typeof n && null !== n && (this.resultState.add(n),
            !0);
        if ("number" !== typeof n && !1 === (n = qa(this, n)))
            return !1;
        let r, i = 1;
        const {length: o} = this;
        if (this.mixedMathArray) {
            const {mixedMathArray: s} = this;
            let a = 0;
            for (; i < o; ) {
                if (r = this[i].getValue(e, t),
                "number" !== typeof r && !1 === (r = qa(this, r)))
                    return !1;
                "*" === this[i].op || "/" === this[i].op ? n = this[i].opFn(n, r) : (s[a] = n,
                s[++a] = this[i],
                a++,
                n = r),
                i++
            }
            s[a] = n;
            let c = s[0];
            for (i = 1; i < s.length; )
                c = s[i].opFn(c, s[i + 1]),
                i += 2;
            this.resultState.add(c)
        } else {
            for (; i < o; ) {
                if (r = this[i].getValue(e, t),
                "number" !== typeof r && !1 === (r = qa(this, r)))
                    return !1;
                n = this[i].opFn(n, r),
                i++
            }
            this.resultState.add(n)
        }
        return !0
    }
    const Ba = {
        get: () => Array
    };
    function Ga(e) {
        return Object.defineProperty(e, Symbol.species, Ba),
        e
    }
    const za = (e, t, n, r) => {
        if ("undefined" !== typeof t)
            return n.method(e, t, r);
        switch (typeof e) {
        case "function":
            return n.addArg(he.h, e, r);
        case "number":
            return n.addArg(he.m, e, r);
        case "string":
            const {calcMethod: t} = void 0;
            return "concat" !== t.methodName || t.query.fields[e] ? n.addArg(he.g, e, r) : n.addArg(he.m, e, r);
        default:
            return n.addArg(he.g, e, r)
        }
    }
    ;
    function Ha(e) {
        return function(e, t) {
            if (e !== he.k || !t) {
                const n = Ma[e];
                if (n || !t)
                    return n;
                switch (e) {
                case he.g:
                    return t.query.CalcFieldArg;
                case he.h:
                    return t.query.CalcGroupArg;
                case he.m:
                    return t.query.CalcValueArg;
                case he.f:
                    return t.query.CalcChildMethodArg;
                default:
                    return void console.log("UNKNOWN = ", e)
                }
            }
            return t.isSelect ? Aa || Ma.__SelectMethod || t.query.CalcSelectMethod : Ea || Ma.__HavingMethod || t.query.CalcHavingMethod
        }(e, this)
    }
    function Ka(e, t, n, r) {
        return new (this.getClass(e))(this,n,r).setProps(t),
        this
    }
    function Ya(e, t, n, r, i) {
        if (!this.canHaveMethod && "count_weekdays" !== e && "count_workdays" !== e) {
            const t = Object(he.B)(this);
            throw t === he.k || t === he.f ? new Error('Calc method "'.concat(this.methodName, '" does not support child methods. Unable to add "').concat(e, '" method.')) : new Error("".concat(t, ' cannot be the parent of a "').concat(e, '" method.'))
        }
        return new (this.getClass(he.f))(this,e,n,i).setProps(t, r),
        this
    }
    function Wa(e, t) {
        return this.addArg(he.g, e, t)
    }
    function $a(e, t) {
        return this.addArg(he.m, e, t)
    }
    function Xa(e, t) {
        return this.addArg(he.h, e, t)
    }
    function Ja(e, t) {
        return za(e, t, this, "+")
    }
    function Za(e, t) {
        return za(e, t, this, "-")
    }
    function ec(e, t) {
        return za(e, t, this, "*")
    }
    function tc(e, t) {
        return za(e, t, this, "/")
    }
    function nc(e) {
        if (this.hasComputedFieldPathArg)
            for (let t = 0; t < this.length; t++)
                this[t].convertPathArgsToFullPathArgs(e);
        return this
    }
    function rc(e) {
        if (this.hasM2MFieldPathArg)
            for (let t = 0; t < this.length; t++)
                this[t].convertM2MArgsToThroughArgs(e);
        return this
    }
    function ic(e) {
        for (let t = 0; t < this.length; t++)
            e = this[t].checkApiRead(e);
        return e || null
    }
    function oc(e) {
        if (!this.hasFieldPathArg)
            return e;
        for (let t of this)
            e = t.getFieldPathArgsTopLevelVFNames(e);
        return e
    }
    function sc(e) {
        this.resultState || (this.resultState = function(e, t) {
            switch (e) {
            case "avg":
                return new Pa(t);
            case "calc":
                return new Va(!1);
            case "count":
                return new Da(t);
            case "field":
                return new Ua;
            case "min":
                return new ka;
            case "max":
                return new ja;
            case "stdDev":
                return new La(!1);
            case "sum":
                return new Va(t);
            case "variance":
                return new La(!0);
            default:
                throw new Error("Unrecognized calc method name: ".concat(e))
            }
        }(this.methodName, this.isDistinct)),
        "undefined" === typeof this.mixedMathArray && (this.mixedMathArray = this.hasMultiplyDivide && this.hasAddSubtract ? [] : null);
        for (let t of this)
            t.prepareToProcess(e);
        return this
    }
    function ac() {
        for (let e = 0; e < this.length; e++)
            this[e].processComplete();
        return this.resultState.reset(),
        this.isExcluded = !1,
        this
    }
    function cc() {
        for (let e of this)
            e.destroy();
        this.parent = void 0,
        this.resultState = void 0,
        this.mixedMathArray = void 0,
        this.directives && (this.directives = void 0,
        this.directiveVariables = void 0,
        this.directiveDefaults = void 0)
    }
    const uc = function() {
        const e = e => function() {
            for (let t of this)
                if (t[e])
                    return !0;
            return !1
        }
          , t = {
            hasAddSubtract: {
                get() {
                    if (this.op && ("+" === this.op || "-" === this.op))
                        return !0;
                    for (let e of this)
                        if (e.hasAddSubtract)
                            return !0;
                    return !1
                }
            },
            hasComputedFieldPathArg: {
                get: e("hasComputedFieldPathArg")
            },
            hasMultiplyDivide: {
                get() {
                    if (this.op && ("*" === this.op || "/" === this.op))
                        return !0;
                    for (let e of this)
                        if (e.hasMultiplyDivide)
                            return !0;
                    return !1
                }
            },
            hasFieldPathArg: {
                get: e("hasFieldPathArg")
            },
            hasM2MFieldPathArg: {
                get: e("hasM2MFieldPathArg")
            },
            hasChildMethod: {
                get() {
                    for (let e of this)
                        if (Object(he.F)(e) || e.hasChildMethod)
                            return !0;
                    return !1
                }
            },
            hasNonGroupArgChildMethod: {
                get() {
                    for (let e of this)
                        if (Object(he.F)(e) && "calc" !== e.methodName || e.hasChildMethod)
                            return !0;
                    return !1
                }
            },
            hasNonNumberArg: {
                get() {
                    for (let e of this)
                        if (e.hasNonNumberArg)
                            return !0;
                    return !1
                }
            },
            isOrHasAggregate: {
                get() {
                    return this.isAggregate || this.hasAggregate
                }
            },
            hasAggregate: {
                get() {
                    for (let e of this)
                        if (e.isOrHasAggregate)
                            return !0;
                    return !1
                }
            }
        };
        for (let n in t)
            t[n].set = void 0,
            t[n].enumerable = !1;
        return t
    }();
    const lc = {
        canHaveMethod: Ia,
        isSelect: Ia,
        isHaving: xa,
        isParent: Ia,
        inChildMethod: xa,
        isOrHasAggregate: uc.hasAggregate,
        hasAggregate: uc.hasAggregate,
        hasChildMethod: uc.hasChildMethod,
        hasNonGroupArgChildMethod: uc.hasNonGroupArgChildMethod,
        hasNonNumberArg: uc.hasNonNumberArg,
        topLevelCalcMethod: wa
    }
      , dc = {
        canHaveMethod: Ia,
        isSelect: xa,
        isHaving: Ia,
        isParent: Ia,
        inChildMethod: xa,
        isOrHasAggregate: uc.hasAggregate,
        hasAggregate: uc.hasAggregate,
        hasChildMethod: uc.hasChildMethod,
        hasNonGroupArgChildMethod: uc.hasNonGroupArgChildMethod,
        hasNonNumberArg: uc.hasNonNumberArg,
        topLevelCalcMethod: wa
    };
    const hc = {
        _maybeEnsureAlias: function(e) {
            return this
        },
        compileGroupByFieldArgs: function(e) {
            for (let t of this)
                e = t.compileGroupByFieldArgs(e);
            return e || null
        },
        convertM2MArgsToThroughArgs: function(e) {
            for (let t of this)
                t.convertM2MArgsToThroughArgs(e);
            return this
        },
        convertPathArgsToFullPathArgs: function(e) {
            for (let t of this)
                t.convertPathArgsToFullPathArgs(e);
            return this
        },
        destroy: function() {
            for (let e of this)
                e.destroy();
            return this.query = void 0,
            this
        },
        getClass: Ha,
        getFieldPathArgsTopLevelVFNames: function(e) {
            for (let t of this)
                e = t.getFieldPathArgsTopLevelVFNames(e);
            return e || null
        },
        isDifferentThan: function(e) {
            if (!e || e.length !== this.length)
                return !0;
            for (let t = 0; t < this.length; t++)
                if (this[t].isDifferentThan(e[t]))
                    return !0;
            return !1
        }
    };
    const fc = (e, t) => {
        t.isDistinct && e.distinct();
        for (let n of t)
            if (Object(he.J)(n))
                e.value(n.valueParam ? ":".concat(n.valueParam) : n.value, n.op);
            else if (Object(he.G)(n)) {
                let {path: t} = n;
                t = t ? [...t, n.name] : n.name,
                e.field(t, n.op)
            } else
                e.method(n.name, e => fc(e, n), n.op)
    }
      , pc = (e, t) => {
        const n = "string" === typeof t ? function(e, t) {
            const n = e.queryCalc;
            if (n)
                for (let r of n)
                    if ((r.alias || r.methodName) === t)
                        return r;
            return null
        }(e, t) : t;
        if (!n)
            throw new Error("The alias ".concat(t, " does not identify a calc select method."));
        return n
    }
    ;
    function gc(e, t, n, r, i) {
        const o = pc(this.query, e);
        return this.addMethod(o.methodName, e => fc(e, o), Object(je.i)(t) ? Object(je.f)(t) : "=", n, o.isDistinct, r, i)
    }
    function mc(e, t, n, r, i, o, s) {
        if ("function" === typeof e) {
            return e(new (this.getClass(he.j))(this,Object(je.i)(t) ? Object(je.f)(t) : "=",o,s)),
            this
        }
        if (Object(je.i)(t))
            return this.addMethodFromSelect(e, t, n, o, s);
        let a = n
          , c = r;
        const u = typeof c;
        return "exists" === a || "isNull" === a ? c = null : Object(je.i)(a) && "undefined" !== u && "boolean" !== u ? a = Object(je.f)(a) : (i = r,
        c = a,
        a = "="),
        this.addMethod(e, t, a, c, i, o, s)
    }
    function yc(e, t, n, r, i, o, s) {
        return new (this.getClass(he.k))(this,e,n,r,o,s).setProps(t, i),
        this
    }
    function vc() {
        return this
    }
    const bc = {
        ...hc,
        addArg: mc,
        addMethod: yc,
        addMethodFromSelect: gc,
        clone: function(e) {
            const t = e.getOrInitQueryHaving();
            for (let n of this)
                n.clone(t);
            return t
        },
        getOrInitQueryHaving: vc,
        getResult: function(e) {
            return null
        },
        mergeMethods: function(e) {
            for (let t of e)
                t.clone(this);
            return this
        }
    };
    class _c extends Array {
        constructor(e) {
            super(),
            this.query = e
        }
    }
    function Sc(e, t, n, r, i) {
        return this.getOrInitQueryHaving().addArg(e, t, n, r, i, !1),
        this
    }
    function Oc(e, t, n, r, i) {
        return this.getOrInitQueryHaving().addArg(e, t, n, r, i, !1, "or"),
        this
    }
    function Tc(e, t, n, r, i) {
        return this.getOrInitQueryHaving().addArg(e, t, n, r, i, !1, "and"),
        this
    }
    function Ic(e, t, n, r, i) {
        return this.getOrInitQueryHaving().addArg(e, t, n, r, i, !0),
        this
    }
    function xc(e, t, n, r, i) {
        return this.getOrInitQueryHaving().addArg(e, t, n, r, i, !0, "or"),
        this
    }
    function wc(e, t, n, r, i) {
        return this.getOrInitQueryHaving().addArg(e, t, n, r, i, !0, "and"),
        this
    }
    Ga(_c),
    Object(L.a)(_c, bc),
    Object.defineProperties(_c.prototype, dc),
    Object(he.z)(_c, he.i),
    Object(he.A)(_c, he.e);
    const Mc = (e, t, n, r) => "function" === typeof t ? e.getOrInitQueryHaving().addArg(t, "exists", void 0, void 0, n, r) : e.getOrInitQueryHaving().addArg("field", t, "exists", void 0, void 0, n, r);
    function Ac(e) {
        return Mc(this, e, !1)
    }
    function Ec(e) {
        return Mc(this, e, !1, "or")
    }
    function Cc(e) {
        return Mc(this, e, !1, "and")
    }
    function Nc(e) {
        return Mc(this, e, !0)
    }
    function Rc(e) {
        return Mc(this, e, !0, "or")
    }
    function Pc(e) {
        return Mc(this, e, !0, "and")
    }
    const Dc = {
        addHavingFromQuery: function(e) {
            return e.queryHaving && this.getOrInitQueryHaving().mergeMethods(e.queryHaving),
            this
        },
        getOrInitQueryHaving: function() {
            return this.queryCalc || this.getOrInitQueryCalc(),
            this.queryHaving || (this.queryHaving = new _c(this))
        },
        having: Sc,
        orHaving: Oc,
        andHaving: Tc,
        havingNot: Ic,
        orHavingNot: xc,
        andHavingNot: wc,
        havingExists: Ac,
        andHavingExists: Cc,
        orHavingExists: Ec,
        havingNotExists: Nc,
        andHavingNotExists: Pc,
        orHavingNotExists: Rc
    };
    const Fc = {
        ...hc,
        addArg: mc,
        addMethod: yc,
        addMethodFromSelect: gc,
        clone: function(e, t) {
            "undefined" === typeof t && (t = this.join);
            const n = new this.constructor(e,this.op,t,this.not,this.id);
            for (let r of this)
                r.clone(n);
            return n
        },
        destroy: function() {
            for (let e of this)
                e.destroy();
            return this.parent = void 0,
            this.query = void 0,
            this.opFn = void 0,
            this
        },
        getOrInitQueryHaving: vc,
        isDifferentThan: function(e) {
            if (this.not !== e.not || this.op !== e.op || this.join !== e.join || this.length !== e.length || Object(he.B)(e) !== he.j)
                return !0;
            for (let t = 0; t < this.length; t++)
                if (this[t].isDifferentThan(e[t]))
                    return !0;
            return !1
        },
        having: Sc,
        orHaving: Oc,
        andHaving: Tc,
        havingNot: Ic,
        orHavingNot: xc,
        andHavingNot: wc,
        havingExists: Ac,
        andHavingExists: Cc,
        orHavingExists: Ec,
        havingNotExists: Nc,
        andHavingNotExists: Pc,
        orHavingNotExists: Rc
    };
    class kc extends Array {
        constructor(e, t, n, r, i) {
            super(),
            this.query = e.query,
            this.parent = e,
            this.argIdx = e.push(this) - 1,
            this.not = !!n,
            this.op = t || "=",
            this.opFn = Object(je.d)(this.op, this.not),
            0 === this.argIdx ? this.join = null : this.join = r,
            i && (this.id = i)
        }
    }
    function jc(e) {
        if (this.isAggregate)
            return e;
        switch (this.methodName) {
        case "count_weekdays":
        case "count_workdays":
            return e ? (e.push(this),
            e) : [this];
        default:
            for (let t of this)
                e = t.compileGroupByFieldArgs(e);
            return e
        }
    }
    function Lc(e) {
        return this.isDistinct = !!lo(this.methodName) && !1 !== e,
        this.resultState = void 0,
        this
    }
    function Vc(e) {
        return this.methodName = e,
        this.isAggregate = (e => !0 === uo[e])(e),
        this
    }
    function Uc(e, t, n) {
        return this.isDistinct = !(!t || !lo(this.methodName)),
        this.alias = n ? this.query.validateAlias(n) : n,
        "function" === typeof e ? e(this) : this.field(e),
        this
    }
    Ga(kc),
    Object(he.z)(kc, he.j),
    Object.defineProperties(kc.prototype, dc),
    Object(L.a)(kc, Fc),
    Ca(kc);
    const qc = {
        bestName: {
            get() {
                return this.alias || this.methodName
            },
            set: void 0,
            enumerable: !1
        },
        calcMethod: {
            get() {
                return this
            },
            set: void 0,
            enumerable: !1
        },
        canHaveMethod: {
            get() {
                return e = this.methodName,
                !0 === co[e];
                var e
            },
            set: void 0,
            enumerable: !1
        },
        isDateLike: {
            get() {
                return e = this.methodName,
                !0 === ao[e];
                var e
            },
            set: void 0,
            enumerable: !1
        },
        isDateCountLike: {
            get() {
                return e = this.methodName,
                !0 === ao[e];
                var e
            },
            set: void 0,
            enumerable: !1
        },
        modelName: {
            get() {
                return this.query.modelName
            },
            set: void 0,
            enumerable: !1
        },
        query: {
            get() {
                return this.parent.query
            },
            set: void 0,
            enumerable: !1
        },
        name: {
            get() {
                return this.methodName
            },
            set: void 0,
            enumerable: !1
        }
    };
    const Qc = {
        addArg: Ka,
        checkApiRead: ic,
        compileGroupByFieldArgs: jc,
        convertM2MArgsToThroughArgs: rc,
        convertPathArgsToFullPathArgs: nc,
        destroy: cc,
        distinct: Lc,
        dividedBy: tc,
        field: Wa,
        getClass: Ha,
        getFieldPathArgsTopLevelVFNames: oc,
        group: Xa,
        method: Ya,
        minus: Za,
        plus: Ja,
        prepareToProcess: sc,
        processComplete: ac,
        setMethodName: Vc,
        setProps: Uc,
        times: ec,
        value: $a
    }
      , Bc = {
        bestName: qc.bestName,
        calcMethod: qc.calcMethod,
        canHaveMethod: qc.canHaveMethod,
        hasAggregate: uc.hasAggregate,
        isOrHasAggregate: uc.isOrHasAggregate,
        hasAddSubtract: uc.hasAddSubtract,
        hasComputedFieldPathArg: uc.hasComputedFieldPathArg,
        hasMultiplyDivide: uc.hasMultiplyDivide,
        hasFieldPathArg: uc.hasFieldPathArg,
        hasM2MFieldPathArg: uc.hasM2MFieldPathArg,
        hasChildMethod: uc.hasChildMethod,
        hasNonGroupArgChildMethod: uc.hasNonGroupArgChildMethod,
        hasNonNumberArg: uc.hasNonNumberArg,
        inChildMethod: xa,
        isParent: Ia,
        modelName: qc.modelName,
        name: qc.name,
        query: qc.query,
        topLevelCalcMethod: {
            get() {
                return this
            },
            set: void 0,
            enumerable: !1
        }
    };
    function Gc(e, t) {
        const n = pc(this.query, e);
        return this.method(n.methodName, e => fc(e, n), t, n.isDistinct)
    }
    const zc = {
        ...Qc,
        addMethodFromSelect: Gc,
        clone: function(e, t) {
            "undefined" === typeof t && (t = this.join);
            const n = new this.constructor(e,this.methodName,this.op,this.compareValueParam ? ":".concat(this.compareValueParam) : this.compareValue,this.not,t,this.id);
            n.isDistinct = this.isDistinct;
            for (let r of this)
                r.clone(n);
            return n
        },
        getRealValue: function(e) {
            return this.compareValueParam ? e[this.compareValueParam] : this.compareValue
        },
        isDifferentThan: function(e) {
            if (this.compareValue !== e.compareValue || this.compareValueParam !== e.compareValueParam || this.not !== e.not || this.op !== e.op || this.join !== e.join || this.methodName !== e.methodName || this.length !== e.length || Object(he.B)(e) !== he.k)
                return !0;
            for (let t = 0; t < this.length; t++)
                if (this[t].isDifferentThan(e[t]))
                    return !0;
            return !1
        }
    }
      , Hc = {
        ...dc,
        ...Bc,
        compareValueType: {
            get() {
                return this.query.model.types.get(Xr.a.QUERY_CALC_VALUE)
            },
            set: void 0,
            enumerable: !1
        }
    };
    class Kc extends Array {
        constructor(e, t, n, r, i, o, s) {
            if (super(),
            this.parent = e,
            this.argIdx = e.push(this) - 1,
            this.not = !!i,
            this.compareValueParam = At(r),
            this.compareValueParam) {
                this.compareValue = void 0;
                const {query: e} = this;
                e.validateParam(this.compareValueParam, 'having method "'.concat(t, '"')),
                e.queryHasVariables = !0
            } else
                this.compareValue = r,
                null === r && "exists" !== n && (n = "isNull");
            this.op = n || "=",
            this.opFn = Object(je.d)(this.op, this.not),
            0 === this.argIdx ? this.join = null : this.join = o || "and",
            s && (this.id = s),
            this.setMethodName(t)
        }
    }
    Ga(Kc),
    Object(L.a)(Kc, zc),
    Object.defineProperties(Kc.prototype, Hc),
    Object(he.z)(Kc, he.k),
    Object(he.A)(Kc, he.a),
    Ea = Kc,
    Ma.__HavingMethod = Ea;
    const Yc = (e, t, n) => {
        let r;
        if (e.__record === e || "undefined" === typeof (r = e[t.VFName]) && (e = e.__record)) {
            if (!(r = e[t.ownFieldName]) || !(r = n.get(r)))
                return null;
            t.isMany && (r = r.getState())
        }
        return r
    }
      , Wc = (e, t, n, r) => {
        const i = t;
        if (n)
            if (n[1])
                for (let o of n)
                    o[e] = i,
                    r.push(o);
            else
                n[0][e] = i,
                r.push(n[0]);
        else
            r.push({
                [e]: i
            })
    }
      , $c = (e, t) => {
        const n = t.length - 1
          , r = e.length
          , i = r - 1;
        let o, s, a, c, u = 0;
        for (; u < r; ) {
            if (s = e[u],
            o = 0,
            u === i)
                for (; o <= n; ) {
                    for (c in a = t[o],
                    s)
                        a[c] = s[c];
                    o++
                }
            else
                for (; o <= n; )
                    t.push({
                        ...t[o],
                        ...s
                    }),
                    o++;
            u++
        }
        return t
    }
      , Xc = (e, t, n, r, i) => {
        let o, s, a, c, u, l;
        i = i ? "".concat(i, "||") : "";
        for (let d in t)
            if (o = n[d],
            s = "".concat(i).concat(d),
            c = Yc(e, o, r[d])) {
                if (a = [],
                t[d])
                    if (o.isMany)
                        for (u in c)
                            Wc(s, c[u], Xc(c[u], t[d], n, r, s), a);
                    else
                        Wc(s, c, Xc(c, t[d], n, r, s), a);
                else if (o.isMany)
                    for (u in c)
                        a.push({
                            [s]: c[u]
                        });
                else
                    a.push({
                        [s]: c
                    });
                l && $c(l, a),
                l = a
            }
        return a
    }
    ;
    function Jc(e, t, n, r) {
        let i, o = "";
        const s = {};
        for (let[,a] of t)
            a.isExcluded || (i = a.getSingleResult(n, r),
            o = o ? "".concat(o, "||").concat(i) : "".concat(i),
            s[a.alias || a.methodName] = i);
        return e[o] ? (r && (e[o].combinedRecords || (e[o].combinedRecords = new Array(e[o].records.length)),
        e[o].combinedRecords.push(r)),
        e[o].records.push(n)) : e[o] = {
            records: [n],
            combinedRecords: r ? [r] : null,
            result: s
        },
        o
    }
    const Zc = {
        ...hc,
        _maybeEnsureAlias: function(e) {
            if (2 === this.length)
                for (let t of this)
                    t.ensureAlias();
            else
                this.length > 1 && e.ensureAlias();
            return this
        },
        addMethod: function(e, t, n, r) {
            const i = this.getClass(he.k);
            if ("field" === e && "object" === typeof t && !Array.isArray(t)) {
                let n;
                for (let r in t)
                    n = new i(this,e).setProps(t[r], !1, r),
                    this._maybeEnsureAlias(n);
                return this
            }
            let o = n;
            "boolean" === typeof o && (r = "boolean" === typeof r ? r : o,
            o = void 0);
            const s = new i(this,e).setProps(t, r, o);
            return this._maybeEnsureAlias(s)
        },
        addMethodFromSelectField: function(e, t, n) {
            if (!n) {
                const n = e.alias || e.name;
                e: for (let e of this) {
                    if ("field" !== e.methodName || e[0].bestName !== n)
                        continue;
                    const r = e[0].path;
                    if (!t && !r)
                        return this;
                    if (t && r && t.length === r.length) {
                        for (let e = 0; e < t.length; e++)
                            if (t[e] !== r[e])
                                continue e;
                        return this
                    }
                }
            }
            const r = new (this.getClass(he.k))(this,"field");
            return r.setPropsFromSelectField(e, t),
            this._maybeEnsureAlias(r)
        },
        addNonAggregatesFromQuery: function(e, t) {
            const {querySelect: n, includeVFs: r} = e;
            if (!n && !r)
                return this;
            if (n) {
                const r = 0 === this.length;
                for (let e in n)
                    this.addMethodFromSelectField(n[e], t, r),
                    n[e].destroy();
                e.querySelect = void 0
            }
            if (!r)
                return this;
            let i;
            for (let o in r)
                (i = r[o]).query && (this.addNonAggregatesFromQuery(i.query, t ? [...t, i.VF] : [i.VF]),
                i.destroy());
            return e.includeVFs = void 0,
            this
        },
        clone: function(e) {
            const t = e.getOrInitQueryCalc();
            for (let n of this)
                n.clone(t);
            return t.isDistinct = this.isDistinct,
            t
        },
        convertToSelect: function(e, t) {
            let n, r, i, o, s;
            const a = e.pagination && e.pagination.getOrderBy();
            if (a) {
                let r = 0
                  , i = a.length;
                for (; r < i; ) {
                    if (({path: n} = a[r]),
                    1 === n.length)
                        o || (o = {}),
                        o[n[0]] = a[r];
                    else {
                        if (t) {
                            a.splice(r, 1),
                            i--;
                            continue
                        }
                        s || (s = {}),
                        s[n.join("__")] = a[r]
                    }
                    r++
                }
                0 === a.length && (e.pagination.orderBy = void 0,
                o = void 0)
            }
            let c, u;
            for (let l of this)
                if ("field" === l.methodName)
                    if (({name: r, path: n} = l[0]),
                    i = e => {
                        e.field(r, l.alias === r ? void 0 : l.alias),
                        ht(e, l)
                    }
                    ,
                    n) {
                        if (!t) {
                            a && (c = o ? o[l.alias] : void 0,
                            u = c ? void 0 : s ? "".concat(n[0].VFName) : void 0);
                            let t = 0;
                            const d = l => {
                                t++,
                                n[t] ? (u && (u += "__".concat(n[t].VFName)),
                                l.include(n[t].VFName, d)) : (l.select(i),
                                (c || u && (c = s["".concat(u, "__").concat(r)])) && (l.orderBy(r, c.type, c.nulls),
                                a.splice(a.indexOf(c), 1),
                                0 === a.length && (e.pagination.orderBy = void 0,
                                o = void 0,
                                s = void 0)))
                            }
                            ;
                            e.include(n[0].VFName, d)
                        }
                    } else
                        e.select(i);
                else
                    o && (c = o[l.alias]) && (a.splice(a.indexOf(c), 1),
                    0 === a.length && (e.pagination.orderBy = void 0,
                    o = void 0,
                    s = void 0));
            return this
        },
        distinct: function(e) {
            return (e = !1 !== e) === this.isDistinct || (this.isDistinct = !(!e || this.hasAggregate) && e),
            this
        },
        getOrInitQueryCalc: function() {
            return this
        },
        getResult: function(e) {
            const t = e.recordsResults || e.records;
            if (!t)
                return null;
            let n = !1
              , r = !1;
            for (let s of this)
                s.prepareToProcess(e),
                !r && s.hasFieldPathArg && (r = !0),
                s.isExcluded || (n = !0);
            if (!n)
                return null;
            const i = r ? function(e, t, n) {
                let r, i, o, s;
                const a = e => {
                    for (let t of e)
                        if (Object(he.H)(t))
                            a(t);
                        else if (t.path && Object(he.G)(t)) {
                            const {path: e} = t;
                            let r, a, c = 0, u = e.length - 1, l = s;
                            for (let t of e)
                                ({VFName: r, instanceId: a} = t),
                                o[a] || (o[a] = t,
                                i[a] = t.getIndex(n)),
                                l[a] || (l[a] = c < u ? {} : null),
                                l = l[a],
                                c++
                        }
                }
                ;
                for (let c of t)
                    c.isExcluded || (r || (r = {},
                    i = {},
                    o = {},
                    s = {}),
                    a(c));
                if (!r)
                    return null;
                for (let c in e)
                    r[c] = Xc(e[c], s, o, i);
                return r
            }(t, this, e.dispatchId) : null;
            let o;
            if (console.log("calc = ", this),
            console.log("combinedRecords = ", i),
            this.groupByMethods) {
                let e, n, r;
                if (i)
                    e = function(e, t, n) {
                        const {groupByMethods: r} = n
                          , i = {};
                        let o, s, a;
                        for (let c in e)
                            if (o = e[c],
                            s = t[c],
                            s)
                                for (a of s)
                                    Jc(i, r, o, a);
                            else
                                Jc(i, r, o, null);
                        return i
                    }(t, i, this);
                else {
                    const {groupByMethods: n} = this;
                    e = {};
                    for (let r in t)
                        Jc(e, n, t[r])
                }
                console.log("byGroup = ", e),
                o = [];
                for (let t in e) {
                    for (n of (r = e[t],
                    this))
                        n.isAggregate && !n.isExcluded && n.addToGroupedResult(r);
                    o.push(r.result)
                }
                return o
            }
            if (this.length > 1) {
                o = {};
                for (let e of this)
                    e.isExcluded || (o[e.alias] = e.getResult(t, i))
            } else
                o = this[0].alias ? {
                    [this[0].alias]: this[0].getResult(t, i)
                } : this[0].getResult(t, i);
            for (let s of this)
                s.processComplete();
            return o
        },
        mergeMethods: function(e) {
            for (let t of e)
                this._maybeEnsureAlias(t.clone(this));
            return this.isDistinct = !(!this.isDistinct && !e.isDistinct || this.hasAggregate),
            this
        }
    };
    class eu extends Array {
        constructor(e) {
            super(),
            this.query = e,
            this.isDistinct = !1
        }
    }
    Ga(eu),
    Object(he.z)(eu, he.l),
    Object(he.A)(eu, he.e),
    Object.defineProperties(eu.prototype, lc),
    Object(L.a)(eu, Zc);
    const tu = /^_/
      , nu = /_+$/;
    function ru(e) {
        return e.replace(/\W+/g, "_").replace(/_{2,}/g, "_").replace(tu, "").replace(nu, "")
    }
    var iu = n(83)
      , ou = n(237);
    const su = (e, t) => e + t
      , au = (e, t) => e - t
      , cu = (e, t) => e * t
      , uu = (e, t) => e / t
      , lu = (e, t) => Math.pow(e, t);
    function du(e) {
        switch (e) {
        case "+":
            return su;
        case "-":
            return au;
        case "*":
            return cu;
        case "/":
            return uu;
        case "^":
            return lu;
        default:
            throw new Error("Unrecognized calc operation: ".concat(e, ". Expected + - * / ^"))
        }
    }
    function hu(e, t) {
        return "undefined" === typeof t && (t = this.op),
        new this.constructor(e,t,this.id)
    }
    function fu(e) {
        return 0 === this.argIdx ? (this.op = null,
        this.opFn = null) : e ? (this.op = e,
        this.opFn = du(e)) : (this.op = "+",
        this.opFn = du("+")),
        this
    }
    const pu = function() {
        const e = {
            calcMethod: {
                get() {
                    return this.parent.calcMethod
                }
            },
            hasAddSubtract: {
                get() {
                    return "+" === this.op || "-" === this.op
                }
            },
            hasMultiplyDivide: {
                get() {
                    return "*" === this.op || "/" === this.op
                }
            },
            query: {
                get() {
                    return this.parent.query
                }
            },
            isSelect: {
                get() {
                    return this.parent.isSelect
                }
            },
            isHaving: {
                get() {
                    return this.parent.isHaving
                }
            },
            inChildMethod: {
                get() {
                    return Object(he.F)(this.calcMethod)
                }
            },
            topLevelCalcMethod: {
                get() {
                    return this.parent.topLevelCalcMethod
                }
            }
        };
        for (let t in e)
            e[t].enumerable = !1,
            e[t].set = void 0;
        return e
    }();
    const gu = (e, t) => {
        if (!t)
            throw new Error("The field ".concat(e.name, " does not exist on model ").concat(e.modelName, "."));
        e.isDynamicForeignFieldLike = !(!t.predicateFieldName && !t.predicateForFieldName)
    }
    ;
    const mu = {
        _preparePath: function(e) {
            return Ks(this.calcMethod.query.model, e)
        },
        checkApiRead: function(e) {
            if (!this.getField().apiRead)
                return e || (e = []),
                e.push('Unknown field "'.concat(this.name, '" in ').concat(this.calcMethod.bestName, " calculation.")),
                e;
            if (!this.path)
                return e;
            const {path: t} = this;
            for (let n of t)
                if (!n.ownModelVFApiRead)
                    return e || (e = []),
                    e.push('Unknown related field "'.concat(n.VFName, '" in ').concat(this.calcMethod.bestName, " calculation.")),
                    e;
            return e
        },
        clone: function(e, t) {
            const n = hu.call(this, e, t);
            return n.path = this.path,
            n.name = this.name,
            n.modelName = this.modelName,
            n.isDynamicForeignFieldLike = this.isDynamicForeignFieldLike,
            this.path && (n.VFInstanceId = this.VFInstanceId,
            n.hasM2MFieldPathArg = this.hasM2MFieldPathArg,
            n.hasComputedFieldPathArg = this.hasComputedFieldPathArg),
            n
        },
        compileGroupByFieldArgs: function(e) {
            return e ? e.push(this) : e = [this],
            e
        },
        convertPathArgsToFullPathArgs: function(e) {
            if (!this.path || !this.hasComputedFieldPathArg)
                return this;
            const {path: t} = this;
            if (e) {
                if (t[0].VFName !== e || !t[0].isComputed)
                    return this;
                if (1 === t.length)
                    this.path = [...t[0].ownFieldFullVFPath];
                else {
                    const [e,...n] = t;
                    n.unshift(...e.ownFieldFullVFPath),
                    this.path = n
                }
            } else {
                const e = [];
                for (let n of t)
                    n.isComputed ? e.push(...n.ownFieldFullVFPath) : e.push(n);
                this.path = e
            }
            return this.setVFInstanceId()
        },
        convertM2MArgsToThroughArgs: function(e) {
            if (!this.path || !this.hasM2MFieldPathArg)
                return this;
            const {path: t} = this;
            let n;
            if (e) {
                let r = t[0];
                if (r.VFName !== e || !r.isManyToMany)
                    return this;
                if (n = [r.ownModelThroughVF, r.ownRefModelThroughVF.modelVF],
                t.length > 1)
                    for (let e = 1; e < t.length; e++)
                        n.push(t[e])
            } else {
                n = [];
                for (let e of t)
                    e.isManyToMany ? n.push(e.ownModelThroughVF, e.ownRefModelThroughVF.modelVF) : n.push(e)
            }
            return this.path = n,
            this.setVFInstanceId()
        },
        destroy: function() {
            this.parent = void 0,
            this.path && (this.path = void 0)
        },
        getField: function() {
            return this.path ? this.path[this.path.length - 1].ownRefModel.fields[this.name] : this.calcMethod.query.fields[this.name]
        },
        getFieldPathArgsTopLevelVFNames: function(e) {
            return this.path ? e ? (e.indexOf(this.path[0].VFName) < 0 && e.push(this.path[0].VFName),
            e) : [this.path[0].VFName] : e
        },
        getValue: function(e, t) {
            return this.path ? t && (e = t[this.VFInstanceId]) ? e.__record[this.name] : null : e.__record[this.name]
        },
        isDifferentThan: function(e) {
            if (Object(he.B)(e) !== he.g || this.name !== e.name || this.modelName !== e.modelName || this.hasM2MFieldPathArg !== e.hasM2MFieldPathArg || this.hasComputedFieldPathArg !== e.hasComputedFieldPathArg)
                return !0;
            const {path: t} = this
              , {path: n} = e;
            if (!t || !n)
                return !(!t && !n);
            if (t.length !== n.length)
                return !0;
            for (let r = 0; r < t.length; r++)
                if (t[r] !== n[r])
                    return !0;
            return !1
        },
        prepareToProcess: function(e) {
            return this
        },
        processComplete: function() {
            return this
        },
        setOp: fu,
        setProps: function(e) {
            if (this.path = null,
            Array.isArray(e) ? 1 !== e.length || Array.isArray(e[0]) ? (e = [...e],
            this.name = e.pop(),
            this.path = this._preparePath(e),
            this.setVFInstanceId()) : this.name = e[0] : this.name = e,
            "*" === this.name || "__ID" === this.name) {
                if (this.path) {
                    const e = this.path[this.path.length - 1];
                    this.modelName = e.ownRefModelName,
                    this.name = e.ownRefModelPk
                } else {
                    const e = this.calcMethod.query;
                    this.modelName = e.modelName,
                    this.name = e.primaryKey
                }
                this.isDynamicForeignFieldLike = !1
            } else if (this.path) {
                const e = this.path[this.path.length - 1];
                this.modelName = e.ownRefModelName,
                gu(this, e.otherModel.fields[this.name])
            } else {
                const e = this.calcMethod.query;
                this.modelName = e.modelName,
                gu(this, e.fields[this.name])
            }
            return this
        },
        setPropsFromSelectField: function(e, t) {
            this.path = t || null,
            this.name = e.name,
            this.modelName = e.query.modelName,
            t && this.setVFInstanceId();
            const n = e.query.fields[this.name];
            return this.isDynamicForeignFieldLike = !(!n.predicateFieldName && !n.predicateForFieldName),
            this
        },
        setVFInstanceId: function() {
            const {path: e} = this;
            let t;
            this.hasM2MFieldPathArg = !1,
            this.hasComputedFieldPathArg = !1;
            for (let n of e)
                t ? t += "||".concat(n.instanceId) : t = n.instanceId,
                n.isManyToMany && (this.hasM2MFieldPathArg = !0),
                n.isComputed && (this.hasComputedFieldPathArg = !0);
            return this.VFInstanceId = t,
            this
        }
    }
      , yu = {
        calcMethod: pu.calcMethod,
        canHaveMethod: xa,
        field: {
            get() {
                return this.path ? this.path[this.path.length - 1].otherModel.fields[this.name] : this.query.fields[this.name]
            },
            set: void 0,
            enumerable: !1
        },
        model: {
            get() {
                return this.path ? this.path[this.path.length - 1].otherModel : this.query.model
            },
            set: void 0,
            enumerable: !1
        },
        hasAddSubtract: pu.hasAddSubtract,
        hasFieldPathArg: {
            get() {
                return !!this.path
            },
            set: void 0,
            enumerable: !1
        },
        hasMultiplyDivide: pu.hasMultiplyDivide,
        hasNonNumberArg: {
            get() {
                switch (this.field.type.KIND) {
                case ei.a.INT:
                case ei.a.FLOAT:
                    return !1;
                default:
                    return !0
                }
            },
            set: void 0,
            enumerable: !1
        },
        hasChildMethod: xa,
        hasNonGroupArgChildMethod: xa,
        inChildMethod: pu.inChildMethod,
        isHaving: pu.isHaving,
        isParent: xa,
        isSelect: pu.isSelect,
        query: pu.query,
        topLevelCalcMethod: pu.topLevelCalcMethod,
        isAggregate: xa,
        isOrHasAggregate: xa
    };
    class vu {
        constructor(e, t, n) {
            this.parent = e,
            this.argIdx = e.push(this) - 1,
            this.hasComputedFieldPathArg = !1,
            this.hasM2MFieldPathArg = !1,
            n && (this.id = n),
            this.setOp(t)
        }
    }
    Object(he.z)(vu, he.g),
    Object(L.a)(vu, mu),
    Object.defineProperties(vu.prototype, yu),
    Ca(vu);
    const bu = (e, t) => {
        for (let n of e)
            if (n.alias === t)
                return !1;
        return !0
    }
    ;
    const _u = e => Object(ve.a)("avg", e)
      , Su = (e, t) => Object(ve.b)(e, t)
      , Ou = e => e;
    const Tu = {
        ...Qc,
        addDirective: function(e, t, n) {
            const r = Tt.call(this, e, t, n);
            if (r)
                throw new Error(Object.values(r).join("\n"));
            return this
        },
        addToGroupedResult: function(e) {
            const {records: t, combinedRecords: n, result: r} = e;
            if (n)
                for (let i = 0; i < t.length; i++)
                    Qa.call(this, t[i], n[i]);
            else
                for (let i of t)
                    Qa.call(this, i);
            r[this.bestName] = this.resultState.getResult(),
            this.resultState.reset()
        },
        clone: function(e) {
            const t = new this.constructor(e,this.methodName,this.id);
            t.isDistinct = this.isDistinct,
            t.alias = this.alias,
            this.directives && gt.call(t, this);
            for (let n of this)
                n.clone(t);
            return t
        },
        ensureAlias: function() {
            if (this.alias)
                return this;
            const {parent: e} = this;
            let t, n;
            if (t = function e(t) {
                let n;
                for (let r of t)
                    if (r.isParent) {
                        if (n = e(r))
                            return n
                    } else if (Object(he.G)(r))
                        return r
            }(this),
            t) {
                let r, i, s = t.name, a = t.field.displayName;
                s = a === s ? (e => ("_" === e.charAt(0) && (e = "_" === e.charAt(e.length - 1) ? e.substring(1, e.length - 1) : e.substring(1)),
                e))(s) : ru(a),
                "avg" === this.methodName ? r = _u : "field" === this.methodName ? (r = Ou,
                i = "") : (r = Su,
                i = this.methodName,
                "count" === i && 1 === this.length && t.field.primary && (s = "total"));
                const {path: c} = t;
                let u;
                if (c) {
                    const e = 1 === c.length ? c[c.length - 1].VFName : Object(iu.a)(s) ? c[c.length - 1].otherModel.modelDisplayName : Object(ou.a)(c[c.length - 1].otherModel.modelDisplayName);
                    s = Object(ve.a)(e, s)
                }
                for (; n = r(s, i),
                u && (n += u),
                !bu(e, n); )
                    u = u ? u + 1 : 1;
                try {
                    return this.query.validateAlias(n),
                    this.alias = n,
                    this
                } catch (o) {}
            }
            let r = "field" === this.methodName ? "field" : "value"
              , i = 1;
            for (; ; ) {
                if (n = 1 === i ? r : "".concat(r).concat(i),
                bu(e, n)) {
                    this.alias = n;
                    break
                }
                i++
            }
            return this
        },
        getResult: function(e, t) {
            if (t) {
                let n, r, i;
                for (let o in e)
                    if (r = t[o])
                        for (i of (n = e[o],
                        r))
                            Qa.call(this, n, i)
            } else
                for (let n in e)
                    Qa.call(this, e[n]);
            return this.resultState.getResult()
        },
        getSingleResult: function(e, t) {
            if ("field" === this.methodName)
                return this[0].getValue(e, t);
            if (Qa.call(this, e, t)) {
                const e = this.resultState.getResult();
                return this.resultState.reset(),
                e
            }
            return null
        },
        getValueParam: function(e) {
            const t = At(e);
            return t && (this.query.queryHasVariables = !0),
            t
        },
        isDifferentThan: function(e) {
            if (!e || this.alias !== e.alias || this.methodName !== e.methodName || this.isDistinct !== e.isDistinct || this.length !== e.length || vt(this, e))
                return !0;
            for (let t = 0; t < this.length; t++)
                if (this[t].isDifferentThan(e[t]))
                    return !0;
            return !1
        },
        prepareToProcess: function(e) {
            return this.shouldInclude(e.variables) ? sc.call(this, e) : (this.isExcluded = !0,
            this)
        },
        setPropsFromSelectField: function(e, t) {
            return !e.alias || t && !bu(this.parent, e.alias) || (this.alias = e.alias),
            this.directives = e.directives,
            this.directiveVariables = e.directiveVariables,
            this.directiveDefaults = e.directiveDefaults,
            new vu(this,null).setPropsFromSelectField(e, t),
            this
        },
        shouldInclude: function(e) {
            return Er(this, e)
        },
        useAlias: function(e) {
            return this.alias = e ? this.query.validateAlias(e) : e,
            this
        }
    }
      , Iu = {
        ...lc,
        ...Bc,
        definedDirectives: {
            get() {
                return this.query.definedDirectives
            },
            set: void 0,
            enumerable: !1
        }
    };
    class xu extends Array {
        constructor(e, t, n) {
            super(),
            this.parent = e,
            this.argIdx = e.push(this) - 1,
            this.op = null,
            n && (this.id = n),
            this.setMethodName(t)
        }
    }
    Ga(xu),
    Object(L.a)(xu, Tu),
    Object.defineProperties(xu.prototype, Iu),
    Object(he.z)(xu, he.k),
    Object(he.A)(xu, he.w),
    function(e) {
        Aa = e,
        Ma.__SelectMethod = Aa
    }(xu);
    const wu = {
        addArg: Ka,
        checkApiRead: ic,
        convertPathArgsToFullPathArgs: nc,
        convertM2MArgsToThroughArgs: rc,
        destroy: cc,
        dividedBy: tc,
        field: Wa,
        getClass: Ha,
        getFieldPathArgsTopLevelVFNames: oc,
        getValue: function(e, t) {
            if ("field" === this.methodName)
                return this[0].getValue(e, t);
            if (Qa.call(this, e, t)) {
                const e = this.resultState.getResult();
                return this.resultState.reset(),
                e
            }
            return null
        },
        group: Xa,
        method: Ya,
        minus: Za,
        plus: Ja,
        prepareToProcess: sc,
        processComplete: ac,
        setOp: fu,
        times: ec,
        value: $a,
        useAlias: function(e) {
            return this
        }
    }
      , Mu = {
        hasAddSubtract: uc.hasAddSubtract,
        hasComputedFieldPathArg: uc.hasComputedFieldPathArg,
        hasFieldPathArg: uc.hasFieldPathArg,
        hasAggregate: uc.hasAggregate,
        isOrHasAggregate: uc.isOrHasAggregate,
        hasM2MFieldPathArg: uc.hasM2MFieldPathArg,
        hasMultiplyDivide: uc.hasMultiplyDivide,
        hasChildMethod: uc.hasChildMethod,
        hasNonGroupArgChildMethod: uc.hasNonGroupArgChildMethod,
        hasNonNumberArg: uc.hasNonNumberArg,
        isHaving: pu.isHaving,
        isParent: Ia,
        isSelect: pu.isSelect,
        inChildMethod: pu.inChildMethod,
        query: pu.query,
        topLevelCalcMethod: pu.topLevelCalcMethod
    };
    const Au = {
        ...wu,
        addMethodFromSelect: Gc,
        clone: function(e, t) {
            "undefined" === typeof t && (t = this.op);
            const n = new this.constructor(e,this.methodName,t,this.id);
            n.isDistinct = this.isDistinct;
            for (let r of this)
                r.clone(n);
            return n
        },
        compileGroupByFieldArgs: jc,
        distinct: Lc,
        isDifferentThan: function(e) {
            if (Object(he.B)(e) !== he.f || this.length !== e.length || this.methodName !== e.methodName || this.isDistinct !== e.isDistinct || this.op !== e.op)
                return !0;
            for (let t = 0; t < this.length; t++)
                if (this[t].isDifferentThan(e[t]))
                    return !0;
            return !1
        },
        setMethodName: Vc,
        setProps: Uc
    }
      , Eu = {
        ...Mu,
        alias: wa,
        bestName: qc.bestName,
        calcMethod: qc.calcMethod,
        canHaveMethod: qc.canHaveMethod,
        modelName: qc.modelName,
        name: qc.name
    };
    class Cu extends Array {
        constructor(e, t, n, r) {
            super(),
            this.parent = e,
            this.argIdx = e.push(this) - 1,
            this.isDistinct = !1,
            this.mixedMathArray = void 0,
            r && (this.id = r),
            this.setMethodName(t).setOp(n)
        }
    }
    Ga(Cu),
    Object(L.a)(Cu, Au),
    Object.defineProperties(Cu.prototype, Eu),
    Object(he.z)(Cu, he.f),
    Ca(Cu);
    const Nu = {
        ...wu,
        clone: function(e, t) {
            "undefined" === typeof t && (t = this.op);
            const n = new this.constructor(e,t,this.id);
            for (let r of this)
                r.clone(n);
            return n
        },
        compileGroupByFieldArgs: function(e) {
            for (let t of this)
                e = t.compileGroupByFieldArgs(e);
            return e
        },
        isDifferentThan: function(e) {
            if (Object(he.B)(e) !== he.h || this.length !== e.length || this.op !== e.op)
                return !0;
            for (let t = 0; t < this.length; t++)
                if (this[t].isDifferentThan(e[t]))
                    return !0;
            return !1
        },
        setMethodName: function(e) {
            return this
        },
        setProps: function(e) {
            return e(this),
            this
        }
    }
      , Ru = {
        ...Mu,
        calcMethod: pu.calcMethod,
        canHaveMethod: {
            get() {
                return this.calcMethod.canHaveMethod
            },
            set: void 0,
            enumerable: !1
        },
        isDistinct: xa,
        isAggregate: xa,
        methodName: {
            get: () => "sum",
            set(e) {},
            enumerable: !1
        }
    };
    class Pu extends Array {
        constructor(e, t, n) {
            super(),
            this.parent = e,
            this.argIdx = e.push(this) - 1,
            this.mixedMathArray = void 0,
            n && (this.id = n),
            this.setOp(t)
        }
    }
    Ga(Pu),
    Object(L.a)(Pu, Nu),
    Object.defineProperties(Pu.prototype, Ru),
    Object(he.z)(Pu, he.h),
    Ca(Pu);
    const Du = {
        clone: function(e, t) {
            const n = hu.call(this, e, t);
            return n.value = this.value,
            n.valueParam = this.valueParam,
            n.valueParam && (n.query.queryHasVariables = !0),
            n
        },
        checkApiRead: function(e) {
            return e
        },
        compileGroupByFieldArgs: function(e) {
            return e
        },
        convertM2MArgsToThroughArgs: function(e) {
            return this
        },
        convertPathArgsToFullPathArgs: function(e) {
            return this
        },
        destroy: function() {
            this.parent = void 0,
            this.value = void 0
        },
        getFieldPathArgsTopLevelVFNames: function(e) {
            return e
        },
        getRealValue: function(e) {
            return this.valueParam ? this.calcMethod.isDateCountLike ? this.valueType.parseValue(e[this.valueParam]) : e[this.valueParam] : this.value
        },
        getValue: function(e, t) {
            return this.value
        },
        isDifferentThan: function(e) {
            return Object(he.B)(e) !== he.m || this.valueParam !== e.valueParam || this.value !== e.value || this.op !== e.op
        },
        prepareToProcess: function(e) {
            return this.valueParam && (this.value = this.getRealValue(e.variables)),
            this
        },
        processComplete: function() {
            return this.valueParam && (this.value = void 0),
            this
        },
        setOp: fu,
        setProps: function(e) {
            return this.valueParam = At(e),
            this.valueParam ? (this.query.validateParam(this.valueParam),
            this.query.queryHasVariables = !0,
            this.value = void 0) : this.value = e,
            this
        }
    }
      , Fu = {
        get: () => !1,
        set: void 0,
        enumerable: !1
    }
      , ku = /^-?[\d\.]*$/
      , ju = {
        calcMethod: pu.calcMethod,
        canHaveMethod: xa,
        hasAddSubtract: pu.hasAddSubtract,
        hasComputedFieldPathArg: Fu,
        hasFieldPathArg: Fu,
        hasM2MFieldPathArg: Fu,
        hasMultiplyDivide: pu.hasMultiplyDivide,
        hasChildMethod: xa,
        hasNonGroupArgChildMethod: xa,
        hasNonNumberArg: {
            get() {
                return !this.valueParam && "number" !== typeof this.value && ku.test(this.value)
            },
            set: void 0,
            enumerable: !1
        },
        inChildMethod: pu.inChildMethod,
        isHaving: pu.isHaving,
        isParent: xa,
        isSelect: pu.isSelect,
        isAggregate: xa,
        isOrHasAggregate: xa,
        query: pu.query,
        topLevelCalcMethod: pu.topLevelCalcMethod,
        valueType: {
            get() {
                switch (this.calcMethod.methodName) {
                case "count_weekdays":
                case "count_workdays":
                    return this.query.model.types.Date.use();
                default:
                    return this.query.model.types.get(Xr.a.QUERY_CALC_VALUE)
                }
            },
            set: void 0,
            enumerable: !1
        }
    };
    class Lu {
        constructor(e, t, n) {
            this.parent = e,
            this.argIdx = e.push(this) - 1,
            n && (this.id = n),
            this.setOp(t)
        }
    }
    Object(L.a)(Lu, Du),
    Object.defineProperties(Lu.prototype, ju),
    Object(he.z)(Lu, he.m),
    Ca(Lu);
    const {MAIN_QUERY: Vu} = pe;
    const Uu = {
        convertVFsData: function() {
            return this
        },
        setVariables: function(e, t) {
            e.variables = this.prepareVariables(t, e);
            const n = e.children;
            if (n) {
                let e;
                for (let r in n)
                    e = n[r],
                    e.query.setVariables(e, t)
            }
            return this
        },
        maybeDestroy: function(e) {
            this._noDestroy || !this.isRootQuery || this.isMutation || this.persistentId || this.destroy(e)
        },
        modelHasField: function(e) {
            return !!this.fields[e]
        },
        getState: function(e) {
            return this.getBestModel(e).getState()
        },
        getBestModel: function(e) {
            if (e) {
                let t = e.model;
                const n = fn(e);
                return t && !t.__closed || (t = this.getBestModel()),
                n && (t = t.getBestInstance(n)),
                e.model = t,
                t
            }
            return this.model.__closed && (this.model = this.model.mainModel),
            this.model
        },
        getSession: function(e) {
            if (!e && !(e = this.payload))
                return this.getBestModel().getSession() || null;
            if (e.session)
                return e.session;
            if (e.action)
                return e.action.meta.getSession() || null;
            if (e.graphqlContext)
                return e.graphqlContext.session || null;
            if (e.mutation)
                return e.mutation.getSession();
            if (e.bestMeta)
                return e.bestMeta.getSession() || null;
            const t = hn(e);
            return t === e ? this.getBestModel().getSession(fn(e)) || null : this.getSession(t)
        },
        getTimeZone: function(e, t) {
            if (this.directives && this.directives[fe.a.TIME_ZONE]) {
                const n = this.directiveVariables && this.directiveVariables[fe.a.TIME_ZONE];
                return n && n.value ? t ? null : e && e.variables ? e.variables[n.value] : null : this.directives[fe.a.TIME_ZONE].value
            }
            if (this.parent)
                return this.parent.getTimeZone(e ? e.parent || e : void 0, t);
            if (t)
                return null;
            {
                const t = this.getSession(e);
                return t ? t.timeZone : null
            }
        },
        executeQuery: function(e) {
            if (!e)
                throw new Error("A payload must be provided to use execute. An execution method (find/fetch) must also be defined somewhere in the payload - either on the payload itself, or a parent's. Otherwise call any of the find or fetch methods.");
            const t = pn(e, "method");
            if (!t)
                throw new Error("No execute method found on the payload or its parent(s). Use any of the find/fetch methods instead.");
            return this[t](e)
        },
        extractVariables: function(e, t, n) {
            if (this.queryHasVariables) {
                n = this.queryArgs.extractVariables(e, t, n);
                const r = this.includeVFs;
                if (r)
                    for (let i in r)
                        n = r[i].extractVariables(e, t, n)
            }
            return n
        }
    }
      , qu = {
        init: function(e, t) {
            const n = new this(Vu);
            return n.model = e,
            n.parent = void 0,
            n.queryName = t || e.schema.queryManyOp,
            e.addRemoveQuery(n),
            n
        }
    }
      , Qu = {
        RecordResult: {
            get() {
                return this.model.RecordResult
            },
            configurable: !0
        },
        primaryKey: {
            get() {
                return this.parentPropsMap.primaryKey ? this.parent.primaryKey : this._primaryKey
            },
            configurable: !0
        },
        modelName: {
            get() {
                return this.parentPropsMap.modelName ? this.parent.modelName : this._modelName
            },
            configurable: !0
        },
        fields: {
            get() {
                return this.parentPropsMap.fields ? this.parent.fields : this._fields
            },
            configurable: !0
        },
        dynamicForeignFields: {
            get() {
                return this.parentPropsMap.fields ? this.parent.dynamicForeignFields : this._dynamicForeignFields
            },
            configurable: !0
        },
        virtualFields: {
            get() {
                return this.parentPropsMap.virtualFields ? this.parent.virtualFields : this._virtualFields
            },
            configurable: !0
        },
        model: {
            get() {
                return this.parentPropsMap.model ? this.parent.model : this._model
            },
            set(e) {
                if (this.parentPropsMap.model)
                    e && this.parent._model !== e && (this.parent.model = e);
                else if (this._model = e,
                e) {
                    const {schema: t} = e;
                    this._virtualFields = t.virtualFields,
                    this._fields = t.fields,
                    this._dynamicForeignFields = t.dynamicForeignFields,
                    this._primaryKey = t.primaryKey,
                    this._modelName = t.name,
                    this._types = e.types,
                    this._definedDirectives = e.directives
                } else
                    this._virtualFields = void 0,
                    this._fields = void 0,
                    this._dynamicForeignFields = void 0,
                    this._types = void 0,
                    this._definedDirectives = void 0
            },
            configurable: !0
        },
        isServer: {
            get() {
                return this.model.isServer
            },
            configurable: !0
        },
        queryHasPathInclude: {
            get() {
                return this._queryHasPathInclude
            },
            set(e) {
                this._queryHasPathInclude = e,
                e && this.parent && (this.parent.queryHasPathInclude = !0)
            }
        },
        queryHasM2MInclude: {
            get() {
                return this._queryHasM2MInclude
            },
            set(e) {
                this._queryHasM2MInclude = e,
                e && this.parent && (this.parent.queryHasM2MInclude = !0)
            }
        },
        queryHasPathArg: {
            get() {
                return this._queryHasPathArg
            },
            set(e) {
                this._queryHasPathArg = e,
                e && this.parentPropsMap.queryHasPathArg && (this.parent.queryHasPathArg = !0)
            },
            configurable: !0
        },
        queryHasM2MArg: {
            get() {
                return this._queryHasM2MArg
            },
            set(e) {
                this._queryHasM2MArg = e,
                e && this.parentPropsMap.queryHasM2MArg && (this.parent.queryHasM2MArg = !0)
            },
            configurable: !0
        },
        definedDirectives: {
            get() {
                return this._definedDirectives || this.parent && this.parent.definedDirectives || void 0
            },
            set: void 0
        },
        types: {
            get() {
                return this._types || this.parent && this.parent.types || void 0
            },
            set: void 0
        }
    }
      , Bu = function(e) {
        e || (e = Ne(Qt()));
        class t extends e {
            constructor(e) {
                super(e),
                this.persistentId = void 0,
                this.isMutation = !1
            }
            static initNewInstance(e, t, n, r) {
                const i = super.initNewInstance(e, t, n, r);
                return i.isGroupedQuery || i.model.addRemoveQuery(i),
                i
            }
            setAsGroupedQuery(e) {
                return super.setAsGroupedQuery(e),
                this.model.addRemoveQuery(this, !0),
                this
            }
            destroy(e) {
                if (this.closed)
                    return;
                this.isGroupedQuery || this.model.addRemoveQuery(this, !0);
                const t = this.queryArgs;
                if (t && (t.results && (t.results.destroy(),
                t.results = void 0),
                t.indexedArgs && (t.indexedArgs = void 0)),
                this.pagination && (this.pagination.destroy(),
                this.pagination = void 0),
                e) {
                    const {query: t, originalQuery: n} = e;
                    t && n && t !== n ? (n === this ? t.destroy() : n.persistentId || n.destroy(),
                    e.query = void 0,
                    e.originalQuery = void 0) : e.query = void 0;
                    const r = this.includeVFs;
                    if (e.parent = void 0,
                    r) {
                        const t = e.children;
                        if (t) {
                            e.children = void 0;
                            for (let e in r)
                                r[e].destroy(t[e])
                        } else
                            for (let e in r)
                                r[e].destroy();
                        this.includeVFs = void 0
                    }
                }
                super.destroy()
            }
            get persistentId() {
                return this._persistentId
            }
            set persistentId(e) {
                this._persistentId = e
            }
        }
        return Object(L.a)(t, Uu, qu),
        Object.defineProperties(t.prototype, Qu),
        Object(L.a)(t, Br),
        Object(L.a)(t, Mo),
        Object(L.a)(t, $r),
        Object(L.a)(t, xs),
        Object(L.a)(t, fa),
        Object(L.a)(t, $t),
        Object(L.a)(t, Vo),
        Object(L.a)(t, Co),
        Object(L.a)(t, da),
        Object(L.a)(t, ns),
        Object(L.a)(t, Wo),
        Object(L.a)(t, Dc),
        Object(L.a)(t, Ts),
        Object.defineProperties(t.prototype, No),
        t.Args = ur,
        t.IncludeVF = Oa,
        t.parentPropsConfig = _r,
        t.parentMethodsConfig = Sr,
        t.CalcHaving = _c,
        t.CalcHavingGroup = kc,
        t.CalcHavingMethod = Kc,
        t.CalcSelect = eu,
        t.CalcSelectMethod = xu,
        t.CalcChildMethodArg = Cu,
        t.CalcFieldArg = vu,
        t.CalcGroupArg = Pu,
        t.CalcValueArg = Lu,
        t
    }(Ne(Qt()));
    function Gu() {
        return Bu
    }
    const zu = {
        [Gr.a]: "createMutations",
        [Gr.c]: "updateMutations",
        [Gr.b]: "deleteMutations"
    }
      , Hu = {
        [Gr.a]: "Create",
        [Gr.c]: "Update",
        [Gr.b]: "Delete"
    }
      , Ku = [Gr.a, Gr.c, Gr.b]
      , Yu = ["createMutations", "updateMutations", "deleteMutations"]
      , Wu = {
        [Gr.a]: "processCreateVFData",
        [Gr.c]: "processUpdateVFData",
        [Gr.b]: null
    }
      , $u = "__".concat(Object(oe.b)(), "__")
      , Xu = "__".concat(Object(oe.b)(), "__")
      , Ju = "__".concat(Object(oe.b)(), "__")
      , Zu = {
        enumerable: !1
    };
    function el(e, t) {
        for (let n in e)
            if (t[n] && tl(t[n], Gr.c))
                return !0;
        return !1
    }
    let tl;
    {
        const e = {
            [Gr.a]: "apiCreate",
            [Gr.c]: "apiUpdate",
            [Gr.b]: "apiDelete"
        };
        tl = function(t, n) {
            return n ? t[e[n]] : t.apiRead
        }
    }
    function nl(e, t, n, r) {
        return n || (n = {}),
        n[e = r ? "".concat(e, ".").concat(r) : e] = '"'.concat(e, '": ').concat(t),
        n
    }
    function rl(e) {
        const t = {};
        return e[$u] = t,
        Object.defineProperty(e, $u, Zu),
        t
    }
    function il(e) {
        return e[$u]
    }
    function ol(e) {
        let t = e[Xu];
        return t || (t = {},
        e[Xu] = t,
        Object.defineProperty(e, Xu, Zu)),
        t
    }
    function sl(e) {
        return e[Ju]
    }
    function al(e, t) {
        let n = e[Ju];
        if (n) {
            if (t)
                for (let r in t)
                    n[r] = t[r]
        } else
            n = t || {},
            e[Ju] = n,
            Object.defineProperty(e, Ju, Zu);
        return n
    }
    function cl(e, t, n, r, i, o) {
        if (!r[e])
            return nl("".concat(n, " dataType"), "The ".concat(e, ' dataType specified for field "').concat(n, '" is not a known type. The default types are: ').concat(Object.values(De).join(", "), ", but this may not be an exhaustive list if the model specifies additional custom dataTypes. See the model's documentation for complete details."), i, o);
        try {
            r[e](t)
        } catch (s) {
            return nl(n, s.message, i, o)
        }
    }
    const {PAYLOAD: ul} = ge;
    function ll(e) {
        return e && !e.isCancelling ? this.responseFormat === ul ? this : this.formattedResponse : void 0
    }
    function dl(e, t) {
        return t.resultOperators ? (!0 === t.resultOperators && (t.resultOperators = void 0),
        e.ofComplete().pipe(Object(Y.a)(ll, t))) : e
    }
    function hl(e, t) {
        if (!t)
            return e.payload.isLocalOnly = !0,
            e;
        const n = e.queryArgs;
        if (n && n.length) {
            if (1 === n.length && Object(he.M)(n[0]) && n[0].key === e.primaryKey && !n[0].valueParam)
                return "in" === n[0].op ? n[0].value = t : 1 === t.length ? n[0].value = t[0] : (n.removeArg(0),
                e.whereIn(e.primaryKey, t)),
                e;
            n.destroy()
        }
        return t.length > 1 ? e.whereIn(e.primaryKey, t) : e.where(e.primaryKey, t[0]),
        e
    }
    const fl = ["action", "bestMeta", "formattedResponse", "recordsResults", "optimisticRecords", "resp"]
      , pl = e => {
        const {records: t} = e;
        if (t)
            for (let n in t)
                t[n] = t[n].getMainInstance();
        gl(e)
    }
    ;
    function gl(e, t) {
        for (let i of fl)
            e[i] && (e[i] = void 0);
        let n;
        t || (t = e.model) && (t = t.getMainInstance()) ? (e.model = t,
        (n = e.query) && n.model && (n.model = t),
        (n = e.originalQuery) && n.model && (n.model = t)) : (n = e.query) && (t = n.model) && (t = t.getMainInstance(),
        n.model = t,
        (n = e.originalQuery) && n.model && (n.model = t));
        const {children: r} = e;
        if (r)
            for (let i in r)
                pl(r[i])
    }
    function ml(e) {
        const t = e.extensions && e.extensions.pkMap;
        if (t)
            for (let n in t)
                t[n] = null
    }
    function yl(e, t) {
        t || (t = {}),
        t = this.createQueryPayload(t);
        let n = this.createQuery(t);
        try {
            e(n)
        } catch (r) {
            return n.destroy(t),
            void this.mutation.error(r)
        }
        return this.addQuery(t),
        dl(this.mutation, t)
    }
    function vl(e, t, n) {
        const r = this.mutation.primaryKey;
        return this.addRecord({
            [r]: e
        }, t, n)
    }
    function bl(e, t, n) {
        let r;
        for (let i in e) {
            if (!(r = this.addPkValue(e[i], t, n)))
                return;
            e[i] = r
        }
        return e
    }
    function _l(e, t, n) {
        const r = e.length;
        let i, o = 0;
        for (; o < r; ) {
            if (!(i = this.addPkValue(e[o], t, n)))
                return;
            e[o] = i,
            o++
        }
        return e
    }
    function Sl(e, t, n) {
        return Array.isArray(e) ? this.forArrayAddPkValue(e, t, n) : this.forObjectAddPkValue(e, t, n)
    }
    const Ol = {
        getTopLevelPayload: hn,
        getBestProperty: pn,
        getBestDispatchId: fn,
        getCommitMutation: function(e, t) {
            let n, r = e;
            for (; (n = r.parent) && n.action; )
                r = n;
            let i = r.mutation;
            if ((i || (i = e.mutation) || (i = hn(r).mutation)) && i.isAcceptingFollowupQueries)
                return t || (r.mutation = i,
                i = i.switchTo(e.model),
                e.model = i.model),
                i;
            if (t)
                return null;
            i = e.model.mutation(e.action.meta.dispatchId),
            r.mutation = i,
            e.model = i.dispatchModel().model;
            const o = i.controller;
            if (o.isExecuting) {
                const t = r === e || r.action.meta.isComplete ? e.action : r.action;
                return o.addToFollowupQueries(on(f.e, t)),
                dn(i, t),
                i
            }
            return o.executeCount > 1 && !o.hasExecuteWhen() ? (dn(i, r === e || r.action.meta.isComplete ? e.action : r.action),
            o.decrementExecuteCount(),
            i) : (r === e || r.action.meta.isComplete || o.hasExecuteWhen(r.action) ? (dn(i, e.action),
            o.executeWhen(e.action)) : (dn(i, r.action),
            o.executeWhen(r.action),
            o.executeCount++,
            o.executeWhen(e.action)),
            i)
        },
        getIncludeQueryPayload: mn,
        knownNoRecords: bn,
        setPayloadProp: yn,
        updatePayloadResponseFormats: vn
    };
    function Tl(e) {
        if (Array.isArray(e)) {
            if (!Object(he.U)(e[0]))
                return;
            const t = {};
            for (let n of e)
                t[n.__ID] = n;
            return t
        }
        if (Object(he.U)(e))
            return {
                [e.__ID]: e
            };
        {
            const t = Object.keys(e);
            let n = t[0];
            if (he.U[e[n]]) {
                if (e[n].__ID !== n) {
                    const r = {};
                    for (n of t)
                        r[e[n].__ID] = e[n];
                    return r
                }
                return e
            }
            return
        }
    }
    const Il = (e, t) => {
        for (const n in e)
            t[e[n]] = null
    }
      , xl = (e, t, n, r) => {
        let i, o, s, a, c, u;
        for (const l in t)
            if (i = t[l].dynamicForeignField,
            ({predicateValueToName: s} = i),
            null !== n[l])
                if (a = n[i.predicate],
                "undefined" === typeof a) {
                    for (a in u = !1,
                    s)
                        if (c = s[a],
                        null === (o = n[c]))
                            u = !0;
                        else if ("undefined" !== typeof o) {
                            Il(s, n),
                            n[c] = o,
                            n[l] = o,
                            n[i.predicate] = a,
                            u = !1;
                            break
                        }
                    u && Il(s, n)
                } else
                    null === a ? (Il(s, n),
                    n[l] = null) : (c = s[a]) ? "undefined" === typeof (o = n[l]) && "undefined" === typeof (o = n[c]) || (Il(s, n),
                    n[c] = o,
                    n[l] = o) : (r || (r = {}),
                    r[i.predicate] = "The predicate value ".concat(a, " is not a registered value."));
            else
                Il(s, n);
        return r
    }
    ;
    function wl(e, t, n, r, i) {
        const {fields: o} = r;
        let s = void 0;
        if (!r.isCommitOnly) {
            r.dynamicForeignFields && (s = xl(0, r.dynamicForeignFields, n));
            for (let t in o)
                if (s = o[t].validate(n, s),
                s && s[t]) {
                    if ("undefined" !== typeof n[t])
                        return r.errorRecordState(s, Gr.a),
                        !1
                } else
                    e.set(t, n[t]);
            if (s) {
                let {invalidRecords: t} = r;
                t || (t = {},
                r.invalidRecords = t),
                t[e.get(r.primaryKey)] = s
            }
            return !0
        }
        const a = e.persistedState;
        let c;
        if (i) {
            let t = !r.isOptimisticComplete;
            for (let i in o)
                if ("undefined" !== typeof (c = n[i]) && a[i] !== n[i]) {
                    if (s = o[i].validate(n))
                        return r.errorRecordState(s, Gr.a),
                        !1;
                    a[i] = n[i],
                    e.set(i, n[i]),
                    t || (t = !0,
                    r.ensurePendingChanges(e.get(r.primaryKey), e.store.instance))
                }
        } else
            for (let u in o)
                if ("undefined" !== typeof (c = n[u])) {
                    if (s = o[u].validate(n))
                        return r.errorRecordState(s, Gr.a),
                        !1;
                    a[u] = n[u],
                    e.set(u, n[u])
                } else if (tl(o[u]))
                    o[u].autoload && (console.log("Missing autoload for field ".concat(u, " on model ").concat(r.modelName, ". Adding to followup queries.")),
                    r.addToFollowupQueries(r.model, r.primaryKey, n[r.primaryKey]));
                else {
                    if (s = o[u].validate(n))
                        return r.errorRecordState(s, Gr.a),
                        !1;
                    e.set(u, n[u])
                }
        return !0
    }
    function Ml(e, t, n, r, i, o) {
        const {fields: s, triggers: a} = i
          , {beforeFieldUpdate: c, afterFieldUpdate: u} = a;
        let l;
        t && ({dataTypesUpdater: l} = i);
        const d = e.store.instance;
        let h, f, p, g, m, y = !i.isOptimisticComplete, v = !1;
        if (!i.dynamicForeignFields || (g = xl(0, i.dynamicForeignFields, n),
        !g)) {
            for (let b in n)
                if (f = s[b])
                    if (p = e.get(b),
                    h = t && t[b] ? l[t[b]](n[b], p) : n[b],
                    ({type: m} = s[b]),
                    m.getComparisonValue(p) !== m.getComparisonValue(h)) {
                        if (y || (y = !0,
                        i.ensurePendingChanges(e.get(i.primaryKey), d)),
                        c[b] && (g = a.call(c[b], "beforeFieldUpdate", d, b, p, h, i, r),
                        g))
                            return void i.error(g);
                        if (v = !0,
                        e.set(b, h),
                        o && (o[b] = h),
                        u[b] && (g = a.call(u[b], "afterFieldUpdate", d, b, p, h, i, r),
                        g))
                            return void i.error(g)
                    } else
                        o && (o[b] = h);
            return v
        }
        i.errorRecordState(g, Gr.c)
    }
    function Al(e, t) {
        return t && (t.records ? t.records[e.__ID] = e : t.records = {
            [e.__ID]: e
        }),
        !0
    }
    function El(e, t, n, r) {
        return n || (n = {}),
        t[e] ? (n[e] ? r[e].isMany ? n[e].push(...t[e]) : n[e].push(t[e]) : n[e] = r[e].isMany ? [...t[e]] : [t[e]],
        n) : (n[e] || (n[e] = null),
        n)
    }
    const Cl = function() {
        const e = new Set;
        return function(t, n) {
            let r, i, o, s, a;
            for (let c in t)
                if (o = t[c]) {
                    for (r = n[c].ownRefModelPk,
                    s = 0,
                    a = o.length; s < a; )
                        i = o[s][r],
                        e.has(i) ? (o.splice(s, 1),
                        a--) : (e.add(i),
                        s++);
                    e.clear()
                }
        }
    }()
      , Nl = e => {
        e.resp || (e.resp = null),
        e.records || (e.records = null);
        const t = e.children;
        if (t)
            for (let n in t)
                Nl(t[n])
    }
      , Rl = (e, t, n) => {
        const r = "function" === typeof e ? e(t, n) : e.switchTo(t);
        return r.action || r.dispatchModel(),
        r
    }
      , Pl = e => !e.isCommitOnly && (e.commitOnly(!0),
    !0);
    function Dl(e, t, n, r, i, o, s) {
        var a;
        if (!e)
            return o && Nl(o),
            null;
        const c = null === o || void 0 === o || null === (a = o.extensions) || void 0 === a ? void 0 : a.permDeniedFields;
        let u = r.get(t).value;
        const {fields: l, virtualFields: d, primaryKey: h} = u.store.storeConfig;
        let f, p, g, m, y, v, b, _ = void 0, S = void 0, O = void 0, T = !1;
        for (let I of e) {
            if (!I[h])
                return new Error('Unable to commit query resp: An entry in the response Array for the model "'.concat(u.store.instance.__typename, '" does not contain a primary key value.'));
            if (f = u.get(I[h])) {
                for (m in p = r.get(f).value,
                g = p.persistedState,
                O = p.mutation && !p.mutation.isOptimisticComplete && p.pChanges,
                p = p.getState(),
                I)
                    if (l[m]) {
                        if (O && O[m])
                            continue;
                        if (c && c.indexOf(m) > -1)
                            continue;
                        if (y = l[m].validate(I))
                            return new Error('Unable to commitResp(): A record on model "'.concat(u.store.instance.__typename, '" has an invalid response value: ').concat(Object.values(y)[0]));
                        ({type: b} = l[m]),
                        yt()(b.getComparisonValue(p[m]), b.getComparisonValue(I[m])) || !S && !(S = {}) ? g[m] = p[m] : (g[m] = I[m],
                        S[m] = I[m])
                    } else
                        d[m] && (_ = El(m, I, _, d));
                if (S) {
                    if (v || (v = Rl(i, t, o),
                    T = Pl(v),
                    v.model !== t && (u = r.get(v.model).value)),
                    f = v.getMutationType(Gr.c).addRecord(f, null, S, !0),
                    !f)
                        return new Error("Unable to commit resp for model ".concat(t.modelName, ". An error occurred in the mutation when attempting to update a record in local state with the data in resp."));
                    S = void 0
                }
                Al(f, o)
            } else {
                for (m in v || (v = Rl(i, t, o),
                T = Pl(v),
                v.model !== t && (u = r.get(v.model).value)),
                S = {},
                I)
                    l[m] ? (!c || c.indexOf(m) < 0) && (S[m] = I[m]) : d[m] && (_ = El(m, I, _, d));
                if (f = v.getMutationType(Gr.a).addRecord(S, !0),
                !f)
                    return new Error("Unable to commit resp for model ".concat(t.modelName, ". An error occurred in the mutation when attempting to create a record that did not exist in local state."));
                Al(f, o),
                S = void 0
            }
        }
        if (_) {
            let e, t, s;
            for (m in Cl(_, d),
            o && (e = o.children,
            xr(o)),
            _)
                if (s = d[m].ownRefModel.getBestInstance(n),
                e && (t = e[m]) ? (t.resp = _[m],
                t.model = s) : t = null,
                y = Dl(_[m], s, n, r, i, t, d[m]),
                y)
                    return y
        }
        return T && v.commitOnly(!1),
        null
    }
    var Fl = n(134)
      , kl = n(100);
    const jl = (e, t) => {
        let {trxActionTypes: n} = e;
        return n || (n = {},
        e.trxActionTypes = n),
        n[c.n] = Fl.b,
        t && (n[c.a] = Fl.b,
        n[c.q] = Fl.b),
        e
    }
    ;
    function Ll(e) {
        return e
    }
    Ll[l.d] = {
        [l.j]: "trxAnchor",
        [l.m]: 100,
        [l.a]: [c.a, c.q],
        [l.k]: f.f,
        [f.f]: Ll,
        [l.n]: !0,
        [l.r]: {
            [h.k]: f.f,
            [h.b]: f.c
        },
        [l.l]: "@isomorix/model",
        [l.i]: "".concat("model", "/logic/addRemoveIndex"),
        [l.e]: "Anchor logic for all [trxOps]{@link module:store/constants/trxOps}. It does not perform any side effects."
    };
    const Vl = Ll[l.d]
      , Ul = {
        ...Ll[l.d],
        [l.a]: c.n,
        [l.i]: "".concat("model", "/logic/mutation")
    };
    function ql(e) {
        return e
    }
    ql[l.d] = {
        [l.j]: "trxPrepareAnchor",
        [l.m]: -1e3,
        [l.a]: kl.d,
        [l.k]: f.f,
        [f.f]: Ll,
        [l.n]: !0,
        [l.r]: {
            [h.k]: f.f
        },
        [l.l]: "@isomorix/model",
        [l.i]: "".concat("model", "/logic/trxActionStandard"),
        [l.e]: "Anchor logic for the [trxPrepare op]{@link module:store/constants/trxOps.TRX_PREPARE}. This is used by the various index stores so that the action does not continue for the index until the trx begins."
    };
    const Ql = ql[l.d]
      , Bl = (e, t, n, r) => {
        const i = e[n];
        i ? e[r] = "function" === typeof i ? i[l.d][l.m] : i[l.m] : "number" !== typeof e[r] && (e[r] = t)
    }
    ;
    function Gl(e, t, n) {
        Bl(e, t, "pendingTrxLogic", "pendingTrxPriority"),
        Bl(e, n || t, "mainTrxLogic", "mainTrxPriority")
    }
    function zl(e, t, n, r) {
        let i;
        if (r) {
            let r, o = void 0;
            for (let[s,a] of t)
                s !== n && (i = a.store.get(e)) && (i.__ID ? (!r || s > o) && (r = i,
                o = s) : r && o < s && (r = void 0,
                o = void 0));
            return r
        }
        for (let[o,s] of t)
            if (o !== n && (i = s.store.get(e)))
                return i
    }
    function Hl(e) {
        const t = this.mutation;
        return e ? ("boolean" !== typeof e.isLocalOnly && (e.isLocalOnly = t.isLocalOnly),
        "undefined" === typeof e.permCheck && (e.permCheck = t.permCheck)) : e = {
            isLocalOnly: t.isLocalOnly,
            permCheck: t.permCheck
        },
        e.userRole = t.userRole,
        e.action = t.action,
        e.dispatchId = t.mainDispatchId,
        e.isServer = t.isServer,
        e.model = t.model,
        e.mutation = t,
        e.mutationType = this.mutationType,
        e.hasCommitted = !1,
        e
    }
    const Kl = e => (e.extensions ? e.extensions.pkMap || (e.extensions.pkMap = {}) : e.extensions = {
        pkMap: {}
    },
    e);
    function Yl(e) {
        let t = this.managedPayload;
        return t || (t = this.createQueryPayload({
            isLocalOnly: !1,
            isManaged: !0
        }),
        t.records = {},
        this.managedPayload = t),
        e ? Kl(t) : t
    }
    function Wl(e) {
        return (e = Hl.call(this, e)).data = null,
        e.dataTypes = null,
        e.records = null,
        e.maybeDeterministic = !0,
        e.mutationHasVF = !1,
        e.isDeterministic = !0,
        e.filterResults = !1,
        e
    }
    function $l() {
        const e = this.mutation
          , t = e.isServer && e.pkIsAutoIncrement;
        let n, r, i = this.managedPayload;
        return e.isServer && !(n = this.nonLocalRecords) && (n = {},
        this.nonLocalRecords = n),
        this._addNonLocal = function(o, s, a, c, u) {
            return n && (n[o] = s),
            c ? c.records || (c.records = {},
            t && Kl(c)) : (r || (r = e.getManagedData(),
            i = this.getManagedPayload(t)),
            r[o] = a,
            c = i),
            c.records[o] = s,
            t && (u && u !== o ? (c.extensions.pkMap[o] = u,
            c.extensions.pkMap[u] = null) : c.extensions.pkMap[o] = null),
            s
        }
        ,
        this
    }
    const Xl = (e, t, n) => {
        if (n)
            e.delete(t);
        else {
            const n = e.get(t);
            n && (n.complete(),
            e.delete(t))
        }
    }
    ;
    let Jl, Zl, ed;
    function td(e, t, n, r, i) {
        const o = this.mutation
          , {primaryKey: s, fields: a} = o
          , c = r.getState();
        let u, l = null;
        for (let d in e)
            d !== s && a[d] && (l = a[d].validate(e, l),
            c[d] !== e[d] && (u || (u = {})) && (u[d] = e[d]));
        if (l)
            o.errorRecordState(l, Gr.a);
        else {
            if (i || (i = e[s]),
            e[s] = c[s],
            u && this.onDuplicateUpdate(r, u, n)) {
                if (!(r = o.getMutationType(Gr.c).addRecord(r, null, u, t)))
                    return void 0 === r ? r : void o.error(new Error("Unable to create record with primaryKey ".concat(i, " on model ").concat(o.modelName, " because a duplicate record exists but it is being deleted.")))
            } else if (o.isCancelling)
                return;
            if (this.processVFData(r, null, e, t))
                return n && o.isServer && !t ? (n.records || (n.records = {},
                o.pkIsAutoIncrement && Kl(n)),
                n.records[e[s]] = r,
                o.pkIsAutoIncrement && (n.extensions.pkMap[i] = e[s])) : Al(r, n),
                o.permCheck && (!n || n.permCheck) && o.model.schema.permRecCreate && Zl(this, n, e[s], r),
                r
        }
    }
    function nd(e, t, n) {
        const r = this.mutation
          , i = e.__ID;
        return r.records[i] ? r.records[i] : (e = r.dispatchRecord(e, Gr.a)) ? (t ? Al(e, n) : this._addNonLocal(i, e, e.getState(), n),
        e) : e
    }
    function rd() {
        const e = this.mutation
          , t = e.model
          , n = e.triggers;
        let r;
        this._callTriggers = function(i, o, s) {
            return !n.create || (r = n.call(n.create, "create", t, i, void 0, o, e, s),
            !r) || (e.error(r),
            !1)
        }
    }
    Jl = (e, t, n) => {
        e._duplicatesPkMap ? e._duplicatesPkMap[t] = n : e._duplicatesPkMap = {
            [t]: n
        }
    }
    ,
    Zl = () => null,
    ed = Zl;
    const id = () => {}
    ;
    function od() {
        const e = this.mutation;
        if (!e.mutationLocalIndex)
            return this._getFromIndex = id,
            this;
        const t = e.mutationLocalIndex.storeConfig
          , n = e.getMutableIndex(t.name).value
          , r = t.fieldNames
          , i = n.store.mainStore.pendingStoreMgr.children
          , {fields: o, mainDispatchId: s} = e;
        return this._getFromIndex = e => {
            for (let n of r) {
                if ("undefined" === typeof e[n]) {
                    const t = o[n].foreignField;
                    if (t) {
                        const n = e[t.modelVFName];
                        !n || !Object(he.U)(n) && t.refField.validate(n) || (e[t.field.name] = n[t.refField.name])
                    }
                }
                if (o[n].validate(e))
                    return null
            }
            if (1 === i.size)
                return n.get(n.getIndexKeyValue(e));
            const t = n.getIndexKeyValue(e);
            return n.get(t) || zl(t, i, s, !0)
        }
        ,
        this
    }
    function sd(e, t, n) {
        return this.setAddRecord().addRecord(e, t, n)
    }
    function ad() {
        return this.addRecord = sd,
        this
    }
    function cd(e, t, n, r) {
        if (n) {
            for (let i in e)
                if (void 0 === this.addRecord(e[i], t, r))
                    return
        } else {
            let n;
            for (let i in e) {
                if (n = this.addRecord(e[i], t, r),
                void 0 === n)
                    return;
                e[i] = n
            }
        }
        return e
    }
    function ud(e, t, n, r) {
        if (n) {
            for (let i of e)
                if (void 0 === this.addRecord(i, t, r))
                    return
        } else {
            const n = e.length;
            let i, o = 0;
            for (; o < n; ) {
                if (i = this.addRecord(e[o], t, r),
                void 0 === i)
                    return;
                e[o] = i,
                o++
            }
        }
        return e
    }
    function ld(e, t, n, r) {
        return Array.isArray(e) ? this.forArrayAddRecord(e, t, n, r) : this.forObjectAddRecord(e, t, n, r)
    }
    function dd() {
        const {managedPayload: e} = this;
        if (!e)
            return !1;
        if (!this.managedQuery) {
            const t = this.createQuery(e);
            e.mutationTypeIdx = this.push(t) - 1,
            this.managedQuery = t
        }
        return !0
    }
    function hd(e) {
        const t = new Error(e.statusMessage || "One or more mutations failed with statusCode ".concat(e.statusCode, "."));
        return t.statusCode = e.statusCode,
        t
    }
    function fd(e) {
        if (e)
            return !!this._duplicatesPkMap && (this.mutation.model.emitPkChanges(this._duplicatesPkMap),
            this._duplicatesPkMap = void 0,
            !0);
        const t = this.mutation;
        if (!this.willCommit || !t.pkIsAutoIncrement)
            return !1;
        if (!t.isServer)
            return !!this._combinedPkMap && (t.model.emitPkChanges(this._combinedPkMap),
            !0);
        const {connectorResp: n} = this;
        if (!n)
            return !1;
        const r = t.primaryKey
          , i = this.recordsToPersist[this.recordsToPersistIdx];
        let o, s, a;
        for (let c = 0; c < n.length; c++)
            (a = n[c]) && i[c] && (a = a[r],
            s = i[c][r],
            a !== s && (o || (o = {})) && (o[s] = a));
        return !!o && (t.model.emitPkChanges(o),
        !0)
    }
    function pd() {
        if (!this.willCommit)
            return null;
        this.willCommit = !1;
        const e = this.mutation;
        if (e.isServer) {
            const t = this.connectorResp;
            if (!this.willSendToConnector)
                for (let e of this)
                    e.payload.hasCommitted = !0;
            return t ? (this.connectorResp = void 0,
            e.constructor.commitResp(t, e.model, e.mainDispatchId, e)) : null
        }
        {
            let t, n, r;
            for (let o of this)
                if (t = o.payload,
                t.hasCommitted = !0,
                !t.isLocalOnly && t.records) {
                    if ((r = t.extensions) && 200 !== r.statusCode && 403 !== r.statusCode)
                        return hd(r);
                    if (n = e.constructor.commitQueryPayload(t, e))
                        return n
                }
            const {_rejectedRecords: i} = this;
            return i && (e.getMutationType(Gr.b).forObjectAddRecord(i, !0),
            this._rejectedRecords = void 0),
            null
        }
    }
    function gd() {
        if (!this.processInvalidRecords())
            return !1;
        if (tl(this.mutation.model.schema, this.mutationType)) {
            this.buildManagedQueries(),
            this.willSendToConnector = !1;
            for (let e of this)
                if (!e.payload.isLocalOnly) {
                    this.willSendToConnector = !0;
                    break
                }
        } else {
            for (let e of this)
                e.payload.isLocalOnly = !0;
            this.willSendToConnector = !1
        }
        return this.setDefaultAddRecord(),
        !0
    }
    function md(e) {
        let t;
        for (t of (this.addRecord = void 0,
        this))
            t.complete(e)
    }
    function yd() {
        const e = this.mutation
          , {records: t, model: n} = e;
        let r, i, o, s, a, c;
        for (r of this) {
            if (i = r.payload,
            o = i.records)
                for (s in o)
                    (c = o[s]) && ((a = t[s]) || (a = c.getMainInstance(),
                    t[s] = a),
                    o[s] = a);
            gl(i, n)
        }
        this.addRecord = void 0
    }
    function vd() {
        let e;
        for (e of (this.addRecord = void 0,
        this))
            e.destroy(e.payload);
        if (this.mutation = void 0,
        this.managedPayload) {
            this.managedPayload = void 0;
            const e = this.managedQuery;
            e && e.payload && e.destroy(e.payload),
            this.managedQuery = void 0
        }
    }
    function bd() {
        if (this.recordsToPersist ? (this.recordsToPersist = void 0,
        this.connectorResp = void 0,
        this.nonLocalRecords = void 0) : this._rejectedRecords && (this._rejectedRecords = void 0),
        this._callTriggers && (this._callTriggers = void 0),
        this._getFromIndex && (this._getFromIndex = void 0),
        this._addNonLocal && (this._addNonLocal = void 0),
        this._onDuplicateUpdate && (this._onDuplicateUpdate = void 0),
        this.toPermCheck && (this.toPermCheck = void 0,
        this.toPermCheckPayload = void 0),
        this.length) {
            let e;
            for (e of this)
                e.payload.data && (e.payload.data = void 0)
        }
    }
    function _d() {
        this.mutation.action && bd.call(this),
        vd.call(this)
    }
    function Sd() {
        return this.commitPkChanges(!0),
        !!gd.call(this) && (this.willSendToConnector || (this.nonLocalRecords = null),
        !0)
    }
    function Od() {
        bd.call(this),
        yd.call(this)
    }
    function Td() {
        return this.setDefaultAddRecord(),
        !0
    }
    function Id() {
        return this.commitPkChanges(!0),
        Td.call(this)
    }
    function xd(e) {
        if (this.managedPayload)
            return !0;
        if (!this.length)
            return !1;
        for (const t of this)
            if (!t.payload.isLocalOnly)
                return !0;
        return !1
    }
    function wd(e, t, n, r) {
        const i = t[e];
        let o, s, a = 1;
        for (let c of n)
            if (!c.isReciprocal && (o = i[c.fieldName],
            o && t[o])) {
                if (o = "" + o,
                o === e)
                    continue;
                (s = r[o]) || (s = wd(o, t, n, r)),
                s >= a && (a = s + 1)
            }
        return r[e] = a,
        a
    }
    function Md() {
        let e = this.recordsToPersist;
        if (e || null === e)
            return e;
        if (!(e = this.nonLocalRecords))
            return this.recordsToPersist = null,
            null;
        this.recordsToPersistIdx = -1;
        const t = this.mutation.model.recursiveVFs;
        return this.recordsToPersist = t ? function(e, t) {
            const n = [];
            let r, i;
            for (let o in e)
                (i = e[o]) && (r = t[o]) && (r--,
                n[r] ? n[r].push(e[o]) : n[r] = [e[o]]);
            return n
        }(e, function(e, t) {
            const n = {};
            for (let r in e)
                !n[r] && e[r] && wd(r, e, t, n);
            return n
        }(e, t)) : [Object.values(e)],
        this.recordsToPersist
    }
    let Ad;
    function Ed(e) {
        if (!this.willSendToConnector)
            return e;
        let t;
        if (this.willSendToConnector = !1,
        this.mutation.isServer) {
            const n = this.getRecordsToPersist();
            if (!n || !(t = n[++this.recordsToPersistIdx]))
                return e;
            this.willCommit = !0,
            e || (e = {}),
            this.recordsToPersistIdx + 1 < n.length && (this.willSendToConnector = !0),
            e[Gr.a] = t
        } else {
            t = e && e.queries;
            let n = 0;
            for (let e of this)
                e.isLocalOnly || !t && !(t = []) || (t.push(e),
                n++);
            t && (this.willCommit = !0,
            this._pendingConnectorResp = n,
            e || (e = {}),
            e.queries = t)
        }
        return e
    }
    Ad = function(e, t, n) {
        return t
    }
    ;
    let Cd = Qs.a;
    function Nd(e, t) {
        if (this.mutation.isServer) {
            if (!e)
                return;
            const t = this.connectorResp;
            this.connectorResp = e,
            this.commitPkChanges(),
            t ? (t.push(...e),
            this.connectorResp = t) : this.connectorResp = e
        } else {
            this._pendingConnectorResp--;
            const {extensions: n, records: r} = t
              , i = n && n.pkMap;
            let {_rejectedRecords: o} = this
              , s = null;
            if (i) {
                let e, {_combinedPkMap: t} = this;
                for (let n in i)
                    r[n] && (e = i[n],
                    !e || i[e] || s && s[e] ? (o || (o = {},
                    this._rejectedRecords = o),
                    o[n] = r[n]) : (t ? s || (s = {}) : (t = {},
                    this._combinedPkMap = t,
                    s = {}),
                    t[n] = e,
                    s[e] = r[n]))
            } else if (e) {
                const t = this.mutation.primaryKey;
                let n = !1;
                for (let i of e)
                    i ? s ? s[i[t]] ? n = !0 : s[i[t]] = r[i[t]] : s = {} : n = !0;
                if (n)
                    if (s) {
                        o || (o = {},
                        this._rejectedRecords = o);
                        for (let e in r)
                            s[e] || (o[e] = r[e])
                    } else if (o)
                        for (let e in r)
                            o[e] = r[e];
                    else
                        o = {
                            ...r
                        },
                        this._rejectedRecords = o
            } else if (o)
                for (let e in r)
                    o[e] = r[e];
            else
                o = {
                    ...r
                },
                this._rejectedRecords = o;
            t.records = s,
            0 === this._pendingConnectorResp && this.commitPkChanges()
        }
    }
    function Rd(e, t) {
        if (this.length < 1)
            return;
        const n = [];
        let r, i;
        for (r of this)
            i = r.payload,
            !i.isLocalOnly && i.records && n.push(...Object.keys(i.records));
        if (n.length) {
            for (let e of n)
                t[Gr.b] = e;
            e.delete(t => t.whereIn(e.primaryKey, n))
        }
    }
    function Pd(e, t) {
        class n extends t.Type {
            constructor(e, t) {
                super(e, t || Gr.a),
                this.setDefaultAddRecord(),
                this.managedPayload = void 0
            }
        }
        const r = n.prototype;
        return function(e, t) {
            const n = e.storesMap;
            t.addFromRecordsToComplete = function(e, t, r, i) {
                const o = this.mutation
                  , s = o.primaryKey
                  , a = n.get(o.model).storeConfig.recordsToComplete
                  , c = a.get(i)
                  , u = e[s];
                let l, d = c.pendingStoreMgr.children.get(o.mainDispatchId);
                return d && (d = d.store.value,
                d.state[s] ? d.state[s] = u : (d.state[s] = u,
                d.size++)),
                d = c.value,
                d.state[s] ? d.state[s] = u : (d.state[s] = u,
                d.size++),
                o.isUndoRedo && (l = o.records[u]) || !(l = o.dispatchRecord(c.instance, Gr.a)) ? (Xl(a, u, l),
                l) : (d = n.get(l).value,
                d.size > 1 && (d.state = {
                    [s]: u
                },
                d.size = 1,
                o.prevRecordState[u] = d.state),
                d.set(s, u),
                wl(d, 0, e, o) ? (t ? Al(l, r) : (this._addNonLocal || this._setAddNonLocal(),
                this._addNonLocal(u, l, l.getState(), r)),
                this._callTriggers || this._setCallTriggers(),
                this._callTriggers(u, l, t) || (l = void 0)) : l = void 0,
                Xl(a, u, l),
                l)
            }
            ,
            t.setAddRecord = function() {
                const e = this.mutation
                  , {Record: t, primaryKey: r} = e;
                e.action || e.dispatchModel(),
                this._callTriggers || this._setCallTriggers();
                const i = e.model
                  , o = n.get(i)
                  , s = o.mainStore.pendingStoreMgr.children
                  , {mainDispatchId: a} = e;
                if (e.isCommitOnly)
                    return this.addRecord = function(i, o) {
                        const c = i[r];
                        c || e.error(new Error('A Record on model "'.concat(e.modelName, '" cannot be created via a commit-only mutation because a value for the primary key ("').concat(r, '") was not provided.')));
                        let u = e.records[c];
                        if (u) {
                            if (!wl(n.get(u).value, 0, i, e, !0) || !this.processVFData(u, null, i, o))
                                return;
                            return u
                        }
                        if (u = s.size > 1 && (u = zl(c, s, a, !0)) ? n.get(u).mainStore.instance : t.build(i),
                        (u = e.dispatchRecord(u, Gr.a)) && wl(n.get(u).value, 0, i, e) && this._callTriggers(c, u, o) && this.processVFData(u, null, i, o))
                            return u
                    }
                    ,
                    this;
                this._setAddNonLocal()._setGetFromIndex();
                const {IDType: c, schema: u} = o.storeConfig
                  , l = o.value
                  , {userRole: d, primaryKey: h} = e
                  , {permRecCreate: f} = u
                  , p = e.isUndoRedo ? o.storeConfig.recordsToComplete : null;
                return this.addRecord = function(o, g, m) {
                    const y = o[r];
                    let v, b;
                    if (y) {
                        if (Object(he.U)(o))
                            return e.records[y] || this._addRecordExisting(o, g, m);
                        if (p) {
                            if (p.has(y))
                                return this.addFromRecordsToComplete(o, g, m, y);
                            void 0
                        }
                    }
                    try {
                        v = c.toGlobalId(y)
                    } catch (_) {
                        return void e.errorRecordState({
                            [r]: '"'.concat(r, '": ').concat(_.message)
                        }, Gr.a)
                    }
                    if (o[r] = v,
                    y) {
                        if (b = e.records[v])
                            return b;
                        !(b = l.get(v)) && !e.pkIsAutoIncrement && s.size > 1 && (b = zl(v, s, a, !0))
                    }
                    if (e.permCheck && (!m || m.permCheck) && !u.permCreate(d, m || e, o))
                        return ed(e, m, y);
                    if (b || (b = this._getFromIndex(o))) {
                        const t = n.get(b)
                          , r = t.value;
                        if (v = r.get(h),
                        e.pkIsAutoIncrement && v !== o[h] && Jl(this, o[h], v, m, g),
                        e.records[v] && !r.persistedState[h])
                            return e.records[v];
                        if (r.persistedState[h])
                            return !m || e.isServer || g ? this._addRecordDuplicate(o, g, m, b, y) : void e.error(new Error("Unable to create record ".concat(v, " on model ").concat(e.modelName, " using a custom query because the record is known to already exist and will not be sent to the server. The mutation could be automatically converted into an UPDATE mutation if not for the custom query.")));
                        if (o[h] = v,
                        t.mainDispatchId && t.mainDispatchId !== a) {
                            if (!g && r.mutation && e.pkIsAutoIncrement) {
                                const t = r.mutation.getRecordQuery(b);
                                let n = !1;
                                if (t ? t.isLocalOnly && (n = !0) : r.mutation.getManagedData(v, !0) || (n = !0),
                                !n && !i.getMutationIndex())
                                    return void e.error(new Error('A non-local CREATE mutation on model "'.concat(e.modelName, '" contains a record that is pending CREATE under 2 simultaneous actions. And there is no unique index that can be used by persistent storage to deduplicate the request. The request cannot be completed.')), {
                                        statusCode: 409,
                                        statusMessage: 'The CREATE mutation for model "'.concat(e.modelName, '" contains a record that is already pending CREATE. Update the record instead.')
                                    })
                            }
                            b = t.mainStore.instance
                        } else if (g)
                            return this._addRecordDuplicate(o, g, m, b, y)
                    } else
                        b = t.build(o);
                    return (b = e.dispatchRecord(b, Gr.a)) ? (e.permCheck && f && (!m || m.permCheck) && Zl(this, m, v, b),
                    wl(n.get(b).value, 0, o, e) && (g && Al(b, m) || this._addNonLocal(v, b, o, m, y)) && this._callTriggers(v, b, g) && this.processVFData(b, null, o, g) ? b : void 0) : void 0
                }
                ,
                this
            }
            ,
            t._addRecordDuplicate = td,
            t._addRecordExisting = nd,
            t._setAddNonLocal = $l,
            t._setCallTriggers = rd,
            t._setGetFromIndex = od,
            t.forArrayAddRecord = ud,
            t.forManyAddRecord = ld,
            t.forObjectAddRecord = cd,
            t.setDefaultAddRecord = ad
        }(e, r),
        function(e, t) {
            const n = e.storesMap;
            t.processInvalidRecords = function() {
                const e = this.mutation
                  , t = e.invalidRecords;
                if (!t)
                    return !0;
                const {fields: r, managedData: i, records: o} = e;
                let s, a, c, u, l, d, h = null;
                for (let f in t)
                    if (c = t[f]) {
                        if (s = n.get(o[f]),
                        !i || !(u = i[f])) {
                            const e = this.getRecordQuery(f);
                            e && (u = e.payload.data[f])
                        }
                        for (l in a = s.getState(),
                        c)
                            if (r[l]) {
                                if (d = a[l],
                                h = r[l].validate(a, h),
                                h)
                                    return void e.errorRecordState(h, Gr.a);
                                d !== a[l] && (d = a[l],
                                a[l] = void 0,
                                s.set(l, d),
                                u && tl(r[l], Gr.a) && (u[l] = d))
                            }
                        t[f] = null
                    }
                return e.invalidRecords = null,
                !0
            }
        }(e, r),
        r._doRetrySendToConnector = Cd,
        r.addFunc = yl,
        r.addPkValue = vl,
        r.buildManagedQueries = dd,
        r.commit = pd,
        r.commitPkChanges = fd,
        r.createQueryPayload = Wl,
        r.destroy = _d,
        r.execute = Id,
        r.fetchMissingRecords = xd,
        r.forObjectAddPkValue = bl,
        r.forArrayAddPkValue = _l,
        r.forManyAddPkValue = Sl,
        r.getManagedPayload = Yl,
        r.getRecordsToPersist = Md,
        r.mainTrxComplete = Od,
        r.onDuplicateUpdate = Ad,
        r.optimisticComplete = Sd,
        r.sendToConnector = Ed,
        r.setConnectorResp = Nd,
        r.undo = Rd,
        n
    }
    const Dd = (e, t, n, r) => {
        r || (al(e)[t.__ID] = t);
        const i = il(e);
        if (!i)
            return;
        let o, s, a, c;
        for (let u in i)
            if (c = e[u],
            n && "undefined" !== typeof (s = n[u])) {
                if (s)
                    if (i[u].isMany)
                        for (a in s)
                            Dd(c, s[a].__record, s[a]);
                    else
                        Dd(c, s.__record, s)
            } else {
                if (!(o = t[u]))
                    continue;
                if (i[u].isMany)
                    for (a in o)
                        Dd(c, o[a]);
                else
                    Dd(c, o)
            }
    }
    ;
    function Fd(e, t) {
        const n = this.mutation;
        t = this.createQueryPayload(t);
        try {
            e(this.createQuery(t))
        } catch (d) {
            return t.query.destroy(t),
            void n.error(d)
        }
        let r = t.query;
        n.permCheck || "boolean" === typeof t.isDeterministic || (r.optimisticRecords(),
        r = t.query);
        let i, o, {isLocalOnly: s, records: a} = t;
        if (null === a)
            return t.resultOperators ? !0 === t.resultOperators ? (r.destroy(t),
            n.ofComplete().pipe(Object(Or.a)(null))) : (t.isLocalOnly = !0,
            this.addQuery(t),
            dl(n, t)) : (r.destroy(t),
            n);
        if (this.mutationType === Gr.c) {
            if (({dataTypes: o, data: i} = t),
            i) {
                if (t.permCheck)
                    try {
                        if (!(i = n.validateUpdateData(o, i, t)))
                            return
                    } catch (d) {
                        if (n.isCancelling)
                            return;
                        return r.permDenied(t),
                        dl(n, t)
                    }
                else if (!(i = n.validateUpdateData(o, i)))
                    return
            } else {
                if (!r.directives)
                    return r.destroy(t),
                    n;
                i = {}
            }
            t.data = i,
            o || (t.dataTypes = null)
        } else {
            if (t.permCheck && !n.model.schema.permDelete(n.userRole, t))
                return n.isCancelling ? void 0 : (r.permDenied(t),
                dl(n, t));
            t.data = null,
            t.dataTypes = null
        }
        let c, u = !1, l = !1;
        if (a)
            !function(e) {
                if (e.querySelect || e.queryAlias || e.directives || e.includeVFs)
                    return !0;
                const t = e.payload;
                return !(!t || !t.resultOperators)
            }(r) ? (u = !0,
            this.mutationType === Gr.c || this.managedPayload || (this.managedPayload = t)) : l = !0;
        else {
            if (this.addQuery(t),
            !(a = t.optimisticRecords))
                return t.isManaged = !1,
                dl(n, t);
            (c = t.recordsResults) && (t.recordsResults = void 0),
            t.optimisticRecords = void 0,
            t.records = a
        }
        if (i) {
            if (a = this.forObjectAddRecord(a, o, i, s, c, !1, u ? null : t),
            a) {
                al(i, a);
                for (let e in a)
                    Dd(i, a[e], c && c[e], !0)
            }
        } else
            a = this.forObjectAddRecord(a, s, !0, u ? null : t);
        if (a)
            u ? function(e, t) {
                const n = t.isLocalOnly ? null : t.mutation.getManagedGroup(t.data, !0);
                !n || n.managedPayload ? t.query.destroy(t) : (n.managedPayload = t,
                t.isManaged = !0)
            }(0, t) : l && function(e, t) {
                t.records && hl(t.query, Object.keys(t.records)),
                t.isManaged = !1,
                e.addQuery(t)
            }(this, t);
        else {
            if (void 0 === a)
                return;
            u || l ? u || !t.resultOperators ? r.destroy(t) : (t.records = null,
            t.isLocalOnly = !0) : t.records = void 0
        }
        return dl(n, t)
    }
    const kd = e => {
        e.error(new Error('Unable to UPDATE a record on model "'.concat(e.modelName, "\" using a custom query because it is pending CREATE. The record could still be updated as long as a custom query isn't used to do it. Just provide the record for the update along with the data and it'll be merged into the existing CREATE.")))
    }
    ;
    function jd(e, t, n, r, i, o, s) {
        if (!r && !s && n[$u] && !this.flattenVFData(e, t, n, r))
            return;
        let a;
        for (let c = 0; c < e.length; c++) {
            if (a = this.addRecord(e[c], t, n, r, i && i[c], !0, s),
            void 0 === a)
                return;
            o || (e[c] = a)
        }
        return e
    }
    function Ld(e, t, n, r, i, o, s) {
        if (!r && !s && n[$u] && !this.flattenVFData(e, t, n, r))
            return;
        let a, c;
        for (let u in e) {
            if (a = this.addRecord(e[u], t, n, r, i && i[u], !0, s),
            !a) {
                if (void 0 === a)
                    return;
                c = !0
            }
            o || (e[u] = a)
        }
        return !o && s && function(e, t, n) {
            if (n) {
                let e = 0
                  , n = null;
                for (let r in t)
                    t[r] && (n || (n = {})) && (n[r] = t[r],
                    e++);
                t = n
            }
            e.records = t
        }(s, e, c),
        e
    }
    function Vd(e, t, n, r, i, o, s) {
        return Array.isArray(e) ? this.forArrayAddRecord(e, t, n, r, i, o, s) : this.forObjectAddRecord(e, t, n, r, i, o, s)
    }
    function Ud(e, t, n, r, i, o, s, a) {
        return this.setAddRecord().addRecord(e, t, n, r, i, o, s, a)
    }
    function qd() {
        return this.addRecord = Ud,
        this
    }
    function Qd(e, t) {
        const n = e.storesMap;
        t.setAddRecord = function() {
            const e = this.mutation
              , {primaryKey: t, isCommitOnly: r, fields: i} = e
              , o = e.controller
              , s = r || !i[Ro.a.TS_FIELD] || e.isUndoRedo ? null : Math.round(o.ts / 1e3)
              , a = this.managedPkValues;
            return this.addRecord = function(c, u, l, d, h, f, p, g) {
                let m = n.get(c);
                if (!m)
                    return void e.error(new Error("An attempt was made to update a record on model ".concat(e.modelName, " whose store is not available. This would mean the record was already deleted, or the record is a pending record and it is already closed.")));
                m = m.value;
                const y = m.get(t);
                if (!y)
                    return null;
                let v;
                if (e.records[y]) {
                    if (e.records[y] !== c && (c = e.records[y],
                    m = n.get(c).value),
                    r)
                        v = m.persistedState;
                    else if (!d && !( (e, t, n) => {
                        if ("string" === typeof n)
                            return !tl(t[n], Gr.c);
                        {
                            let n;
                            for (let r in e)
                                if ((n = t[r]) && tl(n, Gr.c))
                                    return !1;
                            return !0
                        }
                    }
                    )(l, i, h) && m.mutationType === Gr.a && void 0 === ( (e, t, n, r) => {
                        const i = e.getMutationType(Gr.a).getRecordQuery(n);
                        return t.persistedState[e.primaryKey] === n ? i ? void e.error(new Error('Unable to UPDATE a record on model "'.concat(e.modelName, "\" because it is part of a custom CREATE mutation query, even though it has already been persisted. If it weren't part of a custom query, the mutation could be switched to UPDATE automatically."))) : (t.mutationType = Gr.c,
                        e.recordDataType[n] = Gr.c,
                        e.prevRecordState[n] = {
                            ...t.pState
                        },
                        null) : e.getManagedData(n, !0) ? r ? kd(e) : null : r ? kd(e) : i && !i.payload.isLocalOnly ? null : void e.error(new Error('Unable to UPDATE record on model "'.concat(e.modelName, '" because it is part of a CREATE mutation that is local-only. The requested update is not local-only, therefore the update would fail.')))
                    }
                    )(e, m, y, p))
                        return
                } else {
                    if (!(c = e.dispatchRecord(c, Gr.c)))
                        return;
                    m = n.get(c).value,
                    r && (v = m.persistedState)
                }
                if ("string" === typeof h) {
                    if (void 0 === (l = function(e, t, n, r, i, o, s) {
                        const a = o.fields[i];
                        if (!a)
                            return void o.error(new Error('The field "'.concat(i, '" is not a known field on the "').concat(o.modelName, '" model. Unable to set field value on record with ID "').concat(e.store.instance.__ID, '".')));
                        if (a.dynamicForeignFieldName)
                            return Ml(e, t ? {
                                [i]: t
                            } : void 0, {
                                [i]: n
                            }, r, o, s);
                        const c = e.get(i);
                        let u;
                        if (t) {
                            if (u = cl(t, n, i, o.dataTypesValidator),
                            u)
                                return void o.errorRecordState(u, Gr.c);
                            n = o.dataTypesUpdater[t](n, c)
                        }
                        try {
                            n = a.validator(n, a)
                        } catch (d) {
                            return void o.errorRecordState({
                                [i]: '"'.concat(i, '": ').concat(d.message)
                            }, Gr.c)
                        }
                        const l = a.type;
                        if (l.getComparisonValue(n) !== l.getComparisonValue(c)) {
                            o.isOptimisticComplete && o.ensurePendingChanges(e.get(o.primaryKey), e.store.instance);
                            const t = o.triggers;
                            let s = t.beforeFieldUpdate[i];
                            if (s && (u = t.call(s, "beforeFieldUpdate", e.store.instance, i, c, n, o, r),
                            u))
                                return void o.error(u);
                            if (e.set(i, n),
                            (s = t.afterFieldUpdate[i]) && (u = t.call(s, "afterFieldUpdate", e.store.instance, i, c, n, o, r),
                            u))
                                return void o.error(u)
                        }
                        return s && (s[i] = n),
                        n
                    }(m, u, l, !g && d, h, e, v)))
                        return;
                    return d || v || (m.mutationType === Gr.c && a.add(y),
                    e.addManagedDataField(y, h, l)),
                    d || (o.clearActiveRecord(c),
                    s && m.pChanges && m.pState[Ro.a.TS_FIELD] !== s && m.set(Ro.a.TS_FIELD, s)),
                    c
                }
                if (d || p) {
                    if (l[$u] && !this.processVFData(c, u, l, !g && d, h))
                        return
                } else if (v || (v = e.addManagedData(y, u, l, f),
                m.mutationType === Gr.c && a.add(y)),
                l[$u] && !this.flattenVFData(c, u, l, d))
                    return;
                return void 0 !== Ml(m, u, l, !g && d, e, v) ? (s && !d && m.pChanges && m.pState[Ro.a.TS_FIELD] !== s && m.set(Ro.a.TS_FIELD, s),
                c) : void 0
            }
            ,
            this
        }
        ,
        t.setDefaultAddRecord = qd,
        t.forObjectAddRecord = Ld,
        t.forArrayAddRecord = jd,
        t.forManyAddRecord = Vd
    }
    function Bd() {
        const e = this.managedPkValues;
        if (!e.size)
            return !0;
        const {fields: t, managedData: n, managedGroups: r, primaryKey: i, records: o} = this.mutation
          , s = tl(this.mutation.model.schema, this.mutationType);
        let a, c, u, l;
        for (let d of e)
            if (a = n[d],
            c = r && r.get(a),
            s && el(a, t)) {
                if (c && (u = c.managedPayload) ? (l = u.records) || (l = {},
                u.records = l) : (l = {},
                u = this.createQueryPayload({
                    data: a,
                    dataTypes: null,
                    records: l,
                    isLocalOnly: !1
                }),
                this.createQuery(u)),
                c) {
                    for (d of c)
                        e.delete(d),
                        l[d] = o[d];
                    hl(u.query, c),
                    c.managedPayload = void 0,
                    r.delete(a)
                } else
                    u.query.where(i, d),
                    l[d] = o[d];
                u.isDeterministic = !0,
                u.maybeDeterministic = !0,
                u.isManaged = !0,
                u.mutationHasVF = !1,
                u.mutationTypeIdx = this.push(u.query) - 1,
                al(u.data, u.records)
            } else if (c) {
                for (d of c)
                    e.delete(d);
                (u = c.managedPayload) && u.query.destroy(u),
                r.delete(a)
            } else
                e.delete(d);
        return !0
    }
    const Gd = Ro.a.TS_FIELD;
    function zd() {
        this.managedPkValues && (Yn.a.checkinSet(this.managedPkValues),
        this.managedPkValues = void 0),
        vd.call(this)
    }
    function Hd(e, t) {
        t.query.setConnectorUpdateCount(t.resp ? t.resp.length : 0)
    }
    const Kd = (e, t, n, r) => i => (i.localOnly(r),
    e.addChildKeyValuesToQuery(i),
    i.set(t, n),
    i);
    function Yd(e, t, n, r) {
        const i = n[$u]
          , o = this.mutation
          , s = o.controller
          , a = s.getNestedData();
        let c, u, l;
        a && s.nestedStart(null);
        for (let d in i)
            u = s.createNestedData(o, e, i[d]),
            c = s.getModelMutation(i[d].ownRefModel),
            l = t && t[d],
            !r && u.isMissingChildRecords ? c.update(Kd(u, l, n[d], r)) : c.getMutationType(Gr.c).forObjectAddRecord(u.getChildRecords(), l, n[d], r),
            n[d] = void 0,
            l && (t[d] = void 0);
        return n[$u] = void 0,
        a && s.nestedFinish(),
        !0
    }
    function Wd(e, t) {
        void 0
    }
    function $d(e, t) {
        if (this.length < 1)
            return;
        const {prevRecordState: n, triggerData: r, fields: i} = this.mutation;
        let o, s, a, c, u, l, d, h, f, p, g;
        for (o of this)
            if (s = o.payload,
            !s.isLocalOnly && (h = s.records))
                for (l in ({data: a} = s),
                p || (p = e.getMutationType(Gr.c)),
                h) {
                    for (c in d = n[l],
                    f = p.addRecord(h[l], null, d, !0),
                    d = f.getState(),
                    u = {},
                    a)
                        i[c] && (u[c] = d[c]);
                    if (g = r && r[l],
                    g)
                        for (c in g)
                            u[c] = d[c];
                    p.addRecord(f, null, u, !1),
                    t[l] = Gr.c
                }
    }
    const Xd = (e, t) => e ? [...e, t] : [t]
      , Jd = (e, t) => e ? "".concat(e.join("__sys__")).concat("__sys__").concat(t || "") : t || ""
      , Zd = (e, t, n) => {
        const r = "".concat(Jd(n)).concat(t);
        return (!e && (e = {}) || !e[r]) && (e[r] = Xd(n, t)),
        e
    }
    ;
    function eh(e, t, n, r) {
        const {fields: i, virtualFields: o} = e;
        let s;
        for (let a in t)
            o[a] ? n = eh(o[a].otherModel, t[a], n, Xd(r, a)) : !s && i[a] && (s = !0,
            n = Zd(n, e.primaryKey, r));
        return n
    }
    const th = (e, t, n) => {
        let r;
        return r = t.size ? e.query().whereIn(e.primaryKey, [...t]).findAllRecords({
            mutation: n
        }) : Object(D.c)(),
        Yn.a.checkinSet(t),
        r
    }
    ;
    function nh(e, t) {
        const n = e.query;
        for (let u in t)
            n.selection(t[u], u);
        let r, i;
        e.model || (e.model = n.model);
        let o = n.model;
        const s = e.mutation;
        let a, c;
        return s ? (a = s.mainDispatchId,
        c = s) : (a = e.dispatchId) || (a = e.model.__dispatchId),
        n.fetch(e).pipe(Object(P.a)(e => {
            const {resp: n} = e;
            if (!n || !n.length)
                return e.records = null,
                e.recordsByModel = null,
                Object(D.c)();
            i = Yn.a.checkoutMap(),
            r = Yn.a.checkoutMap();
            const {dispatchId: s} = e;
            let a, u;
            for (a in o = o.getBestInstance(s),
            t)
                r.set(a, Ys(o, t[a]).getBestInstance(s)),
                i.set(a, Yn.a.checkoutSet());
            let l = !1;
            for (let t of n)
                for (a in t)
                    (u = t[a]) && (i.get(a).add(u),
                    l = !0);
            if (!l)
                return ( (e, t) => {
                    for (let[,n] of t)
                        Yn.a.checkinSet(n);
                    Yn.a.checkinMap(e),
                    Yn.a.checkinMap(t)
                }
                )(r, i),
                Object(D.c)();
            c || (c = o.pluginMutation(s));
            const d = {};
            for (let[t,o] of i)
                d[t] = th(r.get(t), o, c);
            return Yn.a.checkinMap(r),
            Yn.a.checkinMap(i),
            Object(wr.a)(d)
        }
        ), Object(P.a)(e => {
            if (!e)
                return Object(D.c)();
            if (s)
                return Object(V.a)(e);
            if (!a)
                for (let t in e)
                    e[t] && (e[t] = Object(he.D)(e[t]));
            return c.execute(!a).pipe(Object(Or.a)(e))
        }
        ))
    }
    const rh = (e, t, n, r) => {
        const {userRole: i} = r;
        let o;
        if (!e.isGroupedQuery) {
            if (o = e.model.schema,
            !o.permRead(i, r, e))
                return !1;
            const t = e.directives;
            if (t) {
                const n = e.definedDirectives;
                let o, s, a, c;
                for (let e in t) {
                    if (c = n[e],
                    s = c.args,
                    o = t[e],
                    !c.permUse(i, r, o))
                        return !1;
                    if (s)
                        for (a in o)
                            if (!s[a].permUse(i, r, o[a]))
                                return !1
                }
            }
        }
        const s = e.queryArgs;
        if (s && s.length) {
            const o = e.fields;
            let a, c;
            for (a of s) {
                switch (c = a[he.q],
                c) {
                case he.c:
                    if (!o[a.key].permRead(i, r, a))
                        return !1;
                    break;
                case he.b:
                    a.query && (t = rh(e, t, n, r));
                    break;
                case he.d:
                    a.query && (t = rh(a.query, t, Xd(n, a.VFName), r))
                }
                if (!1 === t)
                    return !1
            }
        }
        return o && o.permRecRead ? Zd(t, o.primaryKey, n) : t
    }
    ;
    function ih(e) {
        const t = rh(e.query, null, null, e);
        return t ? Zd(t, e.query.primaryKey, null) : t
    }
    const {knownNoRecords: oh} = Ol
      , sh = (e, t, n, r, i, o) => {
        const {isLocalOnly: s} = e;
        i || ({model: i, dataTypes: n, data: r} = e);
        const {fields: a, virtualFields: c} = i;
        let u, l, d, h, f, p;
        for (let g in r)
            c[g] ? sh(e, t, n && n[g], r[g], c[g].otherModel, Xd(o, g)) : a[g] && (h || (h = Jd(o, i.primaryKey),
            d = t[h]),
            d && (n && n[g] && (l || (l = {},
            f && (f.dataTypes = l)),
            l[g] = n[g]),
            u || (u = {},
            p = e.mutation.switchTo(i).getMutationType(Gr.c),
            o ? (f = p.createQueryPayload({
                isLocalOnly: s,
                permCheck: !1,
                isDeterministic: !0,
                maybeDeterministic: !0,
                records: d,
                data: u,
                dataTypes: l,
                filterResults: !1
            }),
            hl(p.createQuery(f), Object.keys(d))) : (f = e,
            f.records = d,
            f.permCheck = !1,
            f.isDeterministic = !0,
            f.maybeDeterministic = !0,
            f.data = u,
            f.dataTypes = l,
            f.filterResults = !1,
            f.mutationHasVF = !1,
            hl(e.query, Object.keys(d)))),
            u[g] = r[g]));
        if (u) {
            const e = sl(r)
              , t = p.mutation.records;
            for (let n in d)
                e && e[n] || p.addRecord(d[n], l, u, s, null, !1, f),
                d[n] = t[n];
            o && p.addQuery(f)
        } else
            o || (e.data = {},
            e.dataTypes = null,
            e.hasCommitted = !0,
            e.mutationHasVF = !1,
            e.records ? (e.isDeterministic = !0,
            e.maybeDeterministic = !0,
            e.filterResults = !1,
            e.permCheck = !1) : oh(e))
    }
    ;
    function ah() {
        return this
    }
    const ch = (e, t, n) => {
        if (!e.query.includeVFs || !e.records || e.responseFormat !== ge.RECORDS_RESULTS)
            return;
        const {query: r, fetchPathsResp: i} = e
          , {includeVFs: o} = r;
        let s, a, c, u;
        for (let l in o) {
            if (s = o[l],
            a = s.getQueryPayload(e),
            c = s.VF,
            c.isManyToMany) {
                u = n ? [...n] : [],
                u.push(c.ownModelThroughVF.refModelVFName, c.ownRefModelThroughVF.modelVFName),
                a.filterResults = !1;
                const r = Jd(n, c.ownModelPk)
                  , o = Jd(u, c.ownRefModelPk);
                a.records = t[o];
                let s = null;
                if (e.records) {
                    const {ownModelThroughFieldName: e, otherModelThroughFieldName: t} = c;
                    for (const n of i)
                        n[r] && n[o] && (s || (s = {}),
                        s["".concat(n[r], "__").concat(n[o])] = {
                            [e]: n[r],
                            [t]: n[o],
                            getState: ah
                        })
                }
                a.linkedPayload = {
                    records: a.records,
                    parent: {
                        records: s
                    }
                }
            } else
                u = Xd(n, l),
                a.records = t[Jd(u, c.otherModelPk)];
            a.records ? (a.isDeterministic = !0,
            a.maybeDeterministic = !0,
            a.filterResults = !1,
            ch(a, t, u)) : oh(a)
        }
    }
    ;
    function uh(e, t, n) {
        let r;
        const i = e.mutation.primaryKey;
        let o;
        return t && n ? r = {
            ...t,
            ...n
        } : t ? (t[i],
        r = t) : n && (n[i],
        r = n),
        Object(qs.a)( () => {
            const {mutation: t} = e
              , n = t.model
              , i = n.query().addArgsFromQuery(e.query);
            return o = {
                query: i,
                mutation: t,
                model: n
            },
            nh(o, r)
        }
        ).pipe(Object(Y.a)(t => {
            if (e.fetchPathsResp = o.resp,
            !t)
                return oh(e),
                e.data && (e.data = {},
                e.dataTypes = null),
                null;
            if (e.isDeterministic = !0,
            e.maybeDeterministic = !0,
            e.filterResults = !1,
            e.data)
                return sh(e, t),
                ch(e, t),
                t;
            const n = t[e.mutation.primaryKey];
            if (!n)
                return oh(e),
                t;
            const r = e.records
              , i = e.mutation.getMutationType(Gr.b)
              , {isLocalOnly: s} = e;
            for (let o in n)
                r && r[o] || i.addRecord(n[o], s, e);
            return t
        }
        ))
    }
    function lh(e, t) {
        if (!this.length)
            return !!this.managedPkValues && this.managedPkValues.size > 0;
        const n = this.mutation
          , r = n.model
          , i = this.mutationType === Gr.c;
        let o, s, a, c, u = !!this.managedPkValues && this.managedPkValues.size > 0;
        for (o of this)
            s = o.payload,
            s.isLocalOnly || (o.convertM2MArgsToThroughArgs().convertPathArgsToFullPathArgs(),
            c = void 0,
            a = void 0,
            t && !1 === (a = ih(s)) ? o.permDenied(s) : (u = !0,
            i && (o.convertVFsData(),
            c = eh(r, s.data)),
            (!s.isDeterministic || c && (!c[n.primaryKey] || Object.keys(c).length > 1) || t && s.permCheck && a) && (i || a && a[n.primaryKey] || (a || (a = {}),
            a[n.primaryKey] = [n.primaryKey]),
            e.push(uh(s, a, c)))));
        return u
    }
    let dh = function() {
        return null
    };
    let hh = function(e) {
        return e
    };
    function fh(e, t) {
        class n extends t.Type {
            constructor(e, t) {
                super(e, t || Gr.c),
                this.managedPkValues = Yn.a.checkoutSet(),
                this.isInterimCommit = !1,
                this.setDefaultAddRecord()
            }
        }
        const r = n.prototype;
        return function(e, t) {
            const {storesMap: n} = e
              , r = new Set
              , i = (e, t, o) => {
                const s = sl(t);
                if (!s)
                    return;
                const {parent: a, resp: c} = o;
                if (c) {
                    const {primaryKey: t} = e;
                    for (let e of c)
                        r.add(e[t])
                }
                e = e.switchTo(o.model || o.query.model);
                const {fields: u, prevRecordState: l} = e;
                let d, h, f, p, g, m, y;
                for (let i in s)
                    if (h = s[i],
                    f = h.__ID,
                    !r.has(f)) {
                        for (g in d = void 0,
                        p = l[f],
                        t)
                            u[g] && (d || (d = {})) && (d[g] = p[g]);
                        if (d && (y = n.get(h))) {
                            if (y = y.getBestStore(e.dispatchId),
                            a && (m = e.getTriggerData(!0)) && (m = m[f]))
                                for (g in d)
                                    m[g] = void 0;
                            if (void 0 === Ml(y.value, null, d, !1, e))
                                return r.clear(),
                                null
                        }
                    }
                r.clear();
                const v = il(t);
                if (v) {
                    const {children: n} = o;
                    for (g in v)
                        if (i(e, t[g], n[g]),
                        e.isCancelling)
                            return null
                }
            }
            ;
            t.commit = function() {
                if (!this.willCommit)
                    return null;
                this.willCommit = !1;
                const e = this.mutation
                  , {fields: t, isServer: n} = e
                  , {isInterimCommit: r} = this;
                let o, s, a, c, u, l, d, h, f;
                this.isInterimCommit = !1;
                for (let p of this)
                    if (o = p.payload,
                    o.isLocalOnly || o.hasCommitted)
                        o.hasCommitted = !0;
                    else {
                        if (r) {
                            if (!o.hasInterimCommit) {
                                o.nonInterimData && (o.data = o.nonInterimData,
                                o.dataTypes = o.nonInterimDataTypes,
                                o.nonInterimData = null,
                                o.nonInterimDataTypes = null);
                                continue
                            }
                            o.hasInterimCommit = !1
                        }
                        if (o.hasCommitted = !0,
                        !n && (f = o.extensions) && 200 !== f.statusCode && 403 !== f.statusCode)
                            return hd(f);
                        if (!o.resp && n) {
                            let n;
                            for (c in ({records: s, data: a} = o),
                            t[Gd] && (n = Math.round(e.controller.ts / 1e3)),
                            s) {
                                for (l in d = s[c].getPersistedState(),
                                h = s[c].getState(),
                                a)
                                    t[l] && (d[l] = h[l]);
                                h[Gd] === n && (d[Gd] = h[Gd])
                            }
                        } else {
                            if (u = e.constructor.commitQueryPayload(o, e))
                                return u;
                            i(e, o.data, o)
                        }
                    }
                if (r && this.length > this.interimQueriesStartIdx) {
                    let e = this.interimQueriesStartIdx;
                    const t = this.length;
                    for (; e < t; )
                        this[e].destroy(this[e].payload),
                        e++;
                    this.splice(this.interimQueriesStartIdx),
                    this.interimQueriesStartIdx = this.length
                }
                return null
            }
        }(e, r),
        Wd(),
        Qd(e, r),
        r.addFunc = Fd,
        r.buildManagedQueries = Bd,
        r.destroy = zd,
        r.flattenVFData = Yd,
        r.setConnectorResp = Hd,
        r.undo = $d,
        lh && (r.getNewRecordDeps = dh,
        r.sendInterimToConnector = hh,
        r.fetchMissingRecords = lh),
        n
    }
    let ph;
    function gh(e, t, n, r) {
        let i, o;
        for (let s in e) {
            if (i = this.addRecord(e[s], t, r),
            !i) {
                if (void 0 === i)
                    return;
                o = !0
            }
            n || (e[s] = i)
        }
        return e
    }
    function mh(e, t, n, r) {
        let i;
        for (let o = 0; o < e.length; o++) {
            if (i = this.addRecord(e[o], t, r),
            void 0 === i)
                return;
            n || (e[o] = i)
        }
        return e
    }
    function yh(e, t, n, r) {
        return Array.isArray(e) ? this.forArrayAddRecord(e, t, n, r) : this.forObjectAddRecord(e, t, n, r)
    }
    function vh(e, t, n, r) {
        return this.setAddRecord().addRecord(e, t, n, r)
    }
    function bh() {
        return this.addRecord = vh,
        this
    }
    function _h(e, t) {
        const n = e.storesMap;
        t.setAddRecord = function() {
            const e = this.mutation;
            e.action || e.dispatchModel();
            const {primaryKey: t, controller: r} = e
              , i = e.model
              , o = n.get(i)
              , s = o.storeConfig
              , {triggers: a, recordsToComplete: c} = s;
            let u;
            return this.addRecord = function(s, l, d, h) {
                let f = n.get(s).value;
                const p = f.get(t);
                if (!p) {
                    const n = f.getPrev(t);
                    return n ? (f.mutationType === Gr.b && ph(f, n, l, d),
                    null) : void (g = e).error(new Error('An unknown record associated with model "'.concat(g.modelName, "\" was provided to delete. The record's ID could not be determined. This means the record is already closed, and therefore it cannot be mutated.")))
                }
                var g;
                if (e.records[p]) {
                    if (e.records[p] !== s && (s = e.records[p],
                    f = n.get(s).value,
                    f.mutationType === Gr.b))
                        return ph(f, p, l, d),
                        s;
                    if (!function(e, t, n, r, i) {
                        if (e.recordDataType[t] === Gr.a) {
                            if (e.isCommitOnly)
                                return n.mutationType && (n.mutationType = Gr.b),
                                e.recordDataType[t] = Gr.b,
                                !0;
                            if (e.getRecordQuery(t))
                                throw new Error("Unable to DELETE record on model ".concat(e.modelName, " because it is already associated with a custom CREATE query. If the CREATE was being managed by the mutation, it could be reversed, but since a custom query is being used instead, it cannot be done."));
                            const o = e.getManagedData(void 0, !0);
                            if (o && o[t]) {
                                (r || i) && delete o[t];
                                const n = e.getMutationType(Gr.a).managedPayload;
                                n && delete n.records[t]
                            }
                        } else if (!e.isConnectorComplete) {
                            const n = e.getMutationType(Gr.c);
                            if (n.getRecordQuery(t))
                                return void e.error(new Error('Unable to delete a record on model "'.concat(e.modelName, '" because it is pending an update using a custom mutationQuery. The record must be managed by the Mutation rather than using a custom MutationQuery in order to convert an update into a delete. This record is part of a custom MutationQuery and therefore cannot be converted to a delete.')));
                            const i = e.managedData;
                            if (i && i[t]) {
                                if (r)
                                    return void e.error(new Error('Unable to locally delete a record on model "'.concat(e.modelName, '" because it is pending a non-local update. The non-local update must take affect first before locally deleting the record.')));
                                e.removeFromManagedGroup(t, i[t], !0),
                                i[t] = null,
                                n.managedPkValues.delete(t)
                            }
                        }
                        return e.recordDataType[t] = Gr.b,
                        n.mutationType && (n.mutationType = Gr.b),
                        !0
                    }(e, p, f, l, d) || !f.mutationType && !(s = e.dispatchRecord(s, Gr.b)))
                        return;
                    const t = e.getTriggerData(!0);
                    t && t[p] && (t[p] = void 0)
                } else {
                    if (!(s = e.dispatchRecord(s, Gr.b)))
                        return;
                    f = n.get(s).value
                }
                l || r.setActiveRecord(s),
                c.set(p, f.store.mainStore);
                const m = f.pState && f.pSize ? f.pState : f.state;
                if (a.beforeDelete && (u = a.call(a.beforeDelete, "beforeDelete", i, p, s, m, e, !h && l),
                u))
                    e.error(u);
                else {
                    if (function(e, t, n, r, i) {
                        i ? (i.records || (i.records = {}),
                        i.records[t] = n) : r || ((i = e.managedPayload) || (i = e.createQueryPayload({
                            dataTypes: null,
                            data: null,
                            records: {},
                            isManaged: !0,
                            isLocalOnly: !1,
                            mutationHasVF: !1
                        }),
                        e.managedPayload = i),
                        i.records[t] = n,
                        e.mutation.addManagedData(t, null, null, !0))
                    }(this, p, m, l, d),
                    f.deleteAll(),
                    o.value.delete(p),
                    !a.afterDelete || (u = a.call(a.afterDelete, "afterDelete", i, p, m, s, e, !h && l),
                    !u))
                        return l || r.clearActiveRecord(s),
                        s;
                    e.error(u)
                }
            }
            ,
            this
        }
        ,
        t.forArrayAddRecord = mh,
        t.forManyAddRecord = yh,
        t.forObjectAddRecord = gh,
        t.setDefaultAddRecord = bh
    }
    function Sh() {
        const e = this.managedPayload;
        if (!e || this.managedQuery)
            return !1;
        const t = this.mutation.managedGroups.get(null);
        return e.query || this.createQuery(e),
        hl(e.query, t),
        e.mutationTypeIdx = this.push(e.query) - 1,
        this.managedQuery = e.query,
        !0
    }
    function Oh() {
        const e = this.mutation.model;
        for (let t of this)
            gl(t.payload, e)
    }
    ph = () => {}
    ;
    const Th = new Set;
    function Ih(e, t) {
        const {isServer: n} = t;
        let r = t.records;
        n || (t.query.setConnectorDeleteCount(t.resp ? t.resp.length : 0),
        t.optimisticRecords = r ? {
            ...r
        } : null);
        const i = t.resp;
        if (!i)
            return void (t.records = null);
        const {primaryKey: o} = this.mutation;
        if (r)
            if (n)
                for (let s of i)
                    r[s[o]] || (r[s[o]] = s);
            else {
                let e;
                for (let t of i)
                    e = t[o],
                    Th.add(e),
                    r[e] || (r[e] = t);
                for (e in r)
                    Th.has(e) || delete r[e];
                Th.clear()
            }
        else {
            t.records = r = {};
            for (let e of i)
                r[e[o]] = e
        }
    }
    function xh(e, t) {
        if (this.length < 1)
            return;
        const {prevRecordState: n, primaryKey: r} = this.mutation;
        let i, o, s, a, c, u;
        for (i of this)
            if (o = i.payload,
            !o.isLocalOnly && (u = o.records))
                for (c in s || (s = e.getMutationType(Gr.a)),
                u)
                    (a = n[c]) && (s.addRecord(a, !1),
                    t[a[r]] = Gr.a)
    }
    function wh(e, t) {
        class n extends t.Type {
            constructor(e) {
                super(e, Gr.b),
                this.managedPayload = void 0,
                this.setDefaultAddRecord()
            }
        }
        const r = n.prototype;
        return function(e, t) {
            const {storesMap: n} = e;
            t.commit = function() {
                if (!this.willCommit)
                    return null;
                this.willCommit = !1;
                const e = this.mutation;
                let t, r, i, o, s, a, c = void 0;
                if (e.isServer) {
                    for (let e of this)
                        if (t = e.payload,
                        t.hasCommitted = !0,
                        !t.isLocalOnly && (r = t.records))
                            if (c)
                                for (i in r)
                                    c.push(i);
                            else
                                c = Object.keys(r);
                    return c && this.mutation.commitDeletedRecords(c),
                    null
                }
                for (let n of this)
                    if (t = n.payload,
                    t.hasCommitted = !0,
                    !t.isLocalOnly) {
                        if ((o = t.extensions) && 200 !== o.statusCode && 403 !== o.statusCode)
                            return hd(o);
                        if (r = t.records,
                        a = t.optimisticRecords)
                            for (i in a)
                                r && r[i] || (s ? s.push(e.records[i]) : s = [e.records[i]]);
                        if (r)
                            if (c)
                                for (i in r)
                                    c.push(i);
                            else
                                c = Object.keys(r)
                    }
                if (c && this.mutation.commitDeletedRecords(c),
                !s)
                    return null;
                const {cascadesByRecord: u, prevRecordState: l} = e;
                let d, h, f, p, g, m, y, v, b = e.getMutationType(Gr.a);
                for (let _ of s) {
                    if (i = _.__prevID,
                    void 0 === b.addFromRecordsToComplete(l[i], !0, null, i))
                        return null;
                    if (u && (d = u.get(_)))
                        for ([h,f] of d)
                            if (p = e.switchTo(h.__typename),
                            m = p.getTriggerData(!0),
                            null === f) {
                                if (i = h.__prevID,
                                m && (m[i] = void 0),
                                void 0 === p.getMutationType(Gr.a).addFromRecordsToComplete(p.prevRecordState[i], !0, null, i))
                                    return null
                            } else if (f && (y = n.get(h))) {
                                y = y.getBestStore(e.dispatchId),
                                g = {},
                                i = h.__ID,
                                v = p.prevRecordState[i],
                                m = m && m[i] || null;
                                for (let e of f)
                                    g[e] = v[e],
                                    m && (m[e] = void 0);
                                if (void 0 === Ml(y.value, null, g, !0, p))
                                    return null
                            }
                }
                return null
            }
        }(e, r),
        Wd(),
        _h(e, r),
        r.addFunc = Fd,
        r.buildManagedQueries = Sh,
        r.mainTrxComplete = Oh,
        r.setConnectorResp = Ih,
        r.undo = xh,
        lh && (r.fetchMissingRecords = lh),
        n
    }
    const Mh = {
        action: {
            get() {
                return this.payload.mutation.action
            },
            set(e) {}
        },
        data: {
            get() {
                return this.payload.data
            },
            set(e) {
                this.payload.data = e
            }
        },
        dataTypes: {
            get() {
                return this.payload.dataTypes
            },
            set(e) {
                this.payload.dataTypes = e || null
            }
        },
        deleteCount: {
            get() {
                return this.payload.deleteCount
            },
            set(e) {
                this.payload.deleteCount = e
            }
        },
        graphqlPayload: {
            get() {
                return this.payload.graphqlPayload
            },
            set(e) {
                this.payload.graphqlPayload = e
            }
        },
        graphqlPayloadTypes: {
            get() {
                return this.payload.graphqlPayloadTypes
            },
            set(e) {
                this.payload.graphqlPayloadTypes = e
            }
        },
        isCommitOnly: {
            get() {
                return this.payload.mutation.isCommitOnly
            },
            set: void 0
        },
        isLocalOnly: {
            get() {
                return this.payload.isLocalOnly
            },
            set: void 0
        },
        mutation: {
            get() {
                return this.payload.mutation
            },
            set: void 0
        },
        mutationHasVF: {
            get() {
                return this.payload.mutationHasVF
            },
            set(e) {
                this.payload.mutationHasVF = !!e
            }
        },
        mutationName: {
            get() {
                const e = this.payload;
                if (!e.mutationName) {
                    const {mutationType: t} = e;
                    switch (t) {
                    case Gr.a:
                        const {records: n} = e;
                        if (n) {
                            let t = 0;
                            for (let e in n) {
                                if (t > 1)
                                    break;
                                t++
                            }
                            e.mutationName = t > 1 ? e.model.schema.createManyOp : e.model.schema.createOneOp
                        } else
                            e.mutationName = e.model.schema.createOneOp;
                        break;
                    case Gr.c:
                        e.mutationName = e.model.schema.updateManyOp;
                        break;
                    case Gr.b:
                        e.mutationName = e.model.schema.deleteManyOp;
                        break;
                    default:
                        throw new Error("Unrecognized mutationType. Expected ".concat(Gr.a, ", ").concat(Gr.c, ", or ").concat(Gr.b, ". Got: ").concat(t))
                    }
                }
                return e.mutationName
            },
            set(e) {
                this.payload.mutationName = e
            }
        },
        mutationType: {
            get() {
                return this.payload.mutationType
            },
            set: void 0
        },
        mutationTypeArray: {
            get() {
                const e = this.payload;
                return e.mutation[zu[e.mutationType]]
            },
            set: void 0
        },
        mutationTypeIdx: {
            get() {
                return this.payload.mutationTypeIdx
            },
            set: void 0
        },
        records: {
            get() {
                return this.payload.records
            },
            set(e) {
                this.payload.records = e || null
            }
        },
        updateCount: {
            get() {
                return this.payload.updateCount
            },
            set(e) {
                this.payload.updateCount = e
            }
        },
        variables: {
            get() {
                return this.payload.variables
            },
            set: void 0
        }
    }
      , Ah = Ol.knownNoRecords;
    function Eh(e) {
        const t = this.payload
          , n = t.extensions;
        if (n ? n.statusCode && 200 !== n.statusCode || (n.pkMap && ml(t),
        e ? (n.statusCode = e.statusCode || 500,
        n.statusMessage = e.statusMessage || "An unknown error occurred.") : (n.statusCode = 500,
        n.statusMessage = "An unknown error occurred."),
        Ah(t)) : Ah(t),
        t.apiLogRecord) {
            let n;
            e ? (n = e.error) || (n = new Error(e.statusMessage || "An unknown error occurred."),
            n.publicErrorMessage = n.message,
            n.statusMessage = n.message,
            n.statusCode = e.statusCode || 500) : (n = new Error("An unknown error occurred."),
            n.publicErrorMessage = n.message,
            n.statusMessage = n.message,
            n.statusCode = 500),
            t.apiLogRecord.error = n
        }
        return this
    }
    const {PAYLOAD: Ch} = ge;
    function Nh(e) {
        const t = this.payload;
        if (e && t.resultOperators) {
            const n = t.responseFormat === Ch ? t : t.formattedResponse || null;
            e.push(Object(V.a)(n).pipe(...t.resultOperators))
        }
        t.extensions && !t.extensions.statusCode && (t.extensions.statusCode = 200)
    }
    const Rh = (e, t, n) => (e ? e[t.VFName] = n : rl(e = {
        [t.VFName]: n
    }),
    il(e)[t.VFName] = t,
    e);
    function Ph(e, t) {
        const {virtualFields: n} = t;
        let r, i, o, s, a, c, u, l, d, h = null;
        for (let f in n)
            if (i = e[f])
                if (({[f]: r} = n),
                ({ownFieldFullVFPath: s, ownRefModelVF: a} = r),
                s) {
                    if (c = s[s.length - 1],
                    o = Ph(i, c.ownModel),
                    o) {
                        let e;
                        for (u = s.length - 1; u > 0; )
                            e = s[u],
                            o = {
                                [e.VFName]: o
                            },
                            rl(o)[e.VFName] = e,
                            u--;
                        h = Rh(h, s[0], o)
                    }
                } else
                    r.isManyToMany ? (({ownModelThroughVF: l, ownRefModelThroughVF: d} = r),
                    o = Ph(i, a.ownModel),
                    o && (o = {
                        [d.modelVFName]: o
                    },
                    rl(o)[d.modelVFName] = d.modelVF,
                    h = Rh(h, l.refModelVF, o))) : (o = Ph(i, a.ownModel),
                    h = Rh(h, r, o));
        if (h) {
            const {fields: n} = t;
            for (let t in n)
                "undefined" !== typeof e[t] && (h[t] = e[t]);
            const r = sl(e);
            return r && al(h, r),
            h
        }
        return e
    }
    function Dh() {
        const e = this.payload;
        return !e.mutationHasVF || e.mutationType !== Gr.c || e.originalData || (e.originalData = e.data,
        e.data = Ph(e.originalData, e.model),
        e.dataTypes && (e.originalDataTypes = e.dataTypes,
        e.dataTypes = Ph(e.originalDataTypes, e.model))),
        this
    }
    function Fh() {
        const e = this.payload;
        return e.isDeterministic = !0,
        e.maybeDeterministic = !0,
        e.mutationType === Gr.b && (e.permCheck = !1,
        e.permRecField = null),
        e.filterResults = !1,
        e.records || (e.records = null),
        this.get(e),
        null
    }
    function kh() {
        return null
    }
    const {ENUM: jh} = ei.a;
    function Lh(e, t) {
        const n = e.type;
        return n.KIND === jh ? Object(Zr.c)(n.serialize(t)) : n.serialize(t)
    }
    function Vh() {
        const e = this.payload;
        switch (e.mutationType) {
        case Gr.a:
            return e.records ? function(e) {
                const t = e.payload.records
                  , n = e.fields;
                let r, i, o, s, a = void 0, c = void 0;
                for (let u in t) {
                    for (r in o = t[u].getState(),
                    c = void 0,
                    n)
                        i = o[r],
                        s = n[r],
                        "undefined" !== typeof i && s.apiCreate && (i !== s.defaultValue || s.notNullable) && (c || (c = {}),
                        c[r] = Lh(s, i));
                    c && (a ? a.push(c) : a = [c])
                }
                a && (1 === a.length ? (e.mutationName = e.model.schema.createOneOp,
                e.graphqlPayload = a[0]) : (e.mutationName = e.model.schema.createManyOp,
                e.graphqlPayload = a))
            }(this) : e.graphqlPayload = e.mutation.model.getInputTypeName(Gr.a),
            e.graphqlPayload;
        case Gr.c:
            if (!e.data)
                return e.graphqlPayloadTypes = e.mutation.model.getUpdateTypesInputName(),
                e.graphqlPayload = e.mutation.model.getInputTypeName(Gr.c),
                null;
            const t = this.model;
            return e.graphqlPayload = function e(t, n) {
                const {fields: r, virtualFields: i} = n;
                let o, s, a, c = void 0;
                for (let u in t)
                    s = t[u],
                    "undefined" !== typeof s && ((o = r[u]) ? o.apiUpdate && (c || (c = {}),
                    c[u] = Lh(o, s)) : (a = i[u]) && a.ownModelVFApiUpdate && (s = e(s, a.ownRefModel)) && (c || (c = {}),
                    c[u] = s));
                return c
            }(e.data, t),
            e.dataTypes ? e.graphqlPayloadTypes = function e(t, n, r, i) {
                let o, s, a, c = void 0;
                for (let u in t) {
                    if (o = t[u],
                    r[u]) {
                        if ("undefined" === typeof n[u])
                            continue;
                        s = Object(Zr.c)(o)
                    } else {
                        if (!n[u])
                            continue;
                        a = i[u].ownRefModel,
                        s = e(o, n[u], a.fields, a.virtualFields)
                    }
                    c || (c = {}),
                    c[u] = s
                }
                return c
            }(e.dataTypes, e.graphqlPayload, t.fields, t.virtualFields) : e.graphqlPayloadTypes = null,
            e.graphqlPayload;
        case Gr.b:
            return e.graphqlPayload = null,
            null;
        default:
            throw new Error("Unrecognized mutationType: " + e.mutationType)
        }
    }
    function Uh(e) {
        const t = this.payload;
        return t.variables = this.prepareVariables(t.variables, t),
        this.buildGraphqlPayload(),
        eo(this, e, "string" === typeof t.graphqlPayload ? [] : t.variables, "Mutation")
    }
    function qh(e) {
        const t = this.payload;
        if (t.graphqlContext = e,
        t.extensions) {
            const n = t.extensions
              , r = e.extensions;
            for (let e in n)
                r[e] = n[e]
        }
        return t.extensions = e.extensions,
        this
    }
    const Qh = (e, t, n, r) => {
        const {fields: i, virtualFields: o} = e;
        let s, a, c, u, l = !!r, d = n && !n.parent, {querySelect: h} = e;
        for (let f in t)
            i[f] ? h && h[f] || (d ? ((e = e.cloneForExecute(n)).select(f),
            d = !1,
            ({querySelect: h} = e)) : e.select(f)) : (s = o[f]) && (d && (e = e.cloneForExecute(n),
            d = !1,
            ({querySelect: h} = e)),
            l || (e.includeFromArgs(void 0, void 0, n, void 0, void 0, t),
            l = !0),
            a = e.getOrInitIncludeVF(f, n),
            c = a.getQueryPayload(n),
            u = a.getGroupedQuery(!0, n),
            Qh(u, t[f], c, e));
        return e
    }
    ;
    function Bh(e) {
        const t = this.payload;
        if (t.includeMutationCalled)
            return this;
        t.includeMutationCalled = !0;
        const n = e ? t : void 0;
        let r = this;
        return t.mutationType === Gr.c ? Qh(r, t.data, n) : t.mutationType === Gr.a ? r.cloneForExecute(n).selectAll(!0) : r.isFieldSelected(t.mutation.primaryKey) ? r : r.cloneForExecute(n).select(t.mutation.primaryKey)
    }
    function Gh() {
        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        return this.payload.isLocalOnly = e,
        this
    }
    const zh = (e, t) => t && function(e) {
        if (e.mutationType === Gr.b)
            return !1;
        const t = e.query.getVFsInArgs();
        if (!t)
            return !1;
        const n = il(e.data);
        if (n)
            for (let r in n)
                if (t[r])
                    return !0;
        return !0
    }(e) && function(e, t) {
        const n = e.variables
          , r = e.query
          , i = r.RecordResult
          , o = {};
        for (let s in t)
            o[s] = i.buildForMutation(r, n, t[s]);
        e.recordsResults = o
    }(e, t)
      , Hh = e => e.query.queryArgs ? e.query.queryArgs.get(e) : e.model.size ? {
        ...e.model.getState()
    } : null;
    function Kh(e) {
        const t = this.payload;
        if ("boolean" === typeof t.isDeterministic)
            return e ? void t.mutation.error(new Error((n = this.modelName,
            'Records provided to optimisticRecords() on mutation query for model "'.concat(n, '", but optimistic records are already set. It is acceptable to call optimisticRecords() without records as many times as needed (it will just return the previously determined records), but do not attempt to set optimistic records more than once.')))) : t.optimisticRecords || t.records;
        var n;
        if (e)
            return ( (e, t, n) => {
                return t.nestedMutationData ? void t.mutation.error(new Error((r = n.modelName,
                'Records provided to optimisticRecords() on mutation query for model "'.concat(r, '", but there is nested mutation data associated with this mutation query. Call useRecords() instead, which will disregard the nested mutation data, otherwise use query arguments representing the records and then call optimisticRecords() without records so that the appropriate records can be determined by taking the nested mutation data into account.')))) : (t.isDeterministic = !1,
                t.maybeDeterministic = !1,
                e = Tl(e),
                t.optimisticRecords = e,
                zh(t, e),
                n);
                var r
            }
            )(e, t, this);
        const r = t.nestedMutationData
          , i = t.isLocalOnly || !tl(t.model.schema, t.mutationType)
          , o = !i && t.isServer;
        if (r) {
            if (t.nestedMutationData = null,
            !this.queryArgs && (i || !r.isMissingChildRecords))
                return this.useRecords(r.getChildRecords()),
                t.records;
            r.addChildKeyValuesToQuery(this),
            o && !r.isMissingChildRecords ? this.resolve(t) : (t.isDeterministic = !1,
            t.maybeDeterministic = !1)
        } else
            o ? this.resolve(t) : (t.isDeterministic = !1,
            t.maybeDeterministic = !1);
        return t.isDeterministic ? (e = t.records) ? (zh(t, e),
        t.recordsResults ? (t.records = void 0,
        t.optimisticRecords = e) : hl(this, Object.keys(t.records)),
        e) : (hl(this, null),
        null) : (e = Hh(t),
        t.optimisticRecords = e,
        zh(t, e),
        e)
    }
    const Yh = {}
      , Wh = (e, t, n) => (Yh[e] = function() {
        const {payload: e} = this;
        return e.responseFormat = t,
        e.responseFormatType = n,
        arguments.length > 0 ? (e.resultOperators = [...arguments],
        e.mutation.controller.hasResultOperators = !0) : e.resultOperators = !0,
        this
    }
    ,
    Yh[e]);
    function $h(e, t, n) {
        if (this.parentMethodsMap.set) {
            if (!this.parent.set(e, t, n))
                return;
            return this
        }
        if (this.mutationType !== Gr.c)
            return this;
        if (this.payload.includeMutationCalled)
            throw new Error("Unable to add mutation data: The includeMutation() method has already been called. Add all desired mutation data before calling that method.");
        if ("string" === typeof e) {
            let {data: r, dataTypes: i} = this.payload;
            if (r || (r = {},
            this.payload.data = r),
            "undefined" === typeof n)
                return r[e] = t,
                this;
            i || (i = {},
            this.payload.dataTypes = i),
            i[e] = t,
            r[e] = n
        } else
            "undefined" === typeof t ? this.payload.data = e : (this.payload.dataTypes = e,
            this.payload.data = t);
        return this
    }
    function Xh(e) {
        this.payload.deleteCount = e
    }
    function Jh(e) {
        const t = this.payload;
        let n = null;
        if (t.isServer)
            n = e && e.length > 0 ? e : null;
        else if (e.errors) {
            let n = e.extensions;
            n || (n = {}),
            n.statusCode || (n.statusCode = e.statusCode || 500),
            n.statusMessage || (n.statusMessage = e.errors[0] && e.errors[0].message || "An unknown error occurred."),
            t.extensions = n
        } else {
            const r = e.data;
            t.extensions = e.extensions,
            n = r[t.mutationName] || null,
            n && !Array.isArray(n) && (n = [n])
        }
        return t.resp = n,
        this.mutationTypeArray.setConnectorResp(n, t),
        this
    }
    function Zh(e) {
        this.payload.updateCount = e
    }
    function ef(e, t) {
        const n = this.payload;
        if (this.parentMethodsMap.useRecords)
            return this.parent.useRecords(e, t) ? this : void 0;
        e && "function" === typeof e && (t = e,
        e = void 0);
        const r = function(e, t) {
            const n = e.payload;
            if ("boolean" === typeof n.isDeterministic)
                return t ? new Error('Unable to useRecords() on MutationQuery for model "'.concat(e.model.modelName, '": records were provided to this method but they have already been provided. The useRecords() method can be called more than once, but records should only be provided once.')) : void 0;
            const r = e.queryArgs;
            if (t) {
                if (n.records)
                    return new Error('Unable to useRecords() on MutationQuery for model "'.concat(e.model.modelName, '": records were already provided, they cannot be provided a second time.'));
                if (n.records = Tl(t),
                !n.records)
                    return new Error('Unable to query.useRecords() on MutationQuery for model "'.concat(e.model.modelName, '": The provided `records` must be a single record, an Array of records, or an Object containing records. Got ').concat(typeof t, " instead: ").concat(t, "."));
                n.nestedMutationData = null,
                hl(e, Object.keys(n.records))
            } else {
                const t = n.nestedMutationData;
                t ? (n.nestedMutationData = null,
                r ? (t.addChildKeyValuesToQuery(e),
                n.records = e.queryArgs.get(n)) : n.records = t.getChildRecords()) : n.records = Hh(n),
                hl(e, n.records ? Object.keys(n.records) : null)
            }
            n.isDeterministic = !0,
            n.maybeDeterministic = !0
        }(this, e);
        if (!r) {
            if (t && n.records) {
                const e = n.mutation.controller
                  , r = e.createNestedData(n.query, n.records);
                e.nestedStart(r),
                t(n.mutation, n.records),
                e.nestedFinish()
            }
            return n.query
        }
        n.mutation.error(r)
    }
    function tf(e) {
        if (this.parentMethodsMap.values) {
            if (!this.parent.values(e))
                return;
            return this
        }
        if (this.mutationType !== Gr.a)
            return this;
        const t = this.payload;
        let n;
        if (t.mutation.controller.getNestedData())
            return void t.mutation.error(new Error("Nested VFData exists when attempting to create a new ".concat(t.mutation.modelName, " record. This is not supported.")));
        if (t.mutation.permCheck) {
            let n = t.data;
            n ? Array.isArray(e) ? n.push(...e) : n.push(e) : (n = Array.isArray(e) ? e : [e],
            t.data = n)
        } else if (Array.isArray(e)) {
            if (n = t.mutation.getMutationType(t.mutationType).forArrayAddRecord(e, t.isLocalOnly, !1, t),
            !n)
                return;
            t.data ? t.data.push(...n) : t.data = n
        } else {
            if (n = t.mutation.getMutationType(t.mutationType).addRecord(e, t.isLocalOnly, t),
            !n)
                return;
            t.data ? t.data.push(n) : t.data = [n]
        }
        return this
    }
    const {PAYLOAD: nf} = ge
      , {OBJECT_RESP: rf} = me
      , of = e => {
        class t extends e {
            constructor(e, t) {
                super(e),
                this.payload = t,
                this.isMutation = !0
            }
            static initAsMutation(e) {
                const t = this.init(e.model);
                return t.payload = e,
                e.responseFormat || (e.responseFormat = nf,
                e.responseFormatType = rf),
                e.query = t,
                t
            }
            permDenied(e, t) {
                return e.mutationType === Gr.a && ml(e),
                super.permDenied(e, t)
            }
            mapPkChanges(e, t, n) {
                return super.mapPkChanges(e, t, n || this.payload && this.payload.variables),
                this
            }
            createNewInstance(e, t, n) {
                const r = super.createNewInstance(e, t, n);
                return r.payload = this.payload,
                r
            }
            setVariables(e, t) {
                if (e === this.payload)
                    return super.setVariables(e, t);
                if (e && t)
                    throw new Error('Invalid payload provided to setVariables() on MutationQuery associated with model "'.concat(this.modelName, '": A payload does not need to be provided, but if it is, it must be the payload associated with this MutationQuery.'));
                return super.setVariables(this.payload, e)
            }
            cloneForExecute(e, t) {
                if (!e)
                    return this;
                if (e !== this.payload)
                    throw new Error("Invalid payload provided to a mutationQuery on model ".concat(this.modelName, ": The provided payload is different than the one associated with this mutationQuery (which is the source of truth)."));
                const n = super.cloneForExecute(e, t);
                if (n !== this) {
                    e.mutation.getMutationType(e.mutationType)[e.mutationTypeIdx] = n
                }
                return n
            }
            prepareSelect(e) {
                if (!e || e.mutationType === Gr.c)
                    return super.prepareSelect(e);
                let t = e.query;
                if (e.includeMutationCalled || (e.mutationType === Gr.a ? t = t.cloneForExecute(e).selectAll(!0) : t.isFieldSelected(t.primaryKey) || (t = t.cloneForExecute(e).select(t.primaryKey))),
                e.isServer || !t.includeVFs)
                    return t;
                const n = t.includeVFs;
                for (let r in n)
                    n[r].prepareSelect(e);
                return e.query
            }
            destroy(e) {
                if (e) {
                    const {query: t, originalQuery: n} = e;
                    t && n ? (t.payload = void 0,
                    n.payload = void 0) : this.payload = void 0
                } else
                    this.payload = void 0;
                super.destroy(e)
            }
        }
        const n = t.prototype;
        var r;
        return (r = n).returnPayload = Wh("returnPayload", ge.PAYLOAD, me.OBJECT_RESP),
        r.returnOne = Wh("returnOne", ge.RECORDS_RESULTS, me.SINGLE_RESP),
        r.returnOneRecord = Wh("returnOneRecord", ge.RECORDS, me.SINGLE_RESP),
        r.returnAll = Wh("returnAll", ge.RECORDS_RESULTS, me.OBJECT_RESP),
        r.returnAllArray = Wh("returnAllArray", ge.RECORDS_RESULTS, me.ARRAY_RESP),
        r.returnAllRecords = Wh("returnAllRecords", ge.RECORDS, me.OBJECT_RESP),
        r.returnAllRecordsArray = Wh("returnAllRecordsArray", ge.RECORDS, me.ARRAY_RESP),
        Yh.returnAllRecordsArray = void 0,
        n.buildGraphqlPayload = Vh,
        n.cancel = Eh,
        n.complete = Nh,
        n.convertVFsData = Dh,
        n.executeReturnQuery = Fh,
        n.getConnectorReturnQuery = kh,
        n.includeMutation = Bh,
        n.localOnly = Gh,
        n.optimisticRecords = Kh,
        n.set = $h,
        n.setConnectorDeleteCount = Xh,
        n.setConnectorResp = Jh,
        n.setConnectorUpdateCount = Zh,
        n.toGraphqlMutation = Uh,
        n.useRecords = ef,
        n.values = tf,
        n.withGraphqlContext = qh,
        Object.defineProperties(n, Mh),
        t
    }
      , sf = of(Bu);
    function af(e) {
        !function(e) {
            if (e.mutationType === Gr.c) {
                if (e.mutationHasVF = !!il(e.data),
                e.isLocalOnly)
                    return e;
                if (!e.isServer && e.query.directives) {
                    const t = e.query.directives
                      , n = e.query.definedDirectives;
                    for (let r in t)
                        if (n[r].apiUpdate)
                            return e
                }
                return e.mutationHasVF || tl(e.model.schema, Gr.c) && el(e.data, e.mutation.fields) || (e.isLocalOnly = !0),
                e
            }
            e.mutationHasVF = !1,
            e.isLocalOnly || tl(e.model.schema, e.mutationType) || (e.isLocalOnly = !0)
        }(e),
        e.mutationTypeIdx = this.push(e.query) - 1,
        this.mutation.action || this.mutation.dispatchModel()
    }
    function cf(e) {
        for (let t of this)
            t.cancel(e);
        return this
    }
    function uf(e, t) {
        return this.setDefaultAddRecord(),
        this
    }
    function lf(e) {
        return e || (e = this.createQueryPayload()),
        this.constructor.MutationQuery.initAsMutation(e)
    }
    function df(e) {
        let t, n;
        for (t of this)
            (n = t.executeReturnQuery()) && (e ? e.push(n) : e = [n]);
        return e
    }
    function hf(e) {
        const t = "string" === typeof e ? e : e[this.mutation.primaryKey];
        if (this.mutationType !== Gr.c) {
            let e, n;
            for (n of this)
                if ((e = n.records) && e[t])
                    return n;
            return null
        }
        {
            let e, n = null;
            for (let r of this)
                (e = r.records) && e[t] && (n ? Array.isArray(n) ? n.push(r) : n = [n, r] : n = r);
            return n
        }
    }
    Object.prototype.hasOwnProperty;
    function ff(e, t, n, r) {
        if (!e)
            return e;
        let i;
        if (n || (n = {}),
        r)
            for (let o in e)
                (i = t[o]) ? n[i] = e[o] : null !== i && (n[o] = e[o]);
        else
            for (let o in e)
                (i = t[o]) ? n[i] = e[o] : n[o] = e[o];
        return n
    }
    function pf(e, t, n, r, i) {
        if (!e)
            return e;
        let o, s;
        i || (i = {});
        for (let a in e)
            s = e[a],
            (o = t[a]) ? (i[o] = s,
            !s || r && s[n] !== a || (s[n] = o)) : i[a] = s;
        return i
    }
    const {CREATED: gf, PK_CHANGE: mf} = ws.a
      , yf = ["changes", "changesToCommit", "allChanges"];
    function vf(e, t) {
        const {pChanges: n} = e;
        let r, i, o, s, a = !1, c = !1;
        for (let u in t) {
            for (i of (r = t[u],
            yf))
                (o = e[i]) && (s = o[u]) && s !== mf && (o[r] = s,
                o[u] = mf,
                a = !0);
            n && (s = n[u]) && s !== mf && (n[r] = s,
            n[u] = mf,
            c = !0)
        }
        return a && c ? 3 : c ? 2 : a ? 1 : 0
    }
    function bf(e, t) {
        for (let n in t)
            if (e[n])
                return !0;
        return !1
    }
    function _f(e, t, n, r, i, o) {
        const s = {}
          , a = n.storeConfig.getRecordStore;
        let c, u, l;
        for (let d in e)
            u = e[d],
            (c = t[d]) ? (s[c] = u,
            u && (l = a(u)) && !l.closed && (i && (l.isMain || o && o[d] !== gf) || l.value.changePkValue(r, d, c))) : s[d] = u;
        return s
    }
    function Sf(e, t, n, r, i, o, s) {
        const a = t.storeConfig.getRecordStore;
        let c, u;
        for (let l in e)
            (c = e[l]) && (u = a(c)) && !u.closed && (o && (u.isMain || s && s[l] !== gf) || u.value.changePkValue(n, r, i))
    }
    function Of(e, t, n, r, i) {
        const o = {};
        let s, a, c, u;
        for (let l in e)
            a = e[l],
            (s = t[l]) ? (o[s] = a,
            a && (c = a.value) && (Sf(c.state, n, r, l, s, i),
            c.keyValue = s,
            !i && (u = c.pChanges) && Sf(c.pState, n, r, l, s, i, u))) : o[l] = a;
        return o
    }
    class Tf extends O.a {
        constructor(e) {
            super(),
            this.store = e
        }
        _next(e) {
            !function e(t, n, r, i, o) {
                let s;
                if (!o) {
                    o = n.value;
                    const a = n.history;
                    if (r)
                        for (s of ((s = o.pChanges) && o.pSize > 0 && (o.pState = _f(o.pState, t, r, i, !0, s),
                        o.hasPendingDelete = !1),
                        a))
                            e(t, n, r, i, s);
                    else {
                        r = n.mainStore,
                        i = n.storeConfig.primaryKey;
                        const o = n.pendingStoreMgr.children;
                        if (o.size > 0)
                            for (let[,n] of o)
                                e(t, n.store, r, i);
                        for (s of a)
                            e(t, n, r, i, s)
                    }
                }
                o.size > 0 && (o.state = _f(o.state, t, r, i, !n.isMain));
                vf(o, t)
            }(e, this.store)
        }
        unsubscribe() {
            super.unsubscribe(),
            this.store = void 0
        }
    }
    function If(e, t) {
        const n = {};
        let r, i;
        for (let o in e)
            r = e[o],
            (i = t[o]) ? (n[i] = r,
            r && !r.closed && (r.value.keyValue = i)) : n[o] = r;
        return n
    }
    function xf(e, t, n, r, i, o) {
        let s;
        if (!o) {
            o = t.value;
            const a = t.history;
            if (t.isMain) {
                const o = t.storeConfig;
                i = o.unique,
                r = n ? o.fieldNames[0] : null;
                const s = t.pendingStoreMgr.children;
                if (s.size > 0)
                    for (let[,t] of s)
                        xf(e, t.store, n, r, i)
            } else
                (s = o.pChanges) && o.pSize > 0 && (o.pState = n ? i ? _f(o.pState, e, n, r, !0, s) : Of(o.pState, e, n, r, !0) : i ? ff(o.pState, e) : If(o.pState, e),
                o.hasPendingDelete = !1);
            for (s of a) {
                xf(e, t, n, r, i, s);
                break
            }
        }
        vf(o, e),
        o.size > 0 && (o.state = n ? i ? _f(o.state, e, n, r, !t.isMain) : Of(o.state, e, n, r, !t.isMain) : i ? ff(o.state, e) : If(o.state, e))
    }
    function wf(e, t, n) {
        const r = t.value;
        if (!r)
            return;
        if (!n) {
            n = t.storeConfig.model.primaryKey;
            const r = t.pendingStoreMgr.children;
            if (r.size > 0)
                for (let[,t] of r)
                    wf(e, t.store, n)
        }
        let i = r.patch;
        if (i && (i = i[r.patchKey])) {
            let t, r;
            for (let o in e)
                (t = i[o]) && (t.prevID = o,
                t.ID = e[o],
                (r = t.value) && r[n] === o && (r[n] = e[o]),
                i[e[o]] = i[o])
        }
    }
    class Mf {
        constructor(e, t) {
            this.useNewPk = !1,
            this.useNewPkIsKnown = !1,
            this.idx = t,
            this.fieldNames = e.fieldNames,
            this.unique = e.unique
        }
        changePkValues(e, t, n, r) {
            if (!r) {
                if (r = t.value,
                t.isMain) {
                    n = {},
                    r.size > 0 && (r.state = this.reKeyState(r.state, e, n));
                    const i = t.pendingStoreMgr.children;
                    if (i.size > 0)
                        for (let[,t] of i)
                            this.changePkValues(e, t.store, n);
                    return vf(r, n),
                    this.useNewPk = !1,
                    void (this.useNewPkIsKnown = !1)
                }
                r.pState && (r.pState = this.reKeyState(r.pState, e, n),
                r.hasPendingDelete = !1)
            }
            r.size > 0 && (r.state = this.reKeyState(r.state, e, n)),
            vf(r, n)
        }
        reKeyState(e, t, n) {
            const {fieldNames: r, idx: i, unique: o} = this;
            let {useNewPk: s, useNewPkIsKnown: a} = this;
            const c = r.length;
            let u, l, d, h;
            const f = {};
            for (let p in e)
                if (d = e[p]) {
                    if (!o) {
                        for (u in h = d.getState(),
                        h)
                            if (d = h[u])
                                break;
                        if (!d)
                            continue
                    }
                    for (l = 0,
                    u = ""; l < c; )
                        h = d[r[l]],
                        l === i && h && (a ? s && (h = t[h]) : (t[h] ? (s = !0,
                        h = t[h]) : s = !1,
                        a = !0)),
                        u += 0 === l ? "".concat(h) : "".concat(In.a).concat(h),
                        l++;
                    p !== u && (n[p] = u),
                    f[u] = d
                } else
                    f[p] = d;
            return this.useNewPk = s,
            this.useNewPkIsKnown = a,
            f
        }
    }
    function Af() {
        throw new Error("Managing a compound index's child pkValues is unsupported.")
    }
    function Ef(e, t, n) {
        let r;
        if (n) {
            if (!(r = n.get(null)))
                return;
            r = r.value
        } else {
            n = t.value;
            const i = t.history;
            if ((r = n.get(null)) && (r = r.value),
            t.isMain) {
                const n = t.pendingStoreMgr.children;
                if (n.size > 0)
                    for (let[,t] of n)
                        Ef(e, t.store)
            } else
                r && r.pSize > 0 && bf(r.pState, e) && (r.pState = ff(r.pState, e),
                r.hasPendingDelete = !1);
            for (let n of i)
                Ef(e, t, n);
            if (!r)
                return
        }
        vf(r, e),
        r.size > 0 && bf(r.state, e) && (r.state = ff(r.state, e))
    }
    function Cf(e, t) {
        const n = t.storeConfig;
        let r = Nf
          , {childPkIndex: i, childPkIndexFieldName: o, childPkIndexValues: s} = n;
        i || (n.model === n.childPkChangesModel ? i = n.model : (i = n.model.getIndexByField(n.keyBy)) || (console.warn("The " + n.name + ' index is a non-unique index that has defined a key-by field of "' + n.keyBy + '", which is not indexed. This will definitely cause performance issues.'),
        r = Rf)),
        i ? (Object(he.N)(i) ? (i = i.getMainInstance(),
        n.childPkIndexIsModel = !0,
        n.childPkIndexIsUnique = !0) : (i = i.mainStore,
        n.childPkIndexIsModel = !1,
        n.childPkIndexIsUnique = i.storeConfig.unique),
        n.childPkIndex = i,
        n.childPkIndexFieldName = o || n.fieldNames[0],
        n.childPkIndexValues = s || new Set) : (n.childPkIndex = void 0,
        n.childPkIndexIsModel = void 0,
        n.childPkIndexIsUnique = void 0,
        n.childPkIndexFieldName = void 0,
        n.childPkIndexValues = void 0),
        t.value.updateChildPkChangesConfig(n.childPkChangesModel, r),
        r(e, t)
    }
    function Nf(e, t, n) {
        let r, i = !1;
        if (n)
            r = n.childPkIndexIsModel ? n.childPkIndex.getBestInstance(t.mainDispatchId) : n.childPkIndex.getBestStore(t.mainDispatchId);
        else {
            i = !0,
            n = t.storeConfig;
            const o = t.pendingStoreMgr.children;
            if (o.size > 0)
                for (let[,t] of o)
                    Nf(e, t.store, n);
            r = n.childPkIndex
        }
        const o = n.childPkIndexFieldName
          , s = n.childPkIndexValues
          , a = n.childPkIndexIsUnique;
        let c = n.childPkIndexUseNewPk
          , u = n.childPkIndexUseNewPkIsKnown;
        const l = t.value;
        if (l.size > 0 || !i && l.pSize > 0) {
            const t = r.getState();
            let d, h, f, p, g;
            for (d in e) {
                if (u) {
                    if (!(h = t[c ? e[d] : d]))
                        continue
                } else {
                    if (h = t[e[d]])
                        n.childPkIndexUseNewPk = c = !0;
                    else {
                        if (!(h = t[d]))
                            continue;
                        n.childPkIndexUseNewPk = c = !1
                    }
                    n.childPkIndexUseNewPkIsKnown = u = !0
                }
                if (a)
                    s.add(h[o]);
                else
                    for (f in p = h.getState(),
                    p)
                        (g = p[f]) && s.add(g[o])
            }
            if (s.size > 0) {
                const t = l.getState();
                for (d of s)
                    !(h = t[d]) || !i && h.isMain || Pf(e, h)
            }
        }
        i && (s.clear(),
        n.childPkIndexUseNewPk = !1,
        n.childPkIndexUseNewPkIsKnown = !1)
    }
    function Rf(e, t) {
        const n = t.getState();
        if (t.isMain) {
            for (let t in n)
                Df(e, n[t]);
            const r = t.pendingStoreMgr.children;
            if (r.size > 0)
                for (let[,t] of r)
                    Rf(e, t.store)
        } else {
            const {allChanges: r, pChanges: i} = t.value
              , o = t.mainStore.getState();
            let s, a;
            if (r)
                for (s in r)
                    r[s] !== mf && !o[s] && (a = n[s]) && Df(e, a);
            if (i)
                for (s in i)
                    i[s] !== mf && !o[s] && (a = n[s]) && Df(e, a)
        }
    }
    function Pf(e, t, n) {
        if (!n) {
            n = t.value;
            const r = t.history;
            if (!t.isMain && n.pSize > 0 && (n.pState = ff(n.pState, e),
            n.hasPendingDelete = !1),
            r.length)
                for (let n of r)
                    Pf(e, t, n)
        }
        vf(n, e),
        n.size > 0 && (n.state = ff(n.state, e))
    }
    function Df(e, t, n) {
        let r, i = !1;
        if (n) {
            if (!vf(n, e) && !bf(n.state, e))
                return !1
        } else {
            n = t.value;
            const o = t.history;
            if (t.isMain) {
                const s = t.pendingStoreMgr.children;
                if (s.size > 0) {
                    for (let[,t] of s)
                        Df(e, t.store) && (i = !0);
                    if (!i)
                        return !1
                } else if (!vf(n, e) && !bf(n.state, e))
                    return !1;
                for (r of o)
                    Df(e, t, r);
                vf(n, e)
            } else {
                if (!vf(n, e) && !bf(n.state, e))
                    return !1;
                for (r of (n.pSize > 0 && (n.pState = ff(n.pState, e),
                n.hasPendingDelete = !1),
                o))
                    Df(e, t, r)
            }
        }
        return n.size > 0 && (n.state = ff(n.state, e)),
        !0
    }
    function Ff(e, t, n) {
        const r = {};
        let i;
        for (let o in e)
            (i = e[o]) && (r[o] = i.subscribeToPkChanges(new jf(o,t,n)));
        return new kf(t,n,r)
    }
    class kf {
        constructor(e, t, n) {
            this.activeQueries = e,
            this.activeMutations = t,
            this.allSubs = n,
            this.closed = !1
        }
        fieldChanged(e, t) {
            const n = this.allSubs;
            n[e] && (n[e].unsubscribe(),
            n[e] = void 0),
            t && (n[e] = t.subscribeToPkChanges(new jf(e,this.activeQueries,this.activeMutations)))
        }
        unsubscribe() {
            if (this.closed)
                return;
            this.closed = !0;
            const e = this.allSubs;
            for (let t in e)
                e[t].unsubscribe(),
                e[t] = void 0;
            this.activeQueries = void 0,
            this.activeMutations = void 0,
            this.allSubs = void 0
        }
    }
    class jf extends O.a {
        constructor(e, t, n) {
            super(),
            this.fieldName = e,
            this.activeQueries = t,
            this.activeMutations = n
        }
        _next(e) {
            const {fieldName: t, activeQueries: n, activeMutations: r} = this;
            let i;
            if (n.size > 0)
                for (i of n)
                    i.mapPkChanges(e, t);
            if (r.size > 0)
                for (i of r)
                    i.mapPkChanges(e, t)
        }
        unsubscribe() {
            this.closed || (super.unsubscribe(),
            this.activeQueries = void 0,
            this.activeMutations = void 0)
        }
    }
    class Lf extends O.a {
        constructor(e) {
            super(),
            this.recordsToComplete = e
        }
        _next(e) {
            const t = this.recordsToComplete;
            if (!t.size)
                return;
            let n;
            for (let r in e)
                (n = t.get(r)) && (t.delete(r),
                t.set(e[r], n))
        }
        unsubscribe() {
            super.unsubscribe(),
            this.recordsToComplete = void 0
        }
    }
    const Vf = ["records", "optimisticRecords"];
    function Uf(e, t, n, r) {
        let i;
        if (r.mutationType === Gr.b)
            if (n)
                for (let o of Vf)
                    (i = r[o]) && bf(i, e) && (r[o] = pf(i, e, t, !0));
            else {
                let n, o, s;
                for (let a of Vf)
                    if (i = r[a])
                        for (n in i)
                            (o = i[n]) && (s = e[o[t]]) && (o[t] = s)
            }
        else {
            if (n && (i = r.records) && bf(i, e)) {
                const t = {}
                  , n = r.isServer && r.extensions && r.extensions.pkMap;
                for (let r in i)
                    e[r] ? (n && (n[r] && (n[n[r]] = e[r]),
                    n[r] = e[r]),
                    t[e[r]] = i[r]) : t[r] = i[r];
                r.records = t
            }
            if (r.mutationType === Gr.c) {
                n && (i = r.optimisticRecords) && bf(i, e) && (r.optimisticRecords = ff(i, e));
                const o = r.data;
                o && e[o[t]] && (o[t] = e[o[t]])
            }
        }
    }
    function qf(e, t, n) {
        if (this.length) {
            let r;
            for (r of this)
                Uf(e, t, n, r.payload)
        }
        if (this.managedPayload)
            Uf(e, t, n, this.managedPayload);
        else if (n && this.managedPkValues) {
            const t = this.managedPkValues;
            let n;
            for (let r of t)
                (n = e[r]) && n !== r && (t.delete(r),
                t.add(n))
        }
    }
    function Qf(e) {
        let t;
        for (t of this)
            t.permDenied(t.payload, e);
        return this
    }
    function Bf(e, t) {
        return !1
    }
    function Gf() {
        return !0
    }
    function zf(e, t, n, r, i) {
        const o = this.mutation;
        let s, a, c;
        if (this.mutationType === Gr.a)
            s = o.virtualFields,
            a = Wu[Gr.a];
        else {
            if (!(s = il(n)))
                return !0;
            a = Wu[Gr.c]
        }
        try {
            for (c in s)
                if (n[c] && (s[c][a](e, t, n, o, r, i),
                o.isCancelling))
                    return
        } catch (u) {
            return void o.errorRecordState({
                [c]: '"'.concat(c, '": ').concat(u.message, "\n").concat(u.stack)
            }, this.mutationType)
        }
        return !0
    }
    function Hf(e) {
        if (!this.willSendToConnector)
            return e;
        let t;
        this.willSendToConnector = !1;
        for (let n of this)
            n.isLocalOnly || n.payload.hasCommitted || (t || (e || (e = {}),
            this.mutation.isServer ? (t = e[this.mutationType]) || (t = [],
            e[this.mutationType] = t) : (t = e.queries) || (t = [],
            e.queries = t),
            this.willCommit = !0),
            t.push(n));
        return e
    }
    let Kf = Qs.a;
    function Yf(e) {
        return !1
    }
    const Wf = {
        dataTypesUpdater: {
            get() {
                return this.model.dataTypesUpdater
            },
            set: void 0
        },
        dataTypesValidator: {
            get() {
                return this.model.dataTypesValidator
            },
            set: void 0
        },
        executeCount: {
            get() {
                return this.controller.executeCount
            },
            set(e) {
                this.controller.executeCount = e
            }
        },
        hasSentToConnector: {
            get() {
                return this.controller.hasSentToConnector
            },
            set: void 0
        },
        isAcceptingFollowupQueries: {
            get() {
                return this.controller.isAcceptingFollowupQueries
            },
            set: void 0
        },
        isCommitOnly: {
            get() {
                return this.controller.isCommitOnly
            },
            set: void 0
        },
        isConnectorComplete: {
            get() {
                return this.controller.isConnectorComplete
            },
            set: void 0
        },
        isExecuting: {
            get() {
                return this.controller.isExecuting
            },
            set: void 0
        },
        isExecuteWhenDisabled: {
            get() {
                return this.controller.isExecuteWhenDisabled
            },
            set: void 0
        },
        isHistoryUpdateDisabled: {
            get() {
                return this.controller.isHistoryUpdateDisabled
            },
            set: void 0
        },
        isLocalOnly: {
            get() {
                return this.controller.isLocalOnly
            },
            set: void 0
        },
        isMainTrxComplete: {
            get() {
                return this.controller.isMainTrxComplete
            },
            set: void 0
        },
        isOptimisticComplete: {
            get() {
                return this.controller.isOptimisticComplete
            },
            set: void 0
        },
        isRedo: {
            get() {
                return this.controller.isRedo
            },
            set: void 0
        },
        isUndo: {
            get() {
                return this.controller.isUndo
            },
            set: void 0
        },
        isUndoable: {
            get() {
                return this.controller.isUndoable
            },
            set: void 0
        },
        isUndoRedo: {
            get() {
                return this.controller.isUndoRedo
            },
            set: void 0
        },
        mutationIndex: {
            get() {
                if (!this.pkIsAutoIncrement)
                    return !1;
                let {_mutationIndex: e} = this;
                if (!e && "boolean" !== typeof e) {
                    if (e = this.model.getMutationIndex(this.dispatchId),
                    e)
                        this._mutationLocalIndex = e;
                    else {
                        e = !1;
                        const t = this.model.getMutationIndex(this.dispatchId, !0);
                        this._mutationLocalIndex = t || !1
                    }
                    this._mutationIndex = e
                }
                return e
            },
            set: void 0
        },
        mutationLocalIndex: {
            get() {
                if (this.pkIsAutoIncrement) {
                    let {_mutationLocalIndex: e} = this;
                    return e || "boolean" === typeof e || (e = this.mutationIndex || this._mutationLocalIndex),
                    e
                }
                return !1
            },
            set: void 0
        },
        Record: {
            get() {
                return this.model.Record
            },
            set: void 0
        },
        willCommit: {
            get() {
                if (this.willCommitTriggerData)
                    return !0;
                for (let e of Yu)
                    if (this[e] && this[e].willCommit)
                        return !0;
                return !1
            },
            set: void 0
        },
        willSendToConnector: {
            get() {
                for (let e of Yu)
                    if (this[e] && this[e].willSendToConnector)
                        return !0;
                return !1
            },
            set: void 0
        }
    };
    function $f(e) {
        return this.controller.cancel(e)
    }
    function Xf(e) {
        let t;
        for (let n of Yu)
            (t = this[n]) && t.cancel(e);
        return this
    }
    function Jf(e) {
        return this.controller.commitOnly(e),
        this
    }
    function Zf(e, t) {
        let n;
        for (let r of Ku)
            (n = this[zu[r]]) && n.commitOnly(e, t);
        return this
    }
    function ep() {
        if (!this.willCommit)
            return null;
        let e, t;
        for (let n of Ku)
            if (e = this[zu[n]]) {
                if (t = e.commit(),
                this.isCancelling)
                    return;
                if (t)
                    return void this.error(t)
            }
        return this
    }
    function tp() {
        if (!this.willCommitTriggerData)
            return this;
        this.willCommitTriggerData = !1;
        const e = this.triggerData
          , t = this.model.getState()
          , {fields: n} = this;
        let r, i, o, s = void 0;
        for (let a in e)
            if (r = e[a])
                for (i in o = t[a].getPersistedState(),
                r)
                    n[i] && "undefined" !== typeof r[i] && (o[i] = r[i]);
            else
                null === r && (s ? s.push(a) : s = [a]);
        return s && this.commitDeletedRecords(s),
        this
    }
    function np(e, t, n) {
        const r = e.storesMap;
        n.commitQueryPayload = function(e, t) {
            return function(e, t, n) {
                return e.mutation ? Dl(e.resp, e.model, e.mutation.mainDispatchId, t, n || e.mutation, e) : (n || (n = (t, n) => Ol.getCommitMutation(n || e)),
                Dl(e.resp, e.model, Ol.getBestDispatchId(e), t, n, e))
            }(e, r, t)
        }
        ,
        n.commitResp = function(e, t, n, i, o) {
            return Dl(e, t, n, r, i, o)
        }
        ,
        t.commitDeletedRecords = function(e) {
            let t = r.get(this.model);
            const n = t.storeConfig.recordsToComplete
              , i = t.mainStore.value;
            t = t.value;
            const o = this.primaryKey;
            let s;
            for (let r of e)
                (s = i.get(r)) || (s = t.get(r)) || (s = t.getFromHistory(r)) ? s.getPersistedState()[o] = void 0 : (s = n.get(r)) && (s.value.persistedState[o] = void 0);
            return this
        }
        ,
        t.commitOnly = Jf,
        t._doCommitOnly = Zf,
        t.commit = ep,
        t.commitTriggerData = tp
    }
    function rp(e) {
        let t;
        for (let[,n] of e) {
            for ([,t] of n)
                t && Yn.a.checkinSet(t);
            Yn.a.checkinMap(n)
        }
        Yn.a.checkinMap(e)
    }
    function ip() {
        return this.controller.ofOptimisticComplete()
    }
    function op() {
        return this.controller.optimisticComplete(this)
    }
    function sp() {
        if (!this.action)
            return !0;
        let e;
        this.isInPluginChanges = !1;
        for (let t of Yu)
            if ((e = this[t]) && !e.optimisticComplete())
                return !1;
        return !0
    }
    function ap() {
        return this.controller.ofConnectorComplete()
    }
    let cp = function() {
        return !this.action || void 0 !== this.commit()
    };
    function up(e) {
        return this.controller.ofComplete(e)
    }
    function lp(e) {
        if (this.isComplete = !0,
        !this.action)
            return;
        let t;
        for (let n of Yu)
            (t = this[n]) && t.complete(e)
    }
    const dp = (e, t) => "Invalid records param provided to ".concat(t, '() on model "').concat(e, '". A value was provided but it is not a single record, an Array of records nor an Object containing records.')
      , hp = (e, t, n) => "Invalid param1 provided to mutation.".concat(n, '() for model "').concat(t, '": Expected a function, name of a virtual field, a record, Array of records, or Object containing records but got: ').concat(e)
      , fp = (e, t, n) => {
        const r = e.virtualFields[n];
        if (r)
            return r;
        e.error(new Error(( (e, t, n) => "Invalid virtual field name provided to ".concat(n, '(). The virtual field "').concat(e, '" is not a known virtual field for the "').concat(t, '" model.'))(n, e.modelName, t)))
    }
      , pp = (e, t, n, r, i, o, s) => {
        const a = fp(e, t, n);
        if (a) {
            if (s || (s = e.controller.getNestedData()))
                return e[t = "_".concat(t, "VFNested")](s, a, r, i, o);
            e.error(new Error(( (e, t) => "Invalid argument provided to ".concat(t, '(): The virtual field name "').concat(e, '" was provided to ').concat(t, "(), but the parent record(s) have not been set."))(n, t)))
        }
    }
      , gp = (e, t, n, r, i, o, s) => {
        if (!fp(e, t, r))
            return;
        const a = e.controller
          , c = a.createNestedData(e, n);
        a.nestedStart(c);
        const u = pp(e, t, r, i, o, s, c);
        return u ? (a.nestedFinish(),
        u) : void 0
    }
      , mp = (e, t, n, r) => (r = "boolean" === typeof r ? r : e.isLocalOnly,
    e.getMutationType(t).addFunc(n, {
        isLocalOnly: r,
        nestedMutationData: e.controller.getNestedData()
    }))
      , yp = (e, t, n, r, i, o) => {
        let s = void 0;
        if (Object(he.U)(t))
            return e.addRecord(t, n, r, i, o);
        if (Array.isArray(t)) {
            if (!Object(he.U)(t[0]))
                return void e.mutation.error(new Error(dp(e.mutation.modelName, e.mutationType)));
            s = e.forArrayAddRecord(t, n, r, i, o)
        } else
            ( (e, t, n) => {
                if (Object(he.U)(t[Object.keys(t)[0]]))
                    return t;
                e.error(new Error(dp(e.modelName, n)))
            }
            )(e.mutation, t, e.mutationType) && (s = e.forObjectAddRecord(t, n, r, i, o));
        return void 0 === s ? void 0 : e.mutation
    }
      , vp = (e, t, n, r, i, o, s) => {
        let a;
        "function" === typeof i ? (a = i,
        s = "boolean" === typeof o ? o : e.isLocalOnly,
        i = null,
        o = null) : t ? (s = "boolean" === typeof i ? i : e.isLocalOnly,
        i = null,
        o = null) : "boolean" === typeof o ? (s = o,
        o = i,
        i = null) : o && "object" === typeof o ? "boolean" !== typeof s && (s = e.isLocalOnly) : (s = e.isLocalOnly,
        o = i,
        i = null);
        const c = e.controller;
        let u;
        const l = c.getModelMutation(r.ownRefModel);
        if (!s && n.checkForMissingRefs(r)) {
            c.nestedStart(null);
            const e = e => {
                e.localOnly(s).where(r.ownRefModelVFName, e => n.addChildKeyValuesToQuery(e)),
                o && e.set(i, o),
                a && e.andWhere(a)
            }
            ;
            u = t ? l.delete(e) : l.update(e)
        } else if (a) {
            const i = c.createNestedData(e, n.getChildRecords(), r);
            s || (i.isMissingChildRecords = !1),
            c.nestedStart(i),
            u = t ? l.delete(a, s) : l.update(a, s)
        } else {
            const a = n.getVFRecords(r);
            if (!a)
                return e;
            c.nestedStart(null),
            u = t ? l.delete(a, s) : l.update(a, i, o, s)
        }
        if (void 0 !== u)
            return c.nestedFinish(),
            e
    }
    ;
    function bp(e, t, n, r) {
        if (e.childRecordsIsMany)
            return void this.error(new Error((i = t.bestVFName,
            o = this.modelName,
            'Unable to create "'.concat(i, '" for records associated with model "').concat(o, '" because there is more than 1 parent record, and therefore it cannot be determine which parent record to associate the provided data with.'))));
        var i, o;
        const s = this.controller;
        if ("function" === typeof n)
            return void this.error(new Error("It is unnecessary to provide a function when creating nested VF record(s). Create the record(s) and then use the record(s) as needed to make any additional changes. Once created, the record(s) will be available on the parent record immediately, provided it is also part of this mutation. If it is not, call `mutation.getMutableRecord(parentRecord)` and it will be joined to the mutation so its new ref(s) will be accessible before the mutation executes."));
        "boolean" !== typeof r && (r = this.isLocalOnly),
        s.nestedStart(null);
        const a = e.childRecord;
        try {
            t.processCreateVFData(a, null, n, this, r, !0)
        } catch (c) {
            return void this.error(c)
        }
        return s.nestedFinish(),
        t.isMany ? this : a[t.VFName]
    }
    function _p(e, t) {
        return "boolean" !== typeof t && (t = this.isLocalOnly),
        e && "string" !== typeof e ? this.getMutationType(Gr.a).addRecord(e, t) : this.getMutationType(Gr.a).addPkValue(e, t)
    }
    function Sp(e, t, n, r) {
        if (this.isComplete)
            throw new Error("The mutation for model ".concat(this.modelName, " is already complete. Unable to create a new record. Get a new mutation instead."));
        let i = typeof e;
        if ("function" === i)
            return mp(this, Gr.a, e, t);
        if ("string" === i)
            return pp(this, "create", e, t, n, r);
        if (!e)
            throw new Error(hp(e, this.modelName, "create"));
        if (i = typeof t,
        "string" === i)
            return gp(this, "create", e, t, n, r);
        t = "boolean" === i ? t : this.isLocalOnly;
        const o = this.getMutationType(Gr.a);
        let s;
        return s = Array.isArray(e) ? e[0] && "object" === typeof e[0] ? o.forArrayAddRecord(e, t) : o.forArrayAddPkValue(e, t) : o.forObjectAddRecord(e, t),
        void 0 === s ? void 0 : this
    }
    function Op(e, t, n, r, i) {
        return vp(this, !1, e, t, n, r, i)
    }
    function Tp(e, t, n, r, i) {
        if (this.isComplete)
            throw new Error("The mutation for model ".concat(this.modelName, " is already complete. Unable to create a new record. Get a new mutation instead."));
        if ("function" === typeof e)
            return mp(this, Gr.c, e, t);
        if ("string" === typeof e)
            return pp(this, "update", e, t, n, r);
        if (!e)
            throw new Error(hp(e, this.modelName, "update"));
        let o = null;
        if ("string" === typeof t) {
            if (this.virtualFields[t])
                return gp(this, "update", e, t, n, r, i);
            if (o = t,
            o === this.primaryKey)
                return void this.errorRecordState({
                    [o]: '"'.concat(o, '": Unable to update record field because the provided field ("').concat(this.primaryKey, '") is the primary key for the model ("').concat(this.modelName, '"). This cannot be updated.')
                }, Gr.c);
            t = n,
            n = r,
            "boolean" !== typeof (r = i) && (r = this.isLocalOnly)
        } else
            "boolean" === typeof n ? (r = n,
            n = t,
            t = null) : n && "object" === typeof n ? "boolean" !== typeof r && (r = this.isLocalOnly) : (r = this.isLocalOnly,
            n = t,
            t = null);
        const s = this.getMutationType(Gr.c);
        return o ? yp(s, e, t, n, r, o) : n ? (n = this.validateUpdateData(t, n)) ? yp(s, e, t, n, r) : void 0 : void this.error(new Error('Data is required in order to update one or more records associated with the "'.concat(this.modelName, '" model. Got ').concat(n)))
    }
    function Ip(e, t, n, r) {
        return vp(this, !0, e, t, n, r)
    }
    function xp(e, t, n, r) {
        if (this.isComplete)
            throw new Error("The mutation for model ".concat(this.modelName, " is already complete. Unable to create a new record. Get a new mutation instead."));
        if ("function" === typeof e)
            return mp(this, Gr.b, e, t);
        if ("string" === typeof e)
            return pp(this, "delete", e, t, n, r);
        if (!e)
            throw new Error(hp(e, this.modelName, "delete"));
        if ("string" === typeof t)
            return gp(this, "delete", e, t, n, r);
        t = "boolean" === typeof t ? t : this.isLocalOnly;
        const i = this.getMutationType(Gr.b);
        return yp(i, e, t)
    }
    function wp(e) {
        return e.__typename === this.modelName ? this.records[e.__ID] || this.dispatchRecord(e, Gr.c) : this.controller.getMutableRecord(e)
    }
    function Mp() {
        this.closed || this.controller.destroy()
    }
    function Ap(e) {
        if (this.closed = !0,
        this.model.addRemoveMutation(this, !0),
        e && this[zu[Gr.b]]) {
            const {recordDataType: t} = this;
            for (let n in t)
                t[n] === Gr.b && this.model.getTimeTravelTimestampsForPkValue(n, e)
        }
        let t;
        for (let n of Yu)
            (t = this[n]) && (t.destroy(),
            this[n] = void 0);
        this.action && (this.action = null,
        this.dispatchRecord = void 0,
        this._ensurePendingChanges = void 0),
        this.controller = void 0,
        this.fields = void 0,
        this.dynamicForeignFields = void 0,
        this.userRole = void 0,
        this.invalidRecords && (this.invalidRecords = void 0),
        this.indexesStore && (this.indexesStore = void 0,
        this.indexStores = void 0,
        this.getMutableIndex = void 0),
        this.managedData = void 0,
        this.managedGroups && (Yn.a.checkinMap(this.managedGroups),
        this.managedGroups = void 0),
        this.model = void 0,
        this._mutationLocalIndex && (this._mutationIndex = void 0,
        this._mutationLocalIndex = void 0),
        this.cascadesByRecord && (rp(this.cascadesByRecord),
        this.cascadesByRecord = void 0),
        this._updateVFDataForPkChanges && (this._updateVFDataForPkChanges = void 0),
        this.prevRecordState = void 0,
        this.records = void 0,
        this.recordDataType = void 0,
        this.triggers = void 0,
        this.triggerData = void 0,
        this.virtualFields = void 0,
        this.syncMgr = void 0,
        this.persistentType = void 0,
        this.persistentData = void 0,
        this.entitySlug && this.externalCompleteType && (Yn.a.checkinMap(this.externalCompleteType),
        Yn.a.checkinMap(this.externalCompleteData),
        this.externalCompleteType = void 0,
        this.externalCompleteData = void 0)
    }
    var Ep = n(873);
    const Cp = Object.prototype.hasOwnProperty;
    function Np(e) {
        e.meta.closed || e.meta.subscribe()
    }
    function Rp(e, t) {
        return this.dispatchModel().dispatchRecord(e, t)
    }
    function Pp(e, t) {
        const n = 'The model "'.concat(this.modelName, '" contains a record with invalid state:\n').concat(Object.values(e).join("\n"))
          , r = new Error(n);
        this.errorMessage = n,
        this.controller.errorMessage = n,
        console.warn("".concat(r.stack, "\n\nCancelling Mutation...")),
        this.cancel({
            statusCode: 400,
            statusMessage: r.message
        })
    }
    function Dp(e, t) {
        console.warn("".concat(e.message, "\n").concat(e.stack, "\n\nCancelling Mutation...")),
        e.statusCode && (t ? t.statusCode || (t.statusCode = e.statusCode) : t = {
            statusCode: e.statusCode
        }),
        this.cancel(t)
    }
    const Fp = Object(V.a)(null);
    function kp() {
        return this.controller.ofExecute()
    }
    function jp(e) {
        return this.controller.execute(e)
    }
    function Lp(e) {
        return this.controller.executeNow(e)
    }
    function Vp() {
        return this.controller.incrementExecuteCount(),
        this
    }
    function Up() {
        return this.controller.decrementExecuteCount(),
        this
    }
    function qp() {
        if (this.permCheck = !1,
        !this.action)
            return Fp;
        let e;
        for (let t of Yu)
            if ((e = this[t]) && !e.execute())
                return null;
        return this.action.meta.asObservable()
    }
    function Qp() {
        return this.controller.executeReturnQueries(this)
    }
    function Bp(e) {
        let t;
        for (let n of Yu)
            (t = this[n]) && (e = t.executeReturnQueries(e));
        return e
    }
    function Gp(e, t, n) {
        return this.controller.addToFollowupQueries(e, t, n)
    }
    function zp() {
        return this.controller.executeFollowupQueries(this)
    }
    function Hp(e) {
        return this.controller.getModel(e)
    }
    function Kp(e, t) {
        return this.controller.getModelMutation(e, t)
    }
    function Yp(e, t) {
        let n = this[zu[e]];
        return n || t || (n = new this.constructor[Hu[e]](this),
        this[zu[e]] = n),
        n
    }
    function Wp(e) {
        const t = "string" === typeof e ? e : e[this.primaryKey]
          , n = this.recordDataType[t];
        return n && this[zu[n]] ? this[zu[n]].getRecordQuery(t) : null
    }
    function $p() {
        return this.controller.getSession()
    }
    function Xp(e) {
        return this.controller.disableHistoryUpdate(e),
        this
    }
    function Jp(e) {
        return this.controller.localOnly(e),
        this
    }
    function Zp(e) {
        return this.controller.localOnlyStart(e),
        this
    }
    function eg() {
        return this.controller.localOnlyFinish(),
        this
    }
    function tg(e, t) {
        if (this.managedData) {
            if (e) {
                let n = this.managedData[e];
                return n || t || (n = {},
                this.managedData[e] = n),
                n
            }
            return this.managedData
        }
        if (!t) {
            if (e) {
                const t = {};
                return this.managedData = {
                    [e]: t
                },
                t
            }
            return this.managedData = {},
            this.managedData
        }
    }
    function ng(e, t, n, r) {
        const i = this.getManagedData();
        let o = i[e];
        if (!o)
            return t && r ? n = {
                ...n
            } : r && this.addToManagedGroup(e, n),
            i[e] = n,
            n;
        if (this.removeFromManagedGroup(e, o))
            o = n ? {
                ...o,
                ...n
            } : null,
            i[e] = o;
        else if (n)
            for (let s in n)
                o[s] = n[s];
        else
            o = null,
            i[e] = null;
        return o
    }
    function rg(e, t, n) {
        const r = this.getManagedData();
        let i = r[e];
        return i ? this.removeFromManagedGroup(e, i) ? (i = {
            ...i,
            [t]: n
        },
        r[e] = i) : i[t] = n : (i = {
            [t]: n
        },
        r[e] = i),
        i
    }
    function ig(e, t) {
        if (this.managedGroups) {
            if (e || null === e) {
                let n = this.managedGroups.get(e);
                return n || t || (n = [],
                this.managedGroups.set(e, n)),
                n
            }
            return this.managedGroups
        }
        if (!t) {
            if (this.managedGroups = Yn.a.checkoutMap(),
            e || null === e) {
                const t = [];
                return this.managedGroups.set(e, t),
                t
            }
            return this.managedGroups
        }
    }
    function og(e, t) {
        const n = this.getManagedGroup(t);
        return n.indexOf(e) < 0 && n.push(e),
        n
    }
    function sg(e, t, n) {
        if (!this.managedGroups)
            return !1;
        const r = this.managedGroups.get(t);
        if (!r)
            return !1;
        let i = r.indexOf(e);
        return !!(i > -1 && (r.length > 1 || !r.managedPayload || n)) && (r.splice(i, 1),
        0 === r.length ? (this.managedGroups.delete(t),
        r.managedPayload && (r.managedPayload.query.destroy(r.managedPayload),
        r.managedPayload = void 0)) : r.managedPayload && (r.managedPayload.records = void 0),
        !0)
    }
    const ag = (e, t, n) => {
        let r, i;
        for (let o in e)
            (r = e[o]) && (i = t[r[n]]) && (r[n] = i)
    }
    ;
    function cg(e) {
        return this.controller.setPermCheck(e),
        this
    }
    function ug(e) {
        for (let t of Yu)
            this[t] && this[t].permDenied(e);
        return this
    }
    function lg(e, t, n, r) {
        return e
    }
    var dg = n(183);
    const {STALE: hg} = dg.a;
    function fg(e) {
        if (e.isMain)
            return null;
        const {allChanges: t, pChanges: n} = e.value;
        if (!t && !n)
            return null;
        let r;
        if (t)
            for (let i in t)
                t[i] !== Ns.f && (r || (r = {}),
                n && n[i] && n[i] !== Ns.h ? r[i] = n[i] : r[i] = t[i]);
        if (n) {
            r || (r = {});
            for (let e in n)
                n[e] !== Ns.f && (n[e] === Ns.h && r[e] || (r[e] = n[e]))
        }
        return r || null
    }
    function pg(e, t, n) {
        return t || (n = e[this.fieldNames[0]]),
        !0 === this.includeNull || null !== n ? n : void 0
    }
    function gg(e, t, n) {
        const r = this.fieldNames;
        let i = 1;
        const o = r.length;
        let s;
        if (t)
            for (s = t === r[0] ? n : e[r[0]]; i < o; )
                s += t === r[i] ? "".concat(In.a).concat(n) : "".concat(In.a).concat(e[r[i]]),
                i++;
        else
            for (s = e[r[0]]; i < o; )
                s += "".concat(In.a).concat(e[r[i]]),
                i++;
        return s
    }
    function mg(e, t, n) {
        const r = e.storeConfig;
        return r[t] && r.model.triggers.remove(r[t]),
        r[t] = n || null,
        n && ("throughModelTrigger" === t ? r.VF.throughModel.triggers.add(n) : r.model.triggers.add(n)),
        !0
    }
    var yg = n(344);
    const {FLAT_PATCH: vg} = yg.a;
    class bg extends O.a {
        constructor(e, t, n, r) {
            super(),
            this.store = e,
            this.method = t,
            this.subKey = r,
            this.thisArg = n || t
        }
        _next(e) {
            this.method.call(this.thisArg, e, this.store)
        }
        unsubscribe() {
            if (this.closed)
                return;
            super.unsubscribe();
            const e = this.store.storeConfig;
            e && (e[this.subKey] = void 0),
            this.method = void 0,
            this.thisArg = void 0,
            this.store = void 0
        }
    }
    var _g = n(872)
      , Sg = n(189)
      , Og = n(236);
    function Tg(e) {
        e.isCompleting || e.scheduledCompleteSub !== this || (e.scheduledCompleteSub = void 0,
        0 === e.activeCount && e.dispatchIds && 0 === e.dispatchIds.size && e._complete())
    }
    var Ig = n(187)
      , xg = n(999)
      , wg = n(182);
    class Mg extends xg.a {
        static parseOptions(e, t) {
            return super.parseOptions(Object(Jt.j)(e, this, wg.a), t)
        }
        static create(e) {
            return new this(this.parseOptions(e)).init()
        }
        next(e) {
            let t = this.createManagerInner(e, e.mainDispatchId);
            if (!t)
                throw new Error("The MainTrxMgr already has an action for the mainDispatchId ".concat(e.mainDispatchId, ". Unable to create a new MainTrxMgr for that id. This most likely means that the mainTrx is already completing. This can be caused by dispatching a pending action under the mainDispatchId after the complete procedure has already begun on the mainTrx. Check the mainAction network's isCompleting property before dispatching under a mainDispatchId when the current status of the action is unknown."));
            t._pendingDispatchId = e.dispatchId,
            this.network.registerTrxChildManager(t, t)
        }
        get streamName() {
            return "MainTrxMgr"
        }
    }
    Mg.prototype.isMain = !0,
    Mg.prototype.isCommitOnly = !1;
    class Ag extends xg.a {
        static parseOptions(e, t) {
            return super.parseOptions(Object(Jt.j)(e, this, wg.b), t)
        }
        static create(e) {
            return new this(this.parseOptions(e)).init()
        }
        init() {
            return this.isCommitOnly = this.options.isCommitOnly,
            super.init()
        }
        next(e) {
            const t = this.createManagerInner(e, e.meta.dispatchId);
            this.network.registerTrxChildManager(t, t)
        }
        get streamName() {
            return "PendingTrxMgr"
        }
    }
    function Eg(e) {
        e.MainActionNetwork || function(e) {
            const t = e.objectPool
              , n = e.dispatches
              , r = e.pStoreMgrSetByMainDispatchId
              , o = e.dispatchIdsByMainDispatchId
              , s = e.trxByDispatchId;
            let a, c, u, l, {init: d} = e;
            e.init = t => {
                t ? (({networks: l, mainTrxMgr: a, stores: c, TrxLogic: u} = e),
                d(t),
                d = void 0) : d(t)
            }
            ;
            class h extends e.BaseNetwork {
                constructor(e, n) {
                    super(e, n, !0),
                    this.dispatchIds = t.checkoutSet(),
                    this.activeCount = 0,
                    this.isCompleting = !1;
                    const {mainDispatchId: i} = this;
                    o.set(i, this.dispatchIds),
                    r.set(i, t.checkoutSet()),
                    this.ts = this.createTs(),
                    this.session = void 0,
                    this.isUndoable = !1,
                    this.isUndo = !1,
                    this.isRedo = !1,
                    this._meta = t.checkoutSet()
                }
                get isComplete() {
                    return !!this.parent
                }
                getAssetsMgr() {
                    return this.assetsMgr
                }
                setAssetsMgr(e) {
                    this.assetsMgr = e
                }
                getTs() {
                    return this.ts
                }
                setTs(e) {
                    this.ts = e
                }
                getTsOffset(e) {
                    return this.ts - e
                }
                updateTs(e) {
                    return this.ts = this.ts + e,
                    this.ts
                }
                getSession() {
                    return this.session || this.parent.getSession()
                }
                setSession(e) {
                    this.session = e
                }
                registerTrxChildManager(e, t, n) {
                    e.network = this,
                    s.set(this.mainDispatchId, e),
                    super.registerChildManager(e, t, !0);
                    const r = s.get(e.pendingDispatchId);
                    e.addPendingTrx(r, u, !0),
                    e.begin(e)
                }
                registerChildManager(e, t, n) {
                    e.network = this,
                    this.activeCount++,
                    this._meta.add(e),
                    super.registerChildManager(e, t, n)
                }
                addParentToMainTrx(e, t) {
                    if (t !== u)
                        return !1;
                    let n = c.get(e.store.parentStoreId);
                    if (n) {
                        const e = n.getAction(this.mainDispatchId);
                        u.addStoreToTrx(s.get(this.mainDispatchId), e.meta)
                    }
                    return !0
                }
                registerPendingAction(e, t) {
                    if (this.dispatchIds.add(e.dispatchId),
                    e.isTrx) {
                        const t = s.get(e.dispatchId);
                        let n = s.get(this.mainDispatchId);
                        n ? n.addPendingTrx(t, u, !1) : (this.isTrx = !0,
                        a.next(t))
                    }
                }
                pendingActionComplete(e) {
                    this.dispatchIds.delete(e.dispatchId),
                    this.maybeScheduleComplete()
                }
                mainActionMetaComplete(e) {
                    this.activeCount--,
                    this.dispatchIds && this.maybeScheduleComplete()
                }
                maybeScheduleComplete() {
                    this.scheduledCompleteSub && (this.scheduledCompleteSub.unsubscribe(),
                    this.scheduledCompleteSub = void 0),
                    0 === this.activeCount && 0 === this.dispatchIds.size && (this.scheduledCompleteSub = i.b.schedule(Tg, 0, this))
                }
                _complete() {
                    const {mainDispatchId: e} = this;
                    if (this.isCompleting = !0,
                    this.isTrx) {
                        const t = s.get(e);
                        if (t)
                            return t.complete(),
                            !1;
                        this._checkinTrxDeps()
                    }
                    const t = this._meta
                      , n = r.get(e);
                    if (n.size)
                        for (let r of n)
                            t.delete(r.mainActionMeta),
                            r.complete();
                    if (t.size)
                        for (const r of t)
                            r._opReady(r.value);
                    return t.clear(),
                    this.session = void 0,
                    this.assetsMgr = void 0,
                    l.delete(this.id),
                    !0
                }
                mainTrxComplete(e) {
                    s.delete(e.mainDispatchId),
                    this._complete()
                }
                childManagerComplete(e, i) {
                    if (super.childManagerComplete(e, i),
                    !n.has(this.mainDispatchId)) {
                        this.parent = void 0,
                        t.checkinSet(this._meta),
                        t.checkinSet(this.dispatchIds),
                        this.dispatchIds = void 0,
                        this._meta = void 0;
                        const {mainDispatchId: e} = this;
                        o.delete(e),
                        t.checkinSet(r.get(e)),
                        r.delete(e),
                        this.scheduledCompleteSub && (this.scheduledCompleteSub.unsubscribe(),
                        this.scheduledCompleteSub = void 0)
                    }
                }
            }
            h.prototype.isMain = !0,
            e.MainActionNetwork = h
        }(e),
        e.PendingActionNetwork || function(e) {
            const t = e.networks
              , n = e.dispatches
              , r = e.trxByDispatchId;
            let i, o, {init: s} = e;
            e.init = t => {
                t ? (({pendingTrxMgr: i, TrxLogic: o} = e),
                s(t),
                s = void 0) : s(t)
            }
            ;
            const a = e => {
                const t = n.get(e);
                if (t) {
                    let n;
                    for (let r of t)
                        (n = r.children.get(e)) && n.cancel()
                }
            }
            ;
            class c extends O.a {
                constructor(e) {
                    super(),
                    this.__dispatchId = e
                }
                _complete() {
                    super._complete(),
                    a(this.__dispatchId)
                }
            }
            class u extends e.BaseNetwork {
                constructor(e, t) {
                    super(e, t, !1),
                    this.isTrx && (this.isTrxStarted = !1,
                    i.next(e)),
                    this.mainActionNetwork.registerPendingAction(this, e)
                }
                get mainActionNetwork() {
                    return t.get(this.mainDispatchId)
                }
                get isCancelling() {
                    return !!this._cancel$
                }
                get isCancelled() {
                    return null === this._cancel$
                }
                getAssetsMgr() {
                    return this.mainActionNetwork.getAssetsMgr()
                }
                setAssetsMgr(e) {
                    this.mainActionNetwork.setAssetsMgr(e)
                }
                getTs() {
                    return this.mainActionNetwork.ts
                }
                setTs(e) {
                    this.mainActionNetwork.ts = e
                }
                getTsOffset(e) {
                    return this.mainActionNetwork.getTsOffset(e)
                }
                updateTs(e) {
                    return this.mainActionNetwork.updateTs(e)
                }
                getSession() {
                    return this.mainActionNetwork.getSession()
                }
                setSession(e) {
                    this.mainActionNetwork.setSession(e)
                }
                cancel() {
                    if (!this.parent)
                        return Object(V.a)(this);
                    if (this._cancel$)
                        return this._cancel$;
                    this._cancel$ = new U.a;
                    const e = this.isTrx ? r.get(this.dispatchId) : null;
                    return e ? (e.getTrxOpsStream(null).subscribe(new c(this.dispatchId)),
                    e.cancel()) : a(this.dispatchId),
                    this._cancel$ || Object(V.a)(this)
                }
                get isUndo() {
                    return this.mainActionNetwork.isUndo
                }
                get isRedo() {
                    return this.mainActionNetwork.isRedo
                }
                get isUndoable() {
                    return this.mainActionNetwork.isUndoable
                }
                registerTrxChildManager(e, t, n) {
                    e.network = this,
                    r.set(this.dispatchId, e),
                    super.registerChildManager(e, t, !0)
                }
                registerChildManager(e, t, n) {
                    if (e.network = this,
                    this.isTrx) {
                        const i = r.get(this.dispatchId);
                        if (o.addStoreToTrx(i, e),
                        super.registerChildManager(e, t, n),
                        !this.isTrxStarted) {
                            this.isTrxStarted = !0;
                            const e = r.get(this.dispatchId);
                            e.begin(e.value)
                        }
                    } else
                        super.registerChildManager(e, t, n)
                }
                childManagerComplete(e, i) {
                    if (super.childManagerComplete(e, i),
                    !n.has(this.dispatchId)) {
                        this._cancel$ && (this._cancel$.next(this),
                        this._cancel$.complete(),
                        this._cancel$ = null),
                        this.isTrx && (r.delete(this.dispatchId),
                        this._checkinTrxDeps());
                        const e = this.mainActionNetwork;
                        e ? e.pendingActionComplete(this) : console.warn(">>>> NO MAIN NETWORK..."),
                        this.parent = void 0,
                        t.delete(this.dispatchId)
                    }
                }
            }
            u.prototype.isMain = !1,
            e.PendingActionNetwork = u
        }(e);
        const {networks: t, pStoreMgrSetByMainDispatchId: n} = e;
        let r, o, {init: s} = e;
        e.init = t => {
            if (t)
                ({MainActionNetwork: r, PendingActionNetwork: o} = e),
                s(t),
                s = void 0;
            else {
                let {storeNetwork: n} = e;
                n || (e.storeNetwork = n = new e.StoreNetwork),
                e.mainStoreMgr || (e.mainStoreMgr = Ig.a.create({
                    network: n
                })),
                e.pendingStoreMgr || (e.pendingStoreMgr = Ig.b.create({
                    network: n
                })),
                e.mainTrxMgr || (e.mainTrxMgr = Mg.create({
                    network: n,
                    trxType: Fl.b
                })),
                e.pendingTrxMgr || (e.pendingTrxMgr = Ag.create({
                    network: n,
                    trxType: Fl.b
                })),
                s(t)
            }
        }
        ;
        class a extends e.BaseNetwork {
            constructor(e, t, n) {
                super(e, t, n),
                this.session = void 0
            }
            getSession() {
                return this.session
            }
            setSession(e) {
                this.session = e
            }
            registerTrxChildManager(e, n, r) {
                t.get(e.dispatchId).registerTrxChildManager(e, n, r)
            }
            registerChildManager(e, i, s) {
                if (e.isInner) {
                    let n = t.get(e.dispatchId);
                    n || (n = e.isMain ? new r(i,this) : new o(i,this)),
                    n.registerChildManager(e, i, s)
                } else
                    e.isMain || n.get(e.mainDispatchId).add(e),
                    super.registerChildManager(e)
            }
        }
        return e.StoreNetwork = a,
        e
    }
    Ag.prototype.isMain = !1;
    var Cg = n(392)
      , Ng = n(179);
    const Rg = () => {
        let e = 0;
        return function() {
            return ++e
        }
    }
      , Pg = () => {
        let e = 0;
        return function() {
            return ++e
        }
    }
    ;
    let Dg, Fg;
    const {MUTATION: kg, TRX_ACTION_STANDARD: jg} = ti.a
      , Lg = Object(Jt.d)()
      , Vg = {
        [Fl.b]: Lg
    }
      , Ug = ( (e, t) => {
        const n = [];
        let r = 0;
        return {
            checkout() {
                if (r > 0)
                    return r--,
                    n.pop();
                {
                    const n = {};
                    for (let t of e)
                        n[t] = void 0;
                    return n[l.r] = t,
                    n
                }
            },
            checkin(e) {
                n[r] = e,
                r++
            }
        }
    }
    )(Lg, Fl.b)
      , qg = {
        [Fl.b]: Ug
    }
      , Qg = (e, t, n) => {
        const {[l.h]: r, [l.r]: {[t]: i}} = e
          , {length: o} = n;
        let s, a, c = 0;
        for (; c < o; ) {
            if (n[c].otherLogic[l.h] === r) {
                s = n[c],
                a = n[c + 1];
                break
            }
            c++
        }
        s ? (s.opsMap[t] = i,
        a.opsMap[i] = t) : (s = {
            opsMap: {
                [t]: i
            },
            logic: d.d,
            otherLogic: e,
            asPeer: !0
        },
        n.push(s),
        a = {
            opsMap: {
                [i]: t
            },
            logic: e,
            otherLogic: d.e
        },
        n.push(a))
    }
      , Bg = (e, t, n, r, i) => {
        if (i || ({[l.a]: i} = e),
        "string" === typeof i) {
            if ("*" === i)
                return n;
            {
                const o = n[i];
                if (!o)
                    return n;
                for (let n in t) {
                    if (o[n])
                        throw new Error('The trx op "'.concat(n, '" on store "').concat(r.storeName, '" has 2 defined anchor points for the action "').concat(i, '", one on logic with id ').concat(o[n][l.h], " and another on logic with id ").concat(e[l.h], ". Each trx op can only have one anchor point per action type."));
                    o[n] = e
                }
                return n
            }
        }
        if (Array.isArray(i)) {
            for (let o of i)
                n = Bg(e, t, n, r, o);
            return n
        }
        return n
    }
    ;
    const Gg = []
      , zg = []
      , Hg = [];
    let Kg = 0
      , Yg = 0
      , Wg = 0;
    const $g = {
        [h.b]: h.b
    }
      , Xg = {
        [h.k]: h.e
    }
      , Jg = {
        [h.k]: h.k,
        [h.d]: h.d,
        [h.a]: h.a,
        [h.l]: h.l,
        [h.e]: h.e,
        [h.b]: h.b,
        [h.h]: h.h,
        [h.f]: h.f,
        [h.j]: h.j,
        [h.i]: h.i,
        [h.g]: h.g
    };
    function Zg(e, t) {
        zg[Yg] = t,
        Yg++
    }
    function em(e, t) {
        Gg[Kg] = t,
        Kg++
    }
    function tm() {
        return Wg ? (Wg--,
        Hg.pop()) : {
            asPeer: !0,
            opsMap: Jg
        }
    }
    function nm(e, t) {
        Hg[Wg] = t,
        Wg++
    }
    function rm(e) {
        const t = e.meta.mainStore;
        return t.optimisticExecuteQueue.push(e),
        t.executeQueue.push(null),
        e
    }
    function im(e) {
        const {optimisticExecuteQueue: t, executeQueue: n} = e.meta.mainStore
          , r = t.indexOf(e);
        if (r >= 0) {
            t.splice(r, 1);
            const e = n[r];
            n.splice(r, 1),
            e && e.next(),
            0 === r && n[0] && n[0].next()
        }
        return !0
    }
    function om(e, t) {
        const n = e.meta
          , {optimisticExecuteQueue: r, executeQueue: i} = n.mainStore
          , o = r.indexOf(e);
        if (o < 0)
            return e;
        if (i[o] = t,
        0 === o)
            return r.length > 1 && n.network.forwardSerializeSiblings(r, i),
            e;
        const s = n.dispatchId
          , a = n.network;
        let c;
        for (let u = 0, l = r.length; u < l; u++)
            if (u !== o && (c = r[u],
            a.isSiblingTrx(s, c.meta.dispatchId)))
                return i.splice(o, 1),
                r.splice(o, 1),
                a.forwardSerializeSiblings(r, i),
                e
    }
    function sm(e) {
        const {optimisticExecuteQueue: t, executeQueue: n} = e.meta.mainStore;
        return t[0] !== e || (t.splice(0, 1),
        n.splice(0, 1),
        n[0] && (t[0].meta.network.forwardSerializeSiblings(t, n),
        n[0].next())),
        e
    }
    function am(e, t) {
        let n, r = e.meta;
        r ? n = e : (n = e.value,
        r = n.meta);
        const i = r.store;
        if (i.closed)
            return e;
        const {executeQueue: o, optimisticExecuteQueue: s} = i.mainStore
          , a = s.indexOf(n);
        if (a < 0)
            t.next(e);
        else {
            if (o.splice(a, 1),
            s.splice(a, 1),
            0 === a) {
                const e = o[0];
                e && (n = s[0]) && !n.meta.isCancelOrErrorOp() && (n.meta.network.forwardSerializeSiblings(s, o),
                e.next())
            }
            t.next(e)
        }
    }
    var cm = n(106);
    const um = {
        [h.k]: "trxPrepare",
        [h.h]: !1,
        [h.f]: "optimisticCommit",
        [h.j]: "runOptimisticReducers",
        [h.i]: "optimisticNotify",
        [h.g]: !1,
        [h.d]: !1,
        [h.a]: "commit",
        [h.l]: "runReducers",
        [h.e]: "notify",
        [h.b]: "trxComplete",
        [h.m]: "cancel",
        [h.c]: !1
    };
    function lm(e) {
        const t = e.stores
          , n = e.mainTrxMgr
          , r = e.pendingTrxMgr
          , i = e.mainTrxLogicMap
          , o = e.mainExtraTrxLogicMap
          , s = e.pendingTrxLogicMap
          , a = e.pendingExtraTrxLogicMap
          , c = e.trxActionsDepsMap
          , u = e.trxByDispatchId
          , d = e.isolationDepsMap
          , f = e.objectPool;
        let p, g, m, y, v, b, S, O, T, I, x, w, M, A;
        class E {
            constructor(e, t, i, o) {
                this.storeId = e,
                this.validLogic = t,
                this.isStateLogic = i && !t[l.a],
                this.isMain = o,
                o ? n.cloneLogicProps(t, this) : r.cloneLogicProps(t, this),
                this[l.h] = t[l.h] + "_" + e,
                this[l.b] = void 0,
                this[l.q] = void 0,
                this[l.c] = !1
            }
            static registerStore(e, t, n) {
                const r = e.storeId;
                if (this.addToStore(e, t, !0, n),
                this.addToStore(e, t, !1, n),
                t.mainExtraTrxLogic && this.addExtraToStore(r, t.mainExtraTrxLogic, !0, !0),
                t.pendingExtraTrxLogic && this.addExtraToStore(r, t.pendingExtraTrxLogic, !1, !0),
                n) {
                    const e = n.storeId;
                    this.addExtraToStoreFromStore(r, e, !0),
                    this.addExtraToStoreFromStore(r, e, !1)
                }
            }
            static getLogicIdx(e, t) {
                for (let n = 0, r = t.length; n < r; n++)
                    if (t[n].validLogic[l.h] === e)
                        return n;
                return -1
            }
            static addToStore(e, t, o, a) {
                let c, u, d, h;
                T = e.storeId,
                o ? (c = n,
                u = i,
                h = t.mainTrxLogic) : (c = r,
                u = s,
                h = t.pendingTrxLogic),
                d = h ? c.validateSingleLogic(h, "" + T) : a ? u.get(a.storeId).validLogic : function(e, t) {
                    let n = _[e];
                    return n || (n = {
                        [l.h]: "".concat(e),
                        [l.j]: "".concat(e),
                        [l.m]: e,
                        [l.n]: !0
                    },
                    _[e] = n,
                    n)
                }(o ? t.mainTrxPriority : t.pendingTrxPriority);
                const f = new this(T,d,!0,o);
                return u.set(T, f),
                o ? e.mainTrxPriority = f[l.m] : e.pendingTrxPriority = f[l.m],
                f
            }
            static addLogicInFlight(e, n, r) {
                const i = t.get(n);
                let o, s;
                if (r) {
                    const t = i.storeMgr.children;
                    if (t.size > 0)
                        for ([,s] of t)
                            (o = u.get(s.mainDispatchId)) && 0 === o.opIdx && o.addLogic(e)
                } else {
                    const t = i.pendingStoreMgr.children;
                    if (t.size > 0) {
                        let n, r;
                        for ([,n] of t)
                            if (r = n.children,
                            r.size)
                                for ([,s] of r)
                                    (o = u.get(s.pendingDispatchId)) && 0 === o.opIdx && o.addLogic(e)
                    }
                }
            }
            static addExtraToStore(e, t, i, s) {
                if (!t)
                    return !1;
                let c, u, d;
                i ? (c = n,
                d = o) : (c = r,
                d = a);
                const h = c.validateLogic(t);
                if (!h)
                    return !1;
                (u = d.get(e)) || (u = f.checkoutArray(),
                d.set(e, u));
                let p = u.length;
                if (Array.isArray(h))
                    for (let n of h)
                        this.getLogicIdx(n[l.h], u) < 0 && u.push(new this(e,n,!1,i));
                else
                    this.getLogicIdx(h[l.h], u) < 0 && u.push(new this(e,h,!1,i));
                if (s || p === u.length)
                    return !1;
                const g = u.slice(p);
                return this.addLogicInFlight(g, e, i),
                !0
            }
            static removeExtraFromStore(e, t, i) {
                if (!t)
                    return !1;
                let s, c;
                i ? (s = n,
                c = o.get(e)) : (s = r,
                c = a.get(e));
                const u = s.determineLogicId(t);
                if (!c || !u)
                    return !1;
                let l, d = !1;
                if (Array.isArray(u))
                    for (let n of u)
                        l = this.getLogicIdx(n, c),
                        l > -1 && s.callLogicRemoveReplace(c[l].validLogic) && (c.splice(l, 1),
                        d = !0);
                else
                    l = this.getLogicIdx(u, c),
                    l > -1 && s.callLogicRemoveReplace(c[l].validLogic) && (c.splice(l, 1),
                    d = !0);
                return d
            }
            static addExtraToStoreFromStore(e, t, n) {
                let r, i;
                const s = n ? o : a;
                if (i = s.get(t),
                !i || 0 === i.length)
                    return !1;
                let c, u;
                if (r = s.get(e),
                r || (r = f.checkoutArray(),
                s.set(e, r)),
                0 === r.length)
                    for (u of i)
                        r.push(new this(e,u.validLogic,!1,n));
                else
                    for (u of i)
                        c = u.validLogic,
                        this.getLogicIdx(c[l.h], r) < 0 && r.push(new this(e,c,!1,n));
                return !0
            }
            static addStoreToTrx(e, t) {
                const n = t.storeId;
                if (e.isMain)
                    return !(!(M = i.get(n)) || e.logicObservers.has(M[l.h])) && (e.addLogic(M),
                    (A = o.get(n)) && A.length > 0 && e.addLogic(A),
                    e.network.addParentToMainTrx(t, this),
                    !0);
                {
                    e.addLogic(s.get(n)),
                    (A = a.get(n)) && A.length > 0 && e.addLogic(A);
                    const r = t.value.type;
                    if ((I = c.get(n)) && (w = I[r]) && function(e, t, n) {
                        const r = e.length;
                        let i = 0;
                        for (; i < r; )
                            t._addDependency(n, e[i]),
                            i++,
                            n._addDependency(t, e[i]),
                            i++
                    }(w, e, t),
                    x = d.get(n),
                    x && x[r]) {
                        const n = x[r];
                        for (let r of n)
                            e._addDependency(t, r)
                    }
                    return this.addStoreToTrx(e.mainTrx, t.mainActionMeta),
                    !0
                }
            }
            __prepareOpMethod(e) {
                return !!(S = t.get(this.storeId)) && (this.isMain ? !(!(g = S.storeMgr.getChild(e.dispatchId)) || g.op === g.cancelOp || !(p = g.value)) : !!((b = S.pendingStoreMgr.getChild(e.mainDispatchId)) && (g = b.getChild(e.dispatchId)) && g.op !== g.cancelOp && (p = g.value)))
            }
            opMethod(e) {
                if (m = e.op,
                O = this.validLogic,
                y = O[m]) {
                    if (this.__prepareOpMethod(e))
                        return O[l.b] ? y.call(O[l.q] || O, p, ...O[l.b]) : y.call(O[l.q] || O, p)
                } else
                    this.isStateLogic && (v = um[m]) && this.__prepareOpMethod(e) && g.store.value[v](p);
                return null
            }
            errorOrCancelOpMethod(e) {
                return e instanceof cm.a ? e.value : e
            }
            isMatch(e) {
                return !!this.isMain || (this.isStateLogic ? t.get(this.storeId).pendingStoreMgr.getChild(e.mainDispatchId).getChild(e.dispatchId).value.type === kl.b : Object(je.h)(this.validLogic[l.a], t.get(this.storeId).pendingStoreMgr.getChild(e.mainDispatchId).getChild(e.dispatchId).value.type))
            }
        }
        const C = E.prototype;
        for (let l in um)
            C[l] = C.opMethod;
        return C[h.m] = C.errorOrCancelOpMethod,
        C[h.c] = C.errorOrCancelOpMethod,
        E
    }
    const dm = {
        writable: !1,
        configurable: !1,
        enumerable: !1
    }
      , hm = {
        type: Ng.a
    };
    function fm(e) {
        let t, n, r, i, o, s;
        const a = {}
          , c = Object(Cg.a)(null, a)
          , {objectPool: u, networks: m} = a;
        a.trxActionTypes = u.checkoutMap(),
        a.trxByDispatchId = u.checkoutMap(),
        a.dispatchIdsByMainDispatchId = u.checkoutMap(),
        a.pStoreMgrSetByMainDispatchId = u.checkoutMap(),
        a.mainTrxLogicMap = u.checkoutMap(),
        a.pendingTrxLogicMap = u.checkoutMap(),
        a.mainExtraTrxLogicMap = u.checkoutMap(),
        a.pendingExtraTrxLogicMap = u.checkoutMap(),
        a.trxActionsDepsMap = u.checkoutMap(),
        a.isolationDepsMap = u.checkoutMap(),
        a.trxChildrenMap = u.checkoutMap(),
        a.trxParentsMap = u.checkoutMap(),
        a.trxSiblingsMap = u.checkoutMap();
        const {mainTrxLogicMap: y, pendingTrxLogicMap: _, mainExtraTrxLogicMap: S, pendingExtraTrxLogicMap: O, trxActionsDepsMap: T, isolationDepsMap: I, trxActionTypes: x, trxByDispatchId: w, trxChildrenMap: M, trxParentsMap: A, trxSiblingsMap: E, dispatchIdsByMainDispatchId: C} = a;
        let N;
        a.init = e => {
            if (e) {
                ({mainStoreMgr: t, pendingStoreMgr: r, mainTrxMgr: n, pendingTrxMgr: i, stores: o, TrxLogic: s} = a);
                const e = [n.validateSingleLogic(p), n.validateSingleLogic(g)];
                n.addLogic(e),
                i.addLogic(e),
                a.init = void 0
            } else
                a.stores || (a.stores = u.checkoutMap()),
                a.TrxLogic || (a.TrxLogic = lm(a)),
                a.init(!0)
        }
        ;
        class R extends c {
            constructor(e, t, n) {
                if (e) {
                    const {meta: {mainDispatchId: r, dispatchId: i}} = e;
                    super(n ? r : i, t),
                    this.dispatchId = i,
                    this.mainDispatchId = r;
                    const o = x.get(e.type);
                    o ? (this.isTrx = !0,
                    this.isCommitOnly = o === Fl.a) : this.isTrx = !1
                } else
                    N || (N = a.BaseNetwork.prototype.createDispatchId),
                    super(N(), t),
                    this.dispatchId = void 0,
                    this.mainDispatchId = void 0,
                    this.isTrx = !1
            }
            getDispatchId(e) {
                return e.meta.dispatchId
            }
            isTrxActionType(e) {
                return x.has(e)
            }
            isTrxAction(e, t) {
                "object" === typeof e && (e = e.meta.dispatchId);
                const n = m.get(e);
                return !(!n || !n.isTrx) && (!t || n.isCommitOnly)
            }
            getNetwork(e) {
                return m.get(e)
            }
            getMainStoreMgrClone(n, r, i) {
                const o = t.clone(n, e);
                return o.setStore(i),
                o
            }
            getPendingStoreMgrClone(e, t, n) {
                const i = r.clone(e, t);
                return i.setStore(n),
                i
            }
            getChildStore(e, t) {
                if (!t)
                    return;
                const n = t.mainDispatchId
                  , r = (t = t.mainStore)._storeId;
                let i = o.get(r);
                if (i === t && (i = o.get(e))) {
                    let {_parentStoreId: e} = i;
                    for (; e; ) {
                        if (e === r) {
                            if (!n)
                                return i;
                            const e = i.pendingStoreMgr.getChild(n);
                            return e && e.store || i
                        }
                        ({_parentStoreId: e} = o.get(e))
                    }
                }
            }
            getStoreMainTrxPriority(e) {
                const t = o.get(e);
                return t ? t.mainTrxPriority : void 0
            }
            getStorePendingTrxPriority(e) {
                const t = o.get(e);
                return t ? t.pendingTrxPriority : void 0
            }
            getNetworkForMainStore(e) {
                return a.storeNetwork
            }
            registerStore(e, t, n, r) {
                let i = t.storeId;
                if (i) {
                    if (o.has(i))
                        throw new Error("The provided storeId, " + i + ", is already in use. Unable to register store.")
                } else
                    i = this.createStoreId();
                if (e._storeId = i,
                Object.defineProperty(e, "_storeId", dm),
                "undefined" === typeof r && "undefined" === typeof (r = t.parentStoreId) && n && (r = n.parentStoreId),
                r) {
                    const t = o.get(r);
                    t ? e.parentInstance = t.instance : r = void 0
                } else
                    r = void 0;
                e._parentStoreId = r,
                Object.defineProperty(e, "_parentStoreId", dm);
                const a = this.getNetworkForMainStore(e);
                let c, p, g;
                if (o.set(i, e),
                n) {
                    const r = (n = n.mainStore)._storeId;
                    if (!n || o.get(r) !== n)
                        throw new Error("Invalid fromStore provided. Either it is not valid, or it has already completed. It is not available on the network.");
                    s.registerStore(e, t, n),
                    p = n._isolationLevel,
                    g = I.get(r),
                    c = T.get(r)
                } else {
                    let r, i;
                    s.registerStore(e, t, n),
                    c = function(e, t) {
                        const n = e.pendingStoreMgr
                          , {logicArray: r} = n;
                        let i, o, s, a, c, u, d, f, p;
                        if (t)
                            for (o in t[kg] = Fl.b,
                            t[jg] = Fl.b,
                            i = {},
                            t)
                                switch (({[o]: s} = t),
                                s) {
                                case Fl.b:
                                    i[o] = Ug.checkout();
                                    break;
                                default:
                                    throw new Error("Invalid transaction type for action " + o + ". Expected " + Fl.b + " but got " + s)
                                }
                        else
                            i = {
                                [kg]: Ug.checkout(),
                                [jg]: Ug.checkout()
                            };
                        for (c of r)
                            ({[l.r]: a} = c),
                            a && Bg(c, a, i, e);
                        for (o in i) {
                            for (d of (({[o]: u} = i),
                            u[h.b] || (c = n.validateSingleLogic(v(o, !0)),
                            n.addLogic(c),
                            u[h.b] = c),
                            u[h.k] || (c = n.validateSingleLogic(b(o, !0)),
                            n.addLogic(c),
                            u[h.k] = c),
                            ({[l.r]: a} = u),
                            f = [],
                            f[l.r] = a,
                            p = Vg[a],
                            p))
                                ({[d]: c} = u),
                                c && (u[d] = void 0,
                                Qg(c, d, f));
                            qg[a].checkin(u),
                            i[o] = f
                        }
                        return i
                    }(e, t.trxActionTypes);
                    for (let e in c) {
                        if (r = c[e][l.r],
                        i = x.get(e),
                        i) {
                            if (i !== r)
                                throw new Error("The action type ".concat(e, " is already registered as a ").concat(i, " transaction type. It cannot also be registered as a ").concat(r, " transaction type."))
                        } else
                            x.set(e, r);
                        x.set(e, r)
                    }
                    g = void 0,
                    (p = t.isolationLevel) ? p.type === Ng.b && (g = function(e, t) {
                        let n, r, i, o, s, a, c, u, l, f, p;
                        for (let g in e)
                            if (!(t && t.indexOf(g) < 0)) {
                                for (n = e[g],
                                s = void 0,
                                a = void 0,
                                f = void 0,
                                p = void 0,
                                i = 0,
                                o = n.length; i < o && (r = n[i],
                                ({opsMap: u, otherLogic: c} = r),
                                u[h.k] && (s = u[h.k],
                                f = c),
                                u[h.d] && (a = u[h.d],
                                p = c),
                                !p || !f); i += 2)
                                    ;
                                if (void 0 !== f && void 0 !== p)
                                    l || (l = {}),
                                    l[g] = f === p ? [{
                                        logic: d.d,
                                        opsMap: {
                                            [h.k]: s,
                                            [h.d]: a
                                        },
                                        existingLogic: p
                                    }] : [{
                                        logic: d.d,
                                        opsMap: {
                                            [h.k]: s
                                        },
                                        existingLogic: f,
                                        asPeer: !0
                                    }, {
                                        logic: d.d,
                                        opsMap: {
                                            [h.d]: a
                                        },
                                        existingLogic: p
                                    }];
                                else if (g !== jg)
                                    throw new Error("Unable to establish isolation logic for action: " + g + ". Missing TRX_SYNC definition for TRX_PREPARE or TRX_EXECUTE (or both).")
                            }
                        return l
                    }(c, p.actions),
                    e.executeQueue = u.checkoutArray(),
                    e.optimisticExecuteQueue = u.checkoutArray(),
                    function(e, t) {
                        let n, r, i, o, s, a, c, u, p;
                        for (let g in t)
                            [n,r] = t[g],
                            r ? (({opsMap: {[h.k]: s}, existingLogic: i} = n),
                            ({opsMap: {[h.d]: a}, existingLogic: o} = r)) : (({opsMap: {[h.k]: s, [h.d]: a}, existingLogic: i} = n),
                            o = i),
                            c = i[l.m] - .001,
                            u = o[l.m] - .001,
                            p = {
                                [l.h]: d.a,
                                [l.j]: d.a,
                                [l.m]: c,
                                [l.n]: !0,
                                [l.a]: g,
                                [l.p]: im,
                                [s]: rm
                            },
                            e.addPendingLogic(p),
                            n && (n.otherLogic = p[l.h]),
                            p = {
                                [l.h]: d.b,
                                [l.j]: d.b,
                                [l.m]: u,
                                [l.n]: !1,
                                [l.a]: g,
                                [a]: om,
                                [f.a]: am
                            },
                            r && (r.otherLogic = p[l.h]),
                            e.addPendingLogic(p)
                    }(e, g),
                    function(e, t, n) {
                        let r = Object.keys(t);
                        1 === r.length && (r = r[0]);
                        const i = {
                            [l.h]: d.c,
                            [l.j]: d.c,
                            [h.e]: sm,
                            [l.m]: 999,
                            [l.n]: !0,
                            [l.a]: r,
                            isOptimistic: !1
                        };
                        n.addExtraToStore(e.storeId, i, !1)
                    }(e, g, s)) : p = hm
                }
                return e.isolationLevel = p,
                c && T.set(i, c),
                g && I.set(i, g),
                a
            }
            registerPendingStore(e) {
                const t = e.mainStore;
                if (t._parentStoreId && o.get(t._storeId) === t) {
                    let n = o.get(t._parentStoreId);
                    n ? (n = n.getPendingStore(e.mainDispatchId, !1, e),
                    e.parentInstance = n.instance) : e.parentInstance = void 0
                } else
                    e.parentInstance = void 0
            }
            storeClosed(e) {
                if (e.isMain) {
                    const t = e.storeId;
                    e.executeQueue && (u.checkinArray(e.executeQueue),
                    u.checkinArray(e.optimisticExecuteQueue),
                    e.executeQueue = void 0,
                    e.optimisticExecuteQueue = void 0),
                    T.delete(t),
                    I.delete(t);
                    let n = S.get(t);
                    n && (u.checkinArray(n),
                    S.delete(t)),
                    (n = O.get(t)) && (u.checkinArray(n),
                    O.delete(t)),
                    y.delete(t),
                    _.delete(t),
                    o.delete(t)
                }
            }
            getMainParentInstance(e) {
                return (e = e.mainStore)._parentStoreId && o.get(e._storeId) === e && (e = o.get(e._parentStoreId)) ? e.instance : void 0
            }
            addExtraTrxLogic(e, t, n) {
                return e = e.mainStore,
                o.get(e._storeId) === e && s.addExtraToStore(e._storeId, t, n)
            }
            removeExtraTrxLogic(e, t, n) {
                return e = e.mainStore,
                o.get(e._storeId) === e && s.removeExtraFromStore(e._storeId, t, n)
            }
            getMainDispatchId(e) {
                const t = m.get(e);
                return t ? t.mainDispatchId : void 0
            }
            createTs() {
                return Date.now()
            }
            get trxOp() {
                return this.isTrx ? w.get(this.dispatchId).op : void 0
            }
            get trxOpIdx() {
                return this.isTrx ? w.get(this.dispatchId).opIdx : void 0
            }
            get isPendingTrxOp() {
                return this.isTrx && this.parent ? w.get(this.dispatchId).isPendingOp : void 0
            }
            getTrxOpsStream(e) {
                const t = w.get(this.dispatchId);
                return t ? t.getTrxOpsStream(e) : void 0
            }
            addChildTrx(e) {
                if (!this.isTrx || !e || !this.parent)
                    return !1;
                const t = "number" === typeof e ? e : e.meta.dispatchId
                  , n = w.get(t);
                if (!n)
                    return !1;
                const r = this.dispatchId
                  , i = w.get(r);
                if (n.isMain && !i.isMain && C.get(t).has(r))
                    return !1;
                let o = M.get(r);
                if (o) {
                    if (o.has(t))
                        return !0
                } else
                    o = u.checkoutMap(),
                    M.set(r, o);
                let s = (this.isCommitOnly,
                Yg ? (Yg--,
                zg.pop()) : {
                    opsMap: $g
                });
                return i._addDependency(n, s),
                o.set(t, s),
                o = A.get(t),
                o || (o = u.checkoutMap(),
                A.set(t, o)),
                n.isCommitOnly,
                s = Kg ? (Kg--,
                Gg.pop()) : {
                    asPeer: !0,
                    opsMap: Xg
                },
                n._addDependency(i, s),
                o.set(r, s),
                !0
            }
            addParentTrx(e) {
                let t;
                t = e && "object" === typeof e ? e.meta.dispatchId : e;
                const n = m.get(t);
                return !!n && n.addChildTrx(this.dispatchId)
            }
            addSiblingTrx(e) {
                if (!this.isTrx || !e || !this.parent)
                    return !1;
                const t = "number" === typeof e ? e : e.meta.dispatchId
                  , n = w.get(t);
                if (!n)
                    return !1;
                let r = this.dispatchId;
                const i = w.get(r);
                let o = E.get(r);
                if (o) {
                    if (o.has(t))
                        return !0
                } else
                    o = u.checkoutMap(),
                    E.set(r, o);
                let s = tm(this.isCommitOnly);
                i._addDependency(n, s),
                o.set(t, s);
                let a = E.get(t);
                for ([r] of (a || (a = u.checkoutMap(),
                E.set(t, a)),
                s = tm(n.isCommitOnly),
                n._addDependency(i, s),
                a.set(r, s),
                a))
                    o.has(r) || o.set(r, !0);
                for ([r] of o)
                    a.has(r) || a.set(r, !0);
                return !0
            }
            isSiblingTrx(e, t) {
                const n = E.get("number" === typeof e ? e : e.meta.dispatchId);
                return !!n && (t ? "number" === typeof t ? n.has(t) : n.has(t.meta.dispatchId) : n.has(this.dispatchId))
            }
            forwardSerializeSiblings(e, t) {
                const n = E.get(this.dispatchId);
                if (!n)
                    return;
                let r, i = 1, o = e.length;
                for (; i < o; )
                    (r = t[i]) && n.has(e[i].meta.dispatchId) ? (e.splice(i, 1),
                    t.splice(i, 1),
                    o--,
                    r.next()) : i++
            }
            _checkinTrxDeps() {
                const e = this.dispatchId;
                this.isCommitOnly;
                let t, n;
                if (t = M.get(e)) {
                    for ([,n] of t)
                        Zg(0, n);
                    u.checkinMap(t),
                    M.delete(e)
                }
                if (t = A.get(e)) {
                    for ([,n] of t)
                        em(0, n);
                    u.checkinMap(t),
                    A.delete(e)
                }
                if (t = E.get(e)) {
                    for ([,n] of t)
                        !0 !== n && nm(0, n);
                    u.checkinMap(t),
                    E.delete(e)
                }
            }
        }
        return e ? "boolean" !== typeof e.isServer && (e.isServer = "undefined" === typeof window) : e = {
            isServer: "undefined" === typeof window
        },
        "function" !== typeof e.createDispatchId && (e.createDispatchId = !1 === e.createDispatchId ? Rg() : (Dg || (Dg = Rg()),
        Dg)),
        "function" !== typeof e.createStoreId && (e.createStoreId = !1 === e.createStoreId ? Pg() : (Fg || (Fg = Pg()),
        Fg)),
        R.prototype.createDispatchId = e.createDispatchId,
        R.prototype.createTempId = e.createTempId || oe.b,
        R.prototype.createStoreId = e.createStoreId,
        R.prototype.isServer = e.isServer,
        R.isServer = e.isServer,
        a.BaseNetwork = R,
        a
    }
    function pm(e) {
        const t = fm(e);
        return Eg(t),
        t.init(!1),
        t.storeNetwork
    }
    function gm(e) {
        const {pendingStore: t} = e.meta;
        return t && t.storeMgr.mainActionReady(),
        e
    }
    gm[l.d] = {
        [l.h]: "beginPendingActions",
        [l.j]: "beginPendingActions",
        [l.m]: -1e3,
        [l.a]: "*",
        [l.n]: !0,
        [l.k]: f.b
    };
    const mm = {
        maxCacheSize: void 0,
        network: void 0,
        pendingReducers: void 0,
        mainReducers: void 0,
        pendingLogic: void 0,
        mainLogic: void 0,
        pendingStoreMgr: void 0,
        mainStoreMgr: void 0,
        mainTrxLogic: void 0,
        pendingTrxLogic: void 0,
        isolationLevel: void 0,
        packageName: void 0,
        moduleName: void 0,
        storeName: void 0
    };
    function ym(e, t, n) {
        let r;
        return t ? r = e : e ? (r = {
            MainValue: Sg.a,
            PendingValue: Og.a,
            ...e
        },
        r.network || (r.network = pm())) : r = {
            MainValue: Sg.a,
            PendingValue: Og.a,
            network: pm()
        },
        new bm(r,t,void 0,n)
    }
    const vm = Object(Y.a)(e => e.store.instance);
    class bm extends js {
        constructor(e, t, n, r) {
            if (super(!1),
            this.activeTrxCount = 0,
            n) {
                this.mainStore = t,
                this.isMain = !1;
                const {meta: r} = n;
                this.mainDispatchId = r.mainDispatchId,
                this.stateHasOptimisticCommit = !1,
                this._initPending(e, r)
            } else
                this.value = void 0,
                this.mainStore = this,
                this.instance = void 0,
                this.parentInstance = void 0,
                this.stateLatestDispatchIdOptimistic = void 0,
                this.stateLatestDispatchIdCommit = void 0,
                this.stateLatestDispatchId = void 0,
                this._initMain(e, t, r)
        }
        _initMain(e, t, n) {
            let r, i, o, s;
            if (e)
                ({mainStoreMgr: r, pendingStoreMgr: i, pendingReducers: o, network: s} = e);
            else {
                if (!t)
                    throw new Error("Missing required options. Unable to initialize Store.");
                e = mm
            }
            this.pendingReducers = o,
            super._init(e, t, Sg.a),
            t ? (s || (s = t.network),
            r ? (r.addLogic(e.mainLogic),
            r.addLogic(t.storeMgr.logicArray)) : r = t.storeMgr.clone(e.mainLogic),
            r.setStore(this),
            i ? (i.addLogic(e.pendingLogic),
            i.addLogic(t.pendingStoreMgr.logicArray)) : i = t.pendingStoreMgr.clone(e.pendingLogic),
            i.setStore(this),
            this.PendingValue = e.PendingValue || t.PendingValue,
            t.pendingReducers && this.addPendingReducers(this.pendingReducers ? t.pendingReducers : [...t.pendingReducers]),
            this._storeName = e.storeName || t.storeName,
            this._packageName = e.packageName || t.packageName,
            this._moduleName = e.moduleName || t.moduleName,
            "undefined" === typeof e.savePendingChildByKey ? this.savePendingChildByKey = t.savePendingChildByKey : this.savePendingChildByKey = e.savePendingChildByKey,
            this.savePendingChildByKey && ("undefined" === typeof e.savePendingChildInstance ? this.savePendingChildInstance = t.savePendingChildInstance : this.savePendingChildInstance = e.savePendingChildInstance)) : (r ? r.addLogic(e.mainLogic) : r = s.getMainStoreMgrClone(e.mainLogic),
            r.setStore(this),
            r.addLogic(gm),
            i ? i.addLogic(e.pendingLogic) : i = s.getPendingStoreMgrClone(e.pendingLogic),
            i.setStore(this),
            this.PendingValue = e.PendingValue,
            this._storeName = e.storeName || void 0,
            this._packageName = e.packageName || void 0,
            this._moduleName = e.moduleName || void 0,
            this.savePendingChildByKey = e.savePendingChildByKey,
            this.savePendingChildByKey && (this.savePendingChildInstance = e.savePendingChildInstance)),
            r.setAsOuterManager(),
            this.storeMgr = r,
            this.pendingStoreMgr = i,
            this.network = s.registerStore(this, e, t, n)
        }
        _initPending(e, t) {
            const {mainStore: n} = this
              , {pendingStoreMgr: r, pendingReducers: i, PendingValue: o, instance: s} = n;
            let a, c;
            e && ({logic: a, reducers: c} = e);
            const u = r.createPendingStoreMgr(this, a, t);
            t.isStarted && !t.willEmitOp(f.g) && (u.canStart = !0),
            this.storeMgr = u,
            this.network = u.network,
            this.reducers = i,
            c && this.addReducers(c),
            this.history = [],
            this.value = o.init(this, e),
            this.instance = s ? s._registerPendingStore(this) : void 0,
            this.network.registerPendingStore(this)
        }
        setMainInstance(e) {
            const t = this.mainStore;
            t.instance = e;
            const n = t.pendingStoreMgr.children;
            if (n.size > 0) {
                let t;
                for (let[,r] of n)
                    t = r.store,
                    t.instance = e._registerPendingStore(t)
            }
        }
        get storeId() {
            return this.mainStore._storeId
        }
        get storeName() {
            return this.mainStore._storeName
        }
        set storeName(e) {
            this.mainStore._storeName = e
        }
        get moduleName() {
            return this.mainStore._moduleName
        }
        set moduleName(e) {
            this.mainStore._moduleName = e
        }
        get packageName() {
            return this.mainStore._packageName
        }
        set packageName(e) {
            this.mainStore._packageName = e
        }
        get parentStoreId() {
            return this.mainStore._parentStoreId
        }
        get mainInstance() {
            return this.mainStore.instance
        }
        get mainParentInstance() {
            return this.network.getMainParentInstance(this)
        }
        get mainTrxPriority() {
            return this.mainStore._mainTrxPriority
        }
        set mainTrxPriority(e) {
            this.mainStore === this && "undefined" === typeof this._mainTrxPriority && (this._mainTrxPriority = e)
        }
        get pendingTrxPriority() {
            return this.mainStore._pendingTrxPriority
        }
        set pendingTrxPriority(e) {
            this.mainStore === this && "undefined" === typeof this._pendingTrxPriority && (this._pendingTrxPriority = e)
        }
        get isolationLevel() {
            return this.mainStore._isolationLevel
        }
        set isolationLevel(e) {
            this.mainStore === this && "undefined" === typeof this._isolationLevel && (this._isolationLevel = e)
        }
        get savePendingChildByKey() {
            return this.mainStore._savePendingChildByKey
        }
        set savePendingChildByKey(e) {
            this.mainStore !== this || "undefined" !== typeof this._savePendingChildByKey || this.value && 0 !== this.value.size || (this._savePendingChildByKey = e)
        }
        get savePendingChildInstance() {
            return this.mainStore._savePendingChildInstance
        }
        set savePendingChildInstance(e) {
            this.mainStore !== this || "undefined" !== typeof this._savePendingChildInstance || this.value && 0 !== this.value.size || (this._savePendingChildInstance = !!e)
        }
        get allChanges() {
            return this.value.allChanges
        }
        updateStoreConfig(e, t) {
            const {mainStore: n} = this;
            return n.value.constructor.updateStoreConfig(n, e, t)
        }
        get storeConfig() {
            return this.mainStore._storeConfig
        }
        set storeConfig(e) {
            this.mainStore._storeConfig = e
        }
        createTempId() {
            return this.network.createTempId()
        }
        createDispatchId() {
            return this.network.createDispatchId()
        }
        getChildStore(e) {
            return this.network.getChildStore(e, this)
        }
        getAction(e, t) {
            if (this.closed)
                return;
            const n = this.network.getMainDispatchId(e);
            if (!n)
                return;
            let r;
            if (n === e || t)
                r = this.mainStore.storeMgr.getChild(n);
            else if (this.mainDispatchId === n)
                r = this.storeMgr.getChild(e);
            else {
                const t = this.mainStore.pendingStoreMgr.getChild(n);
                t && (r = t.getChild(e))
            }
            return r ? r.value : void 0
        }
        hasAction(e, t) {
            return !!this.getAction(e, t)
        }
        getActionByType(e, t, n) {
            if (this.closed)
                return;
            let r;
            if (t ? (r = this.network.getMainDispatchId(t),
            n && (t = r)) : (r = this.mainDispatchId,
            t = r),
            !r)
                return;
            const i = this.mainStore.pendingStoreMgr.getChild(r);
            if (!i || !i.children.size)
                return;
            const {children: o} = i;
            for (let[,s] of o)
                if (s.value.type === e && (t === r || s.dispatchId === t))
                    return s.value
        }
        getPendingStore(e, t, n) {
            if (!e)
                return;
            const r = this.mainStore;
            let i, o;
            if ("object" === typeof e ? (({meta: {mainDispatchId: o, pendingDispatchId: i}} = e),
            o = this.network.getMainDispatchId(o)) : (i = e,
            o = this.network.getMainDispatchId(i)),
            !o)
                return;
            let s = r.pendingStoreMgr.getChild(o);
            if (s)
                return n && s.store.value.registerChildStore(n),
                s.store;
            if (t)
                return;
            s = r.storeMgr.getChild(o);
            let a, c = !1;
            return s ? a = s.pendingStore : (o === i && (i = this.network.createDispatchId()),
            c = !0,
            s = r._mainDispatch(kl.a, {
                pendingChildStore: n
            }, o, i, !0, !1, !0).meta),
            a || (a = new r.constructor(void 0,r,s.value)),
            n && a.value.registerChildStore(n),
            c && s.subscribe(),
            a
        }
        getBestStore(e) {
            if (!e)
                return this.mainStore;
            const t = "number" === typeof e ? this.network.getMainDispatchId(e) : e.meta.mainDispatchId;
            if (this.mainDispatchId) {
                if (this.mainDispatchId === t)
                    return this;
                {
                    const e = this.mainStore.pendingStoreMgr.getChild(t);
                    return e ? e.store : this.mainStore
                }
            }
            {
                const e = this.pendingStoreMgr.getChild(t);
                return e ? e.store : this
            }
        }
        callPendingStoresMethod(e, t) {
            const {children: n} = this.mainStore.pendingStoreMgr;
            if (n.size > 0) {
                for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
                    i[o - 2] = arguments[o];
                if (t) {
                    const t = [];
                    for (let[,r] of n)
                        t.push(r.store[e](...i));
                    return t
                }
                for (let[,t] of n)
                    t.store[e](...i);
                return !0
            }
            return !1
        }
        callPendingStoresValueMethod(e, t) {
            const {children: n} = this.mainStore.pendingStoreMgr;
            if (n.size > 0) {
                for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
                    i[o - 2] = arguments[o];
                if (t) {
                    const t = [];
                    for (let[,r] of n)
                        t.push(r.store.value[e](...i));
                    return t
                }
                for (let[,t] of n)
                    t.store.value[e](...i);
                return !0
            }
            return !1
        }
        joinTrx(e, t, n) {
            const r = "object" !== typeof e ? e : e.meta.pendingDispatchId
              , i = this.network.getNetwork(r);
            if (!i || !i.isTrx || i.mainDispatchId === r)
                return;
            const o = this.mainStore;
            let s, a = o.pendingStoreMgr.getChild(i.mainDispatchId);
            return a && (s = a.store,
            a = s.storeMgr.getChild(r),
            a) ? a.value : (t = t ? !0 === t ? e.type : t : i.isCommitOnly ? kl.c : kl.d,
            n = n ? !0 === n ? e.payload : n : {},
            s ? s._pendingDispatch(t, n, i.mainDispatchId, r, !0) : o._mainDispatch(t, n, i.mainDispatchId, r, !1))
        }
        _pendingDispatch(e, t, n, r, i, o) {
            if (!i) {
                const i = this.storeMgr.getChild(r);
                if (i) {
                    if (o)
                        return this._pendingDispatch(e, t, n, this.network.createDispatchId(), !0);
                    if (i.value.type === e)
                        return this.instance ? console.warn("[STORE ".concat(this.storeName, "] -> _pendingDispatch() -> returning pAction (").concat(e, ") for instance with typename or pluginSlug ").concat(this.instance.__typename || this.instance.__pluginSlug)) : this.value.storeConfig || console.warn("[STORE ".concat(this.storeName, "] -> _pendingDispatch() -> returning pAction (").concat(e, ") - no instance & no storeConfig")),
                        i.value;
                    r = this.network.createDispatchId()
                }
            }
            const s = {
                type: e,
                payload: t,
                error: !1
            }
              , a = this.storeMgr.createManagerInner(s, r);
            return !!a && (s.meta = a,
            this.network.registerChildManager(a, s, !0),
            s)
        }
        _mainDispatch(e, t, n, r, i, o, s) {
            let a = i ? void 0 : this.storeMgr.getChild(n);
            if (a)
                return a.pendingStore ? a.pendingStore._pendingDispatch(e, t, n, r, !1, o) : (a._pendingDispatchId = r,
                new this.constructor(void 0,this,a.value)._pendingDispatch(e, t, n, r, !0, o));
            const c = {
                type: e,
                payload: t,
                error: !1
            };
            if (a = this.storeMgr.createManagerInner(c, n),
            a._pendingDispatchId = r,
            c.meta = a,
            this.network.registerChildManager(a, c, !0),
            s)
                return c;
            {
                const i = new this.constructor(void 0,this,c)._pendingDispatch(e, t, n, r, !0);
                return i || (c.type === kl.a ? c : (console.warn("[STORE ".concat(this.storeName, "] -> _mainDispatch() -> No pending logic for action type ").concat(c.type, ", cancelling main action...")),
                a.cancel(),
                !1))
            }
        }
        dispatchMain(e, t, n) {
            if (!this.isMain)
                return this.mainStore.dispatchMain(e, t, n);
            n || (n = this.network.createDispatchId());
            const r = {
                type: e,
                payload: t,
                error: !1
            }
              , i = this.storeMgr.createManagerInner(r, n);
            return i._pendingDispatchId = this.network.createDispatchId(),
            r.meta = i,
            this.network.registerChildManager(i, r, !0),
            r
        }
        dispatch(e, t, n, r) {
            if (this.closed || this.storeMgr.closed) {
                const t = "string" === typeof e ? e : e.type
                  , n = this.isMain ? this._storeName : "<unknown>";
                throw new Error("The Store ".concat(n, " is already closed. Unable to dispatch ").concat(t))
            }
            const {isMain: i, network: o} = this;
            let s, a, c, u = this.mainDispatchId, l = !1;
            if ("string" === typeof e)
                s = e,
                a = t,
                n && (c = n,
                u = o.getMainDispatchId(c),
                u || (u = this.mainDispatchId),
                "ifExists" === r && (l = !0,
                r = !1));
            else {
                let i;
                ({type: s, meta: i, payload: a} = e),
                c = t,
                !0 === n ? r = !0 : (l = "ifExists" === n,
                r = !1),
                c ? u = o.getMainDispatchId(c) : i && (({pendingDispatchId: c, mainDispatchId: u} = i),
                u !== o.getMainDispatchId(u) && (u = void 0))
            }
            return a || (a = {}),
            u ? (c && !r && c !== u || (c = o.createDispatchId()),
            i || u !== this.mainDispatchId ? this.mainStore._mainDispatch(s, a, u, c, !1, l) : this._pendingDispatch(s, a, u, c, !1, l)) : (u = o.createDispatchId(),
            c = !c || r ? o.createDispatchId() : c,
            this.mainStore._mainDispatch(s, a, u, c, !0))
        }
        broadcast(e, t) {
            let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
              , r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
            const i = this.mainStore
              , o = i.pendingStoreMgr.children
              , s = this.network;
            let a;
            if (o.size) {
                a = [];
                for (let[,r] of o)
                    r.mainActionMeta.network.isCompleting || a.push(r.store._pendingDispatch(e, n ? t : {
                        ...t
                    }, r.store.mainDispatchId, s.createDispatchId(), !0))
            }
            return r && (a || (a = []),
            a.push(i._mainDispatch(e, n ? t : {
                ...t
            }, s.createDispatchId(), s.createDispatchId(), !0))),
            a || null
        }
        replaceMainReducers(e) {
            return this.mainStore.replaceReducers(e)
        }
        replacePendingReducers(e, t, n) {
            const r = this.mainStore;
            if (e = e && e.length > 0 ? e : void 0,
            "boolean" !== typeof t && (t = !0),
            t && (r.pendingReducers = e),
            n) {
                const {pendingStoreMgr: t} = r
                  , {children: n} = t;
                for (let[,r] of n)
                    r.store.reducers = e
            }
            return !0
        }
        addMainReducers(e) {
            return !!e && this._addReducers.call(this.mainStore, e, "reducers")
        }
        addPendingReducers(e, t, n) {
            if (!e)
                return !1;
            const r = this.mainStore;
            "boolean" !== typeof t && (t = !0);
            let i = !1;
            if (t && (i = r._addReducers(e, "pendingReducers")),
            n) {
                const {pendingStoreMgr: t} = r
                  , {children: n} = t;
                for (let[,r] of n)
                    r.store.addReducers(e, !0, i) && (i = !0)
            }
            return i
        }
        removeMainReducers(e) {
            return this._removeReducers.call(this.mainStore, e, "reducers")
        }
        removePendingReducers(e, t, n) {
            const r = this.mainStore;
            "boolean" !== typeof t && (t = !0);
            let i = !1;
            if (t && (i = r._removeReducers(e, "pendingReducers")),
            n) {
                const {pendingStoreMgr: t} = r
                  , {children: n} = t;
                for (let[,r] of n)
                    r.store.removeReducers(e, !0, i) && (i = !0)
            }
            return i
        }
        addMainLogic(e, t, n) {
            return this.mainStore.storeMgr.addLogic(e, t, n)
        }
        addPendingLogic(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
              , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return this.mainStore.pendingStoreMgr.addLogic(e, t, n)
        }
        addLogic(e, t, n) {
            return this.storeMgr.addLogic(e, t, n)
        }
        removeMainLogic(e, t, n) {
            return this.mainStore.storeMgr.removeLogic(e, t, n)
        }
        removePendingLogic(e, t, n) {
            return this.mainStore.pendingStoreMgr.removeLogic(e, t, n)
        }
        removeLogic(e, t, n) {
            return this.storeMgr.removeLogic(e, t, n)
        }
        replaceMainLogic(e, t, n, r) {
            return this.mainStore.storeMgr.replaceLogic(e, t, n, r)
        }
        replacePendingLogic(e, t, n, r) {
            return this.mainStore.pendingStoreMgr.replaceLogic(e, t, n, r)
        }
        replaceLogic(e, t, n, r) {
            return this.storeMgr.replaceLogic(e, t, n, r)
        }
        addOrReplaceMainLogic(e, t, n) {
            return this.mainStore.storeMgr.addOrReplaceLogic(e, t, n)
        }
        addOrReplacePendingLogic(e, t, n) {
            return this.mainStore.pendingStoreMgr.addOrReplaceLogic(e, t, n)
        }
        addOrReplaceLogic(e, t, n) {
            return this.storeMgr.addOrReplaceLogic(e, t, n)
        }
        addMainExtraTrxLogic(e) {
            return this.network.addExtraTrxLogic(this, e, !0)
        }
        removeMainExtraTrxLogic(e) {
            return this.network.removeExtraTrxLogic(this, e, !0)
        }
        addPendingExtraTrxLogic(e) {
            return this.network.addExtraTrxLogic(this, e, !1)
        }
        removePendingExtraTrxLogic(e) {
            return this.network.removeExtraTrxLogic(this, e, !1)
        }
        addMainToMainDependency(e, t, n, r) {
            return t && t.actionType && "undefined" === typeof t.depFilter && (t.depFilter = Jt.a),
            this.mainStore.storeMgr.addDependency(e.mainStore.storeMgr, t, n, r)
        }
        addPendingToPendingDependency(e, t) {
            let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
              , r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            return t && t.actionType && "undefined" === typeof t.depFilter && (t.depFilter = Jt.a),
            this.mainStore.pendingStoreMgr.addDependency(e.mainStore.pendingStoreMgr, t, n, r)
        }
        addMainToPendingDependency(e, t, n, r) {
            return t && t.actionType && "undefined" === typeof t.depFilter && (t.depFilter = Jt.a),
            this.mainStore.storeMgr.addDependency(e.mainStore.pendingStoreMgr, t, n, r)
        }
        addPendingToMainDependency(e, t, n, r) {
            return t && t.actionType && "undefined" === typeof t.depFilter && (t.depFilter = Jt.a),
            this.mainStore.pendingStoreMgr.addDependency(e.mainStore.storeMgr, t, n, r)
        }
        addDependency(e, t, n, r) {
            return t && t.actionType && "undefined" === typeof t.depFilter && (t.depFilter = Jt.a),
            this.storeMgr.addDependency(e.storeMgr, t, n, r)
        }
        next(e) {
            if (this.value = e,
            !this.isMain) {
                const t = this.mainStore._allPending$;
                t && t.next(e)
            }
            super.next(this.value)
        }
        complete() {
            if (!this.closed) {
                if (this.storeMgr && !this.storeMgr.closed)
                    return void this.storeMgr.complete();
                super.complete()
            }
        }
        subscribeToInstance(e, t) {
            if (this._instance$ || (this._instance$ = this.pipe(Object(Or.a)(this.instance), Object(_g.a)())),
            "boolean" === typeof e && (t = e,
            e = void 0),
            t && !this.isMain) {
                if (!this._instancePersist$) {
                    const {mainStore: e} = this;
                    this._instancePersist$ = new S.a(t => {
                        let n;
                        return n = this.closed ? e.subscribeToInstance(t) : this._instance$.subscribe({
                            next: e => t.next(e),
                            error: e => t.error(e),
                            complete: () => {
                                e.closed ? t.complete() : (t.next(e.instance),
                                n = e.subscribeToInstance(t))
                            }
                        }),
                        () => n.unsubscribe()
                    }
                    ).pipe(Object(_g.a)())
                }
                return e ? this._instancePersist$.subscribe(e) : this._instancePersist$
            }
            return e ? this._instance$.subscribe(e) : this._instance$
        }
        subscribeToAllPending(e) {
            if (!this.isMain)
                return this.subscribeToAllPending(e);
            let t = this._allPending$;
            return t || (t = new U.a,
            this._allPending$ = t),
            e ? t.asObservable().subscribe(e) : t.asObservable()
        }
        subscribeToAllPendingInstances(e) {
            if (!this.isMain)
                return this.subscribeToAllPendingInstances(e);
            let t = this._allPendingInstances$;
            if (!t) {
                const e = this.subscribeToAllPending();
                this._allPendingInstances$ = t = e.pipe(vm, Object(_g.a)())
            }
            return e ? t.subscribe(e) : t
        }
        subscribeAndPersist(e) {
            if (this.isMain)
                return e ? this.subscribe(e) : this.asObservable();
            {
                const {mainStore: t} = this
                  , n = new S.a(e => {
                    let n;
                    return n = this.closed ? t.subscribe(e) : this.subscribe({
                        next: t => e.next(t),
                        error: t => e.error(t),
                        complete: () => {
                            t.closed ? e.complete() : (e.next(t.value),
                            n = t.subscribe(e))
                        }
                    }),
                    () => n.unsubscribe()
                }
                );
                return e ? n.subscribe(e) : n
            }
        }
        emitComplete() {
            this.closed || (super.emitComplete(),
            this._instance$ = void 0,
            this._instancePersist$ = void 0,
            this._allPending$ = void 0,
            this._allPendingInstances$ = void 0)
        }
        unsubscribe() {
            if (this.closed)
                return;
            const {storeMgr: e} = this;
            if (e.closed) {
                if (this.isMain) {
                    const e = this._allPending$;
                    e && (e.complete(),
                    this._allPending$ = void 0,
                    this._allPendingInstances$ && (this._allPendingInstances$ = void 0)),
                    this._instancePersist$ && (this._instancePersist$ = void 0),
                    this.pendingStoreMgr.complete(),
                    this.pendingStoreMgr = void 0,
                    this.PendingValue = void 0,
                    super.unsubscribe()
                } else
                    super.unsubscribe();
                this.instance && (this._instance$ && (this._instance$ = void 0),
                this.instance._storeClosed(this),
                this.instance = void 0),
                this.network.storeClosed(this),
                this.parentInstance = void 0,
                this.storeMgr = void 0,
                this.mainStore = void 0,
                this.network = void 0
            } else
                e.complete()
        }
    }
    function _m(e) {
        class t extends e {
            static init(e, t) {
                const n = super.init(e, t);
                return n.storeConfig = e.storeConfig,
                n
            }
        }
        return Object(L.a)(t, Sm),
        t
    }
    Object(he.z)(bm, he.r.STORE);
    const Sm = {
        createChild: function(e) {
            const t = this.store.mainStore.pendingStoreMgr.children;
            let n;
            return t.size > 1 && (n = zl(e, t, this.store.mainDispatchId)) && (n = n.mainStore) || (n = ym(void 0, this.storeConfig.childStore, this.store.storeId),
            n.value.keyValue = e,
            n.storeName = "".concat(this.store.storeName, ":childStore"),
            n.value.cacheComplete = this.storeConfig.notExists[e] || !1),
            n
        },
        createIndexKeyValues: function(e, t) {
            const {storeConfig: {fieldNames: n}} = this
              , r = n.length;
            let i = void 0;
            if (1 === r)
                return i = e[n[0]],
                Array.isArray(i) ? i : [i];
            let o, s, a = 0, c = 0, u = 0;
            if (t) {
                let t, l, d;
                for (; a < r; ) {
                    if (o = n[a],
                    s = e[o],
                    0 === a)
                        i = Array.isArray(s) ? [...s] : [s],
                        c = i.length;
                    else if (Array.isArray(s))
                        for (u = c - 1,
                        l = s.length,
                        c *= l,
                        d = c - 1; u >= 0; ) {
                            for (t of s)
                                i[d] = "".concat(i[u]).concat(In.a).concat(t),
                                d--;
                            u--
                        }
                    else
                        for (u = 0; u < c; )
                            i[u] += "".concat(In.a).concat(s),
                            u++;
                    a++
                }
            } else
                for (; a < r; ) {
                    if (o = n[a],
                    s = e[o],
                    0 === a)
                        i = [...s],
                        c = i.length;
                    else {
                        if (s.length !== c)
                            throw new Error("Invariant: createIndexKeyValues method expects\n              one-to-one values for each key unless the combinations argument\n              is true. But the values for key ".concat(o, " does not contain\n              the same number of values as the values provided for ").concat(n[0], ". \n              If this was intentional, pass true for the 3rd argument to create\n              all possible combinations of the provided keyValuesMap. In that case, \n              each key in the keyValuesMap can independently be a single value\n              or an array of values."));
                        for (u = 0; u < c; )
                            i[u] += "".concat(In.a).concat(s[u]),
                            u++
                    }
                    a++
                }
            return i
        },
        getIndexKeyValue: function(e, t, n) {
            return this.storeConfig.getIndexKeyValue(e, t, n)
        },
        getIndexKeyValueOfRecord: function(e, t) {
            if (t && !(e = e.getPrevState()))
                return;
            const n = this.storeConfig.fieldNames;
            let r = n.length
              , i = e[n[0]];
            if (r > 1) {
                let t = 1;
                for (; t < r; )
                    i += "".concat(In.a).concat(e[n[t]]),
                    t++
            }
            return i
        },
        getKeyBy: function(e) {
            return null === e ? this.storeConfig.primaryKey : this.storeConfig.keyBy
        },
        getKeyByValue: function(e, t) {
            return null === e ? t[this.storeConfig.primaryKey] : t[this.storeConfig.keyBy]
        },
        markCacheCompleteFromQueryArg: function(e, t, n, r) {
            const i = this.storeConfig
              , o = i.notExists;
            if (i.unique)
                for (let s of e)
                    this.has(s) || (o[s] = !0);
            else {
                let t;
                for (let n of e)
                    (t = this.get(n)) ? t.value.cacheComplete = !0 : o[n] = !0
            }
            return !r && (r = i.VF) ? r.markCacheCompleteFromQueryArg(e, t, n) : n
        }
    }
      , Om = {
        processingDispatchId: !0,
        includesIndexValues: !0,
        ownModel: !0,
        ownRefModel: !0,
        ownModelVFIndex: !0,
        ownRefModelVFIndex: !0,
        parentQueryIndex: !0,
        parentQueryIndexValue: !0
    }
      , Tm = _m(Sg.a)
      , Im = _m(Og.a)
      , xm = {
        _updatePkChangesConfig: function(e, t, n, r, i, o, s) {
            const a = this.store;
            s || (s = "pkChangesSubscription");
            const c = a.storeConfig
              , u = c[s]
              , l = c[i]
              , d = c[o];
            return !u || l !== e && !0 !== e ? (u && u.unsubscribe(),
            e && (e = e.getMainInstance(),
            "undefined" === typeof t ? t = d || r : t || (t = r),
            c[s] = e.subscribeToPkChanges(new bg(a,t,n,s))),
            c[i] = e,
            c[o] = t,
            !0) : !(!e || d === t) && ("undefined" === typeof t ? t = d || r : t || (t = r),
            u.method = t,
            c[o] = t,
            !0)
        },
        updateCompoundPkChangesConfig: function(e, t, n, r) {
            if ("number" !== typeof e)
                throw new Error("The idx of the field in the storeConfig.fieldNames Array whose config is being updated is required for compound indexes. Got: " + e);
            if (t && !n) {
                const t = this.store.storeConfig;
                if (n = t["pkChangesMethod_" + e]) {
                    const n = t["pkChangesSubscription_" + e];
                    n && n.thisArg instanceof Mf && (n.thisArg.unique = t.unique)
                } else
                    n = (r = new Mf(t,e)).changePkValues
            }
            return this._updatePkChangesConfig(t, n, r, void 0, "pkChangesModel_" + e, "pkChangesMethod_" + e, "pkChangesSubscription_" + e)
        },
        updateCompoundChildPkChangesConfig: function(e, t, n) {
            return this._updatePkChangesConfig(e, t, n, Af, "childPkChangesModel", "childPkChangesMethod", "childPkChangesSubscription")
        },
        updatePkChangesConfig: function(e, t, n) {
            return this._updatePkChangesConfig(e, t, n, xf, "pkChangesModel", "pkChangesMethod", "pkChangesSubscription")
        },
        updateChildPkChangesConfig: function(e, t, n) {
            return this._updatePkChangesConfig(e, t, n, Cf, "childPkChangesModel", "childPkChangesMethod", "childPkChangesSubscription")
        },
        updateUniqueNullPkChangesConfig: function(e, t, n) {
            if (!t) {
                this.store.storeConfig.childPkChangesMethod === Cf && (t = Ef)
            }
            return this._updatePkChangesConfig(e, t, n, Ef, "childPkChangesModel", "childPkChangesMethod", "childPkChangesSubscription")
        },
        ensureCorrectPkChanges: function() {
            const e = this.storeConfig
              , {fieldNames: t, model: n} = e
              , r = t.length;
            if (1 === r)
                this.updatePkChangesConfig(n.getPkChangesModel(t[0])),
                e.unique ? e.model.fields[t[0]].notNullable ? e.childPkChangesModel && this.updateChildPkChangesConfig(null, null) : this.updateUniqueNullPkChangesConfig(n.getPkChangesModel(e.keyBy)) : this.updateChildPkChangesConfig(n.getPkChangesModel(e.keyBy));
            else {
                let i;
                for (let o = 0; o < r; o++)
                    (i = n.getPkChangesModel(t[o])) ? this.updateCompoundPkChangesConfig(o, i) : e["pkChangesModel_" + o] && this.updateCompoundPkChangesConfig(o, null);
                !e.unique && n.pkCanChange ? this.updateCompoundChildPkChangesConfig(n) : e.childPkChangesModel && this.updateCompoundChildPkChangesConfig(null, null)
            }
            this.ensureCorrectPatchPkChanges()
        },
        ensureCorrectPatchPkChanges: function() {
            const e = this.storeConfig
              , t = e.patchType;
            if (!t)
                return;
            if (t !== vg)
                return;
            const n = e.model;
            !e.patchPkChangesSubscription && n.pkCanChange && (e.patchPkChangesSubscription = n.subscribeToPkChanges(new bg(this.store,wf,void 0,"patchPkChangesSubscription")))
        }
    };
    function wm(e) {
        class t extends e {
            static updateStoreConfig(e, t, n, r) {
                const i = e.storeConfig;
                if ("string" !== typeof t)
                    return super.updateStoreConfig(e, t, n);
                switch (t) {
                case "unique":
                    throw new Error("An Index's `unique` property cannot be updated. Remove this index and create a new one.");
                case "keyBy":
                    throw new Error("Updating the index's `keyBy` property is not supported. Remove this index and re-add it.");
                case "childStore":
                    return !!i.childStore && i.childStore.updateStoreConfig(n);
                case "includeNull":
                    throw new Error("Updating whether the index includes `null` values or not is not supported at this time. Remove the index and re-add it.");
                case "trigger":
                    return function(e, t) {
                        return mg(e, "trigger", t)
                    }(e, n);
                case "keyByTrigger":
                    return function(e, t) {
                        return mg(e, "keyByTrigger", t)
                    }(e, n);
                case "throughModelTrigger":
                    return function(e, t) {
                        return mg(e, "throughModelTrigger", t)
                    }(e, n);
                case "fieldNames":
                case "name":
                    return !1;
                default:
                    return super.updateStoreConfig(e, t, n)
                }
            }
            complete() {
                const e = this.store;
                if (!e)
                    return void super.complete();
                const t = e.storeConfig;
                if (this.size) {
                    const e = this.getState();
                    if (t.unique)
                        t.includeNull && e.null && e.null.complete();
                    else
                        for (const t in e)
                            e[t].complete()
                }
                const n = t.fieldNames;
                if (n.length > 1) {
                    let e, r = 0;
                    for (; r < n.length; )
                        (e = t["pkChangesSubscription_" + r]) && e.unsubscribe(),
                        r++
                } else
                    t.pkChangesSubscription && t.pkChangesSubscription.unsubscribe();
                t.patchPkChangesSubscription && t.patchPkChangesSubscription.unsubscribe(),
                t.childPkChangesSubscription && t.childPkChangesSubscription.unsubscribe(),
                t.childStore && t.childStore.complete();
                const r = t.childStoresToComplete;
                if (r && r.size) {
                    for (const e of r)
                        e.complete();
                    r.clear()
                }
                for (let i in t)
                    t[i] = void 0;
                super.complete()
            }
        }
        return t.blacklistPropsCommitPendingState ? t.blacklistPropsCommitPendingState = {
            ...t.blacklistPropsCommitPendingState,
            ...Om
        } : t.blacklistPropsCommitPendingState = {
            ...Om
        },
        t.blacklistPropsCloneNew ? t.blacklistPropsCloneNew = {
            ...t.blacklistPropsCloneNew,
            patch: !0
        } : t.blacklistPropsCloneNew = {
            patch: !0
        },
        Object(L.a)(t, xm),
        t
    }
    const Mm = wm(Tm)
      , Am = (e, t, n, r) => {
        if ("undefined" === typeof e)
            return !1;
        if (null === e || !n.pChanges || !n.pChanges[e])
            return !0;
        if (!n.pState[e])
            return !r;
        const i = n.storeConfig;
        if (i.unique) {
            const r = n.pState[e][i.primaryKey];
            return !r || r === t[i.primaryKey]
        }
        if (i.keyBy === i.primaryKey)
            return !0;
        if (!(n = n.pState[e].value).pChanges)
            return !0;
        if (e = t[i.keyBy],
        !n.pChanges[e])
            return !0;
        if (n.pChanges[e] === ws.a.DELETED)
            return !r;
        const o = n.pState[e][i.primaryKey];
        return !o || o === t[i.primaryKey]
    }
    ;
    function Em(e, t) {
        const n = e.getState()
          , r = this.storeConfig.getIndexKeyValue(n);
        Am(r, n, this, !1) && this.setKeyValue(r, e, t, n)
    }
    const Cm = {
        recordCreate: Em,
        recordUpdate: Em,
        recordFieldUpdate: function(e, t, n, r, i) {
            const o = e.getState()
              , s = this.storeConfig.getIndexKeyValue(o, t, n);
            Am(s, o, this, !0) && this.deleteKeyValue(s, o, i),
            this.setKeyValue(this.storeConfig.getIndexKeyValue(o, t, r), e, i, o)
        },
        recordKeyByUpdate: function(e, t, n, r) {
            const i = e.getState()
              , o = this.storeConfig.getIndexKeyValue(i);
            if ("undefined" === typeof o)
                return !1;
            let s = this.getMutableChild(o, r, !0);
            return !!s && (s = s.value,
            s.pChanges && s.pChanges[t] && (s.pChanges[t] === ws.a.DELETED || s.pState[t][r.primaryKey] !== i[r.primaryKey]) || s.delete(t),
            s.set(n, e),
            s)
        },
        recordDelete: function(e, t) {
            const n = this.storeConfig.getIndexKeyValue(e);
            Am(n, e, this, !0) && this.deleteKeyValue(n, e, t)
        }
    }
      , {STALE: Nm} = dg.a
      , Rm = (e, t) => {
        e.changesToCommit || (e.changesToCommit = {}),
        e.changesToCommit[t] = Nm
    }
    ;
    function Pm(e) {
        class t extends e {
        }
        return Object(L.a)(t, Dm),
        Object(L.a)(t, Cm),
        t
    }
    const Dm = {
        deleteKeyValue: function(e, t, n) {
            if ("undefined" === typeof e)
                return !1;
            if (null !== e && this.storeConfig.unique)
                return this.delete(e);
            {
                const r = this.getMutableChild(e, n, !0);
                return !!r && (r.value.delete(this.getKeyByValue(e, t)),
                r.value)
            }
        },
        dispatchChild: function(e, t) {
            const n = t.dispatchIndexChild(e).meta;
            return n.subscribe(),
            n.store
        },
        getMutableChild: function(e, t, n) {
            let r = this.get(e);
            return r ? r.value ? r.isMain ? this.dispatchChild(r, t) : (this.pChanges && this.pChanges[e] || (r = this.dispatchChild(r, t),
            this.set(e, r)),
            r) : ( (e, t, n, r) => {
                const i = e.get(t).isMain ? null : e.store.mainStore.get(t);
                return i && i.value ? e.dispatchChild(i, n) : r ? null : e.dispatchChild(e.createChild(t), n)
            }
            )(this, e, t, n) : n ? null : this.dispatchChild(this.createChild(e), t)
        },
        registerChildStore: function(e) {
            const t = e.value.keyValue;
            "undefined" !== typeof t && this.set(t, e)
        },
        setKeyValue: function(e, t, n, r) {
            if ("undefined" === typeof e)
                return !1;
            if (null !== e && this.storeConfig.unique)
                return this.set(e, t),
                !0;
            {
                r || (r = t);
                const i = this.getMutableChild(e, n).value;
                return i.set(this.getKeyByValue(e, r), t),
                i
            }
        },
        updateCompoundPkChangesConfig: function(e, t, n, r) {
            return this.store.mainStore.value.updateCompoundPkChangesConfig(e, t, n, r)
        },
        updateKeyValue: function(e, t, n, r, i, o, s) {
            if (!s)
                return e !== n && this.deleteKeyValue(e, t, i),
                this.setKeyValue(n, r, i, o);
            const a = this.storeConfig
              , c = a.fieldNames;
            let u, l = !1;
            for (let d of c)
                if (s[d] === Nm) {
                    l = !0;
                    break
                }
            if (e !== n && "undefined" !== typeof e) {
                if (null !== e && a.unique)
                    this.delete(e);
                else if (u = this.getMutableChild(e, i, !0)) {
                    u = u.value;
                    const n = this.getKeyBy(e);
                    u.delete(t[n]),
                    (l || s[n] === Nm) && Rm(u, t[n])
                }
                l && Rm(this, e)
            }
            if ("undefined" !== typeof n) {
                if (l && Rm(this, n),
                null !== n && a.unique)
                    return this.set(n, r);
                {
                    o || (o = r),
                    u = this.getMutableChild(n, i).value;
                    const a = this.getKeyBy(n);
                    return u.set(o[a], r),
                    (l || s[a] === Nm) && Rm(u, o[a]),
                    e === n && t[a] !== o[a] && (u.delete(t[a]),
                    (l || s[a] === Nm) && Rm(u, t[a])),
                    u
                }
            }
        },
        updatePkChangesConfig: function(e, t) {
            return this.store.mainStore.value.updatePkChangesConfig(e, t)
        },
        updateChildPkChangesConfig: function(e, t) {
            return this.store.mainStore.value.updateChildPkChangesConfig(e, t)
        }
    }
      , Fm = Pm(Im);
    function km(e) {
        const {state: t, changes: n} = e;
        let r;
        for (let i in n)
            (r = t[i]) && (t[i] = Object(he.C)(r));
        return e
    }
    function jm(e) {
        return e ? (e.indexOf(km) < 0 && e.push(km),
        e) : [km]
    }
    var Lm = n(41);
    const Vm = Tm;
    const Um = {
        cacheComplete: {
            get() {
                if (this.storeConfig.query)
                    return !1;
                if (this.store.mainStore.value.cacheComplete)
                    return !0;
                if (null === this.keyValue)
                    return !1;
                const e = this.storeConfig.VF;
                if (e && !e.isManyToMany && e.ownModelCacheMissingFieldName) {
                    const t = e.ownRefModelVF.getIndex(this.store.mainDispatchId).get(this.keyValue);
                    if (t && !1 === t[e.ownModelCacheMissingFieldName])
                        return this.cacheComplete = !0,
                        !0
                }
                return !1
            },
            set(e) {
                this.store.mainStore.value.cacheComplete = e
            },
            enumerable: !1
        }
    }
      , qm = function(e) {
        class t extends e {
        }
        const n = e.blacklistPropsCloneMainState ? {
            ...e.blacklistPropsCloneMainState
        } : {};
        return n.cacheComplete = !0,
        t.blacklistPropsCloneMainState = n,
        Object.defineProperties(t.prototype, Um),
        t
    }(Im)
      , Qm = (e, t, n) => {
        let r, i, o;
        return n ? (r = "pendingTrxPriority",
        i = t.pendingTrxPriority,
        o = e.pendingTrxPriority) : (r = "mainTrxPriority",
        i = t.mainTrxPriority,
        o = e.mainTrxPriority),
        "Invalid child ".concat(r, ". The parent Store has a priority of ").concat(i, ", and the child must have a priority that is offset by ").concat(Lm.b, " from that. Got: ").concat(o)
    }
    ;
    class Bm {
        constructor(e, t) {
            this.setPriority(e),
            this.setThisArg(t)
        }
        static init(e, t) {
            return new this(e,t)
        }
        setThisArg(e) {
            return this.thisArg = e || this,
            this
        }
        setPriority(e) {
            return this.priority = "number" === typeof e ? e : Lm.c,
            this
        }
        setFieldNames(e, t) {
            return t ? (this["".concat(e, "FieldNames")] = t,
            this) : (this.fieldNames = e,
            this)
        }
        on(e, t, n) {
            return this[e] = t,
            n && (this["".concat(e, "FieldNames")] = n),
            this
        }
        destroy() {
            this.thisArg = void 0
        }
    }
    class Gm extends Bm {
        constructor(e, t) {
            super(e, t),
            this.fieldNames = t.fieldNames
        }
    }
    Gm.prototype.afterFieldUpdate = function(e, t, n, r, i, o) {
        i.getMutableIndex(this.name).value.recordFieldUpdate(e, t, n, r, i)
    }
    ,
    Gm.prototype.create = function(e, t, n, r, i, o) {
        i.getMutableIndex(this.name).value.recordCreate(r, i)
    }
    ,
    Gm.prototype.update = function(e, t, n, r, i, o) {
        i.getMutableIndex(this.name).value.recordUpdate(r, i)
    }
    ,
    Gm.prototype.afterDelete = function(e, t, n, r, i, o) {
        i.getMutableIndex(this.name).value.recordDelete(n, i)
    }
    ;
    class zm extends Bm {
        constructor(e, t) {
            super(e, t),
            this.fieldNames = t.keyBy
        }
        afterFieldUpdate(e, t, n, r, i, o) {
            i.getMutableIndex(this.name).value.recordKeyByUpdate(e, n, r, i)
        }
    }
    function Hm(e) {
        const t = e.storeConfig;
        let n = t.trigger;
        null === n || n || (n = new Gm(e.pendingTrxPriority,t),
        t.trigger = n),
        n && t.model.triggers.add(n),
        !(n = t.keyByTrigger) && null !== n && t.keyBy !== t.primaryKey && t.fieldNames.indexOf(t.keyBy) < 0 && (n = new zm(e.pendingTrxPriority,t),
        t.keyByTrigger = n),
        n && t.model.triggers.add(n)
    }
    "opBegin__".concat(c.s),
    "opComplete__".concat(c.s);
    const Km = "hydrateIndex__".concat(c.a)
      , Ym = "addTriggers__".concat(c.a)
      , Wm = "removeTriggers__".concat(c.q)
      , $m = "closeState__".concat(c.q);
    var Xm = n(876);
    const Jm = Xm.b.initModule("@isomorix/model/indexStore/trxLogic");
    let Zm, ey, ty;
    {
        const e = {};
        Zm = e,
        ey = e,
        ty = e
    }
    const {DELETED: ny} = ws.a;
    function ry(e) {
        return e.payload.isMain && Hm(e.meta.store),
        e
    }
    function iy(e) {
        const {payload: t} = e;
        if (0 === t.recordsSize && 0 === t.changesSize)
            return e;
        const n = e.meta.store.storeConfig
          , r = t.mutation
          , {records: i} = t
          , o = r.getMutableIndex(n.name).value;
        let s;
        if (t.isMain)
            for (let a in i)
                s = i[a].getState(),
                o.setKeyValue(n.getIndexKeyValue(s), i[a], r, s);
        else {
            const {mainRecords: e, changes: a} = t;
            let c, u, l, d, h;
            for (let t in a) {
                if ((c = e[t]) ? (h = c.getState(),
                d = n.getIndexKeyValue(h)) : (h = void 0,
                d = void 0),
                a[t] !== ny)
                    c = i[t],
                    s = c.getState(),
                    u = n.getIndexKeyValue(s),
                    l = c.__changesToCommit;
                else {
                    if (!h)
                        continue;
                    s = void 0,
                    u = void 0,
                    l = void 0
                }
                o.updateKeyValue(d, h, u, c, r, s, l)
            }
        }
        return e
    }
    ry[l.d] = {
        [l.h]: Ym,
        [l.j]: "addTriggers",
        [l.n]: !0,
        [l.a]: c.a,
        [l.k]: h.k,
        [h.k]: ry,
        [l.m]: Lm.c,
        [l.l]: Jm.packageName,
        [l.i]: "".concat(Jm.moduleName, "/addIndex"),
        [l.e]: Zm.addTriggers
    },
    Jm.add(ry[l.d]),
    iy[l.d] = {
        [l.h]: Km,
        [l.j]: "hydrateIndex",
        [l.n]: !0,
        [l.a]: c.a,
        [l.k]: h.h,
        [h.h]: iy,
        [l.m]: Lm.c,
        [l.l]: Jm.packageName,
        [l.i]: "".concat(Jm.moduleName, "/addIndex"),
        [l.e]: Zm.hydrateIndex
    },
    Jm.add(iy[l.d]);
    const {STALE: oy, CREATED: sy} = ws.a
      , ay = ["trigger", "keyByTrigger"];
    function cy(e) {
        const t = e.meta.store.storeConfig
          , n = t.model.triggers;
        let r;
        for (let i of ay)
            (r = t[i]) && (n.remove(r),
            "function" === typeof r.destroy && r.destroy(),
            t[i] = null);
        return e
    }
    function uy(e) {
        const t = e.meta.store.mainStore
          , n = t.pendingStoreMgr.children
          , r = t.getState()
          , i = t.storeConfig;
        let o, s, a, c;
        if (i.unique) {
            let {includeNull: e} = i;
            e && (c = r.null) && Object(he.X)(c) && (c.complete(),
            e = !1);
            for (let[,t] of n)
                o = t.store.value,
                e && (c = o.get("null")) && Object(he.X)(c) && (c.complete(),
                e = !1),
                o.pChanges = null,
                o.pState = null,
                o.allChanges = null,
                o.changesToCommit = null
        } else {
            let e, t;
            for (let[,i] of n) {
                if (o = i.store.value,
                ({changesToCommit: e, pChanges: t} = o),
                e) {
                    for (s in e)
                        switch (a = e[s],
                        a) {
                        case oy:
                        case sy:
                            (c = o.get(s)) && !r[s] && c.mainStore.complete()
                        }
                    o.changesToCommit = null
                }
                if (t) {
                    for (s in t)
                        t[s] === sy && (c = o.get(s)) && c.mainStore.complete();
                    o.pChanges = null,
                    o.pState = null
                }
                o.allChanges = null
            }
            for (s in r)
                (c = r[s]) && c.complete();
            i.childStoresToComplete.clear(),
            i.childStoresToComplete = void 0
        }
        return t.complete(),
        e
    }
    cy[l.d] = {
        [l.h]: Wm,
        [l.j]: "removeTriggers",
        [l.n]: !0,
        [l.a]: c.q,
        [l.k]: h.k,
        [h.k]: cy,
        [l.m]: Lm.c,
        [l.l]: Jm.packageName,
        [l.i]: "".concat(Jm.moduleName, "/removeIndex"),
        [l.e]: ty.removeTriggers
    },
    Jm.add(cy[l.d]),
    uy[l.d] = {
        [l.h]: $m,
        [l.j]: "closeState",
        [l.n]: !0,
        [l.a]: c.q,
        [l.k]: h.h,
        [h.h]: uy,
        [l.m]: Lm.c,
        [l.l]: Jm.packageName,
        [l.i]: "".concat(Jm.moduleName, "/removeIndex"),
        [l.e]: ty.closeState
    },
    Jm.add(uy[l.d]);
    const {DELETED: ly} = ws.a;
    function dy() {
        return this[h.f] = null,
        this[h.a] = null,
        !0
    }
    const hy = {
        [l.h]: "manageEmptyChildStores__ANY",
        [l.j]: "manageEmptyChildStores__ANY",
        [l.n]: !0,
        [l.m]: Lm.c + Lm.b / 2,
        [l.o]: dy,
        [l.p]: dy,
        [l.l]: Jm.packageName,
        [l.i]: "".concat(Jm.moduleName, "/childStores"),
        [l.e]: ey.manageEmptyChildStores__ANY
    };
    class fy extends O.a {
        constructor(e) {
            super(),
            this.__stores = e
        }
        _complete() {
            const e = this.__stores;
            super._complete();
            for (let t of e)
                t.complete()
        }
        unsubscribe() {
            super.unsubscribe(),
            this.__stores = void 0
        }
    }
    function py(e) {
        const t = e.meta.pendingStore.value
          , n = t.storeConfig.childStoresToComplete;
        if (!n)
            return e;
        const {allChanges: r} = t;
        if (r) {
            const e = t.state;
            let i;
            for (let t in r)
                "null" !== t && (i = e[t]) && 0 === i.value.size && n.add(i.mainStore)
        }
        let i = e.meta.store.pendingStoreMgr.children;
        const o = e.meta.dispatchId;
        if (n.size && 1 === i.size && i.has(o)) {
            let r, s = t.changesToCommit;
            for (let a of n)
                0 === a.value.size ? (i = a.pendingStoreMgr.children,
                (0 === i.size || 1 === i.size && i.has(o)) && (s ? s[a.value.keyValue] = ly : (s = {
                    [a.value.keyValue]: ly
                },
                t.changesToCommit = s),
                n.delete(a),
                r ? r.push(a) : (r = [a],
                e.meta.subscribe(new fy(r))))) : n.delete(a)
        }
    }
    function gy(e) {
        const t = e.meta.store.value
          , n = t.pChanges;
        if (!n)
            return e;
        const {UPDATED: r} = ws.a
          , i = t.pState
          , o = t.storeConfig.isIncludeQuery;
        let s;
        for (let a in n)
            "null" !== a && n[a] === r && (s = i[a]) && 0 === s.value.pSize && (s.mainStore.complete(),
            o ? t.set(a, null) : t.delete(a));
        return e
    }
    py[l.d] = {
        ...hy,
        [l.k]: h.a,
        [h.a]: py,
        [l.a]: "*"
    },
    gy[l.d] = {
        ...hy,
        [l.k]: [h.f, h.a],
        [h.f]: py,
        [h.a]: py,
        [l.a]: c.n
    };
    const my = Xm.a.initModule("@isomorix/model/indexStore/logic");
    my.add(Vl),
    my.add(Ul),
    my.add(Ql);
    function yy(e, t) {
        if (!e)
            throw new Error("Options are required in order to create an indexStore. Got: ".concat(e));
        const n = e.storeConfig
          , r = t.value.indexesStore
          , i = t.mainStore.instance
          , o = t.storeConfig;
        if (!n || !n.fieldNames || !n.name) {
            let e = "modelName: ".concat(i.modelName, ", ");
            throw n ? n.name ? e += "index name: ".concat(n.name, ", no fields provided") : (e += "no name provided, ",
            e += n.fieldNames ? "fieldNames: [ ".concat(n.fieldNames.join(", "), " ]") : "and no field names either") : e += "no storeConfig Object provided",
            new Error("The `storeConfig` Object is required when creating an index (`storeOptions.storeConfig`), and at a minimum it must define the `fieldNames` and `name` properties on this Object. Unable to create index store (".concat(e, ")."))
        }
        if (r.value.has(n.name))
            throw new Error('Unable to create index: The index "'.concat(n.name, '" already exists on the Model "').concat(i.modelName, '". The name must be unique.'));
        const s = n.query;
        e.MainValue || (e.MainValue = Mm),
        e.mainReducers = jm(e.mainReducers),
        e.PendingValue || (e.PendingValue = s ? void 0 : Fm),
        Gl(e, Lm.c),
        "undefined" === typeof e.parentStoreId && (e.parentStoreId = r.storeId),
        "undefined" === typeof e.network && (e.network = r.network),
        e.pendingLogic ? e.pendingLogic.push(...my) : e.pendingLogic = my,
        e.storeName = "".concat(i.__typename, ":").concat(n.name),
        jl(e, !0),
        n.model = i,
        n.primaryKey = o.primaryKey,
        n.notExists = {};
        const a = !0 === n.unique
          , c = 1 === n.fieldNames.length;
        n.unique = a,
        "string" === typeof n.keyBy && !a && c || (n.keyBy = n.primaryKey),
        "function" !== typeof n.getIndexKeyValue && (n.getIndexKeyValue = c ? pg : gg),
        ("boolean" !== typeof n.includeNull || n.includeNull && !function(e) {
            const t = e.storeConfig
              , n = t.fieldNames;
            return !(n.length > 1) && !t.model.fields[n[0]].notNullable
        }(e)) && (n.includeNull = !1),
        s || function(e) {
            const {storeConfig: t} = e;
            t.query = null,
            t.RecordResult = null,
            t.queryPayload = null,
            t.parentQueryIndex = null,
            t.isM2M = !!t.VF && t.VF.isManyToMany,
            t.includesIndexes = null,
            t.parentVFArgsPath = null,
            t.patchType = null
        }(e),
        function(e) {
            let t = e.pendingExtraTrxLogic;
            if (e.pendingTrxPriority === Lm.c)
                return t ? t.push(...Jm) : e.pendingExtraTrxLogic = [...Jm],
                e;
            t || (t = [],
            e.pendingExtraTrxLogic = t);
            const n = e.pendingTrxPriority;
            for (let r of Jm)
                t.push({
                    ...r,
                    [l.m]: n
                })
        }(e),
        a || (n.childStoresToComplete = new Set,
        function(e) {
            let t, n, r;
            e.storeConfig.isIncludeQuery ? (t = "pendingExtraTrxLogic",
            n = gy,
            r = e.pendingTrxPriority) : (t = "mainExtraTrxLogic",
            n = py,
            r = e.mainTrxPriority),
            n = {
                ...n[l.d],
                [l.m]: r + Lm.b / 2
            },
            e[t] ? e[t].push(n) : e[t] = [n]
        }(e));
        const u = ym(e);
        if (a && !n.includeNull || function(e, t) {
            const n = t.mainTrxPriority + Lm.b
              , r = t.pendingTrxPriority + Lm.b;
            if (e) {
                if (e.MainValue || (e.MainValue = Vm),
                e.PendingValue || (e.PendingValue = qm),
                e.mainReducers = jm(e.mainReducers),
                Gl(e, n, r),
                e.mainTrxPriority > n)
                    throw new Error(Qm(e, t, !1));
                if (e.pendingTrxPriority > r)
                    throw new Error(Qm(e, t, !0));
                e.pendingLogic ? e.pendingLogic.push(Ul) : e.pendingLogic = [Ul]
            } else
                e = {
                    mainTrxPriority: n,
                    MainValue: Vm,
                    mainReducers: jm(),
                    pendingTrxPriority: r,
                    PendingValue: qm,
                    pendingLogic: [Ul]
                };
            const {storeConfig: i} = t;
            e.storeConfig = i,
            e.parentStoreId = t.storeId,
            e.network = t.mainStore.network,
            e.storeName = "".concat(t.storeName, ":childStoreTemplate"),
            jl(e);
            const o = ym(e);
            i.childStore = o
        }(n.childStore, u),
        u.value.ensureCorrectPkChanges(),
        o.QueryConstraints.updateConstraintIndexes(u),
        t.value.mutation)
            t.value.mutation.getMutableIndexesStore().value.set(n.name, u);
        else {
            Hm(u);
            const e = r.value;
            e.state[n.name] = u,
            e.size++
        }
        return u
    }
    const {DELETED: vy} = ws.a
      , by = (e, t, n) => {
        const r = e.mutation.getMutableIndexesStore().value;
        let i = r.store.dispatch(c.a, e, t).meta;
        e.isMain && (i.store.value.isHydrateMainState = !0),
        t = i.dispatchId,
        n.push(i.asObservable());
        const {indexes: o} = e;
        let s;
        for (let a of o)
            i = a.dispatch(c.a, e, t).meta,
            s = i.store,
            r.set(s.storeConfig.name, s),
            n.push(i.asObservable());
        return t
    }
    ;
    function _y(e) {
        return this.dispatchIndexesStore().getMutableIndex(e)
    }
    function Sy(e) {
        return this.indexesStore ? this.indexesStore.get(e) : this.model.getIndex(e)
    }
    function Oy(e) {
        const t = this.controller;
        return e.dispatch(t.actionType, t.indexPayload, t.dispatchId)
    }
    function Ty() {
        return this.indexesStore || this.dispatchIndexesStore() && this.indexesStore
    }
    function Iy() {
        return this.indexesStore || this.model.getIndexesStore(this.mainDispatchId, !0)
    }
    function xy(e) {
        let {indexesToRemove: t} = this;
        if (Array.isArray(e))
            if (t)
                for (let n = 0; n < e.length; n++)
                    t.push(e[n].mainStore);
            else
                this.indexesToRemove = e.map(e => e.mainStore),
                this.controller.hasIndexesToRemove = !0;
        else
            t ? t.push(e.mainStore) : (this.indexesToRemove = [e.mainStore],
            this.controller.hasIndexesToRemove = !0);
        return this
    }
    function wy(e) {
        e ? this.indexesToRemove = null : this.indexesToAdd = null
    }
    function My() {
        return this.controller.sendToConnector(this)
    }
    let Ay = function(e, t) {
        if (!this.action)
            return e;
        let n;
        for (let r of Yu)
            (n = this[r]) && (e = n.sendToConnector(e));
        return e
    }
      , Ey = Qs.a;
    function Cy(e, t, n, r, i, o, s) {
        if (!(e = r.addRecord(e, t, n, !0, o, !1, null, !!i)) || !i)
            return e;
        const a = e.__ID;
        let c = i[a];
        if (null === c)
            return e;
        if (t) {
            c || (c = {
                ...n
            },
            i[a] = c);
            const t = r.mutation.fields
              , o = e.getState()
              , {activeRecord: s} = r.mutation.controller;
            let u;
            for (let e in n)
                t[e] && (c[e] = o[e],
                s && (u || (u = {})) && (u[e] = o[e]));
            u && r.mutation.controller.addToActiveRecord(e, u)
        } else {
            if (c)
                for (let e in n)
                    c[e] = n[e];
            else
                i[a] = s ? {
                    ...n
                } : n;
            r.mutation.controller.addToActiveRecord(e, n)
        }
        return e
    }
    function Ny(e, t, n, r, i) {
        if (i) {
            const t = e.__ID;
            t && (i[t] = null),
            r.mutation.controller.addToActiveRecord(e, null)
        }
        return r.addRecord(e, !0, null, !!i)
    }
    function Ry(e) {
        return e || this.isCommitOnly ? this.triggerData : this.triggerData || (this.triggerData = {}) && this.triggerData
    }
    function Py(e, t, n, r, i) {
        return r || (this.willCommitTriggerData = !0),
        n ? Cy(e, t, n, this.getMutationType(Gr.c), r ? null : this.getTriggerData(), i) : Ny(e, 0, 0, this.getMutationType(Gr.b), r ? null : this.getTriggerData())
    }
    function Dy(e, t, n, r, i) {
        let o, s, a, c = null;
        n ? (o = Cy,
        s = this.getMutationType(Gr.c)) : (o = Ny,
        s = this.getMutationType(Gr.b)),
        r || (this.willCommitTriggerData = !0,
        c = this.getTriggerData());
        for (let u in e) {
            if (a = o(e[u], t, n, s, c, null, !0),
            void 0 === a)
                return;
            i || (e[u] = a)
        }
        return e
    }
    function Fy(e) {
        return this.controller.undoable(e),
        this
    }
    function ky(e) {
        return this.controller.undo(e, this)
    }
    function jy(e) {
        if (!this.action && null !== this.action)
            return;
        const t = e.getModelMutation(this.model)
          , {isLocalOnly: n} = e
          , {recordDataType: r, records: i, prevRecordState: o} = this
          , s = t.recordDataType;
        let a, c, u, l;
        if (!n) {
            const e = {};
            let n;
            for (let i of Yu)
                (n = this[i]) && n.undo(t, e);
            const {triggerData: r} = this;
            if (r) {
                let n, s, u, l, d;
                for (let h in r)
                    if (!e[h])
                        if (n = r[h]) {
                            for (u in c || (c = t.getMutationType(Gr.c)),
                            s = c.addRecord(i[h], null, o[h], !0),
                            l = s.getState(),
                            d = {},
                            n)
                                void 0 !== typeof n[u] && (d || (d = {}),
                                d[u] = l[u]);
                            d && c.addRecord(i[h], null, d, !1)
                        } else
                            null === n && (a || (a = t.getMutationType(Gr.a)),
                            a.addRecord(o[h], !1))
            }
        }
        for (let d in r)
            if (n || !s[d])
                switch (l = r[d],
                l) {
                case Gr.a:
                    u || (u = t.getMutationType(Gr.b)),
                    u.addRecord(i[d], !0);
                    break;
                case Gr.c:
                    c || (c = t.getMutationType(Gr.c)),
                    c.addRecord(i[d], null, o[d], !0);
                    break;
                case Gr.b:
                    a || (a = t.getMutationType(Gr.a)),
                    a.addRecord(o[d], !0)
                }
        return t
    }
    function Ly(e, t, n) {
        let r;
        return "boolean" === typeof t ? r = !0 === e ? this.model.createCacheMissingFieldsObject(t) : this.model.createCacheMissingFieldsObject(e, t) : (r = e,
        n = t),
        n ? this.getMutationType(Gr.c).forArrayAddRecord(n, null, r, !0) : this.getMutationType(Gr.c).forObjectAddRecord(this.records, null, r, !0, null, !0),
        this
    }
    const Vy = Object.hasOwnProperty;
    function Uy(e, t, n) {
        const r = 'Unsupported update provided for model "'.concat(e.ownModelName, '". It is not possible to simultaneously update the field "').concat(e.ownFieldName, '" (which relates records on this model with records on the "').concat(e.ownRefModelName, '" model) while also attempting to update the related records on the "').concat(e.ownRefModelName, '" model via the "').concat(e.VFName, '" virtual field key. This is an ambiguous update request because it cannot be known if the desire is to update the current record(s) on the other model, or the new one(s) once the "').concat(e.ownFieldName, '" field is updated. Only update one or the other per mutation operation.');
        return nl(e.ownFieldName, r, t, n)
    }
    function qy(e, t, n, r, i, o, s) {
        Vy.call(t, this.primaryKey) && (t = function(e, t) {
            let n;
            return ({["".concat(e)]: n, ...t} = t),
            t
        }(this.primaryKey, t),
        i && (i[r.VFName] = t));
        const {userRole: a} = this;
        let c;
        if (n) {
            const e = this.model.schema;
            if (!e.permUpdate(a, n, t))
                throw new Error("".concat(this.modelName, ": Permission Denied."));
            r && e.permRecUpdate && (c = ol(i),
            c[r.VFName] || (c[r.VFName] = null))
        }
        const {fields: u, virtualFields: l} = this
          , d = e ? this.model.dataTypesValidator : null;
        let h, f, p = null;
        for (let g in t)
            if (h = u[g]) {
                if (n && !h.permUpdate(a, n, t))
                    throw new Error("".concat(this.modelName, ".").concat(g, ": Permission Denied."));
                o = u[g].validate(t, o, s),
                e && e[g] && (o = cl(e[g], t[g], g, d, o, s))
            } else
                (f = l[g]) && (o = Vy.call(t, f.ownFieldName) ? Uy(f, o, s) : this.switchTo(f.ownRefModel).validateUpdateData(e ? e[g] : null, t[g], n, f, t, o, s ? "".concat(s, ".").concat(g) : g),
                p || (p = rl(t)),
                p[g] = f);
        return n && r && (c = function(e) {
            return e[Xu]
        }(t)) && (ol(i)[r.VFName] = c),
        r ? o : o ? void this.errorRecordState(o, Gr.c) : t
    }
    function Qy(e) {
        let t, n = !1;
        for (let r of Yu)
            (t = this[r]) && t.fetchMissingRecords(e) && (n = !0);
        return n
    }
    function By(e, t) {
        const n = t.prototype;
        var r;
        !function(e, t) {
            const n = e.storesMap;
            t._rollbackExternalChanges = Qs.a,
            t._doCancel = function() {
                this.isCancelling = !0;
                const {CREATED: e} = ws.a;
                let t, r;
                if (this.action) {
                    t = n.get(this.model);
                    const {recordsToComplete: i} = t.storeConfig;
                    try {
                        const {payload: e} = t.getAction(this.dispatchId);
                        e.isCancelling = !0,
                        e.recordPayload.isCancelling = !0
                    } catch (a) {}
                    t = t.value,
                    t.mutation = void 0,
                    ({pChanges: r} = t);
                    const {recordDataType: o, records: s} = this;
                    for (let a in o)
                        t = n.get(s[a]),
                        o[a] === Gr.a && r && r[a] === e && i.set(a, t.mainStore),
                        t = t.value,
                        t.mutation = void 0,
                        t.mutationType = void 0
                }
                const {indexStores: i} = this;
                if (!i)
                    return;
                let o, s;
                for (let n in i)
                    if (t = i[n].value,
                    r = t.pChanges)
                        if (t.storeConfig.unique)
                            r.null === e && t.pState.null && t.pState.null.mainStore.complete();
                        else
                            for (s in ({pState: o} = t),
                            r)
                                r[s] === e && o[s] && o[s].mainStore.complete()
            }
            ,
            t.cancel = $f,
            t._doCancelComplete = Xf
        }(e, n),
        np(e, n, t),
        function(e, t) {
            const n = e.storesMap;
            t.mainTrxComplete = function() {
                const {records: e} = this;
                let t, r;
                for (let i in e)
                    (t = e[i]) && (e[i] = n.get(t).mainStore.instance);
                if (this.model = this.model.getMainInstance(),
                this.action && (this.action = null,
                this.dispatchRecord = void 0),
                this.userRole = void 0,
                this.cascadesByRecord && (rp(this.cascadesByRecord),
                this.cascadesByRecord = void 0),
                this._mutationLocalIndex && (this._mutationLocalIndex = void 0,
                this._mutationIndex = void 0),
                this.invalidRecords && (this.invalidRecords = void 0),
                this.indexesStore) {
                    this.indexesStore = this.indexesStore.mainStore;
                    const {indexStores: e} = this;
                    if (e)
                        for (let t in e)
                            e[t] = e[t].mainStore;
                    this.getMutableIndex = void 0
                }
                for (let n of Yu)
                    (r = this[n]) && r.mainTrxComplete()
            }
            ,
            t._doComplete = lp,
            t._doOptimisticComplete = sp,
            t._doConnectorComplete = cp,
            t.ofComplete = up,
            t.ofConnectorComplete = ap,
            t.optimisticComplete = op,
            t.ofOptimisticComplete = ip
        }(e, n),
        (r = n).create = Sp,
        r.createOne = _p,
        r._createVFNested = bp,
        r.update = Tp,
        r._updateVFNested = Op,
        r.getMutableRecord = wp,
        r.delete = xp,
        r._deleteVFNested = Ip,
        function(e, t) {
            const n = e.storesMap;
            t.dispatchModel = function() {
                if (this.action)
                    return this;
                const {primaryKey: e} = this
                  , t = this.controller;
                t.modelActionCount++;
                const {actionType: r, dispatchId: i} = t
                  , o = {
                    mutation: this,
                    isServer: this.isServer,
                    isCancelling: !1
                }
                  , s = {
                    mutation: this,
                    recordActions: {},
                    isCancelling: !1,
                    recordPayload: o,
                    public: o,
                    isServer: o.isServer,
                    autoStartRecordActions: !1
                };
                this.action = this.model.dispatch(r, s, i, !1),
                this.model = this.action.meta.instance;
                const a = n.get(this.model);
                a.value.mutation = this,
                n.get(a.parentInstance).value.set(this.modelName, this.model),
                this.isInPluginChanges = !0;
                const c = a.storeConfig.triggers;
                let u;
                return this.dispatchRecord = function(t, l) {
                    let d = n.get(t);
                    const h = d.dispatch(r, o, i);
                    d = h.meta.store,
                    t = d.instance,
                    d = d.value,
                    u = d.get(e),
                    s.recordActions[u] = h;
                    const f = a.value.get(u);
                    if (a.value.set(u, t),
                    this.isInPluginChanges || (this.isInPluginChanges = !0,
                    n.get(a.parentInstance).value.set(this.modelName, this.model)),
                    f && f !== t && c.update) {
                        const e = c.call(c.update, "update", this.model, u, f, t, this, this.isLocalOnly);
                        if (e)
                            return void this.error(e)
                    }
                    return l !== Gr.a && this.records[u] ? l === Gr.b && (this.recordDataType[u] = Gr.b) : (this.records[u] = t,
                    this.recordDataType[u] = l,
                    this.prevRecordState[u] = d.state,
                    d.mutation = this),
                    d.mutationType = this.recordDataType[u],
                    s.autoStartRecordActions && Ep.a.schedule(Np, 0, h),
                    t
                }
                ,
                this.action.meta.subscribe(),
                this
            }
            ,
            t.ensurePendingChanges = function(e, t) {
                if (this.isOptimisticComplete)
                    if (this._ensurePendingChanges)
                        this._ensurePendingChanges(e, t);
                    else {
                        const r = n.get(this.model);
                        this.isInPluginChanges || (this.isInPluginChanges = !0,
                        n.get(r.parentInstance).value.set(this.modelName, this.model)),
                        this._ensurePendingChanges = (e, t) => {
                            r.value.pChanges[e] || r.value.set(e, t)
                        }
                        ,
                        r.value.pChanges && r.value.pChanges[e] || r.value.set(e, t)
                    }
            }
            ,
            t.getRecordPayload = function(e, t) {
                const r = n.get(this.model).getAction(this.dispatchId);
                if (!r)
                    return null;
                if (!e)
                    return r.payload.recordPayload;
                const i = n.get(e).getAction(this.dispatchId);
                if (!i)
                    return null;
                let o = i.payload;
                return t && r.payload.recordPayload === o && (o = {
                    ...o
                },
                i.payload = o),
                o
            }
            ,
            t.setRecordPayload = function(e, t) {
                const r = n.get(this.model).getAction(this.dispatchId);
                if (!r)
                    return null;
                const i = n.get(e).getAction(this.dispatchId);
                if (!i)
                    return null;
                let o = i.payload;
                if (r.payload.recordPayload === o) {
                    for (let e in o)
                        Cp.call(t, e) || (t[e] = o[e]);
                    return i.payload = t,
                    t
                }
                for (let n in t)
                    o[n] = t[n];
                return o
            }
        }(e, n),
        function(e, t) {
            const n = e.storesMap
              , r = e.getModelStoreConfig;
            t.watchUpdateVFDataForPkChanges = function(e) {
                const {pkChangesModels: t} = r(this.model);
                for (let n in e)
                    if (t[n]) {
                        this._updateVFDataForPkChanges || (this._updateVFDataForPkChanges = []),
                        this._updateVFDataForPkChanges.push(e);
                        break
                    }
                return this
            }
            ,
            t.mapPkChanges = function(e, t) {
                const r = t === this.primaryKey;
                let i;
                for (let n of Ku)
                    (i = this[zu[n]]) && i.mapPkChanges(e, t, r);
                if (this._updateVFDataForPkChanges) {
                    const {_updateVFDataForPkChanges: n} = this;
                    let r;
                    for (let i of n)
                        (r = i[t]) && e[r] && (i[t] = e[r])
                }
                const o = this.managedData
                  , s = this.triggerData;
                if (r && bf(this.recordDataType, e)) {
                    if (this.recordDataType = ff(this.recordDataType, e),
                    this.records = ff(this.records, e),
                    this.prevRecordState = pf(this.prevRecordState, e, t, !0),
                    this.action) {
                        let t = n.get(this.model).getAction(this.dispatchId);
                        t && (t = t.payload,
                        t.recordActions = ff(t.recordActions, e))
                    }
                    if (s && bf(s, e) && (this.triggerData = ff(s, e)),
                    o && bf(o, e)) {
                        this.managedData = pf(o, e, t, !0);
                        const n = this.managedGroups;
                        if (n) {
                            let i, o;
                            for (let[,s] of n) {
                                for (i = 0,
                                o = s.length; i < o; )
                                    e[s[i]] && (s[i] = e[s[i]]),
                                    i++;
                                s.managedPayload && Uf(e, t, r, s.managedPayload)
                            }
                        }
                    }
                } else {
                    const n = this.prevRecordState;
                    let r, i;
                    for (let o in n)
                        r = n[o],
                        (i = e[r[t]]) && (r[t] = i);
                    o && ag(o, e, t),
                    s && ag(s, e, t)
                }
            }
        }(e, n),
        function(e, t) {
            t.permDenied = ug,
            t.setPermCheck = cg
        }(0, n),
        function(e, t) {
            const n = e.storesMap;
            function r(e) {
                let t;
                try {
                    t = yy(e, n.get(this.model))
                } catch (r) {
                    return void this.error(r)
                }
                return this.indexesToAdd ? this.indexesToAdd.push(t) : (this.indexesToAdd = [t],
                this.controller.hasIndexesToAdd = !0),
                t
            }
            t.createIndex = r,
            t.dispatchIndexesStore = function() {
                const e = this.controller
                  , t = n.get(this.model).getBestStore(this.mainDispatchId)
                  , r = t.value.indexesStore.dispatch(e.actionType, e.indexPayload, e.dispatchId).meta
                  , i = r.store;
                t.mainDispatchId && (t.value.indexesStore = i);
                const o = {};
                return this.indexesStore = i,
                this.indexStores = o,
                this.getMutableIndex = function(e) {
                    return o[e] || ( (e, t, n) => {
                        const r = t.controller
                          , i = t.indexesStore.get(e).dispatch(r.actionType, r.indexPayload, r.dispatchId).meta;
                        return n[e] = i.store,
                        i.subscribe(),
                        n[e]
                    }
                    )(e, this, o)
                }
                ,
                r.subscribe(),
                this
            }
            ,
            t._processIndexesToRemove = function(e, t) {
                const r = this.getMutableIndexesStore()
                  , i = {
                    indexes: this.indexesToRemove,
                    mutation: this,
                    isMain: !0
                }
                  , o = n.get(this.model).storeConfig
                  , {mutationIndexName: s, mutationLocalIndexName: a, QueryConstraints: u} = o;
                let l = r.dispatch(c.q, i, e).meta;
                const d = l.store.value;
                t.push(l.asObservable());
                const {indexes: h} = i;
                let f, p;
                for (let n of h)
                    l = n.dispatch(c.q, i, e).meta,
                    f = l.store.storeConfig.name,
                    d.delete(f),
                    t.push(l.asObservable()),
                    f !== s && f !== a || (p = !0),
                    u.remove(f);
                p && u.recalculateConstraintIndexes(r)
            }
            ,
            t._processIndexesToAdd = function(e, t, r) {
                const {indexesToAdd: i} = this
                  , o = n.get(this.model).mainStore.value
                  , s = {
                    mutation: e.getModelMutation(this.model),
                    indexes: i,
                    changes: null,
                    changesSize: 0,
                    records: o.state,
                    recordsSize: o.size,
                    isMain: !0
                };
                return by(s, t, r)
            }
            ,
            t._processIndexesToAddInFlight = function(e, t, r) {
                const {indexesToAdd: i} = this
                  , o = n.get(this.model).mainStore
                  , s = o.pendingStoreMgr.children
                  , a = o.value.state;
                let c, u, l, d, h, f, p, g;
                for (let[n,m] of s)
                    if (u = m.store.value,
                    l = fg(u.store)) {
                        for (g in p = u.pState || u.state,
                        h = {},
                        f = 0,
                        d = 0,
                        l)
                            l[g] !== vy && (h[g] = p[g],
                            f++),
                            d++;
                        c = {
                            mutation: e(n, this.model),
                            indexes: i,
                            isMain: !1,
                            changes: l,
                            changesSize: d,
                            records: h,
                            recordsSize: f,
                            mainRecords: a
                        },
                        t[n] = by(c, t[n], r)
                    }
            }
            ,
            t.createIndex = r,
            t.dispatchIndexChild = Oy,
            t.getIndex = Sy,
            t.getIndexesStore = Iy,
            t.getMutableIndex = _y,
            t.getMutableIndexesStore = Ty,
            t._processAddRemoveIndexesComplete = wy,
            t.removeIndex = xy
        }(e, n),
        n._doDestroy = Ap,
        n._doExecute = qp,
        n._doExecuteReturnQueries = Bp,
        n._doSendToConnector = Ay,
        n._doUndo = jy,
        n._doRetrySendToConnector = Ey,
        n.addManagedData = ng,
        n.addManagedDataField = rg,
        n.addToFollowupQueries = Gp,
        n.addTriggerData = Py,
        n.addToManagedGroup = og,
        n.decrementExecuteCount = Up,
        n.destroy = Mp,
        n.disableHistoryUpdate = Xp,
        n.dispatchRecord = Rp,
        n.error = Dp,
        n.errorRecordState = Pp,
        n.execute = jp,
        n.executeNow = Lp,
        n.executeFollowupQueries = zp,
        n.executeReturnQueries = Qp,
        n.forObjectAddTriggerData = Dy,
        n.getManagedData = tg,
        n.getManagedGroup = ig,
        n.getModel = Hp,
        n.getModelMutation = Kp,
        n.getMutationType = Yp,
        n.getRecordQuery = Wp,
        n.getSession = $p,
        n.getTriggerData = Ry,
        n.incrementExecuteCount = Vp,
        n.localOnly = Jp,
        n.localOnlyStart = Zp,
        n.localOnlyFinish = eg,
        n.ofExecute = kp,
        n.preprocessOwnRefModelCreate = lg,
        n.removeFromManagedGroup = sg,
        n.sendToConnector = My,
        n.switchTo = Kp,
        n.undo = ky,
        n.undoable = Fy,
        n.updateCacheMissingFields = Ly,
        n.validateUpdateData = qy,
        n.fetchMissingRecords = Qy
    }
    function Gy(e, t) {
        Object.defineProperties(t.prototype, function(e, t) {
            if (t)
                for (let n in Wf)
                    t[n] = Wf[n];
            else
                t = {
                    ...Wf
                };
            return t.isServer = e.pluginAccessors.isServer,
            t.__pluginId = e.pluginAccessors.__pluginId,
            t.__pluginSlug = e.pluginAccessors.__pluginSlug,
            t.types = e.pluginAccessors.types,
            t
        }(e))
    }
    function zy(e) {
        const t = (e = e.mainStore).storeConfig
          , n = t.getModelStoreConfig;
        class r {
            constructor(e, t) {
                const r = n(e)
                  , i = r.schema;
                this._ensurePendingChanges = void 0,
                this._hasSentToConnector = !1,
                this._isConnectorComplete = !1,
                this._isFollowupQueriesReady = !1,
                this._isOptimisticComplete = !1,
                this._isReturnQueriesReady = !1,
                this.closed = !1,
                this.controller = t,
                this.createMutations = void 0,
                this.dataSourceUid = i.externalId && i.props && i.props.dataSourceUid || void 0,
                this.deleteMutations = void 0,
                this.dispatchId = t.dispatchId,
                this.dynamicForeignFields = i.dynamicForeignFields,
                this.entitySlug = i.entitySlug,
                this.externalId = i.externalId,
                this.fields = i.fields,
                this.hasLocalCache = !i.externalId,
                this.indexStores = void 0,
                this.indexesStore = void 0,
                this.isCancelling = !1,
                this.isComplete = !1,
                this.isFromIPC = t.isFromIPC,
                this.isInPluginChanges = !1,
                this.isPersistentStateChange = !1,
                this.mainDispatchId = t.mainDispatchId,
                this.model = e,
                this.modelName = i.name,
                this.permCheck = t.permCheck,
                this.persistentData = void 0,
                this.persistentType = void 0,
                this.pkIsAutoIncrement = r.pkIsAutoIncrement,
                this.prevRecordState = {},
                this.primaryKey = i.primaryKey,
                this.recordDataType = {},
                this.records = {},
                this.syncMgr = void 0,
                this.syncOrder = i.syncOrder || 0,
                this.triggers = r.triggers,
                this.updateMutations = void 0,
                this.userRole = t.userRole,
                this.virtualFields = i.virtualFields,
                this.willCommitTriggerData = !1,
                t.mutations[this.modelName] = this,
                t.modelCount++,
                this.model.addRemoveMutation(this),
                this.entitySlug && (this.syncOrder += 100,
                this.dataSourceUid && (t.hasDataSource = !0))
            }
        }
        return Object(L.b)(r, t.modelMutationBase),
        By(t, r),
        Gy(t, r),
        Object(he.z)(r, he.r.MODEL_MUTATION),
        Object(he.A)(r, he.r.MUTATION),
        r.Type = function(e, t) {
            class n extends Array {
                constructor(e, t) {
                    super(),
                    this.mutation = e,
                    this.mutationType = t,
                    this.willCommit = !1,
                    this.willSendToConnector = !1
                }
            }
            const r = n.prototype;
            return r._doRetrySendToConnector = Kf,
            r.addQuery = af,
            r.cancel = cf,
            r.commitOnly = uf,
            r.complete = md,
            r.createQuery = lf,
            r.createQueryPayload = Hl,
            r.destroy = vd,
            r.execute = Td,
            r.executeReturnQueries = df,
            r.getRecordQuery = hf,
            r.mainTrxComplete = yd,
            r.mapPkChanges = qf,
            r.optimisticComplete = gd,
            r.permCheck = Bf,
            r.permDenied = Qf,
            r.processInvalidRecords = Gf,
            r.processVFData = zf,
            r.sendToConnector = Hf,
            r.fetchMissingRecords = Yf,
            n.MutationQuery = e.ModelQuery === Bu ? sf : of(e.ModelQuery),
            n
        }(t),
        r.Create = Pd(t, r),
        r.Update = fh(t, r),
        r.Delete = wh(t, r),
        r
    }
    function Hy(e, t, n) {
        let r, i;
        if ("boolean" === typeof e)
            r = void 0,
            i = e,
            n = t;
        else {
            if (e) {
                if (!Array.isArray(e))
                    throw new Error("Expected an Array of virtual field names or a boolean to create the cache missing fields Object. Got: " + e);
                r = e,
                i = t
            } else
                r = void 0,
                i = t;
            if ("boolean" !== typeof i)
                throw new Error("Expected a boolean as the value to set for each cache missing field. Got: " + i)
        }
        const {virtualFields: o} = this;
        let s;
        for (let a in o)
            (!r || r.indexOf(a) > -1) && (s = o[a].ownModelCacheMissingFieldName) && (n || (n = {})) && (n[s] = i);
        return n
    }
    function Ky(e) {
        const {primaryKey: t} = this
          , n = e[t];
        if (!n && !this.pkIsAutoIncrement)
            throw new Error("A primary key is required to create a record when the primary key is not auto-incremented.");
        return e[t] = this.toGlobalId(n),
        e
    }
    function Yy(e) {
        return this.IDType.isValidGlobalId(e)
    }
    function Wy(e) {
        return this.IDType.fromGlobalId(e)
    }
    function $y(e) {
        return this.IDType.toGlobalId(e)
    }
    function Xy(e, t) {}
    function Jy(e, t, n) {
        let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        const i = this.mutation()
          , o = i.controller
          , s = Object(he.U)(t) ? t : this
          , a = s.getMainInstance();
        let c, u;
        if ("boolean" === typeof n ? c = n : n && (u = n,
        c = u.undoable,
        u.localOnly && (r = !0),
        u.disableHistoryUpdate && s === a && o.disableHistoryUpdate(!0)),
        !0 === c && i.undoable(),
        null === e ? i.delete(t, r) : u && u.dataTypes ? i.update(t, u.dataTypes, e, r) : i.update(t, e, r),
        u) {
            const {recordProps: e, modelProps: n} = u;
            if (n && (i.action.payload.props = n),
            e) {
                let n;
                if (Object(he.U)(t))
                    n = i.getRecordPayload(t, !0),
                    n.props = e;
                else
                    for (let r in t)
                        n = i.getRecordPayload(t[r], !0),
                        n.props = e
            }
        }
        return s === a ? o.executeNow() : o.execute(),
        Object(qs.a)( () => s === a ? o.ofComplete(!0).pipe(Object(Or.a)(a)) : s.__closed ? Object(V.a)(a) : o.ofComplete().pipe(Object(Or.a)(s)))
    }
    function Zy(e, t, n) {
        return this.setState(e, t, n, !0)
    }
    var ev = n(268)
      , tv = n(77);
    function nv(e) {
        const t = (e = e.mainStore).storeConfig
          , n = (t.getModelStoreConfig,
        t.StoreWrapper);
        class r extends n {
        }
        Object(L.b)(r, t.sharedCore),
        Object(he.z)(r, he.r.MODEL),
        Object.defineProperties(r.prototype, function(e, t) {
            t || (t = {});
            const n = e.getModelStoreConfig
              , r = e.storesMap
              , i = e.pluginAccessors
              , o = e.plugin;
            return t.__ID = {
                get() {
                    return n(this).schema[ev.a.MODEL]
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.__pluginId = i.__pluginId,
            t.__pluginSlug = i.__pluginSlug,
            t.__types = i.types,
            t.autoloadFields = {
                get() {
                    return n(this).autoloadFields
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.dataSource = {
                get() {
                    const e = this.schema.props;
                    return e && e.dataSourceUid ? this.switchTo(tv.b.DATA_SOURCE).getByUid(e.dataSourceUid) || void 0 : null
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.dataTypesUpdater = {
                get() {
                    return n(this).dataTypesUpdater
                },
                set: void 0,
                configurable: !0,
                enumerable: !1
            },
            t.dataTypesValidator = {
                get() {
                    return n(this).dataTypesValidator
                },
                set: void 0,
                configurable: !0,
                enumerable: !1
            },
            t.directives = i.directives,
            t.dynamicForeignFields = {
                get() {
                    return n(this).schema.dynamicForeignFields
                },
                set: void 0
            },
            t.entity = {
                get() {
                    const e = n(this).schema.entitySlug
                      , t = o.switchTo(tv.b.ENTITY).getState();
                    for (const n in t)
                        if (t[n].slug === e)
                            return t[n];
                    return null
                }
            },
            t.envParser = i.envParser,
            t.fields = {
                get() {
                    return n(this).fields
                },
                set() {
                    console.log(">> fields setter called on model ".concat(this.__typename, " = "), (new Error).stack)
                },
                enumerable: !1,
                configurable: !0
            },
            t.fieldsToConstraintName = {
                get() {
                    return n(this).fieldsToConstraintName
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.fieldsToIndexName = {
                get() {
                    return n(this).fieldsToIndexName
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.graphqlName = {
                get() {
                    return n(this).schema.graphqlName
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.IDType = {
                get() {
                    return n(this).IDType
                },
                set() {
                    console.log(">> IDType setter called on model ".concat(this.__typename, " = "), (new Error).stack)
                },
                enumerable: !1,
                configurable: !0
            },
            t.inDatabase = {
                get() {
                    return n(this).inDatabase
                },
                set(e) {
                    n(this).inDatabase = !!e
                },
                enumerable: !1,
                configurable: !0
            },
            t.isServer = i.isServer,
            t.isLinkedSession = {
                get() {
                    if (this.isServer)
                        return !1;
                    const e = this.getSession();
                    return !(!e || !e.parentId)
                }
            },
            t.lastPersistentStateChangeAt = {
                get() {
                    const e = n(this);
                    return e.schema.isHistory ? e.schema.standardSchema.modelInstance.lastPersistentStateChangeAt : e.lastPersistentStateChangeAt
                }
            },
            t.mainModel = {
                get() {
                    return n(this).model
                },
                set: void 0,
                enumerable: !1,
                configurable: !1
            },
            t.modelId = t.__ID,
            t.modelSync = {
                get() {
                    return n(this).modelSync
                },
                set(e) {
                    const t = n(this);
                    t && (t.modelSync = e)
                }
            },
            t.Mutation = {
                get() {
                    return n(this).Mutation
                },
                set: void 0,
                configurable: !0,
                enumerable: !1
            },
            t.notExists = {
                get() {
                    return n(this).notExists
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.pkCanChange = {
                get() {
                    return n(this).pkIsAutoIncrement
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.pkIsAutoIncrement = t.pkCanChange,
            t.primaryKey = {
                get() {
                    return n(this).primaryKey
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.QueryConstraints = {
                get() {
                    return n(this).QueryConstraints
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.Record = {
                get() {
                    return n(this).Record
                },
                set(e) {
                    n(this).Record = e
                },
                enumerable: !1,
                configurable: !0
            },
            t.RecordResult = {
                get() {
                    return n(this).RecordResult
                },
                set(e) {
                    n(this).RecordResult = e
                },
                enumerable: !1,
                configurable: !0
            },
            t.recursiveVFs = {
                get() {
                    return n(this).schema.recursiveVFs
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.schema = {
                get() {
                    return n(this).schema
                },
                set() {
                    console.log(">> schema setter called on model ".concat(this.__typename, " = "), (new Error).stack)
                },
                enumerable: !1,
                configurable: !0
            },
            t.size = {
                get() {
                    const e = r.get(this);
                    return e ? e.value.size : void 0
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.triggers = {
                get() {
                    return n(this).triggers
                },
                set: void 0,
                configurable: !0,
                enumerable: !1
            },
            t.types = i.types,
            t.UIDType = {
                get() {
                    return n(this).UIDType
                },
                set(e) {
                    n(this).UIDType = e
                }
            },
            t.virtualFields = {
                get() {
                    return n(this).virtualFields
                },
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.volumesAbsPath = i.volumesAbsPath,
            t.modelInstance = {
                get() {
                    return this
                },
                set: void 0,
                enumerable: !1,
                configurable: !1
            },
            t
        }(t));
        const i = r.prototype;
        return function(e, t) {
            t.createCacheMissingFieldsObject = Hy
        }(0, i),
        i.ensureRecordDataHasPkValue = Ky,
        i.isValidGlobalId = Yy,
        i.fromGlobalId = Wy,
        i.toGlobalId = $y,
        function(e, t) {
            const n = e.storesMap
              , r = e.getModelStoreConfig;
            t.getIndexesStore = function(e, t) {
                const r = n.get(this);
                return !e || e === r.mainDispatchId && t ? r.value.indexesStore : t ? r.value.indexesStore.getBestStore(e) : r.value.indexesStore.getPendingStore(e, !0)
            }
            ,
            t.getIndex = function(e, t, r) {
                if (e === In.f)
                    return t ? r ? this.getBestInstance(t) : this.getPendingInstance(t) : this;
                if (!t)
                    return n.get(this).value.indexesStore.get(e);
                let i = n.get(this).value.indexesStore;
                if (r)
                    i = i.getBestStore(t);
                else if (!(i = i.getPendingStore(t, !0)))
                    return;
                return i.get(e)
            }
            ,
            t.getIndexByField = function(e, t, n) {
                "string" !== typeof e && (e = e.name);
                const i = r(this).fieldsToIndexName[e];
                return i ? this.getIndex(i, t, n) : void 0
            }
            ,
            t.determineBestIndex = function(e, t) {
                if (e === In.f)
                    return e;
                if (t === In.f)
                    return t;
                const r = n.get(this).value.indexesStore.getState()
                  , i = r[e]
                  , o = r[t];
                if (i && o)
                    return i.size > o.size ? e : t;
                if (i)
                    return e;
                if (o)
                    return t;
                throw new Error("Unable to determine best index, both " + "".concat(e, " and ").concat(t, " do not exist."))
            }
            ,
            t.getMutationIndex = function(e, t) {
                let r = void 0
                  , i = n.get(this);
                const o = i.storeConfig;
                return o.mutationIndexName ? r = i.value.indexesStore.get(o.mutationIndexName) : t && o.mutationLocalIndexName && (r = i.value.indexesStore.get(o.mutationLocalIndexName)),
                r && e && (i = r.getPendingStore(e, !0)) && (r = i),
                r
            }
        }(t, i),
        function(e, t) {
            const n = e.getModelStoreConfig;
            t.initComplete = function() {
                const e = n(this);
                e.isInitComplete || (e.isInitComplete = !0,
                e.hasPkChangesModels && (e.mutationsQueriesPkSub = Ff(e.pkChangesModels, e.activeQueries, e.activeMutations)),
                e.schema.buildInterimUpdateData())
            }
            ,
            t.registerVF = function(e) {
                const t = n(this);
                return t.virtualFields[e.bestVFName] === e || (t.schema.setVF(e),
                e.ownModelVFName && t.Record.defineVFAccessors(e, e.getRecordAccessorsMap(), e.getRecordAccessors())),
                this
            }
            ,
            t.destroy = function(t) {
                const n = e.storesMap
                  , r = n.get(this);
                if (!r)
                    return;
                const i = r.value;
                if (!i)
                    return;
                const o = r.storeConfig;
                if (i.size) {
                    const e = i.getState();
                    let t;
                    for (const r in e)
                        (t = n.get(e[r])) && t.complete()
                }
                i.indexesStore && (i.indexesStore.complete(),
                i.indexesStore = void 0),
                o.recordStore.complete(),
                o.pkChanges$ && o.pkChanges$.complete(),
                o.recordsToCompletePkSub && o.recordsToCompletePkSub.unsubscribe(),
                o.mutationsQueriesPkSub && o.mutationsQueriesPkSub.unsubscribe();
                const {recordsToComplete: s} = o;
                if (s.size) {
                    for (let[,e] of s)
                        e.complete();
                    s.clear()
                }
                if (o.triggers.destroy(),
                o.activeMutations.clear(),
                o.activeQueries.clear(),
                o.QueryConstraints.destroy(),
                !t) {
                    const {virtualFields: e} = o;
                    let t, n, r;
                    for (let i in e)
                        if (t = e[i],
                        t.isRefModel)
                            for (r in n = t.foreignField,
                            t.modelVF.destroy(),
                            t.destroy(),
                            n)
                                n[r] = void 0
                }
                for (let e in o)
                    o[e] = void 0;
                r.complete()
            }
        }(t, i),
        i.markCacheCompleteFromQueryArg = Xy,
        function(e, t) {
            const n = e.getModelStoreConfig
              , r = e.storesMap;
            t.getPkChangesModel = function(e) {
                return n(this).pkChangesModels[e]
            }
            ,
            t.registerPkChangesModel = function(e, t) {
                const i = n(this);
                if (i.pkChangesModels[e] = t,
                i.hasPkChangesModels = !0,
                !i.isInitComplete)
                    return;
                const o = r.get(this).value.indexesStore.value.getState();
                let s;
                for (let n in o)
                    s = o[n].storeConfig,
                    (s.keyBy === e || s.fieldNames.indexOf(e) > -1) && o[n].value.ensureCorrectPkChanges();
                i.mutationsQueriesPkSub ? i.mutationsQueriesPkSub.fieldChanged(e, i.pkChangesModels[e]) : i.mutationsQueriesPkSub = Ff(i.pkChangesModels, i.activeQueries, i.activeMutations)
            }
            ,
            t.subscribeToPkChanges = function(e) {
                const t = n(this).pkChanges$;
                return t ? e ? t.subscribe(e) : t.asObservable() : void 0
            }
            ,
            t.pipePkChanges = function() {
                const e = n(this).pkChanges$;
                return e ? 0 === arguments.length ? e.asObservable() : e.asObservable().pipe(...arguments) : void 0
            }
            ,
            t.emitPkChanges = function(e) {
                n(this).pkChanges$.next(e)
            }
        }(t, i),
        function(e, t) {
            const n = e.storesMap
              , r = e.getModelStoreConfig;
            t.query = function(e) {
                const t = n.get(this);
                if (t)
                    return t.storeConfig.Query.init(this, e);
                {
                    const t = this.mainModel;
                    return r(t).Query.init(t, e)
                }
            }
            ,
            t.addRemoveQuery = function(e, t) {
                if (t) {
                    const t = r(this);
                    t && t.activeQueries && t.activeQueries.delete(e)
                } else
                    r(this).activeQueries.add(e)
            }
            ,
            t.permPluginQueryCheck = function(t, n) {
                return e.pluginRecord.getBestInstance(n.dispatchId || this.__dispatchId).permQuery(t, n)
            }
            ,
            t.executeQuery = function(e) {
                return n.get(this).parentInstance.executeQuery(e)
            }
            ,
            t.executeDirectQuery = function(e) {
                return n.get(this).parentInstance.executeDirectQuery(e)
            }
            ,
            t.executeSubscription = function(e) {
                return n.get(this).parentInstance.executeSubscription(e)
            }
            ,
            t.mutation = function(e, t) {
                const n = this.pluginMutation(e, t);
                return n ? n.getModelMutation(this) : n
            }
            ,
            t.pluginMutation = function(t, r) {
                return "undefined" === typeof t ? n.get(this).parentInstance.mutation(t, r) : e.plugin.mutation(t, r)
            }
            ,
            t.mutationDangerouslyInitAsCommitOnly = function(e, t) {
                const n = this.mutation(e, t);
                return n ? n.commitOnly(!0) : n
            }
            ,
            t.getVFModelMutation = function(e, t) {
                const r = (n.get(this) || n.get(this.mainModel)).storeConfig.virtualFields[t];
                if (!r)
                    throw new Error("Unable to getVFModelMutation() because the VF ".concat(t, " is not a registered virtual field on the ").concat(this.modelName, " Model."));
                return r.ownRefModel.mutation(e.meta.dispatchId)
            }
            ,
            t.addRemoveMutation = function(e, t) {
                const i = r(this.mainModel);
                if (!t)
                    return void i.activeMutations.add(e);
                const o = i && i.activeMutations;
                if (!o)
                    return;
                const s = i.recordsToComplete;
                if (o.delete(e),
                s.size && "undefined" !== typeof e.action && !e.controller.undoController)
                    if (o.size) {
                        if (4 === i.recordsToCompleteCheckCount++) {
                            let e, t, r;
                            i.recordsToCompleteCheckCount = 0;
                            for (let[i,a] of s) {
                                for (e of (t = !1,
                                o))
                                    if (e.recordDataType[i] && (r = n.get(e.records[i])) && r.storeId === a.storeId) {
                                        t = !0;
                                        break
                                    }
                                t || (s.delete(i),
                                a.complete())
                            }
                        }
                    } else {
                        for (let[e,t] of s)
                            s.delete(e),
                            t.complete();
                        i.recordsToCompleteCheckCount = 0
                    }
            }
            ,
            t.getTimeTravelTimestampsForPkValue = function(e, t) {
                const n = r(this).activeMutations;
                if (!n.size)
                    return t || null;
                const i = !!t;
                let o;
                for (let r of n)
                    r.recordDataType[e] && r.controller.isUndoable && (o = r.controller.ts,
                    t ? (!i || t.indexOf(o) < 0) && t.push(o) : t = [o]);
                return t || null
            }
            ,
            t.getByUid = function(e) {
                if (!e)
                    return null;
                const t = n.get(this).value.indexesStore.get(Ro.e);
                if (!t)
                    return null;
                if ("string" === typeof e)
                    return t.get(e) || null;
                {
                    const n = {};
                    for (const r of e)
                        n[r] = t.get(e) || null;
                    return n
                }
            }
            ,
            t.setState = Jy,
            t.setLocalState = Zy
        }(t, i),
        r
    }
    var rv = n(395);
    class iv {
        constructor() {
            this.mainLogic = void 0,
            this.pendingLogic = void 0,
            this.mainReducers = void 0,
            this.pendingReducers = void 0
        }
        static init() {
            return new this
        }
        _addLogic(e, t) {
            if (!t)
                return this;
            let n = this[e];
            if (!n)
                switch (n = [],
                e) {
                case "pendingLogic":
                    this.pendingLogic = n;
                    break;
                case "pendingExtraTrxLogic":
                    this.pendingExtraTrxLogic = n;
                    break;
                case "mainLogic":
                    this.mainLogic = n;
                    break;
                case "mainExtraTrxLogic":
                    this.mainExtraTrxLogic = n;
                    break;
                default:
                    throw new Error('Unable to add logic, the "'.concat(e, '" is not a known logic option.'))
                }
            return Array.isArray(t) ? n.push(...t) : n.push(t),
            this
        }
        _addReducers(e, t) {
            if (!t)
                return this;
            let n = this[e];
            if (n)
                if (Array.isArray(t))
                    for (let r of t)
                        n.indexOf(r) < 0 && n.push(r);
                else
                    n.indexOf(t) < 0 && n.push(t);
            else
                switch (n = Array.isArray(t) ? [...t] : [t],
                e) {
                case "pendingReducers":
                    this.pendingReducers = n;
                    break;
                case "mainReducers":
                    this.mainReducers = n;
                    break;
                default:
                    throw new Error('Unable to add reducers because "'.concat(e, '" is not a valid reducers option.'))
                }
            return this
        }
        _maybeSetDefault(e, t, n) {
            return "undefined" === typeof t ? "undefined" === typeof this[e] && (this[e] = n) : this[e] = t,
            this
        }
        _maybeSetScDefault(e, t, n) {
            return "undefined" === typeof t ? ("undefined" === typeof this.getStoreConfig(e) && this.setStoreConfig(e, n),
            this) : this.setStoreConfig(e, t)
        }
        _maybeSetScArray(e, t) {
            return t ? this.setStoreConfig(e, t) : this.getStoreConfig(e) ? this : this.setStoreConfig(e, [])
        }
        _maybeSetScObject(e, t, n) {
            return "string" === typeof t ? this.setStoreConfig(e, t, n) : t ? this.setStoreConfig(e, t) : this.getStoreConfig(e) ? this : this.setStoreConfig(e, {})
        }
        parseLongname(e, t, n) {
            if ("." !== e.charAt(0))
                return e;
            let r = Object(rv.a)(this, e, t, n);
            const i = r.lastIndexOf("/");
            return i < 0 ? "module:".concat(r) : "module:".concat(r.substring(0, i), ".").concat(r.substring(i + 1))
        }
        parseModuleName(e, t, n, r) {
            return Object(rv.a)(this, e, t, n, r)
        }
        useStoreOptions(e) {
            let t;
            for (let n in e)
                t = "set".concat(Object(iu.b)(n)),
                "function" === typeof this[t] && this[t](e[n]);
            return this
        }
        addPendingLogic(e) {
            return this._addLogic("pendingLogic", e)
        }
        addMainLogic(e) {
            return this._addLogic("mainLogic", e)
        }
        addLogic(e, t) {
            return t ? this._addLogic("mainLogic", e) : this._addLogic("pendingLogic", e)
        }
        addPendingExtraTrxLogic(e) {
            return this._addLogic("pendingExtraTrxLogic", e)
        }
        addMainExtraTrxLogic(e) {
            return this._addLogic("mainExtraTrxLogic", e)
        }
        addExtraTrxLogic(e, t) {
            return t ? this.addMainExtraTrxLogic(e) : this.addPendingExtraTrxLogic(e)
        }
        addPendingReducers(e) {
            return this._addReducers("pendingReducers", e)
        }
        addMainReducers(e) {
            return this._addReducers("mainReducers", e)
        }
        addReducers(e, t) {
            return t ? this._addReducers("mainReducers", e) : this._addReducers("pendingReducers", e)
        }
        setMainTrxPriority() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
            return this.mainTrxPriority = e,
            this
        }
        setPendingTrxPriority() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
            return this.pendingTrxPriority = e,
            this
        }
        setTrxPriority(e) {
            return this.setMainTrxPriority(e).setPendingTrxPriority(e)
        }
        setSavePendingChildByKey(e) {
            return this.savePendingChildByKey = e,
            this
        }
        setSavePendingChildInstance(e) {
            return this.savePendingChildInstance = !!e,
            this
        }
        setMainTrxLogic(e) {
            return this.mainTrxLogic = e,
            this
        }
        setPendingTrxLogic(e) {
            return this.pendingTrxLogic = e,
            this
        }
        setTrxLogic(e, t) {
            return t ? this.setMainTrxLogic(e) : this.setPendingTrxLogic(e)
        }
        setTrxActionTypes(e, t) {
            if ("string" === typeof e) {
                let n = this.trxActionTypes;
                n ? n[e] = t : (n = {
                    [e]: t
                },
                this.trxActionTypes = n)
            } else
                this.trxActionTypes = e;
            return this
        }
        setIsolationLevel(e) {
            return this.isolationLevel = "string" === typeof e ? {
                type: e
            } : e,
            this
        }
        setPackageName(e) {
            return this.packageName = e,
            this
        }
        setModuleName(e, t) {
            return this.moduleName = Object(rv.a)(this, e, this.moduleName, this.packageName, "packageName"),
            this.storeName || this.setStoreName(this.moduleName),
            this
        }
        setMaxCacheSize(e) {
            return this.maxCacheSize = e,
            this
        }
        setNetwork(e) {
            return this.network = e,
            this
        }
        setMainValue(e) {
            return this.MainValue = e,
            this
        }
        setPendingValue(e) {
            return this.PendingValue = e,
            this
        }
        setStoreId(e) {
            return this.storeId = e,
            this
        }
        setParentStoreId(e) {
            return this.parentStoreId = e,
            this
        }
        setParentStore(e) {
            return this.setParentStoreId(e.storeId),
            this.parentStore = e,
            this.network || this.setNetwork(e.network),
            e.instance && (this.parentInstance = e.instance),
            this
        }
        setStoreName(e) {
            return this.storeName = e,
            this
        }
        setMainStoreMgr(e) {
            return this.mainStoreMgr = e,
            this
        }
        setPendingStoreMgr(e) {
            return this.pendingStoreMgr = e,
            this
        }
        setStoreConfig(e, t, n) {
            if ("string" === typeof e) {
                let r = this.storeConfig;
                if (r || (r = {},
                this.storeConfig = r),
                "undefined" === typeof n)
                    r[e] = t;
                else if (!0 === t)
                    if (r[e]) {
                        const t = r[e];
                        if (Array.isArray(n))
                            for (let e of n)
                                t.indexOf(e) < 0 && t.push(e);
                        else
                            t.indexOf(n) < 0 && t.push(n)
                    } else
                        r[e] = Array.isArray(n) ? [...n] : [n];
                else
                    r[e] ? r[e][t] = n : r[e] = {
                        [t]: n
                    }
            } else
                this.storeConfig = e;
            return this
        }
        getStoreConfig(e, t) {
            const n = this.storeConfig;
            return e ? n ? t ? n[e] ? n[e][t] : void 0 : n[e] : void 0 : n
        }
        reverse() {
            return this.pendingLogic && this.pendingLogic.reverse(),
            this.mainLogic && this.mainLogic.reverse(),
            this.mainReducers && this.mainReducers.reverse(),
            this.pendingReducers && this.pendingReducers.reverse(),
            this
        }
        setStore(e, t) {
            return e && !t ? this.store = e : this.store || this.createStore(t ? e : void 0),
            this
        }
        createStore(e) {
            return this.setStore(ym(this, e)),
            this.store
        }
        destroy() {
            this.store = void 0,
            this.parentStore = void 0,
            this.parentInstance = void 0,
            this.pendingLogic = void 0,
            this.mainLogic = void 0,
            this.pendingReducers = void 0,
            this.mainReducers = void 0,
            this.storeConfig = void 0
        }
    }
    var ov = n(396);
    const sv = (e, t, n) => (Object.defineProperty(e, "__typename", t.modelAccessors.__typename),
    "dispatch"in e.prototype || (e.prototype.dispatch = e.createDispatchMethod(n ? t.recordDispatchers : t.modelDispatchers)),
    t[n ? "Record" : "Model"] = e,
    e);
    const av = function(e) {
        class t extends e {
        }
        return t.blacklistPropsCommitPendingState = {
            ...e.blacklistPropsCommitPendingState,
            mutation: !0,
            indexesStore: !0
        },
        t
    }(Sg.a);
    const cv = function(e) {
        class t extends e {
            commit(e) {
                return this.mutation && this.mutation.dispatchId === e.meta.dispatchId && (this.mutation._ensurePendingChanges = void 0,
                this.mutation = void 0),
                super.commit(e)
            }
        }
        return t.deReferenceProps = [...e.deReferenceProps, "mutation", "indexesStore"],
        t
    }(Og.a);
    var uv = n(291)
      , lv = n(193);
    class dv extends iv {
        static init(e) {
            const t = new this;
            return t.parentInstance = e,
            t.setNetwork(e.network).setTrxActionTypes({
                [c.n]: Fl.b
            }).setMainTrxPriority(Lm.j).setPendingTrxPriority(Lm.j).setMainValue(uv.a).setPendingValue(uv.b).addPendingLogic(lv.b),
            t
        }
        setModuleName(e, t) {
            return super.setModuleName(e),
            t && (this.parentInstance.storeConfig.Record.longname = this.parseLongname(t, this.moduleName, this.packageName)),
            this
        }
        registerExtension(e) {
            const t = this.parentInstance;
            return t.__registerExtension(t.storeConfig.Record, e, this),
            this
        }
        setClass(e) {
            return this.parentInstance.setRecord(e),
            this
        }
        setAccessors(e, t) {
            return this.parentInstance.setRecordAccessors(e, t),
            this
        }
        get modelBuilder() {
            return this.parentInstance
        }
        get Class() {
            return this.parentInstance.Record
        }
        get Record() {
            return this.parentInstance.Record
        }
        get accessors() {
            return this.parentInstance.getStoreConfig("recordAccessors")
        }
        get dispatchers() {
            return this.parentInstance.getStoreConfig("recordDispatchers")
        }
    }
    var hv = n(874);
    const fv = Xm.a.initModule("@isomorix/model/logic")
      , pv = fv.createNewInstance().setEnv("client")
      , gv = fv.createNewInstance().setEnv("server")
      , mv = fv.createNewInstance().addSource(hv.a).useSources().addSource(fv).addSource(pv).addSource(gv)
      , yv = Xm.a.initModule("@isomorix/model/logic");
    let vv, bv, _v;
    {
        const e = {};
        vv = e,
        bv = e,
        _v = e
    }
    function Sv(e) {
        const t = e.meta
          , n = t.pendingStore.value;
        if (n && !n.indexesStore.mainDispatchId) {
            const e = n.indexesStore.getPendingStore(t.dispatchId, !0);
            e && (n.indexesStore = e)
        }
        return e
    }
    Sv[l.d] = {
        [l.j]: "setPendingIndexesStore",
        [l.m]: 10,
        [l.k]: f.f,
        [f.f]: Sv,
        [l.n]: !0,
        [l.a]: "*",
        [l.l]: yv.packageName,
        [l.i]: "".concat(yv.moduleName, "/main"),
        [l.e]: vv.setPendingIndexesStore
    },
    yv.add(Sv[l.d]);
    var Ov = n(397);
    const Tv = mv.getBuilder(c.n, "./mutation");
    Tv.use().setName("ensureMutationIsExecuting").setPriority(-1e3).setPrepareOp().setCancelOp((function(e) {
        const t = e instanceof Error ? e.value : e;
        return t.payload.isCancelling || t.payload.mutation.cancel(),
        t
    }
    )).setPure(!1).setDispatcher(!0).setDescription(bv.ensureMutationIsExecuting).add((function(e, t) {
        const {payload: {mutation: n}} = e;
        return n.isExecuting ? t ? e : Object(V.a)(e) : Object(Ov.a)(n.controller.ofExecute(), e, t)
    }
    ), !0),
    Tv.useRelative("trxPrepare", -100).setName("startRecordActions").setPure(!0).setDescription(bv.startRecordActions).add((function(e) {
        const {payload: t} = e;
        if (!t.autoStartRecordActions) {
            t.autoStartRecordActions = !0;
            const {recordActions: e} = t;
            for (let t in e)
                e[t].meta.subscribe()
        }
        return e
    }
    ), !0),
    Tv.useRelative("trxOptimisticComplete", 1).setName("optimisticComplete").setDescription(bv.optimisticComplete).setPure(!1).add((function(e, t) {
        return Object(Ov.a)(e.payload.mutation.optimisticComplete(), e, t)
    }
    ), !0);
    Tv.use().setName("prepareQueries").setCommitOp().setPure(!0).setPriority(100).setDescription(bv.prepareQueries).add((function(e) {
        const {mutation: t} = e.payload;
        let n, r;
        for (let i in zu)
            if (n = t[zu[i]])
                if (i === Gr.c) {
                    let e;
                    for (r of n)
                        e = r.payload,
                        e.isLocalOnly || r.includeMutation(!0).prepareSelect(e)
                } else
                    for (r of n)
                        r.payload.isLocalOnly || r.includeMutation(!0);
        return e
    }
    ), !0);
    Tv.use().setPriority(200).setCommitOp().setName("sendToConnector").setPure(!1).setDescription(bv.sendToConnector).add((function(e, t) {
        return Object(Ov.a)(e.payload.mutation.sendToConnector(), e, t)
    }
    ), !0),
    Tv.useRelative(800).setName("processAutoloadVFs").setPure(!0).setDescription(bv.processAutoloadVFs).add((function(e) {
        const t = e.payload.mutation;
        if (t.isCancelling)
            return e;
        const n = t.virtualFields;
        for (let r in n)
            n[r].processMutationAutoload(t);
        return e
    }
    ), !0),
    Tv.useRelative(200).setName("executeFollowupQueries").setPure(!1).setDescription(bv.executeFollowupQueries).add((function(e, t) {
        return Object(Ov.a)(e.payload.mutation.executeFollowupQueries(), e, t)
    }
    ), !0),
    Tv.useRelative(200).setName("executeReturnQueries").setPure(!1).setDescription(bv.executeReturnQueries).add((function(e, t) {
        return Object(Ov.a)(e.payload.mutation.executeReturnQueries(), e, t)
    }
    ), !0);
    var Iv = n(363)
      , xv = n(391);
    function wv(e, t, n, r) {
        const i = e.childSync$;
        if (!i)
            return null;
        const o = function(e, t, n, r) {
            const i = e.childSync$;
            if (!i)
                return !1;
            let o, s, a;
            if (n ? (o = n,
            s = sn) : r && (o = r,
            s = on),
            o) {
                const t = e.children;
                let n;
                a = [];
                for (let e in t)
                    (n = t[e].action) && a.push(s(o, n))
            }
            return i.next(t),
            !a || Object(wr.a)(a)
        }(e, t, n, r);
        return i.complete(),
        e.childSync$ = void 0,
        o
    }
    function Mv() {
        const e = this.payload
          , t = e.resp;
        if (t) {
            if (!t.data)
                throw console.log("\n\n", {
                    action: this,
                    payload: e,
                    resp: t,
                    data: t.data
                }),
                new Error("Errors occurred when attempting to execute query:\n\n".concat(e.query.toGraphql(!0)));
            let n = t.data[e.query.queryName];
            e.resp = n && !Array.isArray(n) ? [n] : n,
            e.extensions = t.extensions
        }
        return this
    }
    const Av = mv.getBuilder(c.p, "./query")
      , {getCommitMutation: Ev} = Ol;
    let Cv;
    Cv = function(e) {
        const {payload: t} = e;
        let {query: n} = t;
        return n.queryHasM2MInclude && (n = n.cloneForExecute(t).includeM2MThroughRecords(t)),
        n.prepareSelect(t),
        e
    }
    ,
    Av.use().setName("prepareQuery").setPriority(100).setPrepareOp().setPure(!0).setDescription(_v.prepareQuery).add(Cv, !0),
    Av.useRelative(100).setName("processAutoloadVFs").setPure(!0).setDescription(_v.processAutoloadVFs).add((function(e) {
        const t = e.payload
          , n = e.meta.instance.virtualFields;
        for (let r in n)
            n[r].processQueryAutoload(t);
        return e
    }
    ), !0),
    Av.use().setName("clientDispatchIncludes").setPriority(300).setPrepareOp().setDescription(_v.clientDispatchIncludes).addTo(pv, (function(e, t) {
        const n = e.payload;
        return n.query.prepareIncludes(n),
        Object(Ov.a)(function(e, t) {
            const n = e.query.includeVFs;
            if (n) {
                e.childSync$ = new xv.a(1);
                const r = fn(e)
                  , i = e.children
                  , o = e.forSubscription ? c.s : c.p
                  , s = {};
                let a, u;
                for (let e in n)
                    u = i[e],
                    u = u.query.preparePayload(u),
                    a = u.query.model.dispatch(o, u, r, "ifExists"),
                    u.query.setPayloadAction(u, a),
                    s[e] = on(t, a);
                return Object(wr.a)(s)
            }
            return null
        }(n, f.f), e, t)
    }
    ), !0),
    Av.use().setName("execute").setTransformOp().setPriority(200).setDispatcher(!0).setDescription(_v.execute).add((function(e, t) {
        const n = e.payload;
        if (n.isServer) {
            const r = n.resp ? null : e.meta.parentInstance.executeQuery(n);
            return Object(Ov.a)(r, e, t)
        }
        {
            const t = n.parent;
            return !t || t.isDeterministic ? e.meta.parentInstance.executeQuery(n).pipe(Object(Y.a)(Mv, e)) : t.childSync$.pipe(Object(Iv.a)(e, "execute"))
        }
    }
    ), !0),
    Av.use().setName("commitResp").setPriority(100).setCommitOp().setPure(!0).setDescription(_v.commitResp).add((function(e) {
        const {payload: t} = e;
        if (t.isServer || !t.parent || t.parent.isDeterministic) {
            const t = e.meta.instance.Mutation.commitQueryPayload(e.payload);
            if (t)
                throw t
        }
        return e
    }
    ), !0),
    Av.useRelative(100).setName("executeIncludes").setDescription(_v.executeIncludes).add((function(e, t) {
        const n = e.payload;
        let r;
        return n.isServer ? n.records && n.query.prepareIncludes(n) && (r = n.query.executeIncludes(n)) : r = wv(n, "execute", f.c),
        Object(Ov.a)(r, e, t)
    }
    ), !0),
    Av.useRelative(100).setName("serverUpdateCacheFieldsFromIncludes").setPure(!0).setDescription(_v.serverUpdateCacheFieldsFromIncludes).addTo(gv, (function(e) {
        return xr(e.payload),
        e
    }
    ), !0),
    Av.useRelative(200).setName("updateCacheFieldsFromArgs").setPure(!0).setDescription(_v.updateCacheFieldsFromArgs).add((function(e) {
        const t = e.payload
          , n = t.query;
        if (n.pagination && "number" === typeof n.pagination.getLimit(t.variables))
            return e;
        const r = e.meta.dispatchId;
        if (!n.isRootQuery) {
            const i = n.parentQueryArg
              , {variables: o} = t;
            let s = i.ownQuery;
            for (; s; ) {
                if (s.pagination && "number" === typeof s.pagination.getLimit(o))
                    return e;
                s = s.parent
            }
            const a = i.getGroupedQueryArg();
            if (a && a.query && a.query.queryArgs)
                return e;
            const c = i.getWrapperQueryArg()
              , u = c ? c.getRealValue(o, []) : i.compileWrapperQueryArgValues(t);
            return u && i.VF.markCacheCompleteFromQueryArg(u, r, t),
            e
        }
        {
            const i = n.queryArgs;
            if (i && i.length) {
                let n, o, s, a, c, u, l, d, h = 0;
                for (let f of i) {
                    if (n = i[h + 1],
                    n && "or" !== n.join)
                        break;
                    Object(he.M)(f) && !f.not && (s || (s = e.meta.store,
                    ({fieldsToIndexName: a, primaryKey: c} = s.storeConfig),
                    u = s.value.indexesStore.value,
                    d = s.instance),
                    f.key === c ? d.markCacheCompleteFromQueryArg(f.getRealValue(t.variables, []), r, t) : (o = a[f.key]) && (l = u.get(o)) && l.value.markCacheCompleteFromQueryArg(f.getRealValue(t.variables, []), r, t)),
                    h++
                }
            }
        }
    }
    ), !0),
    Av.use().setPriority(200).setFinalizeOp().setName("processMutationAutoload").setPure(!1).setDescription(_v.processMutationAutoload).add((function(e, t) {
        const {payload: n} = e;
        let r = n.records && Ev(n, !0);
        if (!r)
            return Object(Ov.a)(null, e, t);
        const i = n.parent
          , o = r.controller || r;
        if (!n.isServer && i && !i.isDeterministic) {
            let r = n.parent;
            for (; r.parent && r.parent.action; )
                r = r.parent;
            if (o.hasExecuteWhen(r.action, !0))
                return Object(Ov.a)(null, e, t)
        }
        if (n.records && (r = r.switchTo(e.meta.instance, !0))) {
            const e = r.virtualFields
              , {records: t} = n;
            for (let n in e)
                e[n].processMutationAutoload(r, t)
        }
        return Object(Ov.a)(o.followupQueries && (n.isServer || !i || i.isDeterministic) ? o.executeFollowupQueries(null, !0) : null, e, t)
    }
    ), !0);
    var Nv = n(288)
      , Rv = n.n(Nv)
      , Pv = n(289)
      , Dv = n.n(Pv)
      , Fv = n(290)
      , kv = n.n(Fv);
    function jv(e, t) {
        if ("number" !== typeof e)
            throw new TypeError("A `number` must be provided when specifying ".concat(t, "."))
    }
    function Lv(e, t) {
        if (null === e || "object" !== typeof e)
            throw new TypeError("An `Object` must be provided when specifying ".concat(t, "."))
    }
    pt.a,
    Rv.a,
    Dv.a,
    kv.a,
    _t.a;
    const Vv = new class {
        concat(e, t) {
            return t ? [...t, ...e] : pt()(e)
        }
        decrement(e, t) {
            return "number" === typeof t && (t -= e),
            t
        }
        increment(e, t) {
            return "number" === typeof t && (t += e),
            t
        }
        merge(e, t) {
            return t ? Rv()(e, t) : pt()(e)
        }
        merge_deep(e, t) {
            return t ? Dv()(e, t) : pt()(e)
        }
        merge_nonexistent(e, t) {
            return t ? kv()(e, t) : pt()(e)
        }
        merge_nonexistent_deep(e, t) {
            return t ? _t()(e, t) : pt()(e)
        }
    }
      , Uv = new class {
        concat(e) {
            if (!Array.isArray(e))
                throw new TypeError("An `Array` must be provided when specifying `".concat("concat", "`."))
        }
        decrement(e) {
            return jv(e, "decrement")
        }
        increment(e) {
            return jv(e, "increment")
        }
        merge(e) {
            return Lv(e, "merge")
        }
        merge_deep(e) {
            return Lv(e, "merge_deep")
        }
        merge_nonexistent(e) {
            return Lv(e, "merge_nonexistent")
        }
        merge_nonexistent_deep(e) {
            return Lv(e, "merge_nonexistent_deep")
        }
    }
    ;
    let qv, Qv, Bv, Gv, zv, Hv, Kv, Yv, Wv, $v, Xv, Jv;
    const Zv = Array.isArray;
    class eb {
        constructor(e, t) {
            for (Xv of (Bv = {},
            Hv = {},
            Qv = {},
            t))
                Bv[Xv] = void 0,
                Qv[Xv] = void 0,
                Hv[Xv] = void 0;
            Kv = t.length,
            this.isPrimary = e === In.f,
            this.constraintName = e,
            this.values = Bv,
            this.siblingValues = Hv,
            this.fields = t,
            this.fieldCount = Kv,
            this.missingCount = Kv,
            this.totalCount = Kv,
            this.siblingValuesCount = 0,
            this.valuesCount = 0,
            this.valuesMap = Qv,
            this.changed = !1
        }
        checkin() {
            if (this.changed) {
                if (qv = this.fields,
                ({valuesMap: Qv, values: Bv, siblingValues: Hv} = this),
                this.siblingValuesCount) {
                    for (Xv of (Hv = this.siblingValues,
                    qv))
                        (Gv = Hv[Xv]) && (Yn.a.checkinArray(Gv),
                        Hv[Xv] = void 0),
                        Bv[Xv] = void 0,
                        Qv[Xv] = void 0;
                    this.siblingValuesCount = 0
                } else
                    for (Xv of qv)
                        Bv[Xv] = void 0,
                        Qv[Xv] = void 0;
                Kv = qv.length,
                this.missingCount = Kv,
                this.valuesCount = 0,
                this.fieldCount = Kv,
                this.changed = !1
            }
        }
        cloneSiblingValues(e) {
            for (Xv of (({values: Bv, fields: qv, siblingValues: Hv, siblingValuesCount: Wv, valuesCount: Yv, missingCount: $v} = this),
            Jv = e.siblingValues,
            qv))
                (zv = Jv[Xv]) && (Gv = Yn.a.cloneArray(zv),
                Bv[Xv] = Gv,
                Hv[Xv] = Gv,
                Wv++,
                Yv++,
                $v--);
            return this.missingCount = $v,
            this.siblingValuesCount = Wv,
            this.valuesCount = Yv,
            this.changed = !0,
            this
        }
        addVFQueryParentArg(e, t) {
            ({siblingValues: Hv, values: Bv} = this),
            Gv = Yn.a.checkoutArray(),
            Gv.push(t),
            Bv[e] = Gv,
            Hv[e] = Gv,
            this.valuesCount++,
            this.siblingValuesCount++,
            this.changed = !0,
            this.missingCount--
        }
        addArg(e, t) {
            Xv = e.key,
            Bv = this.values,
            (Gv = Bv[Xv]) ? t && Array.isArray(Gv) && (Bv[Xv] = e) : (Bv[Xv] = e,
            this.missingCount--,
            this.valuesCount++,
            this.changed = !0)
        }
        addParentArg(e) {
            ({values: Bv} = this),
            Xv = e.key,
            Bv[Xv] || (this.missingCount--,
            this.valuesCount++,
            this.changed = !0),
            Bv[Xv] = e
        }
        addSiblingArg(e) {
            if (({values: Bv} = this),
            Xv = e.key,
            Gv = Bv[Xv],
            Gv) {
                if (!Zv(Gv))
                    throw new Error("Query is unsolvable");
                Gv.indexOf(e) < 0 && Gv.push(e)
            } else
                ({siblingValues: Hv} = this),
                Gv = Yn.a.checkoutArray(),
                Gv.push(e),
                this.siblingValues[Xv] = Gv,
                Bv[Xv] = Gv,
                this.valuesCount++,
                this.siblingValuesCount++,
                this.changed = !0,
                this.missingCount--
        }
        addToSibling(e) {
            if (!this.valuesCount)
                return !1;
            const t = this.values;
            let n;
            for (Xv of (({values: Bv, siblingValues: Hv, fields: qv} = e),
            qv))
                (n = t[Xv]) && !Zv(n) && n[he.q] !== he.d && ((Gv = Bv[Xv]) ? Gv.push(n) : (Gv = Yn.a.checkoutArray(),
                Gv.push(n),
                Bv[Xv] = Gv,
                Hv[Xv] = Gv,
                e.missingCount--,
                e.valuesCount++,
                e.siblingValuesCount++,
                e.changed = !0))
        }
    }
    const tb = ["create", "update", "beforeDelete", "afterDelete", "beforeFieldUpdate", "afterFieldUpdate"]
      , nb = {
        create: null,
        update: null,
        beforeDelete: null,
        afterDelete: null,
        beforeFieldUpdate: "beforeFieldUpdateFieldNames",
        afterFieldUpdate: "afterFieldUpdateFieldNames"
    }
      , rb = {
        create: !1,
        update: !1,
        beforeDelete: !1,
        afterDelete: !1,
        beforeFieldUpdate: !0,
        afterFieldUpdate: !0
    }
      , ib = e => {
        for (const t of e)
            "function" === typeof t.destroy && t.destroy()
    }
      , ob = e => {
        for (const t in e)
            e[t] && (ib(e[t]),
            e[t] = void 0)
    }
    ;
    function sb(e, t, n) {
        e[t] ? e[t].indexOf(n) < 0 && Object(pa.a)(n, e[t], "priority") : e[t] = [n]
    }
    function ab(e, t, n) {
        const r = e[t];
        if (r) {
            const i = r.indexOf(n);
            i > -1 && (r.splice(i, 1),
            0 === r.length && (e[t] = null))
        }
    }
    class cb {
        constructor(e) {
            this.create = null,
            this.update = null,
            this.beforeDelete = null,
            this.afterDelete = null,
            e ? (this.beforeFieldUpdate = e.beforeFieldUpdate || {},
            this.afterFieldUpdate = e.afterFieldUpdate || {}) : (this.beforeFieldUpdate = {},
            this.afterFieldUpdate = {})
        }
        destroy() {
            for (const e of tb)
                this[e] && (rb[e] ? ob(this[e]) : ib(this[e]),
                this[e] = void 0)
        }
        add(e, t, n) {
            let r;
            if ("string" !== typeof e) {
                for (r of tb)
                    e[r] && this.add(r, e);
                return this
            }
            if (r = e,
            "beforeFieldUpdate" === r || "afterFieldUpdate" === r) {
                if (!n && !(n = t[nb[r]]) && !(n = t.fieldNames))
                    return this;
                const e = this[r];
                if (Array.isArray(n))
                    for (let r of n)
                        sb(e, r, t);
                else
                    sb(e, n, t)
            } else
                sb(this, r, t);
            return this
        }
        remove(e, t, n) {
            let r;
            if ("string" !== typeof e) {
                for (r of tb)
                    this.remove(r, e);
                return this
            }
            if (r = e,
            "beforeFieldUpdate" === r || "afterFieldUpdate" === r) {
                if (!n && !(n = t[nb[r]]) && !(n = t.fieldNames))
                    return this;
                const e = this[r];
                if (Array.isArray(n))
                    for (let r of n)
                        ab(e, r, t);
                else
                    ab(e, n, t)
            } else
                ab(this, r, t);
            return this
        }
        call(e, t, n, r, i, o, s, a) {
            for (let u of e)
                try {
                    u[t].call(u.thisArg || u, n, r, i, o, s, a)
                } catch (c) {
                    return c
                }
        }
    }
    class ub {
        constructor(e) {
            const t = e.IDType;
            this.activeMutations = new Set,
            this.activeQueries = new Set,
            this.autoloadFields = e.autoloadFields,
            this.dataTypesUpdater = Vv,
            this.dataTypesValidator = Uv,
            this.fields = e.fields,
            this.fieldsToConstraintName = e.fieldsToConstraintName,
            this.fieldsToIndexName = e.fieldsToIndexName,
            this.getRecordStore = void 0,
            this.IDType = t,
            this.inDatabase = !e.isLocalOnly,
            this.isInitComplete = !1,
            this.isServer = !1,
            this.lastPersistentStateChangeAt = 1e3 * (e.lastChangeAt || 0),
            this.Model = void 0,
            this.model = void 0,
            this.modelName = e.name,
            this.modelAccessors = {},
            this.modelDispatchers = {},
            this.modelSync = void 0,
            this.Mutation = void 0,
            this.mutationIndexName = void 0,
            this.mutationLocalIndexName = void 0,
            this.mutationLongname = "module:model.Mutation",
            this.mutationsQueriesPkSub = void 0,
            this.notExists = {},
            this.persistentStateChanges$ = void 0,
            this.pkChangesModels = e.pkChangesModels,
            this.primaryKey = e.primaryKey,
            this.Query = void 0,
            this.queryLongname = "module:query.Query",
            this.Record = void 0,
            this.RecordResult = void 0,
            this.recordAccessors = {},
            this.recordDispatchers = {},
            this.recordResultAccessors = {},
            this.recordStore = void 0,
            this.recordsToComplete = new Map,
            this.recordsToCompleteCheckCount = 0,
            this.schema = e,
            this.triggers = new cb(e),
            this.UIDType = e.UIDType,
            this.VFSyncOptions = void 0,
            this.virtualFields = e.virtualFields,
            t.isAutoIncrement ? (this.hasPkChangesModels = !0,
            this.pkChanges$ = new U.a,
            this.pkIsAutoIncrement = !0,
            this.recordsToCompletePkSub = this.pkChanges$.subscribe(new Lf(this.recordsToComplete))) : (this.hasPkChangesModels = !1,
            this.pkChanges$ = null,
            this.pkIsAutoIncrement = !1,
            this.recordsToCompletePkSub = null,
            this.mutationIndexName = In.f),
            this.QueryConstraints = function(e) {
                let t = {};
                const n = [];
                let r, i, o = 0;
                const s = [];
                class a {
                    constructor() {
                        for (i of s)
                            this[i] = new eb(i,t[i].fields)
                    }
                    static get names() {
                        return s
                    }
                    static get master() {
                        return t
                    }
                    static get pool() {
                        return n
                    }
                    static checkout() {
                        return o ? (o--,
                        n.pop()) : new a
                    }
                    static add(r, i) {
                        if (!t[r]) {
                            if (t[r] = new eb(r,i),
                            s.push(r),
                            o)
                                for (let e of n)
                                    e[r] = new eb(r,i);
                            const {fieldsToConstraintName: a} = e;
                            for (Xv of i)
                                a[Xv] || (a[Xv] = r)
                        }
                    }
                    static has(e) {
                        return !!t[e]
                    }
                    static remove(a) {
                        if (t[a]) {
                            s.splice(s.indexOf(a), 1),
                            r = t[a],
                            e.mutationIndexName === a && (e.mutationIndexName = void 0),
                            e.mutationLocalIndexName === a && (e.mutationLocalIndexName = void 0),
                            qv = r.fields;
                            const {fieldsToConstraintName: c} = e;
                            for (Xv of qv)
                                c[Xv] === a && (c[Xv] = null);
                            let u = {};
                            for (i of s)
                                u[i] = {
                                    ...t[i]
                                };
                            if (t = u,
                            o) {
                                let e;
                                for (let t = 0; t < o; t++) {
                                    for (i of (u = {},
                                    e = n[t],
                                    s))
                                        u[i] = {
                                            ...e
                                        };
                                    n[t] = u
                                }
                            }
                        }
                    }
                    static updateConstraintIndexes(t) {
                        let n = t.storeConfig;
                        const {name: r, fieldNames: i} = n;
                        if (1 !== i.length || n.VF && n.VF.isManyToMany || (e.fieldsToIndexName[n.fieldNames[0]] = r),
                        n.unique) {
                            const {fields: t, fieldsToConstraintName: o} = e;
                            let s, a, c = !1, u = 0, l = !1, d = !1;
                            for (a of i)
                                s = t[a],
                                s.type.isAutoIncrement && (l = !0,
                                s.foreignField || (c = !0)),
                                s.notNullable && u++,
                                s.inDatabase || (d = !0),
                                o[a] || (o[a] = r);
                            if (n.hasAutoIncrementField = l,
                            n.hasOwnAutoIncrementField = c,
                            n.hasNonDbField = d,
                            n.notNullableFieldCount = u,
                            this.add(r, i),
                            r === Ro.e)
                                return !!e.mutationIndexName;
                            if (e.mutationIndexName)
                                return e.mutationIndexName === In.f || d || l || u !== i.length || (e.mutationIndexName = r),
                                !0;
                            if (!u)
                                return !1;
                            if (!l && !d)
                                return e.mutationIndexName = r,
                                e.mutationLocalIndexName = void 0,
                                !0;
                            if (l)
                                if (c) {
                                    if (i.length > 1 && !e.mutationLocalIndexName)
                                        return e.mutationLocalIndexName = n.name,
                                        !0
                                } else {
                                    if (!d)
                                        return e.mutationIndexName = r,
                                        e.mutationLocalIndexName = void 0,
                                        !0;
                                    if (!e.mutationLocalIndexName)
                                        return e.mutationLocalIndexName = void 0,
                                        !0
                                }
                            else if (!e.mutationLocalIndexName)
                                return e.mutationLocalIndexName = r,
                                !0;
                            return !1
                        }
                        return !1
                    }
                    static recalculateConstraintIndexes(t) {
                        const n = t.getState();
                        e.mutationIndexName = void 0,
                        e.mutationLocalIndexName = void 0;
                        const {fieldsToConstraintName: r, fieldsToIndexName: i} = e
                          , {primaryKey: o} = e.schema;
                        for (let e in r)
                            e !== o && (r[e] = null,
                            i[e] = null);
                        for (let e in n)
                            this.updateConstraintIndexes(n[e])
                    }
                    static destroy() {
                        o && (o = 0,
                        n.length = 0,
                        t = void 0)
                    }
                    checkin() {
                        for (i of s)
                            r = this[i],
                            r.changed && r.checkin();
                        n.push(this),
                        o++
                    }
                    addVFQueryParentArg(t) {
                        const n = t.query.parentQueryArg
                          , o = n.VF.ownRefFieldName;
                        (i = e.fieldsToConstraintName[o]) && (r = this[i]) && r.addVFQueryParentArg(o, n)
                    }
                    populate(e) {
                        let t;
                        for (i of s)
                            t = e[i],
                            t.siblingValuesCount && (r = this[i],
                            r.cloneSiblingValues(t));
                        return this
                    }
                    addToSibling(e) {
                        let t;
                        for (i of s)
                            (r = this[i]) && r.valuesCount && (t = e[i]) && r.addToSibling(t)
                    }
                    getCompleteConstraint(e) {
                        if (r = this[In.f],
                        0 === r.missingCount)
                            return e && (e.constraintName = r.constraintName),
                            r;
                        for (i of s)
                            if ((r = this[i]) && 0 === r.missingCount)
                                return e && (e.constraintName = i),
                                r;
                        return e && (e.constraintName = null),
                        null
                    }
                }
                return e.QueryConstraints = a,
                a.add(In.f, e.schema.constraints[In.f].fieldNames),
                a
            }(this),
            function(e) {
                const {modelAccessors: t, recordAccessors: n, schema: {name: r, displayName: i}} = e;
                t.__typename && t.__typename.value === r || (t.__typename = {
                    value: r,
                    enumerable: !1,
                    configurable: !1
                },
                t.modelName = t.__typename,
                n.__typename = t.__typename),
                t.modelDisplayName && t.modelDisplayName.value === i || (t.modelDisplayName = {
                    value: i,
                    enumerable: !1,
                    configurable: !1
                })
            }(this)
        }
    }
    const lb = (db = Sg.a,
    class extends db {
        cloneNew() {
            const e = super.cloneNew();
            return e.isHydrateMainState = !1,
            e
        }
        complete() {
            const e = this.store;
            if (e) {
                if (e.storeConfig.model = void 0,
                this.size) {
                    const e = this.getState();
                    for (const t in e)
                        e[t].complete()
                }
                super.complete()
            } else
                super.complete()
        }
    }
    );
    var db;
    const hb = {
        registerChildStore: function(e) {
            this.set(e.storeConfig.name, e)
        }
    };
    const fb = function(e) {
        class t extends e {
            cloneMainState(e, t) {
                return (t = super.cloneMainState(e, t)).isHydrateMainState = !1,
                t
            }
        }
        return Object(L.a)(t, hb),
        t
    }(Og.a)
      , pb = Xm.a.initModule("@isomorix/model/indexesStore/logic");
    let gb;
    function mb(e) {
        function t(t) {
            const n = t.meta
              , r = e.getPendingStore(n.dispatchId, !0);
            return r && n.pendingStore && (r.value.indexesStore = n.pendingStore),
            t
        }
        return e = e.mainStore,
        t[l.d] = {
            [l.j]: "giveModelStorePendingReference",
            [l.m]: 10,
            [l.k]: f.f,
            [l.n]: !0,
            [l.a]: "*",
            [l.l]: e.packageName,
            [l.i]: "".concat(e.moduleName, "/logic/main"),
            [l.e]: gb.giveModelStorePendingReference
        },
        t
    }
    gb = {},
    pb.add(Vl),
    pb.add(Ul),
    pb.add(Ql);
    class yb extends iv {
        static createStoreConfig(e) {
            return new ub(e)
        }
        static init(e) {
            if (!e)
                throw new Error("storeConfig is required to initialize a modelBuilder.");
            const t = new this;
            return t.storeConfig = e,
            t.setMainTrxPriority(Lm.g).setPendingTrxPriority(Lm.g).setMainValue(av).setPendingValue(cv).addMainReducers(km).addPendingLogic(mv).addMainLogic(yv),
            jl(t),
            t
        }
        setNetwork(e) {
            return e && (this.setStoreConfig("isServer", e.isServer),
            this.addPendingLogic(e.isServer ? gv : pv)),
            super.setNetwork(e)
        }
        setParentStore(e) {
            super.setParentStore(e);
            const t = e.storeConfig;
            return this.storesMap = t.storesMap,
            this
        }
        setGetRecordStore(e) {
            if (e)
                return this.setStoreConfig("getRecordStore", e);
            if (this.getStoreConfig("getRecordStore"))
                return this;
            if (!this.storesMap || !this.parentStore)
                throw new Error('Unable to setRecordStore() on model "'.concat(this.modelName, "\" because the model's parentStore (the plugin's store) has not been set. Therefore, getRecordStore() cannot be created, as it relies on values in the plugin's store to do so."))
        }
        setModuleName(e, t) {
            return super.setModuleName(e),
            t && (t = this.parseLongname(t, this.moduleName, this.packageName),
            this.storeConfig.Model.longname = t),
            this
        }
        setDefaultModuleNames(e) {
            e = e ? this.parseModuleName(e, this.moduleName, this.packageName, "packageName") : this.packageName,
            this.moduleName = "".concat(e, "/model"),
            this.storeName || (this.storeName = this.moduleName);
            const t = this.getRecordBuilder();
            t.packageName || (t.packageName = this.packageName),
            t.moduleName = "".concat(e, "/record"),
            t.storeName || (t.storeName = t.moduleName);
            const n = this.storeConfig;
            let r = n.Model;
            return r || (this.setModel(),
            r = n.Model),
            r.longname || (r.longname = "module:".concat(e, ".Model")),
            (r = n.Record) || (this.setRecord().setRecordResult(),
            r = n.Record),
            r.longname || (r.longname = "module:".concat(e, ".Record")),
            this
        }
        __maybeSetClass(e, t) {
            const n = this.storeConfig;
            if (t) {
                if (t.__typename === n.modelName)
                    return n[e] = t,
                    this
            } else {
                if (n[e])
                    return this;
                t = this.parentStore.storeConfig[e]
            }
            switch (e) {
            case "Model":
                return function(e, t) {
                    sv(class extends e {
                    }
                    , t, !1)
                }(t, n),
                this;
            case "Record":
                return function(e, t) {
                    sv(class extends e {
                    }
                    , t, !0)
                }(t, n),
                this;
            default:
                throw new Error('Unable to __maybeSetClass(): The key, "'.concat(e, '", must be one of Model or Record.'))
            }
        }
        setClass(e) {
            return this.__maybeSetClass("Model", e)
        }
        setModel(e) {
            return this.__maybeSetClass("Model", e)
        }
        setRecord(e) {
            return this.__maybeSetClass("Record", e)
        }
        setRecordResult(e) {
            return e ? this.setStoreConfig("RecordResult", e) : this.getStoreConfig("RecordResult") ? this : this.setStoreConfig("RecordResult", this.parentInstance.RecordResult)
        }
        __registerExtension(e, t, n) {
            t = this.parseLongname(t, n.moduleName, n.packageName);
            let r = e.extends;
            return r ? r.unshift(t) : (r = [t],
            e.extends = r),
            this
        }
        registerExtension(e) {
            return this.__registerExtension(this.storeConfig.Model, e, this)
        }
        getRecordStore() {
            return this.setRecordStore().recordStore
        }
        setRecordStore(e) {
            return e ? (e instanceof dv || (e = dv.init(this).useStoreOptions(e)),
            this.setStoreConfig("recordStore", e)) : (this.getStoreConfig("recordStore") || this.setStoreConfig("recordStore", dv.init(this)),
            this)
        }
        getRecordBuilder() {
            return this.getRecordStore()
        }
        setRecordBuilder(e) {
            return this.setRecordStore(e)
        }
        setAccessors(e, t) {
            return this.setStoreConfig("modelAccessors", e, t)
        }
        setModelAccessors(e, t) {
            return this.setStoreConfig("modelAccessors", e, t)
        }
        setRecordAccessors(e, t) {
            return this.setStoreConfig("recordAccessors", e, t)
        }
        setMutation(e, t) {
            const n = this.storeConfig;
            return n.Mutation = e,
            t && (n.mutationLongname = this.parseLongname(t, this.moduleName, this.packageName)),
            this
        }
        setQuery(e, t) {
            const n = this.storeConfig;
            return n.Query = e,
            t && (n.queryLongname = this.parseLongname(t, this.moduleName, this.packageName)),
            this
        }
        subscribeToInstance(e) {
            if (!this._instanceObservers$) {
                if (this.storeConfig.model)
                    return e ? Object(V.a)(this.storeConfig.model).subscribe(e) : Object(V.a)(this.storeConfig.model);
                this._instanceObservers$ = new U.a
            }
            return e ? this._instanceObservers$.subscribe(e) : this._instanceObservers$
        }
        createInstance() {
            const e = this.store ? this.store.mainStore : this.createStore()
              , t = this.storeConfig
              , n = this.storesMap;
            if (t.Model || this.setModel(),
            t.Record || this.setRecord(),
            t.RecordResult || this.setRecordResult(),
            !t.getRecordStore) {
                const r = e.storeId;
                t.getRecordStore = e => {
                    const t = n.get(e);
                    return t && t.parentStoreId === r ? t : void 0
                }
            }
            const {Model: r, Record: i} = t;
            Object(ov.a)(e, n, t.modelDispatchers, t.modelAccessors),
            Object.defineProperties(r.prototype, t.modelAccessors);
            const o = r.init(e);
            t.model = o,
            e.setMainInstance(o),
            t.pkIsAutoIncrement && (t.pkChangesModels[t.primaryKey] = o,
            t.hasPkChangesModels = !0,
            t.pkChanges$.subscribe(new Tf(e))),
            this.createIndexesStore(e);
            const s = this.getRecordBuilder().setParentStore(e).createStore();
            return t.recordStore = s,
            Object(ov.a)(s, n, t.recordDispatchers, t.recordAccessors),
            Object.defineProperties(i.prototype, t.recordAccessors),
            i.defineFieldAccessors(),
            t.schema.setModelInstance(o),
            this._instanceObservers$ && (this._instanceObservers$.next(e),
            this._instanceObservers$.complete(),
            this._instanceObservers$ = void 0),
            o
        }
        destroy() {
            super.destroy(),
            this.storesMap = void 0
        }
        get Class() {
            return this.getStoreConfig("Model")
        }
        get Model() {
            return this.getStoreConfig("Model")
        }
        get Record() {
            return this.getStoreConfig("Record")
        }
        get RecordResult() {
            return this.getStoreConfig("RecordResult")
        }
        get recordBuilder() {
            return this.getStoreConfig("recordStore")
        }
        get recordStore() {
            return this.getStoreConfig("recordStore")
        }
        get accessors() {
            return this.storeConfig.modelAccessors
        }
        get modelAccessors() {
            return this.storeConfig.modelAccessors
        }
        get recordAccessors() {
            return this.storeConfig.recordAccessors
        }
        get recordResultAccessors() {
            return this.storeConfig.recordResultAccessors
        }
        get dispatchers() {
            return this.storeConfig.modelDispatchers
        }
        get modelDispatchers() {
            return this.storeConfig.modelDispatchers
        }
        get recordDispatchers() {
            return this.storeConfig.recordDispatchers
        }
        get Mutation() {
            return this.storeConfig.Mutation
        }
        get Query() {
            return this.storeConfig.Query
        }
        get QueryConstraints() {
            return this.storeConfig.QueryConstraints
        }
        get autoloadFields() {
            return this.storeConfig.autoloadFields
        }
        get schema() {
            return this.storeConfig.schema
        }
        get modelName() {
            const e = this.getStoreConfig();
            if (e)
                return e.schema ? e.schema.name : e.modelName
        }
        get virtualFields() {
            return this.getStoreConfig("virtualFields")
        }
        get isServer() {
            return this.storeConfig.isServer
        }
        get plugin() {
            return this.parentInstance
        }
        get pluginStore() {
            return this.parentStore
        }
        get types() {
            return this.parentInstance.types
        }
    }
    yb.prototype.createIndexesStore = function(e, t) {
        const n = e.value;
        let r = n.indexesStore;
        if (r)
            return r;
        t ? (t.MainValue || (t.MainValue = lb),
        t.mainReducers = jm(t.mainReducers),
        t.mainLogic || (t.mainLogic = []),
        t.mainLogic.push(mb(e)),
        t.PendingValue || (t.PendingValue = fb),
        Gl(t, Lm.a),
        t.pendingLogic ? t.pendingLogic.push(...pb) : t.pendingLogic = pb) : t = {
            mainTrxPriority: Lm.a,
            MainValue: lb,
            mainReducers: jm(),
            mainLogic: [mb(e)],
            pendingTrxPriority: Lm.a,
            PendingValue: fb,
            pendingLogic: pb
        },
        t.parentStoreId || (t.parentStoreId = e.parentStoreId),
        t.network = e.mainStore.network,
        t.storeName = "".concat(e.instance.__typename, ":indexesStore");
        let i = t.storeConfig;
        return i || (i = {},
        t.storeConfig = i),
        i.model = e.mainStore.instance,
        jl(t, !0),
        r = ym(t),
        n.indexesStore = r,
        r
    }
    ;
    var vb = function() {
        function e(e, t) {
            this.dueTime = e,
            this.scheduler = t
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new bb(e,this.dueTime,this.scheduler))
        }
        ,
        e
    }()
      , bb = function(e) {
        function t(t, n, r) {
            var i = e.call(this, t) || this;
            return i.dueTime = n,
            i.scheduler = r,
            i.debouncedSubscription = null,
            i.lastValue = null,
            i.hasValue = !1,
            i
        }
        return K.a(t, e),
        t.prototype._next = function(e) {
            this.clearDebounce(),
            this.lastValue = e,
            this.hasValue = !0,
            this.add(this.debouncedSubscription = this.scheduler.schedule(_b, this.dueTime, this))
        }
        ,
        t.prototype._complete = function() {
            this.debouncedNext(),
            this.destination.complete()
        }
        ,
        t.prototype.debouncedNext = function() {
            if (this.clearDebounce(),
            this.hasValue) {
                var e = this.lastValue;
                this.lastValue = null,
                this.hasValue = !1,
                this.destination.next(e)
            }
        }
        ,
        t.prototype.clearDebounce = function() {
            var e = this.debouncedSubscription;
            null !== e && (this.remove(e),
            e.unsubscribe(),
            this.debouncedSubscription = null)
        }
        ,
        t
    }(O.a);
    function _b(e) {
        e.debouncedNext()
    }
    var Sb = n(867)
      , Ob = n(362);
    const Tb = {
        past: null,
        future: null
    };
    function Ib(e, t) {
        const n = e.storesMap;
        t.getMutableRecord = function(e, t) {
            const r = n.get(this);
            if (r.value.mutation)
                return this;
            if (e.payload.mutation) {
                const t = e.payload.mutation;
                if (Object(he.P)(t) && !t.isComplete && t.mainDispatchId === e.meta.mainDispatchId)
                    return t.switchTo(this.__typename).getMutableRecord(this)
            }
            const i = t ? t.instance : e.meta.instance;
            switch (Object(he.B)(i)) {
            case he.v:
                if (!t && !(t = e.meta.store) || t.mainStore !== r.mainStore)
                    throw new Error("Unable to getMutableRecord(): permission denied. An action or store for a record was provided, but it is not for this record, or it is a public version of the action. This method was called on a ".concat(this.__typename, " record with ID ").concat(this.__ID, "."));
                break;
            case he.p:
            case he.s:
                if (i.__pluginSlug !== this.__pluginSlug)
                    throw new Error("Unable to getMutableRecord(): permission denied. An action or store was provided that is not associated with the same plugin as this record. This method was called on a ".concat(this.__typename, " record with ID ").concat(this.__ID, ", associated with the ").concat(this.__pluginSlug, " plugin. The provided action is associated with the ").concat(i.__pluginSlug, " plugin."));
                break;
            default:
                throw new Error("Unable to getMutableRecord(): permission denied. An action or store was provided that is not associated with a plugin, model, or record. This method was called on a ".concat(this.__typename, " record with ID ").concat(this.__ID, "."))
            }
            return r.parentInstance.mutation(e.meta.dispatchId).executeWhen(e).getMutableRecord(this)
        }
        ,
        t.__getTimeTravelTimestamps = function(e, t) {
            const r = n.get(this)
              , i = r.parentInstance;
            if (t = i.getTimeTravelTimestampsForPkValue(r.get(i.primaryKey), t),
            !e)
                return t;
            const {virtualFields: o} = i;
            let s, a, c;
            for (let n in o)
                if (c = o[n],
                c.VFName && (s = this[n]))
                    if (c.isMany)
                        for (a in s)
                            t = s[a].__getTimeTravelTimestamps(!1, t);
                    else
                        t = s.__getTimeTravelTimestamps(!1, t);
            return t
        }
        ,
        t.subscribeToTimeTravelTimestamps = function(t) {
            const r = n.get(this).mainStore
              , {plugin: o} = e;
            let s, a, c = null;
            return o.subscribeToTimeTravelEvents().pipe((u = 10,
            void 0 === l && (l = i.a),
            function(e) {
                return e.lift(new vb(u,l))
            }
            ), Object(Sb.a)(""), Object(H.a)( () => {
                const e = o.getTimeTravelTimestamps("firstFuture")
                  , n = r.instance.__getTimeTravelTimestamps(t);
                if (!n)
                    return c = null,
                    a = e,
                    s !== Tb && (s = Tb,
                    !0);
                if (c && c.length === n.length) {
                    let t, r = !1;
                    for (let i = 0; i < c.length; i++)
                        if (t = c[i],
                        t !== n[i] || (t === a || t === e) && a !== e) {
                            r = !0;
                            break
                        }
                    if (!r)
                        return a = e,
                        !1
                }
                a = e;
                let i = null
                  , u = null;
                if (e)
                    for (let t of n)
                        t >= e ? (u || (u = []),
                        u.push(t)) : i ? i.push(t) : i = [t];
                else
                    i = n;
                return c = n,
                s = {
                    past: i,
                    future: u
                },
                !0
            }
            ), Object(Y.a)( () => s), Object(Ob.a)(r));
            var u, l
        }
        ,
        t.__removeFromTimeTravel = function(e) {
            const t = this.__getTimeTravelTimestamps(e);
            if (!t)
                return null;
            const r = n.get(this).parentInstance;
            for (let n of t)
                r.removeTimeTravelTs(n);
            return t
        }
    }
    const {CREATED: xb, UPDATED: wb} = ws.a;
    function Mb(e, t, n) {
        return {
            get() {
                const r = t.get(this);
                if (!r)
                    return;
                const i = r.get(e);
                return "undefined" === typeof i ? n : i
            },
            set(n) {
                let r = t.get(this);
                if (!r)
                    return;
                if (r.isMain)
                    return void (r.value.state[e] = n);
                if (r = r.value,
                r.mutation)
                    return void r.mutation.update(this, e, null, n, !0);
                let i = r.pState;
                if (i) {
                    if (i[e] !== n) {
                        i[e] = n;
                        const t = r.pChanges;
                        t[e] !== xb && (t[e] = wb)
                    }
                } else if (i = r.state,
                i[e] !== n) {
                    i[e] = n;
                    const t = r.changesToCommit;
                    t ? t[e] !== xb && (t[e] = wb) : r.changesToCommit = {
                        [e]: wb
                    }
                }
            },
            enumerable: !1,
            configurable: !0
        }
    }
    function Ab(e, t) {
        const n = e.getModelStoreConfig
          , r = e.storesMap
          , i = {}
          , o = {}
          , s = {}
          , a = e => (i[e.name] || (i[e.name] = function(e, t, n) {
            return {
                get() {
                    const n = t.get(this);
                    return n ? n.get(e) : void 0
                },
                set(n) {
                    let r = t.get(this);
                    if (!r)
                        throw new Error('The record on Model "'.concat(this.__typename, '" is already closed. Cannot set property ').concat(e));
                    if (r = r.value,
                    !r.mutation)
                        throw new Error('The record on Model "'.concat(this.__typename, '" must be\n          part of a mutation to set a value for its "').concat(e, '" field.'));
                    r.mutation.update(this, e, null, n)
                },
                enumerable: !n,
                configurable: !0
            }
        }(e.name, r, !1)),
        e.notEnumerable ? {
            ...i[e.name],
            enumerable: !1
        } : i[e.name])
          , c = (e, t) => (o[e] || (o[e] = function(e, t) {
            return {
                get() {
                    return this.__record[e]
                },
                set: void 0,
                configurable: !0,
                enumerable: !t
            }
        }(e, !1)),
        t ? {
            ...o[e],
            enumerable: !1
        } : o[e])
          , u = (e, t, n) => {
            const {name: r} = e;
            n[r] ? t && n[r].configurable && (n[r] = t) : n[r] = t || c(r, e.notEnumerable)
        }
          , l = e => {
            const {name: t} = e;
            return !0 !== e.defaultValue ? Mb(e.name, r, e.defaultValue) : (s[t] || (s[t] = Mb(t, r, !0)),
            s[t])
        }
        ;
        t.build = function(e) {
            const t = n(this)
              , r = ym(void 0, t.recordStore).value
              , i = new this(r.store);
            let o;
            return "string" === typeof e ? o = e : e ? (o = e[t.primaryKey]) || (o = t.model.toGlobalId(),
            e[t.primaryKey] = o) : o = t.model.toGlobalId(),
            r.persistedState = {},
            r.state[t.primaryKey] = o,
            r.size = 1,
            r.store.instance = i,
            i
        }
        ,
        t.defineAccessor = function(e, t, r) {
            const i = e.name
              , o = n(this);
            u(e, r, o.recordResultAccessors);
            const s = o.recordAccessors;
            s[i] ? t && s[i].configurable && (s[i] = t,
            Object.defineProperty(this.prototype, i, t)) : (t || (t = e.isCacheField ? l(e) : a(e)),
            s[i] = t,
            Object.defineProperty(this.prototype, i, t))
        }
        ,
        t.defineFieldAccessors = function() {
            const e = n(this)
              , t = e.recordResultAccessors
              , r = e.recordAccessors
              , {fields: i} = e.schema;
            let o;
            for (let n in i)
                r[n] || (o = i[n],
                r[n] = o.isCacheField ? l(o) : a(o),
                Object.defineProperty(this.prototype, n, r[n]),
                t[n] = c(n, o.notEnumerable))
        }
        ,
        t.defineVFAccessors = function(e, t, r) {
            const i = n(this)
              , o = i.recordAccessors
              , s = e.ownModelCacheMissingField;
            let a, c, d;
            o[s.name] || (u(s, void 0, i.recordResultAccessors),
            o[s.name] = l(s),
            Object.defineProperty(this.prototype, s.name, o[s.name]));
            for (let n in t)
                c = r[n],
                a = t[n],
                d = o[a],
                (!d || d.configurable && d !== c) && ("function" === typeof c.value ? this.prototype[a] = c.value : Object.defineProperty(this.prototype, a, c),
                o[a] = c)
        }
    }
    var Eb = n(869)
      , Cb = n(239)
      , Nb = n.n(Cb)
      , Rb = n(150);
    class Pb extends Array {
        getField(e) {
            return !!this.changes[e]
        }
        getFieldPath(e, t) {
            if (!this.changes[e[0]])
                return !1;
            const n = Nb()(e, this.state);
            return this.cache[t] !== n && (this.cache[t] = n,
            !0)
        }
        getAcc(e, t) {
            const n = this.record[e];
            return this.cache[t] !== n && (this.cache[t] = n,
            !0)
        }
        getAccPath(e, t) {
            const n = Nb()(e, this.record);
            return this.cache[t] !== n && (this.cache[t] = n,
            !0)
        }
        subscribeToMapper(e) {
            if (this.changes = e.changes,
            !this.changes)
                return null;
            this.prevState = e.getPrevState(),
            this.state = e.getState();
            const {keysArray: t} = this
              , n = t.length;
            let r = 0
              , i = !1;
            for (; r < n; )
                this[this[r]](t[r], r) && (i = !0),
                r++;
            return i ? e.store.instance : null
        }
    }
    function Db(e) {
        return Fb(e.store.instance, e.changes, this)
    }
    const Fb = (e, t, n) => {
        if (!t)
            return null;
        for (let r of n)
            if (t[r])
                return e
    }
    ;
    function kb(e, t, n) {
        const r = new Pb(n.length);
        r.cache = {},
        r.state = e.getState(),
        r.prevState = r.prevState,
        r.changes = null,
        r.record = e.instance,
        r.keysArray = n;
        const i = n.length;
        let o, s = 0;
        for (; s < i; )
            o = n[s],
            "string" === typeof o ? t[o] ? r[s] = "getField" : (r[s] = "getAcc",
            r.getAcc(o, s)) : t[o[0]] ? (r[s] = "getFieldPath",
            r.cache[s] = Nb()(o, r.state)) : (r[s] = "getAccPath",
            r.getAccPath(o, s)),
            s++;
        return r
    }
    function jb(e, t) {
        for (let n of t)
            if ("string" !== typeof n || !e[n])
                return !1;
        return !0
    }
    function Lb(e, t, n, r) {
        if (!r)
            return e.subscribeToInstance(null, n);
        if (!jb(t, r))
            return function(e, t, n, r) {
                const i = kb(e, t, r);
                if (!n || e.isMain)
                    return e.pipe(Object(Y.a)(i.subscribeToMapper, i), Object(Rb.a)());
                let o = !1;
                return e.subscribeAndPersist().pipe(Object(Y.a)(e => e.store.isMain === o ? i.subscribeToMapper(e) : (o = !0,
                i.record = e.store.instance,
                i.record)), Object(Rb.a)())
            }(e, t, n, r);
        if (!n || e.isMain)
            return e.pipe(Object(Y.a)(Db, r), Object(Rb.a)());
        let i = !1;
        return e.subscribeAndPersist().pipe(Object(Y.a)(e => e.store.isMain === i ? Db.call(r, e) : (i = !0,
        e.store.instance)), Object(Rb.a)())
    }
    function Vb(e, t) {
        return this.setState(e, t, !0)
    }
    function Ub(e, t) {
        const n = e.storesMap
          , r = e.getModelStoreConfig;
        t.fromGlobalId = function() {
            const e = r(this);
            return e.model.fromGlobalId(this[e.primaryKey])
        }
        ,
        t._addPatch = function(e) {
            const t = Object(Eb.a)(n, this);
            if (!t)
                throw new Error('Unable to addPatch to record "'.concat(this.__typename, '" because the record is already closed.'));
            {
                let n = t.patches;
                n || (t.patches = n = new Set),
                n.add(e)
            }
        }
        ,
        t._removePatch = function(e) {
            const t = Object(Eb.a)(n, this);
            if (!t)
                throw new Error('Unable to removePatch from record "'.concat(this.__typename, '" because the record is already closed.'));
            {
                let n = t.patches;
                n && n.delete(e)
            }
        }
        ,
        t.getVFValue = function(e, t) {
            const n = r(this).virtualFields[e];
            return n ? n.getValue(this, t) : null
        }
        ,
        t.getFromHistory = function(e) {
            const t = n.get(this);
            if (!t)
                return;
            const r = t.get(e)
              , i = t.value;
            if (i.pState && i.state[e] !== r)
                return i.state[e];
            const {history: o} = t;
            if (!o)
                return;
            let s = o.length - 1;
            for (; s >= 0; ) {
                if (o[s].state[e] !== r)
                    return o[s].state[e];
                s--
            }
        }
        ,
        t.__isVFMany = function(e) {
            const t = r(this).virtualFields[e];
            return !!t && t.isMany
        }
        ,
        t.getPersistedState = function() {
            const e = n.get(this);
            if (e)
                return e.value.persistedState
        }
        ,
        t.subscribeTo = function(e) {
            return Lb(n.get(this), r(this).schema.fields, !1, e)
        }
        ,
        t.subscribeToAndPersist = function(e) {
            return Lb(n.get(this), r(this).schema.fields, !0, e)
        }
        ,
        t.__createVFSubscribeToMapper = function(e) {
            return function(e, t, n) {
                const r = e.mainStore;
                let i = e.instance;
                const o = jb(t, n) ? null : kb(e, t, n);
                return t => t !== i ? (i = t,
                e = r,
                o && (o.record = t),
                !0) : o ? !!o.subscribeToMapper(e.value) : !!Fb(e.instance, e.value.changes, n)
            }(n.get(this), r(this).schema.fields, e)
        }
        ,
        t.getState = function(e) {
            const t = n.get(this);
            if (t) {
                if (e) {
                    const e = {
                        ...t.getState()
                    }
                      , {virtualFields: n} = r(this);
                    let i;
                    for (let t in n)
                        (i = n[t].VFName) && (e[i] = this[i]);
                    return e
                }
                return t.getState()
            }
        }
        ,
        t.getApiFieldsState = function(e) {
            const t = n.get(this);
            if (!t)
                return;
            const i = t.getState()
              , o = r(this)
              , s = o.fields
              , a = {};
            for (let n in s)
                s[n].apiRead && (a[n] = i[n]);
            if (e) {
                const e = o.virtualFields;
                let t, n;
                for (let r in e)
                    n = e[r],
                    (t = n.VFName) && n.ownModelVFApiRead && (a[t] = this[t])
            }
            return a
        }
        ,
        t.setState = function(e, t, r) {
            const i = n.get(this);
            if (!i || !i.get(i.parentInstance.primaryKey))
                return;
            const o = i.value.mutation;
            if (!o)
                return i.parentInstance.setState(e, this, t, r);
            if (null === e ? o.delete(this) : o.update(this, e),
            "boolean" === typeof t)
                !0 === t && o.undoable();
            else if (t) {
                const {recordProps: e, modelProps: n} = t;
                e && (o.getRecordPayload(this, !0).props = e),
                n && (o.action.payload.props = n),
                t.undoable && o.undoable()
            }
            const s = i.mainStore.instance
              , a = o.action.meta;
            return new S.a(e => {
                a.isComplete ? (e.next(i.closed ? s : this),
                e.complete()) : a.pipe(Object(Or.a)(this)).subscribe(e)
            }
            )
        }
        ,
        t.setLocalState = Vb
    }
    function qb(e) {
        const t = (e = e.mainStore).storeConfig
          , n = t.StoreWrapper;
        class r extends n {
        }
        return Object(he.z)(r, he.r.RECORD),
        Object.defineProperties(r.prototype, function(e, t) {
            t || (t = {});
            const n = e.storesMap
              , r = e.getModelStoreConfig;
            return t.__ID = {
                get() {
                    const e = n.get(this);
                    if (e)
                        return e.value.get(r(this).primaryKey)
                },
                set: void 0,
                enumerable: !1
            },
            t.__UID = {
                get() {
                    const e = n.get(this);
                    if (e)
                        return e.value.get(Ro.d)
                },
                set: void 0,
                enumerable: !1
            },
            t.__types = e.pluginAccessors.__types,
            t.__prevID = {
                get() {
                    const e = n.get(this);
                    return e ? e.value.getFromHistory(r(this).primaryKey) : void 0
                },
                set: void 0,
                enumerable: !1
            },
            t.__record = {
                get() {
                    return this
                },
                set: void 0,
                enumerable: !1
            },
            t.__pluginId = e.pluginAccessors.__pluginId,
            t.__pluginSlug = e.pluginAccessors.__pluginSlug,
            t.__mutationType = {
                get() {
                    return n.get(this).value.mutationType || null
                },
                set: void 0,
                enumerable: !1
            },
            t.__isLocalOnly = {
                get() {
                    const e = n.get(this);
                    if (e)
                        return !e.mainStore.value.persistedState[r(this).primaryKey]
                },
                set: void 0,
                enumerable: !1
            },
            t
        }(t)),
        Ab(t, r),
        Ib(t, r.prototype),
        Ub(t, r.prototype),
        r
    }
    function Qb(e, t) {
        const {queryArgs: n} = e;
        if (n) {
            const {__record: e} = this;
            for (let r of n)
                r.addToOptimisticMutationResult(this, e, t)
        }
        return this
    }
    function Bb() {
        this.__record = void 0
    }
    function Gb() {
        return this.__record.__ID
    }
    function zb() {
        return this.__record.__prevID
    }
    function Hb() {
        return this.__record.__typename
    }
    function Kb(e, t, n) {
        return new this(n,!1).__selectAll().__addMutationVFs(e, t)
    }
    function Yb(e, t, n) {
        return new this(e,n).__addParsedSelect(t, n)
    }
    function Wb() {
        return this
    }
    const $b = {
        enumerable: !1,
        configurable: !0
    };
    function Xb(e) {
        let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        return new this(e,t)
    }
    function Jb(e, t) {
        t.buildForMutation = Kb,
        t.buildParsedSelect = Yb,
        t.init = Xb,
        function(e, t) {
            const n = e.getModelStoreConfig;
            t.createRecordResult = function(e, t) {
                class r extends (this) {
                }
                r.prototype.__payload = t,
                Object.defineProperty(r.prototype, "__payload", $b),
                r.prototype.__addParsedSelect = Wb,
                r.prototype.__updateParsedSelect = Wb;
                const i = e.parseSelect(t)
                  , o = n(e.model).recordResultAccessors;
                let s, a;
                for (a of i)
                    s = a.name,
                    Object.defineProperty(r.prototype, a.alias || s, o[s]);
                const c = e.includeVFs;
                if (t.forSubscription && c) {
                    let e, n, i, o, s;
                    r.prototype.__children = t.children,
                    Object.defineProperty(r.prototype, "__children", $b);
                    for (let t in c)
                        e = c[t],
                        n = e.query,
                        i = e.query.queryAlias || t,
                        o = e.VF.accessorsMethods.recordResultWithIndex,
                        Object.defineProperty(r.prototype, i, o.accessor),
                        s = Object(ve.c)(i, "subscribe"),
                        r.prototype[s] = o.subscribe,
                        Object.defineProperty(r.prototype, s, $b)
                }
                return r
            }
        }(e, t)
    }
    const Zb = {
        enumerable: !1,
        configurable: !0
    };
    class e_ extends O.a {
        constructor(e) {
            super(),
            this.recordResult = e
        }
        _error(e) {
            super.unsubscribe(),
            this._switchRecords()
        }
        _switchRecords() {
            const {recordResult: e} = this;
            this.recordResult = void 0,
            e.__record = e.__record.getMainInstance(),
            Object.defineProperty(e, "__record", Zb)
        }
        _complete() {
            this._switchRecords(),
            super._complete()
        }
    }
    function t_(e) {
        const t = e.storeConfig
          , n = function() {
            class e {
                constructor(e, t) {
                    this.__record = e,
                    Object.defineProperty(this, "__record", Zb),
                    t && e.__dispatchId && e.subscribe(new e_(this))
                }
            }
            return Object(he.z)(e, he.r.RECORD_RESULT),
            e
        }();
        var r, i;
        t.RecordResult = n,
        Jb(t, n),
        Object.defineProperties(n.prototype, (r = t,
        i || (i = {}),
        i.__ID = {
            get: Gb,
            set: void 0,
            enumerable: !1
        },
        i.__prevID = {
            get: zb,
            set: void 0,
            enumerable: !1
        },
        i.__typename = {
            get: Hb,
            set: void 0,
            enumerable: !1
        },
        i.__pluginSlug = r.pluginAccessors.__pluginSlug,
        i));
        const o = {
            __addMutationVFs: Qb,
            __destroy: Bb
        };
        return function(e, t) {
            const n = e.getModelStoreConfig;
            t.__addSelect = function(e, t) {
                const {querySelect: r} = e;
                if (r) {
                    const e = n(this.__record).recordResultAccessors;
                    let i, o;
                    for (let n in r)
                        i = r[n],
                        Er(i, t) && (o = i.alias || n,
                        Object.defineProperty(this, o, e[n]))
                }
                return this
            }
            ,
            t.__addParsedSelect = function(e, t) {
                if (!e)
                    return this;
                let r, i;
                if (t) {
                    const t = n(this.__record).recordResultAccessors;
                    for (r of e)
                        i = r.name,
                        Object.defineProperty(this, r.alias || i, t[i])
                } else {
                    const t = this.__record;
                    for (r of e)
                        i = r.name,
                        this[r.alias || i] = t[i]
                }
                return this
            }
            ,
            t.__updateParsedSelect = function(e, t) {
                return t ? this : this.__addParsedSelect(e, !1)
            }
            ,
            t.__selectAll = function(e) {
                const t = n(this.__record)
                  , r = t.fields;
                if (e) {
                    const e = t.recordResultAccessors;
                    for (let t in r)
                        e[t] && Object.defineProperty(this, t, e[t])
                } else {
                    const e = this.__record;
                    for (let t in r)
                        this[t] = e[t]
                }
                return this
            }
        }(t, o),
        function(e, t) {
            const n = e.getModelStoreConfig;
            t.__toPlainObject = function(e, t) {
                const r = n(this.__record).fields
                  , i = {};
                let o, s, a, c, u, l;
                for (let n in this)
                    if (s = this[n],
                    l = r[n],
                    !s || "object" !== typeof s || Array.isArray(s))
                        o = t && l && l.type,
                        o ? o.isSerializable && (i[n] = o.serialize(s)) : i[n] = s;
                    else if (Object(he.V)(s))
                        i[n] = s.__toPlainObject(e, t);
                    else {
                        for (a in u = null,
                        s) {
                            if (c = s[a],
                            !u) {
                                if (!Object(he.V)(c))
                                    break;
                                i[n] = u = e ? [] : {}
                            }
                            c = c.__toPlainObject(e, t),
                            e ? u.push(c) : u[a] = c
                        }
                        u || (t ? l && (o = l.type) ? o.isSerializable && (i[n] = o.serialize(s)) : i[n] = JSON.stringify(s) : i[n] = s)
                    }
                return i
            }
        }(t, o),
        Object(L.a)(n, o),
        n
    }
    const n_ = {
        controller: {
            get() {
                return this
            },
            set: void 0
        },
        hasSchemaChanges: {
            get() {
                return this.hasIndexesToAdd || this.hasIndexesToRemove || !!this.relationshipsToAdd
            },
            set: void 0
        },
        isExecuteWhenDisabled: {
            get() {
                return !1 === this._executeWhenLogic
            },
            set: void 0
        },
        isLocalOnly: {
            get() {
                return this.localOnlyStack[this.localOnlyStackIdx]
            },
            set: void 0
        },
        isUndoRedo: {
            get() {
                return this.isUndo || this.isRedo || !1
            },
            set: void 0
        },
        willCommit: {
            get() {
                const e = this.mutations;
                for (let t in e)
                    if (e[t].willCommit)
                        return !0;
                return !1
            }
        },
        willCommitCount: {
            get() {
                let e = 0;
                const t = this.mutations;
                for (let n in t)
                    t[n].willCommit && e++;
                return e
            }
        },
        willSendToConnector: {
            get() {
                const e = this.mutations;
                for (let t in e)
                    if (e[t].willSendToConnector)
                        return !0;
                return !1
            }
        }
    };
    let r_;
    function i_(e, t, n) {
        let r = e[t];
        r && (e[t] = void 0,
        r.isStopped || (r._events && r._events.length || r.next(n ? e : void 0),
        r.complete()),
        r.unsubscribe())
    }
    function o_(e) {
        e._cancelling$ && (e.isCancelling && e._cancelling$.next(e),
        e._cancelling$.complete(),
        e._cancelling$ = void 0)
    }
    function s_(e) {
        const {followupQueries: t} = e;
        if (!t)
            return e;
        const {__queries__: n} = t;
        n && (n.queriesSrc$.complete(),
        n.queriesSub.unsubscribe(),
        n.queries$ = void 0,
        n.queriesSrc$ = void 0,
        n.queriesSub = void 0);
        for (let r in t)
            t[r] = void 0;
        return e.followupQueries = null,
        e
    }
    function a_(e) {
        let {_resp$: t} = e;
        return t || (t = new xv.a(1),
        t.subscribe(),
        e._resp$ = t),
        t
    }
    function c_(e) {
        const t = e.__subject$;
        t && (t.isStopped || t.complete(),
        e.unsubscribe())
    }
    r_ = n(597).client;
    class u_ extends O.a {
        constructor(e, t) {
            super(),
            this.__emitValue = t,
            this.__subject$ = e
        }
        _next(e) {
            this.__subject$.next(this.__emitValue || e)
        }
        _error(e) {
            this.__subject$.error(e)
        }
        _complete() {
            Ep.a.schedule(c_, 0, this)
        }
        unsubscribe() {
            super.unsubscribe(),
            this.__subject$ = void 0,
            this.__emitValue = void 0
        }
    }
    function l_(e) {
        const {mutations: t} = this;
        let n = void 0;
        for (let r in t)
            n = t[r]._doCancelComplete(e, n);
        return this.complete(),
        this
    }
    function d_() {
        return this.isComplete ? this.isCancelling ? Object(V.a)(this) : Xt.a : this.isCancelling ? Object(V.a)(this) : (this._cancelling$ || (this._cancelling$ = new U.a),
        this._cancelling$.asObservable())
    }
    function h_() {
        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        if (e === this.isCommitOnly || this.isOptimisticComplete)
            return this;
        const t = this.mutations
          , n = this.isCommitOnly;
        this.isCommitOnly = e,
        this.localOnlyStack[0] = e;
        for (let r in t)
            t[r]._doCommitOnly(n, e);
        return this
    }
    function f_(e) {
        e._scheduledExecuteSub === this && (e._scheduledExecuteSub = void 0,
        0 === e.executeCount && e.execute())
    }
    class p_ extends O.a {
        constructor(e) {
            super(),
            this.__controller = e
        }
        _complete() {
            f_.call(this, this.__controller),
            this.unsubscribe()
        }
        unsubscribe() {
            super.unsubscribe(),
            this.__controller = void 0
        }
    }
    function g_(e) {
        e.destroy()
    }
    function m_(e) {
        i_(e, "_resp$")
    }
    function y_() {
        let e = this._optimisticComplete$;
        if (!e) {
            if (this.isOptimisticComplete)
                return Object(V.a)(this);
            e = new U.a,
            this._optimisticComplete$ = e
        }
        return e.asObservable()
    }
    const v_ = e => {
        i_(e, "_optimisticComplete$", !0)
    }
    ;
    function b_(e) {
        if (e && !e._isOptimisticComplete && (e._isOptimisticComplete = !0,
        this.optimisticCompleteCount++,
        this.optimisticCompleteCount === this.modelActionCount))
            if (this.isOptimisticComplete) {
                if (!e._doOptimisticComplete())
                    return
            } else {
                this.isOptimisticComplete = !0;
                const e = this.mutations;
                for (let t in e)
                    if (!e[t]._doOptimisticComplete())
                        return;
                this.isCommitOnly = !0,
                this.localOnlyStack[0] = !0,
                Ep.a.schedule(v_, 0, this)
            }
        return this.ofOptimisticComplete()
    }
    function __() {
        let e = this._connectorComplete$;
        if (!e) {
            if (this.isConnectorComplete)
                return Object(V.a)(this);
            e = new U.a,
            this._connectorComplete$ = e
        }
        return e
    }
    const S_ = e => {
        i_(e, "_connectorComplete$", !0)
    }
    ;
    function O_() {
        if (this.isConnectorComplete)
            return this.ofConnectorComplete();
        if (this.isConnectorComplete = !0,
        !this.isCancelling) {
            const t = this.mutations;
            try {
                for (const e in t)
                    if (!t[e]._doConnectorComplete())
                        break
            } catch (e) {
                this.error(e)
            }
        }
        return Ep.a.schedule(S_, 0, this),
        this.ofConnectorComplete()
    }
    function T_() {
        const e = this.sendToConnectorCompleteObserver;
        return this.sendToConnectorCompleteObserver = void 0,
        e ? (e.complete(),
        this.ofConnectorComplete()) : this._doConnectorComplete()
    }
    function I_(e) {
        return e ? this.isMainTrxComplete ? Object(V.a)(this) : (this._mainTrxComplete$ || (this._mainTrxComplete$ = new U.a),
        this._mainTrxComplete$.asObservable()) : this.isComplete ? Object(V.a)(this) : a_(this).asObservable()
    }
    function x_(e) {
        if ("boolean" !== typeof e && (e = !1),
        this.isComplete)
            return e ? Object(V.a)(this) : this;
        this.isComplete = !0,
        this.isUndoRedo && this._timeTravelComplete(),
        this.isOptimisticComplete || (this.isOptimisticComplete = !0,
        i_(this, "_execute$", !0),
        i_(this, "_optimisticComplete$", !0)),
        this.isConnectorComplete || this.connectorComplete(),
        s_(this),
        i_(this, "_followupQueries$"),
        i_(this, "_returnQueries$"),
        o_(this);
        const t = e ? [] : null
          , n = this.mutations;
        for (let r in n)
            n[r]._doComplete(t);
        return t ? t.length ? Object(wr.a)(t).pipe(Object(Or.a)(this)) : Object(V.a)(this) : this
    }
    function w_() {
        var e;
        if (this.isMainTrxComplete = !0,
        i_(this, "_mainTrxComplete$", !0),
        !this.closed)
            if (this.isUndoable) {
                const e = this.mutations;
                for (let t in e)
                    e[t].mainTrxComplete();
                !function(e) {
                    e._resp$ && i.b.schedule(m_, 5, e)
                }(this),
                this._removeFromStoresMap()
            } else
                e = this,
                i.b.schedule(g_, 5, e)
    }
    function M_() {
        if (this.closed)
            return;
        this.closed = !0,
        this.isComplete || (this.complete(),
        i_(this, "_resp$"));
        const e = this.mutations;
        if (this.isUndoable || this.isUndoRedo || this.undoController)
            for (let t in e)
                e[t]._doDestroy();
        else {
            let t, n = null;
            for (let r in e)
                !n && e[r].getMutationType(Gr.b, !0) && (n = [],
                t = e[r].model),
                e[r]._doDestroy(n);
            if (n && n.length)
                for (let e of n)
                    t.removeTimeTravelTs(e)
        }
        this.undoController = void 0,
        this.mutations = void 0,
        this.mutationsArray = void 0,
        this.indexPayload = void 0,
        this.activeRecord = void 0,
        this.plugin = void 0,
        this._respSub && (this._respSub.unsubscribe(),
        this._respSub = void 0),
        this.nestedStack && (this.nestedStack = void 0),
        this._executeWhenLogic && (this._executeWhenLogic = void 0),
        this.userRole = void 0,
        this._removeFromStoresMap()
    }
    function A_(e) {
        return console.warn("".concat(e.message, "\n").concat(e.stack)),
        this.cancel({
            statusCode: e.statusCode || e.publicStatusCode || 500,
            statusMessage: e.statusMessage || e.publicErrorMessage,
            error: e
        })
    }
    const E_ = e => {
        e._scheduledExecuteSub && (e._scheduledExecuteSub.unsubscribe(),
        e._scheduledExecuteSub = void 0)
    }
    ;
    function C_() {
        let e = this._execute$;
        if (!e) {
            if (this.isExecuting)
                return Object(V.a)(this);
            e = new U.a,
            this._execute$ = e
        }
        return e
    }
    function N_(e) {
        return E_(this),
        this.executeCount = 0,
        this.execute(e)
    }
    function R_() {
        return this.isExecuting || this.isCancelling || (E_(this),
        this.executeCount++),
        this
    }
    function P_() {
        return !this.isExecuting && !this.isCancelling && this.executeCount > 0 && this.executeCount--,
        this
    }
    function D_(e, t) {
        const n = e.storeConfig
          , r = n.storesMap;
        t.execute = function(e) {
            if (this.isExecuting || this.isCancelling)
                return this.ofComplete(e);
            if (this.executeCount > 0)
                return this.executeCount--,
                0 !== this.executeCount || this._scheduledExecuteSub || (this._scheduledExecuteSub = function(e, t) {
                    if (!t.schemaMutation$ || e.ignoreSchemaMutation)
                        return i.b.schedule(f_, 0, e);
                    const n = new p_(e);
                    return t.schemaMutation$.pipe(Object(T.a)()).subscribe(n),
                    n
                }(this, n)),
                this.ofComplete(e);
            if (this._scheduledExecuteSub)
                throw new Error("Off by one execution for mutation. Unable to execute.");
            return this.commitOnly(!1),
            this.hasSchemaChanges ? (this._scheduledExecuteSub = new p_(this),
            this.processSchemaChanges().pipe(Object(T.a)()).subscribe(this._scheduledExecuteSub),
            this.ofComplete(e)) : (this.isExecuting = !0,
            0 === this.modelActionCount ? (this.isOptimisticComplete = !0,
            this.connectorComplete(),
            this.isAcceptingFollowupQueries = !1,
            r.get(this).getAction(this.dispatchId).meta.pipe(Object(Y.a)(this.complete, this)).subscribe(new u_(a_(this))),
            i_(this, "_execute$", !0),
            i_(this, "_optimisticComplete$", !0),
            this.ofComplete(e)) : (this.permCheck ? this._doPermCheck() : this.isServer ? this.fetchMissingRecords() : this._doExecute(),
            this.ofComplete(e)))
        }
        ,
        t._doExecute = function() {
            this.permCheck = !1;
            const e = a_(this)
              , t = this.mutations
              , n = [];
            let i;
            for (let r in t) {
                if (!(i = t[r]._doExecute()))
                    return e;
                n.push(i)
            }
            return n.push(r.get(this).getAction(this.dispatchId).meta.asObservable()),
            this.isUndoable && this._registerAsUndoable(),
            this._respSub = Object(wr.a)(n).pipe(this.hasResultOperators ? Object(P.a)( () => this.complete(!0)) : Object(Y.a)(this.complete, this), Object(N.a)(e => (this.error(e),
            Object(V.a)(void 0)))).subscribe(new u_(e)),
            i_(this, "_execute$", !0),
            e
        }
        ,
        t.ofExecute = C_,
        t.executeNow = N_,
        t.incrementExecuteCount = R_,
        t.decrementExecuteCount = P_
    }
    function F_() {
        let {_returnQueries$: e} = this;
        if (!e || e.isStopped) {
            if (this.isReturnQueriesReady || this.isCancelling)
                return Object(V.a)(this);
            e = new xv.a(1),
            e.subscribe(),
            this._returnQueries$ = e
        }
        return e.asObservable()
    }
    function k_(e) {
        if (this.isCancelling)
            return this.ofReturnQueriesComplete();
        if (this.isReturnQueriesReady)
            return e && !e._isReturnQueriesReady && (e._isReturnQueriesReady = !0,
            this.returnQueriesReadyCount++),
            this.ofReturnQueriesComplete();
        if (!e || e._isReturnQueriesReady)
            return this.ofReturnQueriesComplete();
        if (e._isReturnQueriesReady = !0,
        this.returnQueriesReadyCount++,
        this.returnQueriesReadyCount !== this.modelActionCount)
            return this.ofReturnQueriesComplete();
        let t = null;
        const n = this.mutations;
        for (let i in n)
            t = n[i]._doExecuteReturnQueries(t);
        if (!t) {
            this.isReturnQueriesReady = !0;
            const {_returnQueries$: e} = this;
            return e ? (this._doExecuteFollowupQueries().subscribe(new u_(e)),
            e.asObservable()) : this._doExecuteFollowupQueries()
        }
        const r = this.ofReturnQueriesComplete();
        return this.isReturnQueriesReady = !0,
        Object(wr.a)(t).pipe(Object(P.a)( () => this._doExecuteFollowupQueries())).subscribe(new u_(this._returnQueries$)),
        r
    }
    var j_ = n(862);
    function L_(e, t, n) {
        if (!this.isAcceptingFollowupQueries) {
            let t;
            return t = Object(he.N)(e) || Object(he.T)(e) ? e.modelName : "(unknown, custom Observable provided)",
            this.error(new Error("Unable to add followup query for model ".concat(t, " because followup queries are already complete. Be sure to check the `isAcceptingFollowupQueries` property before calling addToFollowupQueries().")))
        }
        let r = this.followupQueries;
        if (r || (r = {},
        this.followupQueries = r),
        Object(he.N)(e))
            return ( (e, t, n, r) => {
                const i = t.modelName
                  , o = e[i];
                if ("object" === typeof n)
                    o ? o.__compound__ ? o.__compound__.push(n) : o.__compound__ = [n] : e[i] = {
                        __compound__: [n]
                    };
                else if (o) {
                    const e = o[n];
                    if (e)
                        if (Array.isArray(r))
                            for (let t of r)
                                e.indexOf(t) < 0 && e.push(t);
                        else
                            e.indexOf(r) < 0 && e.push(r);
                    else
                        o[n] = Array.isArray(r) ? [...r] : [r]
                } else
                    e[i] = {
                        [n]: Array.isArray(r) ? [...r] : [r]
                    }
            }
            )(r, e, t, n),
            this;
        let i, o = r.__queries__;
        if (o || (o = {},
        o.queriesSrc$ = new U.a,
        o.queries$ = o.queriesSrc$.pipe(Object(Rb.b)(), Object(_g.a)()),
        o.queriesSub = o.queries$.subscribe(),
        r.__queries__ = o),
        Object(he.T)(e)) {
            const t = {
                mutation: this
            };
            i = Object(qs.a)( () => e.fetch(t)),
            e._noDestroy || this.ofComplete().subscribe( () => e.destroy(t))
        } else
            i = e.pipe(Object(te.a)());
        return this.isOptimisticComplete || (i = this.ofOptimisticComplete().pipe(Object(j_.a)(i))),
        o.queriesSrc$.next(i),
        this
    }
    function V_(e, t) {
        if (this.isCancelling)
            return Object(V.a)(this);
        if (t)
            return this._doExecuteFollowupQueries(!0);
        e && !e._isFollowupQueriesReady && (e._isFollowupQueriesReady = !0,
        this.followupQueriesReadyCount++);
        let n = this._followupQueries$;
        if (!n) {
            if (!this.followupQueries && this.followupQueriesReadyCount === this.modelActionCount)
                return Object(V.a)(this);
            n = new xv.a(1),
            n.subscribe(),
            this._followupQueries$ = n
        }
        return this.followupQueriesReadyCount === this.modelActionCount && (this._followupQueries$ = void 0,
        this._doExecuteFollowupQueries().subscribe(new u_(n))),
        n.asObservable()
    }
    function U_(e) {
        const t = this.followupQueries;
        if (!t)
            return Object(V.a)(this);
        let n, r, i, o;
        if (!e && (r = t.__queries__)) {
            const {queriesSrc$: e, queries$: i, queriesSub: o} = r;
            n = [new S.a(t => {
                i.subscribe(new q_(t)),
                o.unsubscribe(),
                e.complete()
            }
            )],
            t.__queries__ = void 0,
            r.queriesSrc$ = void 0,
            r.queries$ = void 0,
            r.queriesSub = void 0
        }
        for (let s in t)
            if ("__queries__" !== s) {
                for (i in r = t[s],
                o = this.switchTo(s).model.query().selectAll("autoload"),
                r)
                    if ("__compound__" === i)
                        for (let e of r[i])
                            o.orWhere(e);
                    else
                        o.orWhereIn(i, r[i]);
                n ? n.push(o.fetch({
                    mutation: this
                })) : n = [o.fetch({
                    mutation: this
                })]
            }
        return n ? (this.followupQueries = e && (r = t.__queries__) ? {
            __queries__: r
        } : null,
        Object(wr.a)(n).pipe(Object(P.a)( () => this._doExecuteFollowupQueries(e)))) : Object(V.a)(this)
    }
    class q_ extends O.a {
        constructor(e) {
            super(),
            this.__origObserver = e
        }
        _error(e) {
            this.__origObserver.error(e),
            this.unsubscribe()
        }
        _complete() {
            this.__origObserver.next(null),
            this.__origObserver.complete(),
            super._complete()
        }
        unsubscribe() {
            super.unsubscribe(),
            this.__origObserver = void 0
        }
    }
    function Q_(e) {
        return this.isHistoryUpdateDisabled = !1 !== e,
        this
    }
    function B_() {
        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        return this.localOnlyStackIdx++,
        this.localOnlyStack[this.localOnlyStackIdx] = e,
        this
    }
    function G_() {
        return this.localOnlyStackIdx > 0 && (this.localOnlyStack.pop(),
        this.localOnlyStackIdx--),
        this
    }
    function z_() {
        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        return this.localOnlyStack[0] = e,
        this
    }
    class H_ {
        setProps(e, t, n) {
            if (this.parentVF = n,
            this.childRecords = void 0,
            this.childKeyValues = void 0,
            Object(he.O)(e) ? (this.parentMutation = e,
            this.parentQuery = null) : (this.parentMutation = e.mutation,
            this.parentQuery = e),
            Array.isArray(t)) {
                const e = {};
                let n = 0;
                for (let r of t)
                    e[r.__ID] = r,
                    n++;
                this.parentRecordsIsMany = n > 1,
                this.parentRecord = this.parentRecordsIsMany ? null : t[0],
                t = e
            } else if (Object(he.U)(t))
                this.parentRecordsIsMany = !1,
                this.parentRecord = t,
                t = {
                    [t.__ID]: t
                };
            else {
                const e = Object.keys(t);
                if (this.parentRecordsIsMany = e.length > 1,
                t[e[0]].__ID !== e[0]) {
                    const n = {};
                    let r;
                    for (let i = 0; i < e.length; i++)
                        r = t[e[i]],
                        e[i] = r.__ID,
                        n[e[i]] = r;
                    t = n
                }
                this.parentRecord = this.parentRecordsIsMany ? null : t[e[0]],
                n && n.ownFieldName !== n.ownModelPk || (this.childKeyValues = e)
            }
            return this.parentRecords = t,
            n ? (this.parentKey = n.ownFieldName,
            this.parentCacheFieldName = n.ownModelCacheMissingFieldName,
            this.childKey = n.ownRefFieldName,
            this.childRecords = void 0,
            this.childRecordsIsMany = void 0,
            this.childRecord = void 0,
            this.isMissingChildRecords = void 0) : (this.parentKey = this.parentMutation.primaryKey,
            this.parentCacheFieldName = void 0,
            this.childKey = this.parentKey,
            this.childRecords = this.parentRecords,
            this.childRecordsIsMany = this.parentRecordsIsMany,
            this.childRecord = this.parentRecord,
            this.isMissingChildRecords = !1),
            this
        }
        getVFRecords(e, t) {
            t || (t = this.childRecords);
            const n = e.bestVFName;
            let r, i, o;
            if (e.isMany) {
                let e, s;
                for (let a in t)
                    if (i = t[a],
                    (e = i[n]) && (r || (r = {})))
                        for (s in e)
                            o = e[s],
                            r[o.__ID] = o
            } else
                for (let s in t)
                    i = t[s],
                    (o = i[n]) && (r || (r = {})) && (r[o.__ID] = o);
            return r || null
        }
        checkForMissingRefs(e, t) {
            if (!t) {
                if (this.isMissingChildRecords)
                    return !0;
                t = this.childRecords
            }
            const n = e.ownModelCacheMissingFieldName;
            for (let r in t)
                if (t[r][n])
                    return !0;
            return !1
        }
        getChildRecords() {
            let {childRecords: e} = this;
            return e || null === e || (e = this.getVFRecords(this.parentVF, this.parentRecords),
            this.childRecords = e,
            this.parentRecordsIsMany || this.parentVF.isMany ? (this.childRecord = null,
            this.childRecordsIsMany = !0) : (this.childRecord = this.parentRecord[this.parentVF.VFName],
            this.childRecordsIsMany = !1)),
            e
        }
        getChildKeyValues() {
            let e = this.childKeyValues;
            if (e || null === e)
                return e;
            if (!this.parentVF)
                return e = Object.keys(this.parentRecords),
                this.childKeyValues = e,
                e;
            const {parentRecords: t, parentKey: n} = this;
            let r;
            e = Yn.a.checkoutSet();
            for (let i in t)
                r = t[i][n],
                (r || null !== r && "undefined" !== typeof r) && e.add(r);
            return this.childKeyValues = e.size ? [...e] : null,
            Yn.a.checkinSet(e),
            this.childKeyValues
        }
        addChildKeyValuesToQuery(e) {
            const t = this.parentVF
              , n = this.getChildKeyValues();
            return e.maybeConvertToGroupedQuery(),
            t && t.isManyToMany ? e.andWhere(t.ownRefModelVFName, e => e.whereIn(t.ownFieldName, n)) : e.andWhereIn(this.childKey, n),
            e
        }
        get isMissingChildRecords() {
            let e = this._isMissingChildRecords;
            if ("boolean" === typeof e)
                return e;
            const t = this.parentCacheFieldName;
            if (!t)
                return this._isMissingChildRecords = !0,
                !0;
            const n = this.parentRecords;
            e = !1;
            for (let r in n)
                if (n[r][t]) {
                    e = !0;
                    break
                }
            return this._isMissingChildRecords = e,
            e
        }
        set isMissingChildRecords(e) {
            this._isMissingChildRecords = e
        }
    }
    function K_(e) {
        return this.nestedStack ? this.nestedStackIdx = this.nestedStack.push(e) - 1 : (this.nestedStack = [e],
        this.nestedStackIdx = 0),
        this
    }
    function Y_() {
        const e = this.nestedStackIdx;
        return 0 === e ? this.nestedStack.splice(0, 1) : (this.nestedStack.splice(e, 1),
        this.nestedStackIdx = e - 1),
        this
    }
    function W_() {
        return this.nestedStack && this.nestedStack[this.nestedStackIdx] || null
    }
    function $_(e, t, n) {
        return (new H_).setProps(e, t, n)
    }
    let X_;
    function J_(e) {
        e || (e = "Permission Denied.");
        const {mutations: t} = this;
        for (let n in t)
            t[n].permDenied(e);
        return this.cancel()
    }
    X_ = n(596).client;
    class Z_ extends O.a {
        constructor(e, t) {
            super(),
            this.__controller = e,
            this.__observer = t
        }
        _complete() {
            const e = this.__controller;
            e && (e._processIndexesToAddInFlight().subscribe(this.__observer),
            super._complete())
        }
        unsubscribe() {
            super.unsubscribe(),
            this.__controller = void 0,
            this.__observer = void 0
        }
    }
    const eS = (e, t, n) => {
        if ((e => {
            const {schemaMutation$: t} = e;
            t && (e.schemaMutation = null,
            e.schemaMutation$ = null,
            t.next(),
            t.complete())
        }
        )(n),
        t.length) {
            for (let e = 0; e < t.length; e++)
                t[e] = t[e].execute();
            return Object(wr.a)(t).pipe(Object(Y.a)( () => (e._processAddRemoveIndexesComplete(!1),
            e)))
        }
        return e._processAddRemoveIndexesComplete(!1),
        Object(V.a)(e)
    }
    ;
    function tS() {
        return this._processAddRemoveIndexesComplete(!0),
        this
    }
    function nS(e) {
        return this.createModels({
            [e.name]: e
        })[e.name]
    }
    function rS(e) {
        const {mutations: t} = this
          , n = e ? "indexesToRemove" : "indexesToAdd";
        let r;
        for (let i in t)
            r = t[i],
            r[n] && r._processAddRemoveIndexesComplete(e)
    }
    function iS(e, t) {
        const n = e.storeConfig
          , r = n.storesMap;
        t.createModels = function(e) {
            const t = {
                modelSchemas: e,
                mutation: this
            };
            return r.get(this).dispatch(c.c, t).meta.subscribe(),
            t.models
        }
        ,
        t.processSchemaChanges = function() {
            return this.hasIndexesToRemove ? this.processIndexesToRemove().pipe(Object(P.a)( () => this.processSchemaChanges())) : this.processIndexesToAdd()
        }
        ,
        t.processIndexesToRemove = function() {
            if (!this.hasIndexesToRemove)
                return Object(V.a)(this);
            if (n.schemaMutation$ && n.schemaMutation !== this)
                return n.schemaMutation$.pipe(Object(P.a)( () => this.processIndexesToRemove()));
            this.hasIndexesToRemove = !1;
            const t = this.mutations
              , r = []
              , i = e.network.createDispatchId();
            let o;
            for (let e in t)
                o = t[e],
                o.indexesToRemove && o._processIndexesToRemove(i, r);
            return Object(wr.a)(r).pipe(Object(Y.a)(tS, this))
        }
        ,
        t.processIndexesToAdd = function() {
            if (!this.hasIndexesToAdd)
                return Object(V.a)(this);
            const t = ( (e, t) => {
                const n = t.storeConfig;
                if (n.schemaMutation$) {
                    if (n.schemaMutation !== e)
                        return new S.a(e => {
                            n.schemaMutation$ ? n.schemaMutation$.subscribe(e) : (e.next(),
                            e.complete())
                        }
                        )
                } else
                    n.schemaMutation = e,
                    n.schemaMutation$ = new U.a;
                const r = t.pendingStoreMgr.children;
                if (r.size < 2)
                    return null;
                const i = e.mainDispatchId
                  , {schemaMutation$: o} = n;
                let s, a, c;
                for (let[u,l] of r)
                    u !== i && (c = l.store.value.mutation) && c.isExecuting && (c.isAcceptingFollowupQueries ? (s || (s = Object(qs.a)( () => n.schemaMutation$ === o ? o : Object(V.a)(null))),
                    c.addToFollowupQueries(s)) : a ? a.push(c.ofComplete()) : a = [c.ofComplete()]);
                return a ? Object(wr.a)(a) : null
            }
            )(this, e);
            if (t)
                return t.pipe(Object(P.a)( () => this.processIndexesToAdd()));
            this.hasIndexesToAdd = !1;
            const {mutations: n} = this;
            let i;
            const o = this.constructor.get().localOnly();
            o.ignoreSchemaMutation = !0;
            let s = o.mainDispatchId;
            const a = [];
            let c;
            const u = e => {
                i = r.get(e.model),
                s = e._processIndexesToAdd(o, s, a)
            }
            ;
            for (let e in n)
                c = n[e],
                c.indexesToAdd && Ep.a.schedule(u, 0, c);
            const l = r.get(o);
            return new S.a(e => {
                Ep.a.schedule( () => {
                    a.length ? Object(wr.a)(a).subscribe(e) : (console.warn("[Controller -> processIndexesToAdd()]: PROBLEM - See fn"),
                    e.next(),
                    e.complete())
                }
                , 0)
            }
            ).pipe(Object(P.a)( () => o.execute()), Object(j_.a)(new S.a(e => {
                l.closed ? this._processIndexesToAddInFlight().subscribe(e) : l.subscribe(new Z_(this,e))
            }
            )))
        }
        ,
        t._processIndexesToAddInFlight = function() {
            const {mutations: t} = this
              , r = []
              , i = ( (e, t, n) => {
                const r = e.pendingStoreMgr.children;
                return (e, i) => {
                    if (e === t.mainDispatchId)
                        return t.getModelMutation(i);
                    let o = r.get(e).store.value.mutation;
                    return o || (o = t.constructor.get(),
                    n.push(o)),
                    i ? o.getModelMutation(i) : o
                }
            }
            )(e, this, r)
              , o = (e => {
                const t = e.pendingStoreMgr.children
                  , n = {};
                for (let[r] of t)
                    n[r] = r;
                return n
            }
            )(e)
              , s = [];
            let a, c;
            const u = e => {
                e._processIndexesToAddInFlight(i, o, s)
            }
            ;
            for (a in t)
                c = t[a],
                c.indexesToAdd && Ep.a.schedule(u, 0, c);
            return new S.a(e => {
                Ep.a.schedule( () => {
                    s.length ? Object(wr.a)(s).pipe(Object(P.a)( () => eS(this, r, n))).subscribe(e) : eS(this, r, n).subscribe(e)
                }
                , 0)
            }
            )
        }
        ,
        t.createModel = nS,
        t._processAddRemoveIndexesComplete = rS
    }
    function oS() {
        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        return this.isExecuting || (this.isUndoable = e),
        this
    }
    function sS(e) {
        return this.undo(e, !0)
    }
    class aS extends O.a {
        constructor(e) {
            super(),
            this.__ctrl = e
        }
        _error(e) {
            this.__ctrl.isComplete || this.__ctrl.isCancelling || this.__ctrl.error(e),
            this.unsubscribe()
        }
        unsubscribe() {
            super.unsubscribe(),
            this.__ctrl = void 0
        }
    }
    function cS(e) {
        return this.isConnectorComplete || this.isCancelling ? Object(V.a)(this) : (e.action && !e._hasSentToConnector && this.sendToConnectorReadyCount++,
        this.sendToConnectorReadyCount === this.modelActionCount && this._doSendToConnector().subscribe(new aS(this)),
        this.ofConnectorComplete())
    }
    class uS extends O.a {
        constructor(e) {
            super(),
            this.__ctrl = e
        }
        _next(e) {
            e.payload.error ? this.__ctrl.error(e.payload.error) : this.__ctrl.connectorComplete(),
            this.unsubscribe()
        }
        _error(e) {
            this.__ctrl.error(e),
            this.unsubscribe()
        }
        unsubscribe() {
            super.unsubscribe(),
            this.__ctrl = void 0
        }
    }
    function lS(e, t) {
        ( (e, t) => {
            t.sendToConnector = cS
        }
        )(0, t),
        function(e, t) {
            const n = e.storeConfig.storesMap;
            t._doSendToConnector = function() {
                const e = this.mutations;
                let t = null;
                for (let n in e)
                    if (t = e[n]._doSendToConnector(t),
                    this.isCancelling)
                        return Object(D.c)();
                if (!t)
                    return this.connectorComplete();
                this.hasSentToConnector = !0,
                this.isPersistentStateChange = !0;
                const r = n.get(this)
                  , i = r.dispatch(c.g, {
                    controller: this,
                    queries: t.queries
                }, this.mainDispatchId, !0);
                return r.getAction(this.dispatchId).payload.executionActions.push(i),
                i.meta.subscribe(new uS(this)),
                this.ofConnectorComplete()
            }
        }(e, t)
    }
    function dS(e) {
        const t = (e = e.mainStore).storeConfig
          , n = t.storesMap
          , r = t.isServer;
        class i {
            constructor(e, t) {
                this.actionType = c.n;
                const i = e.dispatch(this.actionType, {
                    controller: this,
                    executionActions: []
                }, t || null, !0).meta
                  , o = i.mainAction.payload;
                o.__callMainTrxComplete ? o.__callMainTrxComplete.push(this) : o.__callMainTrxComplete = [this],
                this.closed = !1,
                this.dispatchId = i.dispatchId,
                this.executeCount = 1,
                this.followupQueries = void 0,
                this.followupQueriesReadyCount = 0,
                this.hasApiLogRecord = !1,
                this.hasDataSource = !1,
                this.hasIndexesToAdd = !1,
                this.hasIndexesToRemove = !1,
                this.hasResultOperators = !1,
                this.hasSentToConnector = !1,
                this.indexPayload = {
                    controller: this
                },
                this.isAcceptingFollowupQueries = !0,
                this.isCancelling = !1,
                this.isCancelUndo = !1,
                this.isCommitOnly = !1,
                this.isComplete = !1,
                this.isConnectorComplete = !1,
                this.isExecuting = !1,
                this.isFromIPC = !1,
                this.isHistoryUpdateDisabled = !1,
                this.isIsolationRemoved = r,
                this.isMainTrxComplete = !1,
                this.isOptimisticComplete = !1,
                this.isPersistentStateChange = !1,
                this.isPersistentStateCommitted = !1,
                this.isRedo = !1,
                this.isUndo = !1,
                this.isUndoable = !!i.network.isUndoable,
                this.isReturnQueriesReady = !1,
                this.localOnlyStack = [!1],
                this.localOnlyStackIdx = 0,
                this.mainDispatchId = i.mainDispatchId,
                this.mutations = {},
                this.mutationsArray = void 0,
                this.modelCount = 0,
                this.modelActionCount = 0,
                this.optimisticCompleteCount = 0,
                this.permCheck = !1,
                this.sendToConnectorCompleteObserver = void 0,
                this.sendToConnectorFailCount = 0,
                this.sendToConnectorIteration = 0,
                this.sendToConnectorReadyCount = 0,
                this.sendToConnectorSyncOrder = 0,
                this.relationshipsToAdd = void 0,
                this.returnQueriesReadyCount = 0,
                this.ts = i.getTs(),
                this.undoController = void 0,
                this.userRole = void 0;
                const s = i.store;
                this.plugin = s.instance,
                s.value.mutation = this,
                n.set(this, s),
                i.subscribe()
            }
            static getWithInstance(e, t) {
                const r = n.get(e)
                  , i = r.value.mutation;
                return i ? (i.executeCount++,
                i) : t ? null : new this(r)
            }
            static get(t, n) {
                let r;
                if (t && (r = e.getPendingStore(t, !0))) {
                    const e = r.value.mutation;
                    if (e && e.isAcceptingFollowupQueries)
                        return e.isExecuting || e.executeCount++,
                        e
                } else
                    r = e;
                return n ? null : new this(r,t)
            }
            static initFromHistory(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                const i = this.get(n).commitOnly(r);
                return i.ts = e,
                i.undoRedoObservers$ = t,
                i.isFromHistory = !0,
                i.undoable(),
                i
            }
        }
        Object(L.b)(i, t.pluginMutationBase);
        const o = i.prototype;
        function s(e, t) {
            let r;
            if ("string" === typeof e) {
                if ((r = this.mutations[e]) || t)
                    return r || null;
                const n = this.getModel(e);
                if (!n)
                    return void this.error(Error('Unable to retrieve a mutation for model "'.concat(e, '" because it is not a model associated with the plugin that this mutation is associated with, or permission is denied.')));
                e = n
            } else if ((r = this.mutations[e.modelName]) || t)
                return r || null;
            const i = n.get(e).getBestStore(this.mainDispatchId);
            return new i.storeConfig.Mutation(i.instance,this)
        }
        return o.setTs = function(e) {
            return n.get(this).getAction(this.dispatchId).meta.setTs(e),
            this.ts = e,
            this
        }
        ,
        o.getModel = function(e) {
            return (n.get(this) || t.plugin).get(e)
        }
        ,
        o.getModelMutation = s,
        o.switchTo = s,
        o.getMutableRecord = function(e) {
            return this.switchTo(e.__typename).getMutableRecord(e)
        }
        ,
        o.getSession = function() {
            return n.get(this).getAction(this.mainDispatchId).meta.network.getSession() || null
        }
        ,
        o.removeIsolation = function() {
            return this.isIsolationRemoved || (this.isIsolationRemoved = !0,
            n.get(this).getAction(this.dispatchId).meta.removeLogic([d.a, d.b])),
            this
        }
        ,
        o._removeFromStoresMap = function() {
            n.delete(this)
        }
        ,
        o._timeTravelComplete = function() {
            t.plugin.addRemoveTimeTravelMutation(this, !0)
        }
        ,
        function(e, t) {
            const n = e.storeConfig.storesMap;
            t.cancel = function(e) {
                if (this.isCancelling || this.isComplete)
                    return this.ofComplete();
                this.isCancelling = !0;
                const {mutations: t} = this;
                for (const n in t)
                    t[n].isCancelling = !0;
                const r = n.get(this).getAction(this.dispatchId)
                  , i = r.payload.executionActions;
                let o = void 0;
                if (console.log("CANCELLING MUTATION, isCancelUndo ?? ".concat(this.isCancelUndo)),
                i && i.length) {
                    for (let e of i)
                        e.meta.network && (o || (o = []),
                        o.push(e.meta.asObservable()));
                    if (i.length = 0,
                    o) {
                        const t = () => {
                            this.isCancelling = !1,
                            this.cancel(e)
                        }
                        ;
                        return Object(wr.a)(o).subscribe({
                            error: t,
                            complete: t
                        }),
                        this.ofComplete()
                    }
                }
                if (!this.isConnectorComplete) {
                    const t = () => {
                        this.isCancelling = !1,
                        this.cancel(e)
                    }
                    ;
                    return this.ofConnectorComplete().subscribe({
                        error: t,
                        complete: t
                    }),
                    this.connectorComplete(),
                    this.ofComplete()
                }
                const s = r.meta;
                let a = !this.isPersistentStateCommitted;
                if (this.isServer && a) {
                    const {mutations: e} = this;
                    for (const t in e)
                        try {
                            o = e[t]._rollbackExternalChanges(o)
                        } catch (l) {
                            console.log("ERROR CALLING ".concat(t, " mutation's _rollbackExternalChanges() = ").concat(l.message))
                        }
                    o && (o = Object(wr.a)(o).pipe(Object(N.a)(e => (console.error("[Plugin Mutation] cancel() -> ERROR in Observable(s) returned from modelMutation._rollbackExternalChanges(): ".concat(e.message, "\n\n").concat(e.stack, "\n\nPROCEEDING WITH CANCELLING.")),
                    Object(D.c)()))))
                }
                o_(this),
                s_(this),
                this.isAcceptingFollowupQueries = !1;
                const c = a_(this);
                s.store.value.mutation = null;
                let u = null;
                a && (!this.isExecuting || !this.modelActionCount || !this.isOptimisticComplete && s.willEmitOp(h.f, !0)) || this.isCancelUndo || (u = this.constructor.get(this.dispatchId).localOnly(a),
                u.isUndo = !0,
                u.isUndoable = !1),
                this.isUndoable && n.get(this).instance.removeTimeTravelTs(this.ts),
                this.undoController = u,
                this._respSub && (this._respSub.unsubscribe(),
                this._respSub = void 0);
                for (let n in t)
                    t[n]._doCancel(e);
                return o = o ? o.pipe(Object(P.a)( () => (console.log("DONE ROLLING BACK EXTERNAL CHANGES"),
                s.network ? s.network.cancel() : Object(D.c)()))) : Object(qs.a)( () => s.network ? s.network.cancel() : Object(D.c)()),
                u && (u.isCancelUndo = !0,
                o = o.pipe(Object(P.a)( () => this.undo(u).execute()))),
                o.pipe(Object(Y.a)( () => this._doCancelComplete(e))).subscribe(new u_(c)),
                c
            }
            ,
            t._doCancelComplete = l_,
            t.ofCancelling = d_
        }(e, o),
        D_(e, o),
        function(e, t) {
            t.permDenied = J_,
            X_(e, t)
        }(e, o),
        iS(e, o),
        function(e, t) {
            const n = e.storeConfig.storesMap;
            t.undo = function(e, t) {
                let r;
                Object(he.Q)(e) ? r = e : (r = this.constructor.get(e).undoable(!0).setTs(this.ts),
                r.isRedo = !!t,
                r.isUndo = !t,
                n.get(r).instance.addRemoveTimeTravelMutation(r));
                const i = this.mutations;
                for (let n in i)
                    i[n]._doUndo(r);
                return this.mainDispatchId !== r.mainDispatchId && n.get(r).getAction(r.dispatchId).meta.mainAction.payload.__callMainTrxComplete.push(this),
                this.isUndoable = !1,
                this.undoController = r,
                r
            }
            ,
            t.redo = sS,
            t.undoable = oS
        }(e, o),
        r_(o),
        o._doConnectorComplete = O_,
        o._doExecuteFollowupQueries = U_,
        o.addToFollowupQueries = L_,
        o.commitOnly = h_,
        o.complete = x_,
        o.connectorComplete = T_,
        o.createNestedData = $_,
        o.destroy = M_,
        o.disableHistoryUpdate = Q_,
        o.error = A_,
        o.executeFollowupQueries = V_,
        o.executeReturnQueries = k_,
        o.getNestedData = W_,
        o.localOnly = z_,
        o.localOnlyStart = B_,
        o.localOnlyFinish = G_,
        o.mainTrxComplete = w_,
        o.nestedFinish = Y_,
        o.nestedStart = K_,
        o.ofComplete = I_,
        o.ofConnectorComplete = __,
        o.ofOptimisticComplete = y_,
        o.ofReturnQueriesComplete = F_,
        o.optimisticComplete = b_,
        Object.defineProperties(o, function(e, t) {
            if (t)
                for (let n in n_)
                    t[n] = n_[n];
            else
                t = {
                    ...n_
                };
            return t.__pluginId = e.pluginAccessors.__pluginId,
            t.__pluginSlug = e.pluginAccessors.__pluginSlug,
            t.isServer = e.pluginAccessors.isServer,
            t.types = e.pluginAccessors.types,
            t
        }(t)),
        Object(he.z)(i, he.r.MUTATION_CONTROLLER),
        Object(he.A)(i, he.r.MUTATION),
        lS(e, o),
        i
    }
    const hS = Xm.a.initModule("@isomorix/plugin/logic")
      , fS = Xm.a.initModule("@isomorix/plugin/logic").addSource(hv.a).useSources().addSource(hS);
    var pS = n(16);
    const gS = (e, t) => {
        let n = t[0];
        if (e.hasAction(n.mainDispatchId))
            for (n of t)
                n.isUndoable = !1;
        else
            for (n of t)
                n.destroy()
    }
    ;
    function mS(e, t) {
        const n = e.storeConfig
          , {futureMutations: r, pastMutations: i} = n
          , o = () => {
            if (r.length) {
                for (let t of r)
                    gS(e, t);
                n.futureMutations.length = 0
            }
        }
          , s = (e, t) => {
            const n = t.length;
            let r = 0;
            for (; r < n; ) {
                if (t[r].ts === e)
                    return r;
                r++
            }
            return -1
        }
        ;
        t._doRemoveTimeTravelTs = function(t, a) {
            const {currentMutations: c} = n;
            if (!a)
                return ( () => {
                    if (i.length) {
                        for (let t of i)
                            gS(e, t);
                        n.pastMutations.length = 0
                    }
                }
                )(),
                o(),
                void (c && (gS(e, c),
                n.currentMutations = void 0));
            let u = s(t, r);
            u > -1 ? (gS(e, r[u]),
            r.splice(u, 1)) : (u = s(t, i)) > -1 && (gS(e, i[u]),
            i.splice(u, 1)),
            c && c.ts === a || (c && gS(e, c),
            (u = s(a, i)) > -1 ? (n.currentMutations = i[u],
            i.splice(u, 1)) : (u = s(a, r)) > -1 && (n.currentMutations = r[u],
            r.splice(u, 1)))
        }
        ,
        t._doRegisterUndoableMutation = function(t, r) {
            let {currentMutations: i} = n;
            return i && i.ts !== t && (i[0].isUndo ? gS(e, i) : n.pastMutations.push(i),
            i = void 0),
            r && (i || (i = [],
            i.ts = t),
            i.push(r)),
            n.currentMutations = i,
            o(),
            this
        }
        ,
        t._doUndo = function(e, t) {
            let {currentMutations: r} = n;
            if (!r)
                return null;
            if (r[0].isUndo) {
                const t = n.pastMutations[n.pastMutations.length - 1];
                if (!t || t.ts !== e)
                    return null;
                n.futureMutations.unshift(r),
                r = t,
                n.pastMutations.pop()
            } else if (r.ts !== e)
                return null;
            let i = void 0;
            for (let n of r)
                i = n.undo(i || t);
            const o = [i];
            return o.ts = e,
            n.currentMutations = o,
            i
        }
        ,
        t._doRedo = function(e, t) {
            let {currentMutations: r} = n;
            if (!r)
                return null;
            if (r[0].isRedo) {
                const t = n.futureMutations[0];
                if (!t || t.ts !== e)
                    return null;
                n.pastMutations.push(r),
                r = t,
                n.futureMutations.shift()
            } else if (r.ts !== e)
                return null;
            n.currentMutations = void 0;
            let i = void 0;
            for (let n of r)
                i = n.redo(i || t);
            const o = [i];
            return o.ts = e,
            n.currentMutations = o,
            i
        }
    }
    function yS() {
        return this.getState()
    }
    function vS(e) {
        const t = (e = e.mainStore).storeConfig
          , n = t.StoreWrapper
          , {sharedCore: r, storesMap: i} = t;
        if (!n || !r || !i)
            throw new Error("Unable to create Plugin mixin because `store.storeConfig.sharedCore`, `store.storeConfig.StoreWrapper`, and/or `store.storeConfig.storesMap` does not exist. All 3 are needed in order to create the Plugin class.");
        class o extends n {
        }
        Object(L.b)(o, r),
        Object(he.z)(o, he.r.PLUGIN),
        function(e, t) {
            const n = e.storeConfig;
            t.__ID = {
                get: () => n.pluginRecord[ev.a.PLUGIN],
                set: void 0,
                enumerable: !1
            },
            t.__pluginId = t.__ID,
            t.__pluginSlug = {
                value: n.pluginRecord.slug,
                writable: !1,
                enumerable: !1
            },
            t.__typename = {
                value: null,
                enumerable: !1,
                writable: !1
            },
            t.__types = {
                get: () => n.types,
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.clientConnections = {
                get: () => n.clientConnections,
                set: void 0,
                enumerable: !1,
                configurable: !1
            },
            t.connections = {
                get: () => n.connections,
                set: void 0,
                enumerable: !1,
                configurable: !1
            },
            t.Cookie = {
                get: () => n.Cookie,
                set: void 0,
                enumerable: !1
            },
            t.directives = {
                get: () => n.pluginRecord.directives,
                set: void 0,
                enumerable: !1
            },
            t.envParser = {
                get: () => n.envParser,
                set: void 0,
                enumerable: !1
            },
            t.isServer = {
                value: n.isServer,
                configurable: !1,
                writable: !1,
                enumerable: !1
            },
            t.isStateChangesIPCEnabled = {
                get: () => n.isStateChangesIPCEnabled
            },
            t.lastPersistentStateChangeAt = {
                get: () => n.lastPersistentStateChangeAt
            },
            t.localStorage = {
                get: () => n.localStorage,
                set: void 0,
                enumerable: !1
            },
            t.pluginRecord = {
                get: () => n.pluginRecord,
                set(e) {
                    n.pluginRecord = e;
                    let t = e.types;
                    if (t && (n.types = t),
                    Object(he.U)(e) && Object(he.R)(e)) {
                        const t = e.getMainInstance();
                        e.subscribe({
                            complete: () => {
                                n.pluginRecord = t
                            }
                        })
                    }
                },
                enumerable: !1,
                configurable: !0
            },
            t.processEnv = {
                get: () => n.processEnv,
                set: void 0,
                enumerable: !1,
                configurable: !0
            },
            t.sessionStorage = {
                get: () => n.sessionStorage,
                set: void 0,
                enumerable: !1
            },
            t.schema = {
                get: () => n.pluginRecord.schema,
                set: void 0,
                enumerable: !1
            },
            t.slug = t.__pluginSlug,
            t.timeTravelInFlight = {
                get: () => n.timeTravelInFlight,
                set: void 0,
                enumerable: !1,
                configurable: !1
            },
            t.types = t.__types,
            t.volumesAbsPath = {
                get: () => n.volumesAbsPath,
                set: void 0,
                enumerable: !1,
                configurable: !1
            }
        }(e, t.pluginAccessors);
        const s = o.prototype;
        return function(e, t) {
            const n = e.storeConfig
              , r = e.storeConfig.storesMap;
            let i;
            t.executeQuery = function(e) {
                const t = e.action
                  , n = r.get(this).dispatch(c.h, e, t ? t.meta.mainDispatchId : e.__didPrepare ? e.dispatchId : e.dispatchId ? r.get(this).network.getMainDispatchId(e.dispatchId) : void 0).meta;
                return t || (e.dispatchId = n.mainDispatchId),
                n.pipe(Object(Or.a)(e))
            }
            ;
            const o = n.directQueryQueueSrc$;
            o.pipe(Object(T.a)(), Object(P.a)( () => {
                const e = i;
                return i = void 0,
                e.length ? n.plugin.executeDirectQuery({
                    payloads: e
                }) : Object(D.c)()
            }
            ), Object(Y.a)(e => {
                if (!e)
                    return;
                const {payloads: t} = e;
                let n;
                for (const i of t) {
                    n = i.__directObserver,
                    i.__directObserver = void 0;
                    try {
                        n.next(i),
                        n.complete()
                    } catch (r) {}
                }
            }
            )).subscribe();
            const s = Object(N.a)(e => Object(D.c)());
            function a(e, t) {
                return "undefined" === typeof e ? n.Mutation.getWithInstance(this, t) : n.Mutation.get(e, t)
            }
            t.executeDirectQuery = function(e) {
                return e.payloads ? r.get(this).mainStore.dispatchMain(pS.a, e).meta.pipe(s, Object(Or.a)(e)) : new S.a(t => {
                    e.__directObserver = t,
                    i ? i.push(e) : (i = [e],
                    o.next())
                }
                )
            }
            ,
            t.executeDbSyncSchema = function(e, t) {
                const n = r.get(this);
                t && (t = n.network.getMainDispatchId(t));
                const i = n.dispatch(c.t, e, t).meta;
                return e.dispatchId = i.mainDispatchId,
                i.pipe(Object(Or.a)(e))
            }
            ,
            t.executeBuildModels = function(e, t) {
                const n = r.get(this);
                let {mutation: i} = e;
                t && (t = n.network.getMainDispatchId(t)),
                !i || i.isComplete ? (i = this.mutation(t),
                e.mutation = i,
                i.decrementExecuteCount()) : (i = i.controller,
                e.mutation = i),
                t || (t = i.mainDispatchId),
                !e.modelSchemas && e.schema && (e.modelSchemas = e.schema.models);
                let {entity: o} = e;
                return (o || e.schema && (o = e.schema.entity)) && (e.entity = i.getMutableRecord(o)),
                n.dispatch(c.c, e, t).meta.pipe(Object(Or.a)(e))
            }
            ,
            t.executeSubscription = function(e) {
                const t = e.action;
                return r.get(this).dispatch(c.i, e, t ? t.meta.mainDispatchId : void 0).meta.pipe(Object(Or.a)(e))
            }
            ,
            t.mutation = a,
            t.pluginMutation = a,
            t.mutationDangerouslyInitAsCommitOnly = function(e, t) {
                const n = this.mutation(e, t);
                return n ? n.commitOnly(!0) : n
            }
            ,
            t.addRemoveTimeTravelMutation = function(e, t) {
                t ? n.timeTravelInFlight.delete(e) : n.timeTravelInFlight.add(e)
            }
            ,
            t.getModelNameFromGraphqlOperation = function(e) {
                return n.pluginRecord.schema.graphqlOpsToModelName[e]
            }
        }(e, s),
        mS(e, s),
        s.dispatch = o.createDispatchMethod(t.pluginDispatchers),
        s.getConnection = function(e, n) {
            return t.connections[e] ? t.connections[e](n) : null
        }
        ,
        s.getModels = yS,
        o
    }
    const bS = {
        ensureMixin: function(e, t, n) {
            const r = e.meta.store
              , i = r.storeConfig;
            return i[t] || (i[t] = n(r)),
            e
        }
    };
    var _S = n(238)
      , SS = n.n(_S);
    class OS {
        constructor(e) {
            this.prefix = e
        }
        getItem(e) {
            return localStorage.getItem("".concat(this.prefix, "__").concat(e))
        }
        setItem(e, t) {
            return localStorage.setItem("".concat(this.prefix, "__").concat(e), t)
        }
    }
    class TS {
        constructor(e) {
            this.prefix = e
        }
        getItem(e) {
            return sessionStorage.getItem("".concat(this.prefix, "__").concat(e))
        }
        setItem(e, t) {
            return sessionStorage.setItem("".concat(this.prefix, "__").concat(e), t)
        }
    }
    class IS {
        constructor(e) {
            this.prefix = e
        }
        get(e) {
            return SS.a.get("".concat(this.prefix, "__").concat(e))
        }
        set(e, t, n) {
            SS.a.set("".concat(this.prefix, "__").concat(e), t, n)
        }
        remove(e, t) {
            SS.a.remove("".concat(this.prefix, "__").concat(e), t)
        }
    }
    let xS, wS, MS;
    {
        const e = {};
        xS = e,
        wS = e,
        MS = e
    }
    const AS = fS.getBuilder(c.o, "./init").setPure(!0);
    AS.use().setName("trxPrepare").setActionType(c.c, !0).setActionType(kl.d, !0).setDescription(xS.trxPrepare).setOp(f.f).setPriority(0).setTrxSync(h.k, f.f).add((function(e) {
        return e
    }
    ), !0);
    AS.useRelative(100).setName("prepareAction").setDescription(xS.prepareAction).add((function(e) {
        e.payload.pluginBuilder.setAction(e);
        const t = e.meta.store
          , n = t.mainStore;
        return t.subscribe({
            complete: () => {
                setTimeout( () => {
                    if (n.closed)
                        return;
                    const e = n.pendingStoreMgr
                      , t = (e => {
                        const t = [];
                        for (let n of e)
                            n[l.a] === c.o && t.push(n);
                        return t
                    }
                    )(e.logicArray);
                    t.length && e.removeLogic(t, "all", "all")
                }
                , 2e3)
            }
        }),
        e
    }
    ), !0),
    AS.useRelative(100).setName("preparePrefixedStorage").setDescription(xS.preparePrefixedStorage).add((function(e) {
        const t = e.meta.store;
        if (t.network.isServer)
            return e;
        const n = t.storeConfig
          , r = n.pluginRecord.slug;
        return n.Cookie || (n.Cookie = new IS(r)),
        n.localStorage || (n.localStorage = new OS(r)),
        n.sessionStorage || (n.sessionStorage = new TS(r)),
        e
    }
    ), !0),
    AS.useRelative(100).setName("initConnections").setDescription(xS.initConnections).addTo(hS),
    AS.useRelative(100).setName("preparePluginState").setDescription(xS.preparePluginState).setPure(!1).addTo(hS),
    AS.useRelative(100).setName("prepareStoreWrapper").setDescription(xS.prepareStoreWrapper).add((function(e) {
        return e.payload.pluginBuilder.setStoreWrapper(),
        e
    }
    ), !0),
    AS.useRelative(100).setName("prepareSharedCore").setDescription(xS.prepareSharedCore).addTo(hS),
    AS.useRelative(100).setName("preparePluginMixin").setDescription(xS.preparePluginMixin).add((function(e) {
        return bS.ensureMixin(e, "Plugin", vS)
    }
    ), !0),
    AS.useRelative(100).setName("createPluginInstance").setDescription(xS.createPluginInstance).add((function(e) {
        return e.payload.pluginBuilder.createInstance(),
        e
    }
    ), !0),
    AS.useRelative(100).setName("defineScalarAndEnumTypes").setDescription(xS.defineScalarAndEnumTypes).addTo(hS),
    AS.useRelative(100).setName("prepareMutationBases").setDescription(xS.prepareMutationBases).addTo(hS),
    AS.useRelative(100).setName("preparePluginMutation").setDescription(xS.preparePluginMutation).add((function(e) {
        return bS.ensureMixin(e, "Mutation", dS)
    }
    ), !0),
    AS.useRelative(100).setName("prepareModelQuery").setDescription(xS.prepareModelQuery).add((function(e) {
        return bS.ensureMixin(e, "ModelQuery", Gu)
    }
    ), !0),
    AS.useRelative(100).setName("prepareModelMutation").setDescription(xS.prepareModelMutation).add((function(e) {
        return bS.ensureMixin(e, "ModelMutation", zy)
    }
    ), !0),
    AS.useRelative(100).setName("defineRolesAndDirectives").setDescription(xS.defineRolesAndDirectives).addTo(hS),
    AS.useRelative(100).setName("prepareModelMixin").setDescription(xS.prepareModelMixin).add((function(e) {
        return bS.ensureMixin(e, "Model", nv)
    }
    ), !0),
    AS.useRelative(100).setName("prepareRecordMixin").setDescription(xS.prepareRecordMixin).add((function(e) {
        return bS.ensureMixin(e, "Record", qb)
    }
    ), !0),
    AS.useRelative(100).setName("prepareRecordResult").setDescription(xS.prepareRecordResult).add((function(e) {
        return bS.ensureMixin(e, "RecordResult", t_)
    }
    ), !0),
    AS.useRelative(100).setName("preparePluginSchema").setPriority(100).setTransformOp().setPure(!1).add((function(e, t) {
        const {payload: n} = e
          , {pluginRecord: r} = e.meta.store.storeConfig
          , i = r.schema;
        return n.fromCache ? (i.setSchemaData(r.schemaData),
        Object(Ov.a)(i.addAsync().pipe(Object(P.a)( () => (n.modelSchemas = i.models,
        n.initHistoryDisabled || i.initHistory(),
        Object(T.b)()))), e, t)) : (i.create({
            models: n.modelSchemas,
            directives: r.directives
        }),
        r.schema.defineDefaultDirectives(),
        n.modelSchemas = r.schema.models,
        Object(Ov.a)(Object(T.b)(), e, t))
    }
    ), !0),
    AS.useRelative(100).setName("initModelBuilders").setActionType(c.c, !0).setDescription(xS.initModelBuilders).add((function(e) {
        const t = e.payload
          , n = t.modelSchemas;
        let r = t.models;
        if (r || (r = {},
        t.models = r),
        !n)
            return e;
        const i = t.ModelBuilder || yb
          , o = e.meta.store
          , s = o.storeConfig
          , a = t.modelStateChangeTimestamps
          , {Model: c, Record: u, RecordResult: l, ModelMutation: d, ModelQuery: h, modelStoreConfigs: f, pendingRecordLogic: p} = s;
        let g, m, y, v;
        for (let _ in n)
            (g = r[_]) || (g = i.init(i.createStoreConfig(n[_])).setParentStore(o).setModel(c).setRecord(u).setRecordResult(l).setQuery(h).setMutation(d),
            r[_] = g),
            a && (m = g.storeConfig,
            y = m.schema,
            !y.isHistory && (v = a[m.schema.id]) && v > m.lastPersistentStateChangeAt && (m.lastPersistentStateChangeAt = v)),
            f[_] = g.storeConfig,
            p && p[_] && (g.getRecordBuilder().addPendingLogic(p[_]),
            p[_] = void 0);
        if (t.modelFns) {
            const e = t.modelFns;
            for (const t in e)
                if (r[t])
                    try {
                        e[t](r[t])
                    } catch (b) {}
        }
        return e
    }
    ), !0);
    const ES = (e, t, n, r) => {
        if (!t)
            return new S.a(t => {
                ES(e, t, n, !0)
            }
            );
        const o = e.payload.modelNames.length;
        !function(e, t) {
            const {length: n, batchSize: r, scheduler: i} = t;
            let o, s = 0;
            for (; ; ) {
                if (o = s + r,
                o >= n) {
                    o = n,
                    i.schedule(e, 0, {
                        startIdx: s,
                        stopIdx: o
                    });
                    break
                }
                i.schedule(e, 0, {
                    startIdx: s,
                    stopIdx: o
                }),
                s = o
            }
        }(n, {
            length: o,
            batchSize: 4,
            scheduler: i.b
        }),
        i.b.schedule( () => {
            r && t.next(e),
            t.complete()
        }
        , 0)
    }
    ;
    let CS = Qs.a;
    AS.useRelative(100).setName("createModelStores").setActionType(c.c, !0).setDescription(xS.createModelStores).setPure(!1).add((function(e, t) {
        const {payload: n} = e
          , {models: r} = n
          , i = Object.keys(r);
        let o;
        return n.modelNames = i,
        ES(e, t, e => {
            let {startIdx: t, stopIdx: n} = e;
            for (; t < n; )
                o = r[i[t]],
                o.store || (CS(o),
                o.createStore()),
                t++
        }
        )
    }
    ), !0),
    AS.useRelative(100).setName("initModels").setActionType(c.c, !0).setPure(!1).setDescription(xS.initModels).add((function(e, t) {
        const {meta: {store: {value: n}}, payload: {models: r, modelNames: i}} = e;
        return n.setAsModelRefChange(),
        ES(e, t, e => {
            let t, {startIdx: o, stopIdx: s} = e;
            for (; o < s; )
                t = i[o],
                Object(he.N)(r[t]) || (r[t] = r[t].createInstance()),
                n.set(t, r[t]),
                o++
        }
        )
    }
    ), !0),
    AS.useRelative(100).setName("trxOptimisticCommitAndReducers").setActionType(c.c, !0).setTrxSync(h.f, f.g).setTrxSync(h.j, f.g).setDescription(xS.trxOptimisticCommitAndReducers).add((function(e) {
        return e
    }
    ), !0),
    AS.useRelative(100).setName("createRelationships").setPure(!1).setActionType(c.c, !0).setDescription(xS.createRelationships).add((function(e) {
        const t = e.meta.store.storeConfig
          , {payload: n} = e;
        let r;
        n.disableHydrateIndexes || (r = n.mutation) || e.type === c.o || (r = e.meta.instance.mutation(e.meta.mainDispatchId),
        n.mutation = r);
        const i = n.schema || t.pluginRecord.schema
          , {models: o} = n;
        return Object(T.b)().pipe(Object(P.a)( () => n.fromCache ? i.activateSchema(r, o) : i.activateCreatedSchema(r, o)), Object(T.a)(), Object(Y.a)( () => {
            for (let e in o)
                o[e].initComplete();
            return e
        }
        ))
    }
    ), !0),
    AS.use().setName("saveModels").setPriority(100).setCommitOp().setDescription(xS.saveModels).setPure(!1).addTo(hS),
    AS.useRelative(100).setName("trxCommitAndReducers").setActionType(c.c, !0).setTrxSync(h.a, f.b).setTrxSync(h.l, f.b).setDescription(xS.trxCommitAndReducers).add((function(e) {
        return e
    }
    ), !0),
    AS.useRelative(200).setName("initAppContainer").setDescription(xS.initAppContainer).addTo(hS),
    AS.use().setName("pluginReady").setPriority(400).setFinalizeOp().setDescription(xS.pluginReady).addTo(hS),
    AS.setPure(!1);
    const NS = mv.findExistingBuilder(c.n);
    NS.use().setName("ensureMutationIsExecuting").setPriority(-1e3).setPrepareOp().setPure(!1).setDescription(MS.ensureMutationIsExecuting).setLogicMgr(fS, "./mutation").add((function(e, t) {
        return Object(Ov.a)(e.payload.controller.ofExecute(), e, t)
    }
    ), !0);
    NS.useRelative("trxOptimisticComplete", 10).setName("maybeRemoveIsolation").setDescription(MS.maybeRemoveIsolation).setPure(!1).setLogicMgr(fS, "./mutation").add((function(e) {
        return e.payload.controller.ofOptimisticComplete().pipe(Object(Y.a)(t => (!t || t.isCancelling || t.hasSentToConnector || t.willSendToConnector || t.removeIsolation(),
        e)))
    }
    ), !0);
    NS.useRelative("sendToConnector", -10).setName("waitForSendToConnectorComplete").setDescription(MS.waitForSendToConnectorComplete).setPure(!1).setLogicMgr(fS, "./mutation").add((function(e, t) {
        const n = e.payload.controller;
        return n.isCancelling || n.isConnectorComplete || n.isComplete ? Object(Ov.a)(null, e, t) : t ? (t.setNextValue(e),
        void (n.sendToConnectorCompleteObserver = t)) : new S.a(e => (n.sendToConnectorCompleteObserver = e,
        () => {
            n.sendToConnectorCompleteObserver = void 0
        }
        )).pipe(Object(te.a)(), Object(D.a)(), Object(Or.a)(e))
    }
    ), !0),
    NS.useRelative("sendToConnector", 100).setName("doConnectorComplete").setDescription(MS.doConnectorComplete).setPure(!0).setCancelOp(e => {
        const t = (e instanceof Error ? e.value : e).payload.controller;
        return t && (t.sendToConnectorCompleteObserver = void 0,
        t._doConnectorComplete()),
        e
    }
    ).setLogicMgr(fS, "./mutation").add((function(e) {
        const t = e.payload.controller;
        return t.sendToConnectorCompleteObserver = void 0,
        t._doConnectorComplete(),
        e
    }
    ), !0);
    const RS = Xm.a.initModule("@isomorix/connector-graphql/logic").setEnv("client").addSource(fS)
      , PS = Xm.a.initModule("@isomorix/connector-graphql/logic").setEnv("client").addSource(RS);
    function DS(e) {
        const t = e.meta.getSession();
        return (t && t.entity || e.meta.instance).getConnection(u.a.GRAPHQL, e)
    }
    function FS(e, t, n) {
        const {query: r} = e;
        let i;
        if (Object(he.T)(r))
            try {
                i = {
                    id: r.persistentId,
                    query: r.toGraphql(!0)
                }
            } catch (o) {
                return null
            }
        else
            i = {
                id: null,
                query: "string" === typeof r ? r : Object(de.a)(r)
            };
        return i.variables = e.variables,
        i.batchId = n,
        t ? e.respIdx = t.push(i) - 1 : t = i,
        t
    }
    class kS extends O.a {
        constructor(e, t) {
            super(),
            this._batchActions = e,
            this._batchObservers = t
        }
        _next(e) {
            const t = this._batchActions
              , n = this._batchObservers;
            let r;
            for (let i = 1; i < t.length; i++)
                ({payload: r} = t[i]),
                r.resp = e[r.respIdx],
                n[i].next(t[i]);
            ({payload: r} = t[0]),
            r.resp = e[r.respIdx],
            n[0].next(t[0])
        }
        unsubscribe() {
            super.unsubscribe(),
            this._batchActions = void 0,
            this._batchObservers = void 0
        }
    }
    function jS(e, t) {
        if (Array.isArray(e)) {
            const n = e;
            if ((e = n[0]).meta.closed)
                return;
            const r = []
              , i = e.meta.dispatchId;
            for (let e of n)
                FS(e.payload, r, i);
            if (!r.length)
                return void e.meta.cancel();
            DS(e).query(r).subscribe(new kS(n,t))
        } else if (!e.meta.closed)
            return DS(e).query(FS(e.payload)).pipe(Object(Y.a)(t => (e.payload.resp = t,
            e)))
    }
    le.use().setName("executeQuery").setPriority(200).setCommitOp().setActionType(c.h).setLogicMgr(RS, "./query").setDescription("Executes the query(ies) by sending to the graphql backend. This will (potentially) include more than 1 query if query batching is enabled.").addTo(RS, jS, !0);
    function LS(e) {
        const t = this.payload.queries;
        let n, r, i, o = !0;
        for (let s = 0; s < e.length; s++)
            n = e[s],
            t[s].setConnectorResp(n),
            o && (n.errors && n.errors.length || ((r = t[s].payload.extensions) && (i = r.statusCode) || (i = n.statusCode)) && 200 !== i && (i >= 500 || 400 === i || 403 === i || 408 === i || 409 === i)) && (o = !1);
        return o && (this.payload.controller.isPersistentStateCommitted = o),
        this
    }
    function VS(e) {
        return this.payload.resp = e,
        this
    }
    le.useRelative(PS.findByName("initConnections", c.o), 0).setName("initGraphqlConnection").setPure(!0).setActionType(c.o).setLogicMgr(PS, "./init").add((function(e) {
        const {payload: t} = e
          , n = e.meta.store
          , r = n.storeConfig;
        let i = r.connections[u.a.GRAPHQL];
        if (i) {
            if ("function" === typeof i)
                return e
        } else
            i = r.clientConnections[u.a.GRAPHQL];
        const o = new ue(i,t.coreApiKey,t.graphqlBatch);
        if (o.batchMs) {
            const e = [jS[l.d][l.k]];
            n.addPendingLogic(E(jS, e, o.batchMs, e, !0), !0, !0)
        } else
            n.addPendingLogic(jS, !0, !0);
        return r.connections[u.a.GRAPHQL] = o.connectionMethod,
        n.mainStore.subscribe({
            complete: () => o.destroy()
        }),
        o.getWsClient(),
        e
    }
    ), !0),
    le.use().setName("executeMutation").setCommitOp().setPriority(100).setErrorOp(e => {
        const t = e.value;
        t.payload.error = e,
        t.meta.cancel(t)
    }
    ).setActionType(c.g).setDescription("Executes the mutations by sending them to the graphql backend.").setLogicMgr(PS, "./mutation").add((function(e) {
        const t = []
          , n = e.meta
          , r = e.payload.queries
          , i = r.length
          , o = r[0].action.meta.getTsOffset(n.createTs());
        let s, a = 0;
        for (; a < i; )
            s = r[a],
            t[a] = {
                tsOffset: o,
                query: s.toGraphqlMutation(!0),
                variables: s.variables
            },
            a++;
        return DS(e).mutation(t).pipe(Object(Y.a)(LS, e))
    }
    ), !0),
    le.useRelative(jS, 0).setName("executeSubscription").setPure(!0).setActionType(c.i).setLogicMgr(PS, "./subscription").setDescription("Executes the subscription by sending to the graphql backend.").add((function(e) {
        const {query: t} = e.payload;
        return e.payload.resp = DS(e).subscription({
            query: Object(he.T)(t) ? t.toGraphqlSubscription(!0) : "string" === typeof t ? t : Object(de.a)(t),
            variables: e.payload.variables
        }),
        e
    }
    ), !0);
    const US = (e, t) => {
        e[t.respIdx] ? t.resp = e[t.respIdx] : t.resp = null
    }
    ;
    function qS(e) {
        const t = this.payload.payloads;
        for (let n in t)
            US(e, t[n]);
        return this.payload.resp = e,
        this
    }
    function QS(e) {
        const t = this.payload.payloads;
        for (let n of t)
            US(e, n);
        return this.payload.resp = e,
        this
    }
    function BS(e) {
        const {payload: t} = e;
        if (!t.payloads) {
            const t = FS(e.payload);
            return t ? DS(e).query(t).pipe(Object(Y.a)(VS, e)) : void e.meta.cancel()
        }
        const n = []
          , r = e.meta.dispatchId
          , {payloads: i} = t;
        let o = QS;
        if (Array.isArray(i))
            for (let s = 0; s < i.length; s++)
                FS(i[s], n, r);
        else {
            for (let e in i)
                FS(i[e], n, r);
            o = qS
        }
        if (n.length)
            return DS(e).query(n).pipe(Object(Y.a)(o, e));
        e.meta.cancel()
    }
    const GS = le.useProps(jS).setOpMethod(BS).setActionType(pS.a).setLogicMgr(PS, "../mainLogic/query").setModuleName("@isomorix/connector-graphql/mainLogic/query").setId(!0).done(BS);
    function zS(e) {
        return e.addPendingLogic(PS).addMainLogic(GS)
    }
    function HS(e) {
        return e
    }
    var KS = n(221)
      , YS = n(162);
    let WS;
    WS = function(e) {
        return e.LogicTypeEnum.define({
            modelName: tv.b.CORE_LOGIC,
            values: Object.values(YS.a)
        })
    }
    ;
    var $S = n(369)
      , XS = n(274);
    var JS = n(368);
    function ZS() {
        return !0
    }
    function eO(e) {
        return !!e
    }
    function tO() {
        return !1
    }
    function nO(e, t) {
        const n = typeof e;
        if ("string" === n)
            return {
                name: e,
                value: this.createUserCanMethod(e)
            };
        if ("function" === n) {
            if (!t)
                throw new Error("A function was provided to the PermissionUserCanEnum, but it was not provided in an Object so that the key could be used as the name (slug) for the method. Provide an Object containing method(s) rather than the method alone.");
            return {
                name: t,
                value: e
            }
        }
        return e
    }
    function rO(e) {
        return function(t) {
            var n;
            const r = null === t || void 0 === t || null === (n = t.role) || void 0 === n ? void 0 : n.permissions;
            return !(!r || !r[e])
        }
    }
    var iO = n(160);
    var oO = n(370);
    var sO = n(371);
    var aO = n(367);
    function cO(e, t) {
        return "".concat(e).concat(t, "Enum")
    }
    function uO(e, t) {
        return e.replace("".concat(t, "Enum"), "")
    }
    function lO(e) {
        if (e.LogicEnum)
            return e.LogicEnum;
        class t extends e.Enum {
            static ensureValidConfig(e) {
                if (!e.modelName)
                    throw new Error("The ".concat(e.name, " Logic").concat(this.baseName, "Enum does not provide the name of the Logic Model that the enum is associated with. This is required."));
                return e.name = this.createName(e.modelName),
                e.description || (e.description = this.createDescription(e.name, e.modelName)),
                e.values || (e.values = [{
                    name: "Placeholder".concat(this.baseName, "EnumValue"),
                    description: void 0,
                    value: this.defaultValue
                }]),
                super.ensureValidConfig(e)
            }
            static getByModelName(t) {
                return t || (t = tv.b.CORE_LOGIC),
                e.get(this.createName(t))
            }
            static getOrDefineByModelName(e) {
                return e || (e = tv.b.CORE_LOGIC),
                this.getByModelName(e) || this.define({
                    modelName: e
                })
            }
            static addValueTo(e, t, n) {
                e || (e = tv.b.CORE_LOGIC);
                let r = this.getByModelName(e);
                return r ? r.addValue(t, n) : (this.define({
                    modelName: e,
                    values: [t]
                }),
                !0)
            }
            static addValuesTo(e, t, n) {
                e || (e = tv.b.CORE_LOGIC);
                let r = this.getByModelName(e);
                return r ? r.addValues(t, n) : (this.define({
                    modelName: e,
                    values: t
                }),
                !0)
            }
            static addLazyValueTo(e, t, n) {
                return this.getOrDefineByModelName(e).addLazyValue(t, n)
            }
            static addLazyValuesTo(e, t, n) {
                return this.getOrDefineByModelName(e).addLazyValues(t, n)
            }
        }
        return t.baseName = "Base",
        t.defaultValue = void 0,
        Object(L.a)(t, null, dO),
        e.LogicEnum = t,
        t
    }
    const dO = {
        createName: function(e) {
            return cO(e, this.baseName)
        },
        modelNameFromEnumName: function(e) {
            return uO(e, this.baseName)
        },
        createDescription: function() {}
    };
    var hO = n(296);
    function fO(e) {
        return Object(x.d)(e, Jt.h)
    }
    var pO = n(235);
    function gO(e, t, n) {
        let r = e.get(n);
        if (r) {
            let e = t[l.d][l.h];
            return e || (Object(hO.b)(t[l.d]),
            e = t[l.d][l.h]),
            !r.getInternalValue(e) && (r.addValue(t),
            !0)
        }
        return e.LogicMethodEnum.define({
            modelName: uO(n, "Method"),
            values: [t]
        }),
        !0
    }
    function mO(e, t, n) {
        let r, i, o;
        if ("function" === typeof t) {
            if ((r = t[l.d]) && (i = r[l.g]))
                gO(e, t, i);
            else if (!n)
                throw new Error("Cannot register functional logic ".concat(Object(pO.a)(t), " as a LogicMethodEnum value because it is missing a ").concat(l.g, " property on its ").concat(l.d, " prototype property."))
        } else if ((i = t[l.g]) && (o = fO(t)))
            gO(e, o, i);
        else if (!n)
            throw new Error("Cannot register logic ".concat(t[l.j], " as a LogicMethodEnum value because it is either missing a ").concat(l.g, ' property, or the functional version of the logic (the "method") could not be extracted automatically.'))
    }
    function yO(e) {
        return e
    }
    yO[l.d] = {
        [l.h]: "PlaceholderMethodEnumValue",
        [l.j]: "PlaceholderMethodEnumValue",
        [l.e]: "A placeholder (default) logic."
    };
    const vO = (e, t) => "".concat(e.name, ".prepareValueConfig() expects the logic method to be a function, and it must define a ").concat(l.d, " Object on its prototype. Got: ").concat(Object(pO.a)(t));
    function bO(e, t, n, r) {
        const i = t[l.d];
        if (!i)
            throw new Error(vO(e, t));
        if (n)
            if (i[l.h]) {
                if (i[l.h] !== n)
                    throw new Error("An Object of values was provided to the ".concat(e.name, ' enum, and the key "').concat(n, '" does not match the ').concat(l.h, ' property of the logic method it represents ("').concat(i[l.h], '"). They must be the same.'))
            } else
                i[l.h] = n;
        else
            (n = i[l.h]) || (n = Object(hO.b)(i)[l.h]);
        return r ? i[l.e] = r : (r = i[l.e]) || (r = "This logic does not provide a description.",
        i[l.e] = r),
        {
            name: n,
            description: r,
            value: t
        }
    }
    function _O(e, t, n) {
        const r = this.getByModelName(e);
        if (r)
            r.addValues(t);
        else if (!n) {
            const t = this.createName(e);
            throw new Error("The ".concat(t, " does not exist. Unable to add values."))
        }
        return r
    }
    function SO(e, t) {
        return "function" === typeof e ? {
            name: t || e.displayName,
            value: e,
            description: e.description || null
        } : "string" === typeof e ? {
            name: t || e,
            value: e,
            description: null
        } : e.$$typeof ? {
            name: t || e.displayName,
            value: e,
            description: e.description || null
        } : e
    }
    var OO = n(163)
      , TO = n(164);
    const IO = {
        getItemValue: function(e) {
            if (!e)
                return;
            const t = this.getInternalValue(e);
            return t ? t.value : void 0
        },
        initItem: function(e, t, n, r) {
            if (!e)
                return n && !r ? Object(D.c)() : null;
            const i = this.getInternalValue(e);
            if (!i || "function" !== typeof i.init)
                return n && !r ? Object(D.c)() : null;
            if (!n)
                return i.init(t, e);
            const o = i.init(t, e);
            if (null === o || "undefined" === typeof o)
                return r ? o : Object(D.c)();
            if (Object(OO.a)(o))
                return o;
            if (Object(TO.a)(o)) {
                let e, t, n = !1;
                return o.then(n => {
                    t ? (t.next(n || null),
                    t.complete()) : e = n || null
                }
                ).catch(r => {
                    t ? t.error(r) : (e = r,
                    n = !0)
                }
                ),
                new S.a(r => {
                    if ("undefined" === typeof e)
                        return t = r,
                        () => {
                            t = null
                        }
                        ;
                    n ? r.error(e) : (r.next(e),
                    r.complete())
                }
                )
            }
            return Object(V.a)(o)
        },
        initItems: function(e, t, n, r) {
            if (!e || !e.length)
                return r ? [Object(D.c)()] : null;
            if (n) {
                const n = new Array(e.length);
                for (let i = 0; i < e.length; i++)
                    n[i] = this.initItem(e[i], t, r);
                return n
            }
            for (let i of e)
                this.initItem(i, t)
        },
        renderItem: function(e, t, n, r) {
            const i = this.getInternalValue(e);
            "boolean" === typeof n && (n = null);
            const o = i && "function" === typeof i.render ? i.render(t, n, e) : null;
            return o ? r ? Array.isArray(r) ? void r.push(o) : [r, o] : o : n
        },
        renderItems: function(e, t, n, r) {
            if (!e)
                return n && !0 !== n ? n : null;
            if (n) {
                !0 === n && (n = null);
                let r = e.length - 1;
                for (; r >= 0; )
                    n = this.renderItem(e[r], t, n),
                    r--;
                return n
            }
            if (!1 !== n) {
                let n, i;
                for (let o of e)
                    n = this.renderItem(o, t),
                    n && (i ? i.push(n) : r ? Array.isArray(r) ? (i = r,
                    i.push(n)) : i = [r, n] : i = [n]);
                return i || null
            }
            for (let i of e)
                this.renderItem(i, t)
        },
        renderItemOrItems: function(e, t, n, r) {
            return e && Array.isArray(e) ? this.renderItems(e, t, n, r) : this.renderItem(e, t, n, r)
        }
    };
    function xO(e) {
        !function(e) {
            if (e.LogicTypeEnum)
                return e.LogicTypeEnum;
            class t extends (lO(e)) {
            }
            t.baseName = "Type",
            t.defaultValue = "placeholderLogicType",
            t.configDefaults = {
                ...t.configDefaults,
                JSDOC_TYPE: "string",
                PERSISTENT_KIND: ei.a.STRING
            },
            e.LogicTypeEnum = t
        }(e),
        function(e) {
            if (e.LogicMethodEnum)
                return e.LogicMethodEnum;
            class t extends (lO(e)) {
                static use(t) {
                    let n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (Array.isArray(t))
                        for (let r of t)
                            mO(e, r, n);
                    else
                        mO(e, t, n)
                }
            }
            t.baseName = "Method",
            t.defaultValue = yO,
            t.configDefaults = {
                ...e.Enum.configDefaults,
                JSDOC_TYPE: "function",
                PERSISTENT_KIND: ei.a.STRING,
                prepareValueConfig: function(t, n) {
                    let r, i, o = typeof t;
                    if ("function" === o)
                        r = (t = bO(this, t, n)).value[l.d];
                    else {
                        if (!t || "object" !== o)
                            throw new Error(vO(this, t));
                        if (t.value) {
                            let e = t.value;
                            if ("function" !== typeof e && !(e = fO(e)))
                                throw new Error(vO(this, t));
                            t = bO(this, e, n || t.name, t.description),
                            r = e[l.d]
                        } else {
                            const e = fO(t);
                            if (!e)
                                throw new Error(vO(this, t));
                            r = (t = bO(this, e, n)).value[l.d]
                        }
                    }
                    const s = r[l.s];
                    return s && ((i = e.get(cO(this.modelName, "Type"))) ? i.getInternalValue(s) || i.addValue(s) : e.LogicTypeEnum.define({
                        modelName: this.modelName,
                        values: [s]
                    })),
                    t
                }
            },
            e.LogicMethodEnum = t
        }(e),
        function(e) {
            if (e.LogicComponentEnum)
                return e.LogicComponentEnum;
            class t extends (lO(e)) {
            }
            t.use = _O,
            t.baseName = "Component",
            t.defaultValue = () => {}
            ,
            t.configDefaults = {
                ...t.configDefaults,
                JSDOC_TYPE: "function",
                PERSISTENT_KIND: ei.a.STRING,
                prepareValueConfig: SO
            },
            e.LogicComponentEnum = t
        }(e),
        function(e) {
            if (e.LogicItemEnum)
                return e.LogicItemEnum;
            class t extends (lO(e)) {
                getValue(e) {
                    return e && "object" === typeof e && e.itemName ? this._nameLookup[e.itemName] : super.getValue(e)
                }
            }
            t.use = _O,
            t.baseName = "Item",
            t.defaultValue = {},
            t.configDefaults = {
                ...t.configDefaults,
                JSDOC_TYPE: "Object",
                PERSISTENT_KIND: ei.a.STRING
            },
            Object(L.a)(t, IO),
            e.LogicItemEnum = t
        }(e)
    }
    function wO(e) {
        xO(e),
        function(e) {
            {
                const t = Object.values($S.a);
                e.Enum.define({
                    name: qo.a.DATA_SOURCE_TYPE,
                    PERSISTENT_KIND: ei.a.STRING,
                    values: t
                }),
                e.Enum.define({
                    name: qo.a.DATA_SOURCE_MANAGER,
                    PERSISTENT_KIND: ei.a.STRING,
                    values: t
                }),
                e.Enum.define({
                    name: qo.a.DATA_SOURCE_COMPONENT,
                    PERSISTENT_KIND: ei.a.STRING,
                    values: t
                }),
                e.Enum.define({
                    name: qo.a.DATA_SOURCE_STATUS,
                    PERSISTENT_KIND: ei.a.STRING,
                    values: Object.values(XS.b)
                }),
                e.Enum.define({
                    name: qo.a.DATA_SOURCE_EXTERNAL_RECORD_STATUS,
                    values: Object.values(XS.a)
                })
            }
        }(e),
        WS(e),
        function(e) {
            class t extends e.Enum {
            }
            let n, r;
            t.configDefaults = {
                ...t.configDefaults,
                prepareValueConfig: nO,
                createUserCanMethod: rO
            },
            r = {
                [Uo.a.ANY]: {
                    value: ZS
                },
                [Uo.a.ANY_USER]: {
                    value: eO
                },
                [Uo.a.NEVER]: {
                    value: tO
                }
            },
            n = "function",
            t.define({
                name: qo.a.PERMISSION_USER_CAN,
                description: void 0,
                values: r,
                PERSISTENT_KIND: ei.a.STRING,
                JSDOC_TYPE: n
            })
        }(e)
    }
    function MO(e, t, n) {
        const r = () => {
            !function(e) {
                e.Enum.define({
                    name: qo.a.LOCATION_CHANGE_TYPE,
                    values: {
                        [JS.a.PUSH]: {
                            name: JS.a.PUSH
                        },
                        [JS.a.REPLACE]: {
                            name: JS.a.REPLACE
                        },
                        [JS.a.POP]: {
                            name: JS.a.POP
                        }
                    }
                })
            }(e),
            function(e) {
                e.Enum.define({
                    name: qo.a.QUERY_ARG_OPERATOR,
                    values: ["eq", "neq", "gt", "gte", "like", "rlike", "lt", "lte", "in", "exists", "isNull"]
                })
            }(e),
            function(e) {
                e.Enum.define({
                    name: qo.a.QUERY_ORDER_BY,
                    values: {
                        asc: {
                            name: "asc"
                        },
                        desc: {
                            name: "desc"
                        }
                    }
                })
            }(e),
            function(e) {
                e.Enum.define({
                    name: qo.a.QUERY_ORDER_BY_NULLS,
                    values: {
                        first: {
                            name: "first"
                        },
                        last: {
                            name: "last"
                        }
                    }
                })
            }(e),
            function(e) {
                const t = {}
                  , n = {};
                let r;
                for (let i in De)
                    r = "INCREMENT" === i || "DECREMENT" === i ? t : n,
                    r[De[i]] = {
                        description: ke[i]
                    };
                e.Enum.define({
                    name: qo.a.QUERY_PAYLOAD_TYPES_INT,
                    values: t
                }),
                e.Enum.define({
                    name: qo.a.QUERY_PAYLOAD_TYPES_JSON,
                    values: n
                })
            }(e),
            function(e) {
                e.Enum.define({
                    name: qo.a.SSL_CERT_STATUS,
                    values: Object.values(aO.a)
                })
            }(e),
            function(e, t) {
                e.Enum.define({
                    name: qo.a.VF_RELATIONSHIP_TYPE,
                    values: {
                        [iO.a.BELONGS_TO]: {
                            value: t.BELONGS_TO
                        },
                        [iO.a.HAS_ONE]: {
                            value: t.HAS_ONE
                        },
                        [iO.a.HAS_MANY]: {
                            value: t.HAS_MANY
                        },
                        [iO.a.BELONGS_TO_MANY]: {
                            value: t.BELONGS_TO_MANY
                        },
                        [iO.a.BELONGS_TO_MANY_REF]: {
                            value: t.BELONGS_TO_MANY_REF
                        }
                    }
                })
            }(e, t),
            function(e) {
                e.Enum.define({
                    name: qo.a.RESOURCE_SHARE_STATUS,
                    values: Object.values(oO.a)
                })
            }(e),
            function(e) {
                e.Enum.define({
                    name: qo.a.SESSION_STATUS,
                    values: Object.values(sO.a)
                })
            }(e),
            function(e) {
                e.Enum.define({
                    name: qo.a.TS_ACTION_TYPE,
                    values: [ti.d.CREATE, ti.d.UPDATE, ti.d.DELETE]
                })
            }(e)
        }
        ;
        n ? n.schedule(r, 0) : r()
    }
    var AO = n(1016);
    function EO(e) {
        if (e) {
            if (e.types)
                return e;
            e.codeVersion || (e.codeVersion = KS.a)
        } else
            e = {
                name: KS.b.NAME,
                description: KS.b.DESCRIPTION,
                slug: KS.b.SLUG,
                codeVersion: KS.a,
                permMutation: Uo.a.ANY,
                permQuery: Uo.a.ANY
            };
        return e.types = new AO.a(e.slug),
        e[ev.a.PLUGIN] || (e[ev.a.PLUGIN] = e.types.ModelID.use(tv.b.PLUGIN).toGlobalId(e[ev.a.PLUGIN])),
        wO(e.types),
        e
    }
    const CO = void 0;
    var NO = n(376);
    const RO = [l.h, l.j, l.m, l.a, l.n, l.i, l.l];
    function PO(e, t) {
        const n = this.__logic[e.meta.op];
        return n ? Object(Ov.a)(this.__args ? n.call(this.__thisArg, e.meta.getPublicAction(), ...this.__args) : n.call(this.__thisArg, e.meta.getPublicAction()), e, t) : Object(Ov.a)(null, e, t)
    }
    function DO(e) {
        const t = this.__logic[e.meta.op];
        return t ? this.__args ? t.call(this.__thisArg, e.meta.getPublicAction(), ...this.__args) : t.call(this.__thisArg, e.meta.getPublicAction()) : e
    }
    function FO(e, t) {
        return this.__logic.call(this.__thisArg, e, t)
    }
    function kO(e, t, n) {
        return this.__logic.call(this.__thisArg, e, t, n)
    }
    class jO {
        constructor(e, t, n) {
            e = "function" === typeof e ? Object(x.f)(e) : e,
            this.__logic = e,
            this.__thisArg = e[l.q] || e,
            this.__args = e[l.b];
            const r = e[l.e];
            let i = r;
            t && (r ? "string" === typeof r ? i = "".concat(t, "\n\n").concat(r) : (i = t,
            r.logic && (i += "\n\n".concat(r.logic)),
            i = {
                ...r,
                logic: i
            }) : (i = t,
            n && (i += "\n\n".concat(n)))),
            this[l.e] = i;
            for (let s of RO)
                this[s] = e[s];
            const o = e[l.n] ? DO : PO;
            for (let s of Jt.h)
                e[s] ? this[s] = o : this[s] = !1;
            this[f.d] = !1,
            e[f.a] ? this[f.a] = o : this[f.a] = !1,
            e[l.o] && (this[l.o] = FO),
            e[l.p] && (this[l.p] = kO)
        }
        static create(e, t, n) {
            if (Array.isArray(e)) {
                const r = [];
                for (let i of e)
                    LO(i, t, n, this, r);
                return r
            }
            return new this(e,t,n)
        }
    }
    function LO(e, t, n, r, i) {
        if (Array.isArray(e))
            for (let o of e)
                LO(e, t, n, r, i);
        else
            i.push(new r(e,t,n))
    }
    function VO(e) {
        return new this(e)
    }
    class UO {
        constructor(e) {
            "boolean" !== typeof e && (e = "undefined" === typeof window);
            const t = {};
            this.MetaField = void 0,
            this.coreMetaFields = void 0,
            this.schemaMutation = void 0,
            this.schemaMutation$ = void 0,
            this.buildModelsQueue = void 0,
            window.__PRELOAD_STATE__ && (this.clientConnections = window.__PRELOAD_STATE__.__CONNECTIONS__ || {}),
            this.isStateChangesIPCEnabled = !1,
            this.lastPersistentStateChangeAt = 0,
            this.connections = {},
            this.directQueryQueueSrc$ = new U.a,
            this.Cookie = void 0,
            this.currentMutations = void 0,
            this.pastMutations = [],
            this.futureMutations = [],
            this.timeTravelInFlight = new Set,
            this.getModelStoreConfig = function(e) {
                return t[e.__typename]
            }
            ,
            this.modelStoreConfigs = t,
            this.envParser = void 0,
            this.graphqlInstanceMixin = void 0,
            this.graphqlRequestPrototypeMethod = void 0,
            this.graphqlSchema = void 0,
            this.graphqlRoleSchemas = e ? {} : null,
            this.graphqlLongnameToUrl = null,
            this.isServer = e,
            this.localStorage = void 0,
            this.Model = void 0,
            this.ModelMutation = void 0,
            this.modelMutationBase = void 0,
            this.ModelQuery = void 0,
            this.modelStoreConfigs = t,
            this.Mutation = void 0,
            this.pendingRecordLogic = void 0,
            this.Plugin = void 0,
            this.plugin = void 0,
            this.pluginAccessors = {},
            this.pluginDispatchers = {},
            this.pluginMutationBase = void 0,
            this.pluginRecord = void 0,
            this.processEnv = void 0,
            this.queries = {},
            this.Record = void 0,
            this.RecordResult = void 0,
            this.Schema = void 0,
            this.sessionStorage = void 0,
            this.sharedCore = void 0,
            this.StoreWrapper = void 0,
            this.storesMap = void 0,
            this.mainTrxQueue = [],
            this.mainTrxQueue$ = new U.a,
            this.types = void 0
        }
    }
    var qO = n(373);
    const QO = Xm.b.initModule("@isomorix/plugin/trxLogic/main")
      , BO = Xm.b.initModule("@isomorix/plugin/trxLogic");
    let GO, zO;
    {
        const e = {};
        GO = e,
        zO = e
    }
    function HO(e) {
        return e === this
    }
    const KO = QO.getBuilder("*");
    function YO() {
        const e = this.payload.__callMainTrxComplete;
        if (e)
            for (let t of e)
                t.mainTrxComplete();
        return this
    }
    KO.use().setName("trxQueueEnter").setPriority(1).setPure(!1).setOp([h.f, h.a]).setDescription(GO.trxQueueEnter).add((function(e) {
        const t = e.meta.store.storeConfig;
        return 0 === t.mainTrxQueue.push(e) - 1 ? e : t.mainTrxQueue$.pipe(Object(H.a)(HO, e), Object(te.a)(), Object(qO.a)())
    }
    ), !0),
    KO.use().setName("trxQueueExit").setPriority(999).setPure(!0).setOp([h.i, h.e]).setDescription(GO.trxQueueExit).add((function(e) {
        const t = e.meta.store.storeConfig
          , n = t.mainTrxQueue;
        return n.shift(),
        n[0] && t.mainTrxQueue$.next(n[0]),
        e
    }
    ), !0),
    KO.use().setName("taskTiming").setPriority(Lm.c - .01).setPure(!1).setOp([h.f, h.a]).add((function e(t) {
        const n = Object(T.b)().pipe(Object(Or.a)(t));
        return t.meta.trxOp === h.a ? n.pipe(Object(Y.a)( () => t.meta.store.removeMainExtraTrxLogic(e))) : n
    }
    ), !0);
    KO.use().setName("manageCallMainTrxComplete").setPriority(10).setPure(!1).setCompleteOp().setDescription(GO.manageCallMainTrxComplete).add((function(e, t) {
        return e.payload.__callMainTrxComplete ? Object(T.b)().pipe(Object(Y.a)(YO, e)) : Object(Ov.a)(Object(T.b)(), e, t)
    }
    ), !0);
    const WO = BO.getBuilder(c.n, "./mutation");
    function $O() {
        const e = this.payload.controller
          , {mutations: t} = e;
        for (let n in t)
            t[n].commitTriggerData();
        return this
    }
    WO.use().setName("taskTiming").setPriority(Lm.c - .01).setPure(!1).setOp([h.h, h.f, h.a]).setActionType(c.n).add((function(e) {
        return Object(T.b)().pipe(Object(Or.a)(e))
    }
    ), !0),
    WO.use().setName("executeFollowupQueries").setCommitOp().setPriority(1).setPure(!1).setDescription(zO.executeFollowupQueries).add((function(e) {
        const t = e.payload.controller;
        return t.followupQueries ? t._doExecuteFollowupQueries().pipe(Object(Y.a)(t => (t.isAcceptingFollowupQueries = !1,
        e))) : (t.isAcceptingFollowupQueries = !1,
        Object(V.a)(e))
    }
    ), !0),
    WO.useRelative(.5).setName("commitTriggerData").setCommitOp().setRollbackOp((function(e) {
        const t = e.payload.controller;
        return t.isCancelling || t.cancel(),
        e
    }
    )).setPure(!1).setDescription(zO.commitTriggerData).add((function(e) {
        return Object(T.b)().pipe(Object(Y.a)($O, e))
    }
    ), !0);
    const {CREATED: XO} = ws.a
      , {OPTIMISTIC: JO, COMMIT: ZO, NONE: eT} = dg.a
      , tT = {
        allChanges: void 0,
        dispatchId: void 0,
        changes: void 0,
        event: eT,
        hasCreate: !1,
        hasDelete: !1,
        isOptimistic: !0,
        isStatePool: !1,
        mainDispatchId: void 0,
        size: 0,
        state: void 0,
        statePoolId: void 0,
        store: void 0
    }
      , nT = {
        ...tT,
        changesToCommit: void 0,
        hasPendingDelete: !1,
        isModelRefChange: !1,
        mutation: void 0,
        pChanges: void 0,
        pSize: void 0,
        pState: void 0
    };
    tT.isUndo = !1,
    tT.isRedo = !1;
    const rT = Object.keys(tT)
      , iT = Object.keys(nT)
      , oT = (e, t) => {
        let n = 0
          , r = e.length;
        for (; n < r; )
            t[e[n]] ? (e.splice(n, 1),
            r--) : n++;
        return e
    }
      , sT = oT([...rT], Sg.a.blacklistPropsCloneNew)
      , aT = oT([...rT], Sg.a.blacklistPropsCommitPendingState);
    aT.splice(aT.indexOf("isStatePool"), 1),
    aT.splice(aT.indexOf("statePoolId"), 1);
    const cT = ["store"]
      , uT = oT([...iT], Og.a.blacklistPropsCloneNew)
      , lT = oT([...rT], Og.a.blacklistPropsCloneMainState);
    lT.splice(lT.indexOf("isStatePool"), 1);
    const dT = ["store", "mutation"];
    function hT(e) {
        let t;
        const n = e.storeConfig;
        e.subscribeToAction(e => {
            t = e.meta.mainStore
        }
        );
        const r = []
          , i = []
          , o = [];
        let s = 0
          , a = 0
          , c = 0
          , u = Object(oe.b)()
          , l = Qs.a;
        const d = e => s ? (s--,
        r.pop()) : {
            ...e
        };
        class h extends Sg.a {
            cloneNew() {
                let e;
                a ? (e = i.pop(),
                a--) : e = new h(!1);
                for (const t of sT)
                    e[t] = this[t];
                return e.isStatePool = !1,
                e
            }
            cloneCommit(e) {
                const t = this.cloneNew();
                for (const n of aT)
                    t[n] = e[n];
                return t
            }
            _prepareCommitState(e, t, n, i) {
                const {changes: o} = t;
                if (t.hasDelete) {
                    r.length = 0,
                    s = 0,
                    u = Object(oe.b)(),
                    console.log("Main._prepareCommitState(".concat(e.meta.mainDispatchId, ", ").concat(t.event, ") -> hasDelete -> INVALIDATING POOL")),
                    super._prepareCommitState(e, t, n, i);
                    const {state: a} = t;
                    for (const e in o)
                        a[e] && (a[e] = Object(he.C)(a[e]))
                } else if (t.hasCreate || n.isModelRefChange) {
                    const i = this.state
                      , a = n.state
                      , c = d(i);
                    let l, h, f = !1;
                    for (const n in o)
                        if (l = Object(he.C)(a[n]),
                        l !== c[n]) {
                            if (s)
                                for (h = 0; h < s; )
                                    r[h][n] = l,
                                    h++;
                            f || (f = !0,
                            u = Object(oe.b)(),
                            console.log("Main._prepareCommitState(".concat(e.meta.mainDispatchId, ", ").concat(t.event, ") -> ").concat(n, " changed -> ").concat(s, " updated in pool"))),
                            o[n] === XO && t.size++,
                            c[n] = l
                        }
                    t.state = c
                } else
                    t.state = d(this.state);
                return t.isStatePool = !0,
                t.statePoolId = u,
                t
            }
            deReference() {
                for (const e of cT)
                    this[e] = void 0
            }
            destroy() {
                this.statePoolId === u && this.isStatePool && (r[s] = this.state,
                s++),
                (e => {
                    for (const t of rT)
                        e[t] = tT[t];
                    i[a] = e,
                    a++
                }
                )(this)
            }
        }
        const f = () => c ? (c--,
        o.pop()) : new g(!1)
          , p = (e, t) => {
            for (const n in t)
                e[n] = e[n].mainModel;
            r[s] = e,
            s++
        }
        ;
        class g extends Og.a {
            static init(e, t) {
                const n = f();
                n.store = e;
                const r = e.getAction(e.mainDispatchId);
                return n.mainDispatchId = r.meta.mainDispatchId,
                n.dispatchId = r.meta.pendingDispatchId,
                n.cloneMainState(e.mainStore.value, n),
                n
            }
            cloneNew() {
                const e = f();
                for (const t of uT)
                    e[t] = this[t];
                return e.isStatePool = !1,
                e
            }
            cloneMainState(e, t) {
                t || (t = this.cloneNew());
                for (const n of lT)
                    t[n] = e[n];
                return t.isStatePool = !1,
                t
            }
            cloneState() {
                if (s && this.statePoolId === u) {
                    s--;
                    const e = r.pop();
                    if (this.allChanges) {
                        const {allChanges: t, state: n} = this;
                        for (const r in t)
                            e[r] = n[r]
                    }
                    return e
                }
                return {
                    ...this.state
                }
            }
            registerChildStore(e) {
                Object(he.N)(e.instance) && this.set(e.instance.modelName, e.instance)
            }
            setAsModelRefChange() {
                if (!this.isModelRefChange) {
                    this.isModelRefChange = !0;
                    const e = this.store.history;
                    if (e.length)
                        for (const t of e)
                            t.isModelRefChange = !0
                }
                return this
            }
            deleteModel(e) {
                if (!this.get(e))
                    return !1;
                if (delete n.modelStoreConfigs[e],
                this.delete(e),
                this.statePoolId) {
                    this.statePoolId = void 0;
                    const e = this.store.history;
                    if (e.length)
                        for (const t of e)
                            t.statePoolId = void 0
                }
                return l(e),
                !0
            }
            optimisticCommit(e) {
                const t = this._prepareCommit(e, JO);
                return t.isOptimistic = !0,
                t.state !== this.state && (t.isStatePool = !0),
                t
            }
            commit(e) {
                this.mutation && this.mutation.dispatchId === e.meta.dispatchId && (this.mutation = void 0);
                const t = this._prepareCommit(e, ZO);
                return t.isOptimistic = !1,
                t.state !== this.state && (t.isStatePool = !0),
                t
            }
            deReference() {
                for (const e of dT)
                    this[e] = void 0
            }
            destroy() {
                !this.isModelRefChange && this.statePoolId === u && t.value && (this.isStatePool && p(this.state, this.allChanges),
                this.pState && p(this.pState, this.pChanges)),
                (e => {
                    for (const t of iT)
                        e[t] = nT[t];
                    o[c] = e,
                    c++
                }
                )(this)
            }
        }
        return e.setMainValue(h).setPendingValue(g)
    }
    const fT = [c.c, c.k, c.o, c.g, c.e, c.f, c.j, c.h, c.i]
      , pT = (e, t, n) => t ? e.subscribe(t) : n ? e.asObservable() : e
      , gT = (e, t, n) => (e[t] || (e[t] = new U.a),
    pT(e[t], n, !0))
      , mT = (e, t, n, r) => {
        e[t] && (r && (n = n.getBestStore(r)),
        e[t].next(n),
        e[t].complete(),
        e[t] = void 0)
    }
    ;
    class yT extends iv {
        static createStoreConfig(e) {
            return new UO(e)
        }
        static init(e) {
            const t = new this;
            return e && !0 !== e || (e = this.createStoreConfig(e)),
            t.storeConfig = void 0,
            hT(t.setStoreConfig(e).setTrxActionTypes({
                [c.c]: Fl.b,
                [c.n]: Fl.b,
                [c.o]: Fl.b
            }).setIsolationLevel(t.isServer ? null : {
                type: Ng.b,
                actions: [c.n]
            }).setTrxPriority(Lm.h)).setPluginDispatchers(),
            t.payload = {
                pluginBuilder: t
            },
            t
        }
        addDefaultLogic() {
            return this.addPendingLogic(fS).addMainExtraTrxLogic(QO).addPendingExtraTrxLogic(BO)
        }
        setNetwork(e) {
            return e && this.setStoreConfig("isServer", e.isServer),
            super.setNetwork(e)
        }
        addPackage(e, t) {
            return "function" === typeof e && e(this, t),
            this
        }
        setStoreWrapper(e) {
            let t = this.getStoreConfig("storesMap");
            if (e) {
                if (!t)
                    throw new Error('Unable to set StoreWrapper for plugin "'.concat(this.pluginSlug, '" because a StoreWrapper was provided and no storesMap is set for the Plugin. They need to share the storesMap.'))
            } else {
                if (this.getStoreConfig("StoreWrapper"))
                    return this;
                t || (t = new Map,
                this.setStoreConfig("storesMap", t)),
                e = function(e, t) {
                    e || (e = new Map);
                    const n = {
                        init: VO,
                        createDispatchMethod: function(t) {
                            return function(n, r, i, o) {
                                let s, a, c;
                                "string" === typeof n ? (s = n,
                                a = r,
                                c = i) : (({type: s, payload: a} = n),
                                c = r,
                                !c && n.meta && (c = n.meta.pendingDispatchId),
                                o = i);
                                const u = e.get(this)
                                  , l = t[s];
                                if (!u || !l)
                                    return null;
                                if ("function" === typeof l)
                                    return l.call(u, s, a, c, o);
                                {
                                    const e = u.dispatch(s, a, c, o);
                                    return e ? e.meta.getPublicAction() : null
                                }
                            }
                        }
                    }
                      , r = {
                        _registerPendingStore: function(e) {
                            return new this.constructor(e)
                        },
                        hasAction: function(t, n) {
                            return !!e.get(this).getAction(t, n)
                        },
                        hasActionByType: function(t, n) {
                            return !!e.get(this).getActionByType(t, n)
                        },
                        getAction: function(t, n) {
                            const r = e.get(this).getAction(t, n);
                            return r && r.meta.getPublicAction()
                        },
                        getState: function() {
                            return e.get(this).getState()
                        },
                        getPrevState: function() {
                            return e.get(this).value.getPrevState()
                        },
                        getMainInstance: function() {
                            return e.get(this).mainInstance
                        },
                        getBestInstance: function(t) {
                            return e.get(this).getBestStore(t).instance
                        },
                        getPendingInstance: function(t) {
                            const n = e.get(this).getPendingStore(t, !0);
                            return n ? n.instance : void 0
                        },
                        get: function(t) {
                            return e.get(this).get(t)
                        },
                        getPrev: function(t) {
                            return e.get(this).value.getPrev(t)
                        },
                        getFromHistory: function(t) {
                            return e.get(this).value.getFromHistory(t)
                        },
                        has: function(t) {
                            return e.get(this).value.has(t)
                        },
                        subscribe: function(t) {
                            return e.get(this).subscribeToInstance(t)
                        },
                        subscribeAndPersist: function(t) {
                            return e.get(this).subscribeToInstance(t, !0)
                        },
                        subscribeToAllPending: function(t) {
                            return e.get(this).subscribeToAllPendingInstances(t)
                        },
                        pipe: function() {
                            return arguments.length ? this.subscribe().pipe(...arguments) : this.subscribe()
                        },
                        pipeAndPersist: function() {
                            return arguments.length ? this.subscribeAndPersist().pipe(...arguments) : this.subscribeAndPersist()
                        },
                        addActionDependency: function(t, n, r, i) {
                            const o = e.get(this).getAction(t);
                            if (!o)
                                return !1;
                            const s = Object(he.X)(n) ? n : e.get(n);
                            if (!s)
                                return !1;
                            const a = s.getAction(i || t);
                            if (!a)
                                return !1;
                            if (Array.isArray(r)) {
                                const e = o.meta
                                  , t = a.meta;
                                for (let n of r)
                                    e.addDependency(t, n)
                            } else
                                o.meta.addDependency(a.meta, r);
                            return !0
                        },
                        _storeClosed: function() {
                            e.delete(this)
                        },
                        _getMainDispatchId: function(t) {
                            return e.get(this).network.getMainDispatchId(t)
                        },
                        addLogic: function(t, n, r) {
                            return e.get(this).addLogic(jO.create(t), n, r)
                        },
                        addMainLogic: function(t, n, r) {
                            return e.get(this).addMainLogic(jO.create(t), n, r)
                        },
                        addPendingLogic: function(t, n, r) {
                            return e.get(this).addPendingLogic(jO.create(t), n, r)
                        },
                        removeLogic: function(t, n, r) {
                            return e.get(this).removeLogic(t, n, r)
                        },
                        removeMainLogic: function(t, n, r) {
                            return e.get(this).removeMainLogic(t, n, r)
                        },
                        removePendingLogic: function(t, n, r) {
                            return e.get(this).removePendingLogic(t, n, r)
                        },
                        replaceLogic: function(t, n, r, i) {
                            return e.get(this).replaceLogic(t, jO.create(n), r, i)
                        },
                        replaceMainLogic: function(t, n, r, i) {
                            return e.get(this).replaceMainLogic(t, jO.create(n), r, i)
                        },
                        replacePendingLogic: function(t, n, r, i) {
                            return e.get(this).replacePendingLogic(t, jO.create(n), r, i)
                        },
                        addOrReplaceLogic: function(t, n, r) {
                            return e.get(this).addOrReplaceLogic(jO.create(t), n, r)
                        },
                        addOrReplaceMainLogic: function(t, n, r) {
                            return e.get(this).addOrReplaceMainLogic(jO.create(t), n, r)
                        },
                        addOrReplacePendingLogic: function(t, n, r) {
                            return e.get(this).addOrReplacePendingLogic(jO.create(t), n, r)
                        }
                    }
                      , i = {
                        __changesToCommit: {
                            get() {
                                const t = e.get(this);
                                return t ? t.value.changesToCommit : void 0
                            }
                        },
                        __changesDispatchId: {
                            get() {
                                return e.get(this).value.dispatchId
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __changesEvent: {
                            get() {
                                return e.get(this).value.event
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __changes: {
                            get() {
                                return e.get(this).value.changes
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __allChanges: {
                            get() {
                                return e.get(this).value.allChanges
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __closed: {
                            get() {
                                return !e.get(this)
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __storeId: {
                            get() {
                                return e.get(this).storeId
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __dispatchId: {
                            get() {
                                return e.get(this).mainDispatchId
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __pChanges: {
                            get() {
                                return e.get(this).value.pChanges
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __isUndo: {
                            get() {
                                return e.get(this).value.isUndo
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __isRedo: {
                            get() {
                                return e.get(this).value.isRedo
                            },
                            set: void 0,
                            enumerable: !1
                        },
                        __isUndoRedo: {
                            get() {
                                return e.get(this).value.isUndoRedo
                            },
                            set: void 0,
                            enumerable: !1
                        }
                    };
                    if (i.changes = {
                        get() {
                            return console.log(new Error("The changes property is deprecated, use __changes instead. Store name = ".concat(e.get(this).storeName, ", module = ").concat(e.get(this).moduleName, ".")).stack),
                            e.get(this).value.changes
                        },
                        set: void 0,
                        enumerable: !1
                    },
                    t)
                        return {
                            staticMethods: n,
                            instanceMethods: r,
                            instanceAccessors: i,
                            storesMap: e
                        };
                    class o {
                        constructor(t) {
                            e.set(this, t)
                        }
                    }
                    return Object(L.a)(o, r, n),
                    Object.defineProperties(o.prototype, i),
                    o
                }(t)
            }
            return this.setStoreConfig("StoreWrapper", e)
        }
        setConnections(e, t) {
            return this._maybeSetScObject("connections", e, t)
        }
        getConnections(e) {
            return this.getStoreConfig("connections", e)
        }
        setPastMutations(e) {
            return this._maybeSetScArray("pastMutations", e)
        }
        setFutureMutations(e) {
            return this._maybeSetScArray("futureMutations", e)
        }
        setQueries(e, t) {
            return this._maybeSetScObject("queries", e, t)
        }
        getQueries(e) {
            return this.getStoreConfig("queries", e)
        }
        setPluginDispatchers(e, t) {
            if (e)
                return this.setStoreConfig("pluginDispatchers", e, t);
            {
                let e = this.getStoreConfig("pluginDispatchers");
                e || (e = {},
                this.setStoreConfig("pluginDispatchers", e));
                for (let t of fT)
                    "undefined" === typeof e[t] && (e[t] = !0);
                return this
            }
        }
        setPluginAccessors(e, t) {
            return this._maybeSetScObject("pluginAccessors", e, t)
        }
        setPluginRecord(e, t) {
            return "string" !== typeof e ? e.types && this.setStoreConfig("types", e.types) : "types" === e && this.setStoreConfig("types", t),
            this.setStoreConfig("pluginRecord", e, t)
        }
        getPluginRecord(e) {
            return this.getStoreConfig("pluginRecord", e)
        }
        setEnvParser(e) {
            return e && "string" !== typeof e && this.setStoreConfig("envParser", e),
            this
        }
        setModelStoreConfigs(e, t) {
            return this._maybeSetScObject("modelStoreConfigs", e, t)
        }
        setSharedCore(e) {
            return this.setStoreConfig("sharedCore", e)
        }
        getPayload(e) {
            let t = this.payload;
            return t || (this.setPayload(),
            ({payload: t} = this)),
            e ? t[e] : t
        }
        setPayload(e, t) {
            let n = this.payload;
            if (e && "string" !== typeof e)
                if (n) {
                    if (n !== e)
                        throw new Error("The payload already exists and it is different than the provided Object. This is not allowed.")
                } else
                    this.payload = e,
                    e.pluginBuilder = this;
            else
                n || (n = {
                    pluginBuilder: this
                },
                this.payload = n),
                e && (n[e] = t);
            return this
        }
        dispatchInit() {
            const e = (this.store || this.createStore()).dispatch(c.o, this.getPayload());
            return this.store = e.meta.store,
            this.action = e,
            e
        }
        setAction(e) {
            if (this.setEnvParser(),
            e !== this.action) {
                const {store: t} = this;
                this.action = e,
                this.payload = e.payload,
                this.store = e.meta.store,
                this.storeConfig = this.store.storeConfig,
                this.payload.pluginBuilder = this,
                t || this.setStoreConfig("isServer", e.meta.network.isServer)
            }
            const t = this.types;
            return this.payload.envParser = this.getStoreConfig("envParser"),
            this.payload.types = t,
            this.payload.isServer = this.isServer,
            mT(this, "_actionObservers$", e),
            this
        }
        subscribeToAction(e) {
            const t = this.action && this.action.meta;
            return t && (t.isComplete || Object(he.X)(t.store)) ? pT(Object(V.a)(this.action), e) : gT(this, "_actionObservers$", e)
        }
        subscribeToInstance(e) {
            const t = this.storeConfig;
            if (!t.plugin)
                return gT(this, "_instanceObservers$", e);
            const n = this.action && this.action.meta;
            return pT(n && !n.isComplete ? Object(V.a)(n.store) : Object(V.a)(t.storesMap.get(t.plugin)), e)
        }
        createInstance() {
            if (!this.action)
                throw new Error("Unable to initialize the Plugin instance because the PLUGIN_INIT action has not been dispatched yet.");
            let e = this.action.meta.instance;
            const t = this.storeConfig
              , n = this.store.mainStore;
            if (e)
                e = e.getMainInstance();
            else {
                const r = t.Plugin;
                Object(ov.a)(n, t.storesMap, t.pluginDispatchers, t.pluginAccessors),
                Object.defineProperties(r.prototype, t.pluginAccessors),
                e = r.init(n)
            }
            return t.pluginRecord.pluginInstance = e,
            t.plugin = e,
            n.setMainInstance(e),
            mT(this, "_instanceObservers$", n, this.action.meta.dispatchId),
            e
        }
        destroy() {
            super.destroy(),
            this.action = void 0,
            this.payload = void 0
        }
        get storesMap() {
            return this.getStoreConfig("storesMap")
        }
        get StoreWrapper() {
            return this.getStoreConfig("StoreWrapper")
        }
        get Mutation() {
            return this.getStoreConfig("Mutation")
        }
        get ModelMutation() {
            return this.getStoreConfig("ModelMutation")
        }
        get ModelQuery() {
            return this.getStoreConfig("ModelQuery")
        }
        get pastMutations() {
            return this.getStoreConfig("pastMutations")
        }
        get futureMutations() {
            return this.getStoreConfig("futureMutations")
        }
        get pluginDispatchers() {
            return this.getStoreConfig("pluginDispatchers")
        }
        get pluginAccessors() {
            return this.getStoreConfig("pluginAccessors")
        }
        get connections() {
            return this.getStoreConfig("connections")
        }
        get pluginSlug() {
            return this.getStoreConfig("pluginRecord", "slug")
        }
        get pluginRecord() {
            return this.getStoreConfig("pluginRecord")
        }
        get sharedCore() {
            return this.getStoreConfig("sharedCore")
        }
        get isServer() {
            return this.getStoreConfig("isServer")
        }
        get types() {
            return this.getStoreConfig("types")
        }
        get modelStoreConfigs() {
            return this.getStoreConfig("modelStoreConfigs")
        }
        get logicMethodEnumValues() {
            return this.getPayload("logicMethodEnumValues")
        }
        get logicComponentEnumValues() {
            return this.getPayload("logicComponentEnumValues")
        }
        get permissionUserCanValues() {
            return this.getPayload("permissionUserCanValues")
        }
    }
    var vT = n(372);
    const bT = /^[^"'\r\n`]+$/;
    var _T = n(285);
    function ST(e) {
        if ("undefined" === typeof e || null === e)
            return e;
        if ("string" === typeof e) {
            if ("false" === e)
                return !1;
            if ("true" === e)
                return !0;
            e = Object(_T.f)(e)
        }
        return e
    }
    const OT = /^[A-Za-z]\w*$/;
    const TT = /^[+-]\d\d:\d\d$/;
    const IT = /^(?=.*[A-Z])(?=.*[a-z])(?=.*[\d\W]).{8,}$/;
    function xT(e) {
        return function(e) {
            e.RegExp.define({
                name: Xr.a.DATE_FORMAT_DIRECTIVE_VALUE,
                description: void 0,
                min: 0,
                regex: bT,
                regexErrorMsg: "The value must be between 1 and 255 characters, and cannot contain single or double quotes, backticks (`), or multiple lines."
            })
        }(e),
        function(e) {
            e.JSON.define({
                name: Xr.a.LOCATION_HISTORY,
                isSerializable: !0
            })
        }(e),
        function(e) {
            e.JSON.define({
                name: Xr.a.LOCATION_MATCH,
                isSerializable: !0
            })
        }(e),
        function(e) {
            e.Slug.define({
                name: Xr.a.PERMISSION,
                description: void 0
            })
        }(e),
        function(e) {
            e.ModelID.useString({
                modelName: tv.b.PERMISSION,
                fieldName: ev.a.PERMISSION,
                PERSISTENT_KIND: ei.a.STRING,
                canAutoGenerate: !1,
                regex: e.ModelID.createRegex(tv.b.PERMISSION, "[a-z0-9_]+"),
                regexErrorMsg: "The ID can only contain lowercase letters, numbers and underscores."
            })
        }(e),
        function(e) {
            e.ObjectInstance.use(he.r.PLUGIN)
        }(e),
        function(e) {
            e.ObjectInstance.use(he.r.PLUGIN_TYPES)
        }(e),
        function(e) {
            e.JSON.define({
                name: Xr.a.QUERY_CALC_VALUE,
                parseValue: ST
            })
        }(e),
        function(e) {
            e.RegExp.define({
                name: Xr.a.QUERY_SELECT_ALIAS_OR_VARIABLE_NAME,
                description: void 0,
                JSDOC_TYPE: "string",
                regex: OT,
                regexErrorMsg: "The value must start with an upper or lowercase letter, followed by only letters, numbers, or underscores."
            })
        }(e),
        function(e) {
            let t = e.get(Xr.a.SCHEMA_NAME);
            t || (t = {
                name: Xr.a.SCHEMA_NAME,
                regex: /^(?:$|[A-Za-z]\w{0,64}$)/,
                regexErrorMsg: "Must start with a letter followed by 0 or more letters, numbers, and underscores with a maximum of 64 total characters.",
                min: 0,
                max: 64
            },
            e.RegExp.define(t))
        }(e),
        function(e) {
            e.Slug.define({
                name: Xr.a.TAG,
                description: void 0
            })
        }(e),
        function(e) {
            e.RegExp.define({
                name: Xr.a.TIMEZONE_UTC_OFFSET,
                description: void 0,
                regex: TT,
                regexErrorMsg: 'The value must be a string starting with a sign ("+" or "-"), followed by "HH:MM", where "HH" is the number of hours (with leading 0 if less than 10), and "MM" is the number of minutes (also with leading 0 if less than 10).'
            })
        }(e),
        function(e) {
            e.RegExp.define({
                name: Xr.a.USER_PASSWORD,
                description: void 0,
                regex: IT,
                regexErrorMsg: "The password must be at least 8 characters, with at least 1 upper case and lower case letter, and at least 1 number or special character.",
                isEncrypted: !0
            })
        }(e),
        e
    }
    function wT(e) {
        return function(e) {
            e.JSON.define({
                name: Xr.a.ENCRYPTED_JSON,
                isSerializable: !0,
                min: 0,
                max: 1e4
            })
        }(e),
        xT(e)
    }
    const MT = "LogicLocalPropsScalar";
    var AT = n(1019);
    function ET(e) {
        return {
            mainTrxPriority: e.ownRefFieldIndexPriority,
            pendingTrxPriority: e.ownRefFieldIndexPriority,
            storeConfig: {
                name: e.ownRefFieldIndexName,
                VF: e,
                fieldNames: [e.ownRefFieldName],
                unique: !e.isMany,
                keyBy: e.ownRefFieldIndexKeyBy,
                includeNull: e.ownRefFieldIndexIncludeNull
            }
        }
    }
    const CT = e => e.pChanges ? e.pSize ? e.pState : null : e.size ? e.state : null;
    let NT = void 0
      , RT = void 0;
    const {FETCH: PT, FETCH_RAW: DT, FETCH_DIRECT: FT, FIND: kT, GET: jT} = ye
      , {PAYLOAD: LT, RECORDS_RESULTS: VT} = ge
      , {ARRAY_RESP: UT, OBJECT_RESP: qT, SINGLE_RESP: QT} = me;
    function BT(e) {
        const {responseFormat: t} = this
          , n = t === LT ? this.records : this.formattedResponse;
        let r = null;
        if (n) {
            if (this.responseFormatType === QT)
                return n[this.VF.ownRefModelThroughVF.modelVFName];
            const {VF: e} = this
              , i = e.ownRefModelThroughVF.modelVFName
              , o = e.ownRefModelPk
              , s = t === VT;
            let a;
            for (let t in n)
                (a = n[t][i]) && (r || (r = {})) && (r[s ? a.__record[o] : a[o]] = a)
        }
        if (t === LT)
            return this.records = r,
            this;
        if (!r)
            return r;
        {
            const {responseFormatType: e} = this;
            switch (e) {
            case qT:
                return r;
            case UT:
                return Object.values(r);
            default:
                return r
            }
        }
    }
    function GT(e) {
        return e.addDirectivesFromQuery(this).addSelectFromQuery(this).addIncludesFromQuery(this)
    }
    function zT(e) {
        return e.addArgsFromQuery(this)
    }
    function HT(e, t, n) {
        const r = e.queryArgs;
        let i;
        if (t.isManyToMany) {
            const o = t.ownModelThroughVF
              , s = t.ownRefModelThroughVF;
            i = t.throughModel.query().where(o.fieldName, n[o.refFieldName]),
            i.include(s.modelVFName, GT, e),
            r && i.andWhere(s.modelVFName, zT, e)
        } else
            r && 0 !== r.argsGroupIdx ? (i = e.convertToGroupedQuery(),
            i.andWhere(t.ownRefFieldName, n[t.ownFieldName])) : (i = e,
            i[r ? "andWhere" : "where"](t.ownRefFieldName, n[t.ownFieldName]));
        return i
    }
    const KT = function(e) {
        return class extends e {
            static initNewInstance(e, t, n, r) {
                const i = super.initNewInstance(e, t, n, r);
                return i.isRootQuery && (i.VF = t.VF,
                i.record = t.record),
                i
            }
            _normalizeQueryForVF(e, t, n, r) {
                if (!this.isRootQuery || !this.VF)
                    return super[r || jT](e, t, n);
                const {VF: i, record: o} = this;
                let s;
                if (!i.isManyToMany)
                    return s = HT(this, i, o),
                    s.VF = void 0,
                    s.record = void 0,
                    s[r || jT](e, t, i.isMany ? n : QT);
                let a = r;
                if (r === kT) {
                    const i = e ? {
                        dispatchId: e.dispatchId,
                        model: e.model,
                        responseFormat: t || e.responseFormat,
                        responseFormatType: n || e.responseFormatType
                    } : void 0
                      , o = this.resolve(i);
                    if (o && !0 === o.isDeterministic)
                        return super[r](o, t, n);
                    a = PT
                }
                if (this.pagination || r === DT) {
                    let a, c = i.ownRefModelThroughVF.refModelVFName;
                    if (c)
                        a = i.ownModelThroughVF.fieldName;
                    else {
                        if (!(c = i.ownRefModelVFName))
                            throw new Error("In order to use ".concat(this.pagination ? "pagination" : "fetchRaw()", ' on a many-to-many VFQuery ("').concat(i.ownModelName, '" -> "').concat(i.ownRefModelName, '"), the other model ("').concat(i.ownRefModelName, '") must have a named reciprocal relationship with the "').concat(i.ownModelName, '" model, or a named relationship with the through model ("').concat(i.throughModelName, '"). The named relationship with the through model is preferred, as this provides a more efficient query.'));
                        a = i.ownFieldName
                    }
                    return s = this.queryArgs && 0 !== this.queryArgs.argsGroupIdx ? this.convertToGroupedQuery() : this,
                    s.VF = void 0,
                    s.record = void 0,
                    s.andWhere(c, {
                        [a]: o[i.ownFieldName]
                    }),
                    s[r || jT](e, t, n)
                }
                if (s = HT(this, i, o),
                (e = s.preparePayload(e, t, n, r)).VF = i,
                !r || r === jT) {
                    const r = s.get(e, t, n);
                    return BT.call(e, r)
                }
                return s[a](e, t, n).pipe(Object(Y.a)(BT, e))
            }
            get(e, t, n) {
                return this._normalizeQueryForVF(e, t, n)
            }
            find(e, t, n) {
                return this._normalizeQueryForVF(e, t, n, kT)
            }
            fetch(e, t, n) {
                return this._normalizeQueryForVF(e, t, n, PT)
            }
            fetchRaw(e) {
                return this._normalizeQueryForVF(e, LT, qT, DT)
            }
            fetchDirect(e) {
                return this._normalizeQueryForVF(e, LT, qT, FT)
            }
            toGraphql(e, t) {
                if (this.isRootQuery && this.VF) {
                    const n = HT(this, this.VF, this.record);
                    return super.toGraphql.call(n, e, t)
                }
                return super.toGraphql(e, t)
            }
        }
    }(Bu)
      , YT = Ol.getBestDispatchId;
    const {COMMIT: WT} = dg.a;
    function $T(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
          , r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        if (!t.__ID)
            return console.warn("An attempt has been made to subscribe to a deleted or completed pending Record on the ".concat(e.ownModelName, " Model, VFName = ").concat(e.VFName, ", that references the ").concat(e.ownRefModelName, " Model, refVFName = ").concat(e.ownRefModelVFName, ".")),
            Xt.a;
        const i = n ? t.subscribeToAllPending() : t.subscribeAndPersist();
        return e.isMany ? Es(i, n ? e.getIndex().subscribeToAllPending() : e.getIndex(t.__dispatchId).subscribeAndPersist()).pipe(tI(e, t, n, r)) : i.pipe(XT(e, t, n, r))
    }
    function XT(e, t, n, r) {
        return i => i.lift(new JT(e,t,n,r))
    }
    class JT {
        constructor(e, t, n, r) {
            this.VF = e,
            this.record = t,
            this.allPending = n,
            this.createDelete = r
        }
        call(e, t) {
            return t.subscribe(new ZT(e,this.VF,this.record,this.allPending,this.createDelete))
        }
    }
    class ZT extends O.a {
        constructor(e, t, n, r, i) {
            super(e),
            this.VF = t,
            this.allPending = r,
            this.createDelete = i,
            this.fieldValue = n[t.ownFieldName];
            const o = this.VF.getIndex(n.__dispatchId);
            this.indexIsModel = Object(he.N)(o),
            this.indexSubscriber = r ? o.subscribeToAllPending(new eI(this)) : o.subscribeAndPersist(new eI(this)),
            e.add(this.indexSubscriber)
        }
        _next(e) {
            const t = e[this.VF.ownFieldName];
            t !== this.fieldValue && (this.fieldValue = t,
            this.destination.next(this.VF.getIndex(e.__dispatchId).get(this.fieldValue) || null))
        }
        notifyNext(e, t) {
            if (this.createDelete) {
                if (this.indexIsModel) {
                    const e = t.__changes
                      , n = e && e[this.fieldValue];
                    if (!n || n === ws.a.UPDATED)
                        return
                } else if (!t.changes || !t.hasCreate && !t.hasDelete)
                    return
            } else {
                let e;
                if (e = this.indexIsModel ? t.__changesEvent === WT ? t.__allChanges : t.__changes : t.event === WT ? t.allChanges : t.changes,
                !e || !e[this.fieldValue])
                    return
            }
            this.destination.next(t.get(this.fieldValue))
        }
        notifyError(e, t) {
            this.destination.error(t),
            this.unsubscribe()
        }
        notifyComplete() {
            this.destination.remove(this.indexSubscriber),
            this.indexSubscriber = null,
            super._complete()
        }
        unsubscribe() {
            this.closed || (super.unsubscribe(),
            this.indexSubscriber && (this.indexSubscriber.unsubscribe(),
            this.indexSubscriber = null),
            this.VF = null)
        }
    }
    class eI extends O.a {
        constructor(e) {
            super(),
            this.parent = e
        }
        _next(e) {
            this.parent.notifyNext(this, e)
        }
        _error(e) {
            this.parent.notifyError(this, e),
            this.unsubscribe()
        }
        _complete() {
            this.parent.notifyComplete(this),
            this.unsubscribe()
        }
        unsubscribe() {
            this.closed || (super.unsubscribe(),
            this.parent = null)
        }
    }
    function tI(e, t, n, r) {
        return i => i.lift(new nI(e,t,n,r))
    }
    class nI {
        constructor(e, t, n, r) {
            this.VF = e,
            this.record = t,
            this.allPending = n,
            this.createDelete = r
        }
        call(e, t) {
            return t.subscribe(new rI(e,this.VF,this.record,this.allPending,this.createDelete))
        }
    }
    class rI extends O.a {
        constructor(e, t, n, r, i) {
            super(e),
            this.VF = t,
            this.allPending = r,
            this.createDelete = i,
            this.childIndexSubscriber = null,
            this.childIndex$ = null,
            this.fieldValue = null,
            this.__processSub(n, !0)
        }
        __processSub(e, t) {
            let n;
            if (Object(he.U)(e)) {
                const t = e[this.VF.ownFieldName];
                if (t === this.fieldValue)
                    return;
                this.fieldValue = t,
                n = this.VF.getIndex(e.__dispatchId).get(t)
            } else
                n = e.get(this.fieldValue);
            const r = this.childIndex$;
            if (n && r) {
                if (n.storeId === r.storeId)
                    return;
                this.childIndex$ = n,
                this.destination.remove(this.childIndexSubscriber),
                this.childIndexSubscriber.unsubscribe(),
                this.childIndexSubscriber = this.allPending ? n.subscribeToAllPending(new iI(this)) : n.subscribeAndPersist(new iI(this)),
                this.destination.add(this.childIndexSubscriber),
                super._next(n.value)
            } else
                n ? (this.childIndex$ = n,
                this.childIndexSubscriber = this.allPending ? n.subscribeToAllPending(new iI(this)) : n.subscribeAndPersist(new iI(this)),
                this.destination.add(this.childIndexSubscriber),
                t || super._next(n.value)) : r && (this.childIndex$ = null,
                this.destination.remove(this.childIndexSubscriber),
                this.childIndexSubscriber.unsubscribe(),
                this.childIndexSubscriber = null,
                t || super._next(null))
        }
        _next(e) {
            this.__processSub(e)
        }
        notifyNext(e, t) {
            e === this.childIndexSubscriber && (this.createDelete ? t.changes && (t.hasCreate || t.hasDelete) && this.destination.next(t) : (t.changes || t.event === WT && t.allChanges) && this.destination.next(t))
        }
        notifyError(e, t) {
            e === this.childIndexSubscriber && (this.destination.error(t),
            this.unsubscribe())
        }
        notifyComplete(e) {
            this.destination.remove(e),
            e === this.childIndexSubscriber && (this.childIndexSubscriber = null,
            this.childIndex$ = null,
            super._next(null))
        }
        unsubscribe() {
            this.closed || (super.unsubscribe(),
            this.childIndexSubscriber && (this.childIndexSubscriber.unsubscribe(),
            this.childIndexSubscriber = null,
            this.childIndex$ = null),
            this.VF = null)
        }
    }
    class iI extends O.a {
        constructor(e) {
            super(),
            this.parent = e
        }
        _next(e) {
            this.parent.notifyNext(this, e)
        }
        _error(e) {
            this.parent.notifyError(this, e),
            this.unsubscribe()
        }
        _complete() {
            this.parent.notifyComplete(this),
            this.unsubscribe()
        }
        unsubscribe() {
            this.closed || (super.unsubscribe(),
            this.parent = null)
        }
    }
    const oI = {
        addTriggers: function(e) {
            return this
        },
        buildJsdoc: function(e, t, n) {
            if (!this.VFName || !NT)
                return e;
            const r = e.instance.getMeta("members")
              , i = this.accessorsMap;
            return r[this.VFName] = NT.property(this, e, t, n),
            r[i.query] = NT.query(this, e),
            r[i.subscribe] = NT.subscribe(this, e),
            r[i.subscribeToCreateDelete] = NT.subscribeToCreateDelete(this, e),
            e
        },
        destroy: function() {
            if (this.foreignField = void 0,
            this.isManyToMany ? (this.modelThroughVF = void 0,
            this.refModelThroughVF = void 0) : this.manyToManyVF && (this.manyToManyVF = void 0),
            this.refModelTrigger = void 0,
            Object.hasOwnProperty.call(this, "processMutationAutoload") && (this.processMutationAutoload = void 0),
            this.computedApi && (this.computedApi.destroy(),
            this.computedApi = void 0),
            this.accessorsMap) {
                this.accessorsMap = void 0;
                const {accessorsMethods: e} = this;
                for (let t in e)
                    e[t] = void 0;
                this.accessorsMethods = void 0
            }
        },
        executeIncludeQuery: function(e) {
            const t = e.query;
            return t.parentQueryArg && t.parentQueryArg.prepareWrapperQueryArg(e) ? t.executeQuery(e) : null
        },
        get: function(e, t) {
            if (!e)
                return;
            let n = e[this.ownFieldName];
            return n && (n = this.getIndex(t || e.__dispatchId).get(n)) && (!this.isMany || (n = CT(n.value))) ? n : !1 === e[this.ownModelCacheMissingFieldName] ? null : void 0
        },
        getIndex: function(e) {
            return this.ownRefFieldIndexModel.getIndex(this.ownRefFieldIndexName, e, !0)
        },
        getter: function(e, t) {
            if (!t)
                return null;
            let n = t.get(this.ownFieldName);
            return n && (n = this.getIndex(t.mainDispatchId).get(n)) && (!this.isMany || (n = CT(n.value))) ? n : !1 === t.get(this.ownModelCacheMissingFieldName) ? null : void 0
        },
        getValue: function(e, t) {
            const n = e[this.ownFieldName];
            return null === n || "undefined" === typeof n ? n : this.getIndex(t || e.__dispatchId).get(n)
        },
        getWithIndex: function(e, t) {
            let n = t[this.ownFieldName];
            return n && (n = e.get(n)) && (!this.isMany || (n = CT(n.value))) ? n : !1 === t[this.ownModelCacheMissingFieldName] ? null : void 0
        },
        graphqlCreateInputFieldDesc: function(e) {
            return RT && RT.createInputField(this, e) || ""
        },
        graphqlObjectFieldDesc: function(e) {
            return RT && RT.objectField(this, e)
        },
        graphqlQueryInputFieldDesc: function(e) {
            return RT && RT.queryInputField(this, e) || ""
        },
        graphqlUpdateInputFieldDesc: function(e) {
            return RT && RT.updateInputField(this, e) || ""
        },
        markCacheCompleteFromQueryArg: function(e, t, n) {},
        mergeQueryResults: function(e) {
            const t = e.parent.recordsResults;
            if (!t)
                return;
            const n = e.recordsResults
              , r = e.originalQuery ? e.originalQuery.queryAlias || this.bestVFName : e.query.queryAlias || this.bestVFName;
            let i;
            if (!n) {
                for (let e in t)
                    i = t[e],
                    i[r] || (i[r] = null);
                return
            }
            const {ownRefModelPk: o} = this
              , s = this.ownFieldIsPk ? null : this.ownFieldName
              , a = e.parent.records
              , c = this.getIndex(YT(e)).getState();
            let u;
            if (this.isMany) {
                let e, l, d;
                for (let h in t) {
                    if (i = t[h],
                    e = i[r],
                    s) {
                        if (!(u = a[h][s]))
                            continue
                    } else
                        u = h;
                    if (d = c[u])
                        for (u in d = d.getState(),
                        d)
                            l = n[d[u][o]],
                            l && (e || (i[r] = e = {}),
                            e[u] = l);
                    e || (i[r] = null)
                }
            } else {
                let e;
                for (let l in t) {
                    if (i = t[l],
                    s) {
                        if (!(u = a[l][s]))
                            continue
                    } else
                        u = l;
                    (e = c[u]) && (e = n[e[o]]) ? i[r] = e : i[r] || (i[r] = null)
                }
            }
        },
        prepareIncludeQuery: function(e) {
            if (!e.isVerified) {
                e.isVerified = !0;
                const {ownFieldFullVFPath: t} = this;
                if (t) {
                    const n = e.parent
                      , r = n.query.cloneForExecute(n).includeWithFullPath(this.bestVFName, null, n)
                      , {ownModel: i} = this;
                    let o;
                    for (let e of t) {
                        if (e.ownModel !== i)
                            break;
                        o = r.getInclude(e.bestVFName),
                        o.getQueryPayload(n).isVerified = !1,
                        o.prepareQuery(n)
                    }
                }
            }
            return e
        },
        prepareIncludeQueryIndex: function(e) {
            return e
        },
        prepareIncludeQueryRecordResult: function(e, t) {
            let n = e => {
                const r = this.ownRefFieldIndexModel.getIndex(t.originalQueryId);
                n = e => this.getWithIndex(r, e),
                n(e)
            }
            ;
            Object.defineProperty(e.prototype, this.bestVFName, {
                get() {
                    return n(this.__record)
                },
                set: void 0
            })
        },
        processCreateVFData: function(e, t, n, r, i, o) {},
        processQueryAutoload: function(e) {},
        processMutationAutoload: function(e, t) {},
        processUpdateVFData: function(e, t, n, r, i, o) {
            const s = this.bestVFName
              , a = n[s];
            if (!a)
                return;
            const c = r.switchTo(this.ownRefModel);
            let u;
            if (c.watchUpdateVFDataForPkChanges(a),
            o ? (u = o[s]) || null === u || (u = e[s],
            o = null) : u = e[s],
            u)
                if (t = t ? t[s] : null,
                this.isMany)
                    if (o)
                        for (let l in u)
                            c.addTriggerData(u[l].__record, t, a, i, u[l]);
                    else
                        c.forObjectAddTriggerData(u, t, a, i, !0);
                else
                    o && (o = u,
                    u = u.__record),
                    c.addTriggerData(u, t, a, i, o)
        },
        query: function(e, t) {
            t || null === t || (t = e.__dispatchId);
            const n = KT.init(t ? this.ownRefModel.getBestInstance(t) : this.ownRefModel);
            return n.VF = this,
            n.record = e,
            n
        },
        register: function(e) {
            !this.VFName && this.ownModelVFName && (this.VFName = this.ownModelVFName),
            this.isMany && !this.keyBy && this.ownRefFieldIndexKeyBy !== this.ownRefModelPk && (this.keyBy = this.ownRefFieldIndexKeyBy),
            this.addIndex(e).addTriggers(e),
            this.ownModel.registerVF(this)
        },
        setter: function(e, t, n) {
            const r = n.value.mutation;
            if (!r)
                throw new Error("The record on Model ".concat(this.ownModelName, " has attempted to set a value for its ").concat(this.VFName, " VirtualField. But the Record is not part of a mutation, which it must be in order for this to be done. Call the mutation's getMutableRecord() before attempting to set any values on the Record, or in some way ensure the record is part of a mutation."));
            r.create(e, this.bestVFName, t)
        },
        subscribe: function(e, t) {
            if (t && Array.isArray(t))
                return function(e, t, n) {
                    if (!e.isMany)
                        return $T(e, t, !1, !0).pipe($(e => e ? e.subscribeTo(n).pipe(Object(Sb.a)(e)) : Object(D.c)()));
                    if (jb(e.ownRefModel.fields, n))
                        return $T(e, t, !1, !1).pipe(Object(H.a)(e => {
                            if (!e || !e.size || e.hasDelete || e.hasCreate)
                                return !0;
                            if (!e.changes)
                                return !1;
                            const {state: t, changes: r} = e;
                            for (let i in r)
                                if (!t[i] || Fb(t[i], t[i].__changes, n))
                                    return !0;
                            return !1
                        }
                        ));
                    let r, i = e.getValue(t);
                    if (i) {
                        i = i.getState(),
                        r = {};
                        for (let e in i)
                            r[i[e].__storeId] = i[e].__createVFSubscribeToMapper(n)
                    }
                    return $T(e, t, !1, !1).pipe(Object(H.a)(e => {
                        if (!e || !e.size)
                            return !0;
                        if (!e.changes)
                            return !1;
                        r || (r = {});
                        const {state: t, changes: i} = e;
                        let o, s = !1;
                        for (let a in i)
                            t[a] ? (o = t[a].__storeId,
                            r[o] ? r[o](t[a]) && (s = !0) : (r[o] = t[a].__createVFSubscribeToMapper(n),
                            s = !0)) : s = !0;
                        return s
                    }
                    ))
                }(this, e, t);
            const n = $T(this, e);
            return t ? n.subscribe(t) : n
        },
        subscribeToAllPending: function(e, t) {
            const n = $T(this, e, !0);
            return t ? n.subscribe(t) : n
        },
        subscribeToCreateDelete: function(e, t) {
            const n = $T(this, e, !1, !0);
            return t ? n.subscribe(t) : n
        }
    };
    function sI(e) {
        const t = new this;
        return t.isMetaVF = !1,
        t.extraWrapperKeys = null,
        t.foreignField = e || null,
        t.isMany = this.isMany,
        t.isManyToMany = this.isManyToMany,
        t.isRefModel = this.isRefModel,
        e ? (t.instanceId = "".concat(e.id || "vf".concat(Object(oe.b)()), "__").concat(this.isRefModel ? "refModel" : "model"),
        t.ownModelVF = t,
        !t.VFName && t.ownModelVFName && (t.VFName = t.ownModelVFName),
        t) : (t.instanceId = "vf_instance_id_".concat(Object(oe.b)()),
        t)
    }
    function aI(e) {}
    function cI(e, t) {
        if (e.isRefModel = !1,
        Object.defineProperties(e.prototype, AT.e),
        e.prototype.processQueryAutoload = aI,
        !t)
            return e;
        const n = t.storeConfig.getPluginStoreConfig;
        e.prototype.processMutationAutoload = function(e, t) {
            const r = n(e.model).storesMap
              , i = r.get(e.model).mainStore
              , o = this.ownRefFieldIndexIsModelState ? r.get(this.getIndex(e.mainDispatchId)).mainStore : this.getIndex(e.mainDispatchId).mainStore
              , {fieldName: s, refFieldName: a} = this
              , c = this.ownModelCacheMissingFieldName
              , u = this.refModel.getMainInstance()
              , l = this.ownRefModelVF.isMany ? null : this.refModelCacheMissingFieldName;
            let d;
            this.processMutationAutoload = function(e, t) {
                d = this.ownModelAutoload,
                t || ({records: t} = e);
                const n = i.getBestStore(e.mainDispatchId).value
                  , h = o.getBestStore(e.mainDispatchId).value;
                let f, p, g, m;
                for (let i in t)
                    (f = n.get(i)) && (p = r.get(f).value,
                    p.get(c) && ((g = p.get(s)) ? (m = h.get(g)) ? (f[c] = !1,
                    l && (m[l] = !1)) : d && (f[c] = !1,
                    e.addToFollowupQueries(u, a, g)) : f[c] = !1))
            }
            ,
            this.processMutationAutoload(e, t)
        }
    }
    function uI(e) {
        const {ownRefModelName: t, ownModelName: n, ownFieldName: r, ownRefFieldName: i} = e;
        return e.isRefModel ? new Error("Unable to create the ".concat(t, " records provided with the ").concat(n, " records. The field ").concat(r, " was not provided with the ").concat(n, " records in order to populate the field ").concat(i, " on the provided ").concat(t, " records, nor was there a valid value for the field ").concat(i, " in the ").concat(t, " records. There is not enough information to create the relationship.")) : new Error("Unable to create the ".concat(t, " record with the ").concat(n, " record provided. The reference field ").concat(i, " on ").concat(t, " is not an auto-incremented primary key (which would allow it to be auto-created), and the key was not provided. Additionally, the foreign field ").concat(r, " on ").concat(n, " was also not provided. So there is not enough information to associate the records, or create the record on\n    ").concat(t, "."))
    }
    const lI = (e, t) => {
        !e.isMany && e.ownModelCacheMissingFieldName && (t[e.ownModelCacheMissingFieldName] = !1)
    }
    ;
    function dI(e, t, n, r, i, o) {
        let s;
        if (o)
            s = n,
            n = null;
        else if (!(s = n[this.bestVFName]))
            return;
        e = r.getMutationType(Gr.c).addRecord(e, null, !1, !0, this.ownModelCacheMissingFieldName);
        const a = r.getModelMutation(this.ownRefModel);
        if (r.isCommitOnly)
            return lI(this.ownRefModelVF, s),
            void a.getMutationType(Gr.a).addRecord(s, i);
        if (Object(he.U)(s)) {
            s = a.getMutableRecord(s);
            const t = s[this.ownRefFieldName]
              , n = e[this.ownFieldName];
            if (!n && !t)
                throw uI(this);
            if (n === t)
                return;
            return !n || !this.isRefModel && t ? r.getMutationType(Gr.c).addRecord(e, null, t, i, this.ownFieldName) : a.getMutationType(Gr.c).addRecord(s, null, n, i, this.ownRefFieldName),
            void lI(this.ownRefModelVF, s)
        }
        if (!(s = a.preprocessOwnRefModelCreate(s, this, e, n)))
            return void r.getMutationType(Gr.c).addRecord(e, null, !0, !0, this.ownModelCacheMissingFieldName);
        lI(this.ownRefModelVF, s);
        let c = e[this.ownFieldName];
        if (c) {
            if (s[this.ownRefFieldName] = c,
            s = a.getMutationType(Gr.a).addRecord(s, i)) {
                const t = s[this.ownRefFieldName];
                if (t === c)
                    return;
                this.isRefModel ? a.getMutationType(Gr.c).addRecord(s, null, c, i, this.ownRefFieldName) : r.getMutationType(Gr.c).addRecord(e, null, t, i, this.ownFieldName)
            } else if (!r.isCancelling && !this.isRefModel) {
                if (this.ownField.notNullable)
                    throw new Error("A ".concat(r.modelName, ' mutation contained data for virtual field "').concat(this.VFName, '", but permission was denied to create the record on the "').concat(this.ownRefModelName, '" model. Yet the foreignField "').concat(this.ownFieldName, '" on the ').concat(r.modelName, " is not nullable. Therefore, the mutation cannot be completed."));
                r.getMutationType(Gr.c).addRecord(e, null, null, i, this.ownFieldName)
            }
        } else {
            if (!s[this.ownRefFieldName] && !this.ownRefFieldIsPk)
                throw uI(this);
            (s = a.getMutationType(Gr.a).addRecord(s, i)) && (c = s[this.ownRefFieldName],
            r.getMutationType(Gr.c).addRecord(e, null, c, i, this.ownFieldName))
        }
        s || r.isCancelling || c && this.getIndex(r.dispatchId).get(c) || r.getMutationType(Gr.c).addRecord(e, null, !0, !0, this.ownModelCacheMissingFieldName)
    }
    function hI(e) {
        return e.isMany = !1,
        e.isManyToMany = !1,
        e.prototype.processCreateVFData = dI,
        e
    }
    function fI(e, t, n) {
        const r = this.getIndex(t)
          , i = this.ownRefModelVF
          , o = i.getIndex(t).value
          , s = this.ownModelCacheMissingFieldName
          , a = this.ownRefFieldIndexIsModelState ? r.notExists : r.storeConfig.notExists
          , c = o.storeConfig.notExists;
        let u;
        if (i.isMany) {
            let t, n, i;
            for (let l of e)
                if (u = r.get(l)) {
                    if (s && (t = o.get(l)))
                        for (i in n = t.getState(),
                        n)
                            n[i][s] = !1
                } else
                    a[l] = !0,
                    c[l] = !0
        } else {
            const t = this.ownRefModelCacheMissingFieldName;
            let n;
            for (let i of e)
                (u = r.get(i)) ? (n = o.get(i)) && (s && (n[s] = !1),
                t && (u[t] = !1)) : (a[i] = !0,
                c[i] = !0)
        }
    }
    function pI(e, t) {
        class n extends e {
        }
        return cI(n, t),
        hI(n),
        function(e) {
            e.relationshipType = iO.a.BELONGS_TO,
            e.otherRelationshipType = iO.a.HAS_MANY,
            e.prototype.markCacheCompleteFromQueryArg = fI
        }(n),
        n
    }
    function gI(e) {
        class t extends e {
        }
        return function(e) {
            e.isRefModel = !1,
            e.relationshipType = iO.a.BELONGS_TO_MANY,
            e.otherRelationshipType = iO.a.BELONGS_TO_MANY_REF,
            Object.defineProperties(e.prototype, AT.d)
        }(t),
        t
    }
    function mI(e) {
        class t extends e {
        }
        return function(e) {
            e.isRefModel = !0,
            e.relationshipType = iO.a.BELONGS_TO_MANY_REF,
            e.otherRelationshipType = iO.a.BELONGS_TO_MANY,
            Object.defineProperties(e.prototype, AT.f)
        }(t),
        t
    }
    function yI(e, t, n, r, i, o) {
        let s;
        if (o)
            s = n,
            n = null;
        else if (!(s = n[this.bestVFName]))
            return;
        let a = r.getModelMutation(this.ownRefModel);
        if (a.isCommitOnly)
            return void a.getMutationType(Gr.a).forManyAddRecord(s, i);
        if (!(s = a.preprocessOwnRefModelCreate(s, this, e, n)))
            return;
        const {ownRefFieldName: c} = this;
        let u = e[this.ownFieldName];
        if (null === u || "undefined" === typeof u) {
            if (u = function(e, t) {
                let n, r = void 0;
                if (Array.isArray(e))
                    for (let i of e) {
                        if (n = i[t],
                        null === n || "undefined" === typeof n || void 0 !== r && r !== n) {
                            n = !1;
                            break
                        }
                        r = n
                    }
                else
                    for (let i in e) {
                        if (n = e[i][t],
                        null === n || "undefined" === typeof n || void 0 !== r && r !== n) {
                            n = !1;
                            break
                        }
                        r = n
                    }
                return n
            }(s, c),
            !1 === u)
                throw uI(this);
            if (void 0 === r.getMutationType(Gr.c).addRecord(e, null, u, i, this.ownFieldName))
                return
        }
        if (this.manyToManyVF) {
            const {field: e, fieldName: t, bestVFName: n, refModel: r, refModelPk: o} = this.manyToManyVF.ownRefModelThroughVF.modelVF;
            Array.isArray(s) || (s = Object.values(s));
            const l = a.getMutationType(Gr.a);
            let d, h, f;
            for (let a = 0; a < s.length; a++) {
                if (d = s[a],
                d[c] = u,
                h = d[n])
                    (f = h[o]) ? d[t] = f : (f = d[t]) ? h[o] = f : (r.ensureRecordDataHasPkValue(h),
                    d[t] = h[o]);
                else if (!d[t] && e.notNullable)
                    throw uI(this.manyToManyVF.ownRefModelThroughVF);
                if (s[a] = l.addRecord(d, i),
                void 0 === s[a])
                    return
            }
        } else {
            a = a.getMutationType(Gr.a);
            const {ownRefFieldName: e} = this;
            let t, n;
            if (Array.isArray(s)) {
                for (let o = 0, c = s.length; o < c; o++)
                    if (t = s[o],
                    Object(he.U)(t) ? (n || (n = r.switchTo(this.ownRefModel).getMutationType(Gr.c)),
                    s[o] = n.addRecord(t, null, u, i, this.ownRefFieldName)) : (t[e] = u,
                    s[o] = a.addRecord(t, i)),
                    void 0 === s[o])
                        return
            } else
                for (let o in s)
                    if (t = s[o],
                    Object(he.U)(t) ? (n || (n = r.switchTo(this.ownRefModel).getMutationType(Gr.c)),
                    s[o] = n.addRecord(t, null, u, i, this.ownRefFieldName)) : (t[e] = u,
                    s[o] = a.addRecord(t, i)),
                    void 0 === s[o])
                        return
        }
    }
    function vI(e) {
        return e.isMany = !0,
        e.isManyToMany = !1,
        e.prototype.processCreateVFData = yI,
        e
    }
    var bI = n(161);
    const {NO_ACTION: _I, RESTRICT: SI, CASCADE: OI} = bI.a;
    function TI(e, t, n, r, i, o, s) {
        if (i.isUndoRedo)
            return;
        if (s || (s = this.onUpdate),
        s === _I || s === SI)
            return;
        const a = this.getIndex(i.mainDispatchId).get(n);
        if (!a)
            return;
        r = {
            [this.ownRefFieldName]: s === OI ? r : null
        };
        const c = i.getModelMutation(this.ownRefModel);
        this.isMany ? c.forObjectAddTriggerData(a.getState(), null, r, o, !0) : c.addTriggerData(a, null, r, o)
    }
    class II extends Bm {
        static use(e) {
            if (!e.isRefModel)
                throw new Error('The RefModelTrigger should only be instantiated with a virtualField that is serving as the "refModel" in the relationship.');
            if (e.isManyToMany)
                throw new Error("The RefModelTrigger cannot be used with a many-to-many virtualField.");
            const t = this.init(e.ownRefFieldIndexPriority, e);
            return t.setFieldNames(e.ownFieldName),
            e.ownModel.triggers.add(t),
            t
        }
    }
    function xI(e) {
        return this.refModelTrigger = II.use(this),
        this
    }
    function wI(e, t) {
        if (e.isRefModel = !0,
        e.prototype.addTriggers = xI,
        Object.defineProperties(e.prototype, AT.g),
        !t)
            return e;
        const n = t.storeConfig.getPluginStoreConfig;
        return e.prototype.processMutationAutoload = function(e, t) {
            if (!this.ownModelAutoload)
                return;
            const r = n(e.model).storesMap
              , i = r.get(e.model).mainStore
              , o = this.ownModelCacheMissingFieldName
              , s = this.isMany ? null : this.getIndex(e.mainDispatchId).mainStore
              , {ownFieldName: a, ownRefFieldName: c} = this
              , u = this.ownRefModel.getMainInstance();
            this.processMutationAutoload = function(e, t) {
                if (!this.ownModelAutoload)
                    return !1;
                t || ({records: t} = e);
                const n = i.getBestStore(e.mainDispatchId).value
                  , l = s ? s.getBestStore(e.mainDispatchId).value : null
                  , d = e.controller;
                let h, f, p;
                for (let i in t)
                    (h = n.get(i)) && (p = r.get(h),
                    p.get(o) && (h[o] = !1,
                    !(f = p.get(a)) || l && l.get(f) || d.addToFollowupQueries(u, c, f)))
            }
            ,
            this.processMutationAutoload(e, t)
        }
        ,
        e.prototype.processQueryAutoload = function(e) {
            if (!this.ownModelAutoload)
                return;
            const t = e.query;
            if (!t.isRootQuery) {
                if (t.parentQueryArg.VF === this.ownRefModelVF)
                    return
            }
            t.cloneForExecute(e).includeAll(this.ownModelVFName, !0, e)
        }
        ,
        e
    }
    II.prototype.afterFieldUpdate = TI,
    II.prototype.afterDelete = function(e, t, n, r, i, o) {
        if (!i.isUndoRedo)
            if (this.onDelete !== OI)
                TI.call(this, r, this.ownFieldName, n[this.ownFieldName], null, i, o, this.onDelete);
            else {
                const e = this.getIndex(i.mainDispatchId).get(n[this.ownFieldName]);
                if (!e)
                    return;
                const t = i.getModelMutation(this.ownRefModel);
                this.isMany ? t.forObjectAddTriggerData(e.getState(), null, null, o, !0) : t.addTriggerData(e, null, null, o)
            }
    }
    ;
    function MI(e, t, n) {
        const r = this.getIndex(t).value
          , i = this.ownRefModelVF.getIndex(t)
          , o = this.ownModelCacheMissingFieldName
          , s = this.ownRefModelCacheMissingFieldName
          , a = r.storeConfig.notExists
          , c = this.manyToManyVF;
        let u, l, d, h;
        if (c) {
            const n = c.getIndex(t)
              , f = n.storeConfig.notExists
              , p = c.ownModelCacheMissingFieldName
              , g = c.ownRefModelThroughVF.modelCacheMissingFieldName;
            let m, y;
            for (let t of e)
                if ((u = i.get(t)) && o && (u[o] = !1),
                l = r.get(t)) {
                    for (d in l.value.cacheComplete = !0,
                    h = l.getState(),
                    y = !0,
                    h)
                        m = h[d],
                        y && m[g] && (y = !1),
                        u && s && (m[s] = !1);
                    y && (u && p && (u[p] = !1),
                    (l = n.get(t)) && (l.value.cacheComplete = !0))
                } else
                    a[t] = !0,
                    f[t] = !0,
                    u && p && (u[p] = !1)
        } else
            for (let f of e)
                if ((u = i.get(f)) && o && (u[o] = !1),
                l = r.get(f)) {
                    if (!l.value.cacheComplete && (l.value.cacheComplete = !0,
                    u && s))
                        for (d in h = l.getState(),
                        h)
                            h[d][s] = !1
                } else
                    a[f] = !0
    }
    function AI(e, t) {
        class n extends e {
        }
        return wI(n, t),
        vI(n),
        function(e) {
            e.relationshipType = iO.a.HAS_MANY,
            e.otherRelationshipType = iO.a.BELONGS_TO,
            e.prototype.markCacheCompleteFromQueryArg = MI
        }(n),
        n
    }
    function EI(e, t, n) {
        const r = this.getIndex(t).value
          , i = this.ownRefModelVF.getIndex(t)
          , o = this.ownModelCacheMissingFieldName
          , s = this.ownRefModelCacheMissingFieldName
          , a = r.storeConfig.notExists;
        let c, u;
        for (let l of e)
            (c = i.get(l)) && o && (c[o] = !1),
            (u = r.get(l)) ? c && s && (u[s] = !1) : a[l] = !0
    }
    function CI(e, t) {
        class n extends e {
        }
        return wI(n, t),
        hI(n),
        function(e) {
            e.relationshipType = iO.a.HAS_ONE,
            e.otherRelationshipType = iO.a.BELONGS_TO,
            e.prototype.markCacheCompleteFromQueryArg = EI
        }(n),
        n
    }
    function NI(e) {
        const t = this.throughModelUniqueIndexName;
        return t ? this.throughModel.getIndex(t, e, !0) : null
    }
    function RI(e, t, n) {
        const r = this.ownModel.getBestInstance(t)
          , i = this.ownRefModel.getBestInstance(t)
          , o = this.getIndex(t)
          , s = this.ownRefModelVF.getIndex(t);
        console.log(" "),
        console.log("CACHE COMPLETE FOR M2M " + this.VFName + " - " + this.ownModelRelationship),
        console.log({
            ownModel: r,
            ownRefModel: i,
            ownModelState: r.getState(),
            ownRefModelState: i.getState(),
            ownIndex: o,
            ownRefIndex: s,
            VF: this,
            ownRefVF: this.ownRefModelVF,
            values: e,
            payload: n
        })
    }
    class PI extends Bm {
        constructor(e, t, n) {
            if (super(e),
            Object(he.Z)(t)) {
                let e, r = t;
                r.isRefModel ? (e = r,
                r = r.ownRefModelVF) : e = r.ownRefModelVF,
                this.modelM2MIndex = e.getIndex(n).mainStore,
                this.modelThroughIndex = r.throughModelUniqueConstraint ? null : r.modelThroughVF.getIndex(n).mainStore,
                this.modelThroughFieldName = r.modelThroughFieldName,
                this.refModelM2MIndex = r.getIndex(n).mainStore,
                this.refModelThroughFieldName = r.refModelThroughFieldName
            } else
                this.modelM2MIndex = t.modelM2MIndex,
                this.modelThroughIndex = t.modelThroughIndex || null,
                this.modelThroughFieldName = t.modelThroughFieldName,
                this.refModelM2MIndex = t.refModelM2MIndex,
                this.refModelThroughFieldName = t.refModelThroughFieldName;
            let r = this.modelM2MIndex.storeConfig;
            this.modelIdxName = r.name,
            this.modelName = r.model.modelName,
            r = this.refModelM2MIndex.storeConfig,
            this.refModelIdxName = r.name,
            this.refModelName = r.model.modelName,
            this.fieldNames = [this.modelThroughFieldName, this.refModelThroughFieldName]
        }
        maybeDelete(e, t, n) {
            const r = n.getModel(this.modelName)
              , i = n.getModel(this.refModelName);
            let o = r.get(e)
              , s = i.get(t);
            if (!o || !s) {
                if (!o && !r.getPrev(e))
                    return;
                if (!s && !i.getPrev(t))
                    return;
                let a = n.switchTo(r)
                  , c = a.getMutableIndex(this.modelIdxName).value.getMutableChild(t, a, !0);
                return c && c.value.deleteAll(),
                a = n.switchTo(i),
                c = a.getMutableIndex(this.refModelIdxName).value.getMutableChild(e, a, !0),
                void (c && c.value.deleteAll())
            }
            if (this.modelThroughIndex) {
                const r = this.modelThroughIndex.getBestStore(n.mainDispatchId).get(e);
                if (!r)
                    return;
                const i = r.getState()
                  , o = this.refModelThroughFieldName;
                for (let e in i)
                    if (i[e][o] === t)
                        return
            }
            (n = n.switchTo(r)).getMutableIndex(this.modelIdxName).value.deleteKeyValue(t, o, n),
            (n = n.switchTo(i)).getMutableIndex(this.refModelIdxName).value.deleteKeyValue(e, s, n)
        }
        updateIndexes(e, t, n) {
            const r = n.getModel(this.modelName)
              , i = n.getModel(this.refModelName)
              , o = r.get(e);
            if (!o)
                return;
            const s = i.get(t);
            s && ((n = n.switchTo(r)).getMutableIndex(this.modelIdxName).value.setKeyValue(t, o, n, o.getState()),
            (n = n.switchTo(i)).getMutableIndex(this.refModelIdxName).value.setKeyValue(e, s, n, s.getState()))
        }
        afterFieldUpdate(e, t, n, r, i) {
            if (t === this.modelThroughFieldName) {
                const t = e[this.refModelThroughFieldName];
                if (!t)
                    return;
                n && this.maybeDelete(n, t, i),
                r && this.updateIndexes(r, t, i)
            } else {
                const t = e[this.modelThroughFieldName];
                if (!t)
                    return;
                n && this.maybeDelete(t, n, i),
                r && this.updateIndexes(t, r, i)
            }
        }
        afterDelete(e, t, n, r, i, o) {
            const {[this.modelThroughFieldName]: s, [this.refModelThroughFieldName]: a} = n;
            s && a && this.maybeDelete(s, a, i)
        }
        create(e, t, n, r, i, o) {
            const {[this.modelThroughFieldName]: s, [this.refModelThroughFieldName]: a} = r.getState();
            s && a && this.updateIndexes(s, a, i)
        }
    }
    const DI = Xm.b.initModule("@isomorix/core/modelsRelationships/types/manyToMany/trxLogic").setPackageName("@isomorix/core-models-relationships").addSource(Jm)
      , {STALE: FI} = dg.a
      , {CREATED: kI, UPDATED: jI} = ws.a
      , LI = (e, t, n, r, i, o) => {
        const s = e[r]
          , a = t[r];
        if (a === s)
            return;
        const c = t.__changesToCommit;
        (!o || c && c[r] === FI) && n.recordKeyByUpdate(t, s, a, i, c && c[r] === FI)
    }
      , VI = DI.findByName("addTriggers", c.a)
      , UI = DI.findByName("hydrateIndex", c.a);
    function qI(e) {
        if (e.payload.isMain) {
            const t = e.meta.store.storeConfig;
            if (!t.throughModelTrigger) {
                if (t.ownM2MIndex.storeConfig.throughModelTrigger)
                    return e;
                t.throughModelTrigger = new PI(t.VF.ownFieldIndexPriority,t.VF,e.meta.dispatchId)
            }
            t.VF.throughModel.triggers.add(t.throughModelTrigger)
        }
        return e
    }
    function QI(e) {
        const {payload: t} = e;
        if (0 === t.recordsSize && 0 === t.changesSize)
            return e;
        const {records: n, changes: r} = t
          , i = e.meta.store.storeConfig
          , o = t.mutation
          , s = o.getMutableIndex(i.name).value
          , a = i.keyBy === i.primaryKey ? null : i.keyBy
          , {throughFieldName: c} = i
          , u = i.ownThroughIndex.getBestStore(o.mainDispatchId).value
          , l = u.getState()
          , d = i.ownM2MIndex.storeConfig.model.getBestInstance(e.mainDispatchId).getState();
        let h, f, p, g, m;
        if (t.isMain) {
            for (let e in l)
                if (g = d[e]) {
                    m = l[e].getState(),
                    p = void 0;
                    for (let t in m)
                        (f = m[t][c]) && (h = n[f]) && (p || (p = s.getMutableChild(e, o)),
                        p.set(a ? h[a] : f, h))
                }
            return e
        }
        const {mainRecords: y} = t;
        let v = u.store.getAction(o.dispatchId);
        if (v) {
            const e = o.model.getState();
            ( (e, t, n) => {
                const r = e.store.mainStore.value.getState()
                  , i = e.getState();
                let o, s, a, c, u;
                for (let l in t)
                    if (c = t[l],
                    i[l]) {
                        for (o in a = i[l].getState(),
                        u = void 0,
                        c)
                            a[o] !== c[o] && (u || (u = e.getMutableChild(l, n).value),
                            u.set(o, c[o]));
                        if (s = r[l])
                            for (o in s = s.getState(),
                            s)
                                c[o] || (u || (u = e.getMutableChild(l, n).value),
                                u.delete(o))
                    } else
                        for (o in u = e.getMutableChild(l, n).value,
                        c)
                            u.set(o, c[o]);
                for (let l in r)
                    !t[l] && (u = e.getMutableChild(l, n, !0)) && u.value.deleteAll()
            }
            )(s, ( (e, t, n, r, i) => {
                const o = {};
                let s, a, c, u;
                for (let l in e)
                    if (i[l]) {
                        u = e[l].getState(),
                        s = void 0;
                        for (let e in u)
                            (c = u[e][t]) && (a = r[c]) && (s || (s = {},
                            o[l] = s),
                            s[n ? a[n] : c] = a)
                    }
                return o
            }
            )(u.getState(), c, a, e, d), o);
            const t = v.payload;
            if (( (e, t, n, r, i) => {
                const {throughFieldName: o, ownThroughFieldName: s} = n.storeConfig;
                let a, c, u, l, d, h, f = n.changesToCommit;
                for (let p in e)
                    (a = t[p]) && (u = a.__changesToCommit) && (u[s] === FI || u[o] === FI) && (l = a[o]) && (h = i[l]) && (c = a[s]) && (d = n.get(a[c])) && (d = d.value,
                    d.changesToCommit || (d.changesToCommit = {}),
                    d.changesToCommit[r ? h[r] : l] = FI,
                    u[s] === FI && (f || (f = {}),
                    f[c] = FI));
                n.changesToCommit = f
            }
            )(t.changes, t.records, s, a, e),
            a)
                for (let i in r)
                    r[i] === jI && (h = y[i]) && LI(h, n[i], s, a, o, !0)
        } else {
            let e, t;
            for (let i in r)
                switch (e = r[i],
                e) {
                case kI:
                    s.recordCreate(n[i], o);
                    break;
                case jI:
                    h = n[i],
                    s.recordUpdate(h, o),
                    a && (t = y[i]) && LI(t, h, s, a, o)
                }
        }
        return e
    }
    qI[l.d] = {
        ...VI,
        [VI[l.k]]: qI,
        [l.h]: void 0,
        [l.j]: "addThroughModelTrigger",
        [l.i]: "".concat(DI.moduleName, "/addIndex"),
        [l.l]: DI.packageName,
        [l.e]: "Adds the trigger to the ThroughModel that is used to monitor changes to its records. It will only add the trigger if it doesn't exist on `storeConfig.throughModelTrigger` and doesn't exist on the other many-to-many index (`storeConfig.ownM2MIndex.storeConfig.throughModelTrigger`). But it is better practice to only add this logic to one side of the relationship. The check will still occur, simply because accidentally including it on both would result in parsing every single change 2x."
    },
    DI.add(qI[l.d]),
    QI[l.d] = {
        ...UI,
        [UI[l.k]]: QI,
        [l.i]: "".concat(DI.moduleName, "/addIndex"),
        [l.l]: DI.packageName
    },
    DI.add(QI[l.d]);
    const BI = Jm.findByName("removeTriggers", c.q);
    function GI() {
        const {storeConfig: e} = this.store
          , t = this.store.storeConfig;
        let n;
        if (t.VF)
            n = t.VF.ownModel;
        else {
            if (!t.ownM2MIndex)
                return;
            n = t.ownM2MIndex.storeConfig.model
        }
        const r = n.getPkChangesModel(n.primaryKey);
        this.updatePkChangesConfig(r);
        const i = e.model.getPkChangesModel(e.keyBy);
        i ? (t.childPkIndex = t.throughIndex.mainStore,
        t.childPkIndexFieldName = t.ownThroughFieldName,
        this.updateChildPkChangesConfig(i)) : this.updateChildPkChangesConfig(i),
        this.ensureCorrectPatchPkChanges()
    }
    DI.add({
        ...BI,
        [BI[l.k]]: function(e) {
            const t = e.meta.store.storeConfig
              , n = t.throughModelTrigger;
            return n && (t.ownThroughIndex.storeConfig.model.triggers.remove(n),
            "function" === typeof n.destroy && n.destroy(),
            t.throughModelTrigger = void 0),
            e
        },
        [l.h]: void 0,
        [l.j]: "removeThroughModelTrigger",
        [l.i]: "".concat(DI.moduleName, "/removeIndex"),
        [l.l]: DI.packageName,
        [l.e]: "Removes the trigger from the ThroughModel that is used to monitor changes to its records. It is best practice to only add this logic to one side of the relationship, but it must be the same side that the `addThroughModelTrigger` logic is added to since it needs access to the trigger, which will be set on `storeConfig.throughModelTrigger`."
    });
    const zI = function(e) {
        const t = wm(e);
        return t.prototype.ensureCorrectPkChanges = GI,
        t
    }(Tm);
    const HI = {
        getThroughRecords: function(e, t) {
            let n = this.storeConfig.throughIndex.getBestStore(t).get(e);
            return n ? n.getState() : null
        },
        recordCreate: function(e, t) {
            let n = this.storeConfig;
            const r = e[n.primaryKey];
            let i = n.ownM2MIndex.getBestStore(t.mainDispatchId).value;
            if (i.pChanges && i.pChanges[r] === ws.a.CREATED)
                return;
            const o = this.getThroughRecords(r, t.mainDispatchId);
            if (!o)
                return;
            const s = i.storeConfig.model.getBestInstance(t.mainDispatchId).getState()
              , a = n.ownThroughFieldName;
            let c, u, l, d;
            for (let h in o)
                if ((u = o[h][a]) && (l = s[u])) {
                    if (!c) {
                        c = e[n.keyBy],
                        n = i.storeConfig,
                        d = n.keyBy === n.primaryKey ? null : n.keyBy;
                        const o = t.switchTo(n.model);
                        i = o.getMutableIndex(n.name).value.getMutableChild(r, o)
                    }
                    this.getMutableChild(u, t).value.set(c, e),
                    i.set(d ? l[d] : u, l)
                }
        },
        recordUpdate: function(e, t) {
            const n = this.storeConfig
              , r = this.getThroughRecords(e[n.primaryKey], t.mainDispatchId);
            if (!r)
                return !1;
            const i = n.ownM2MIndex.storeConfig.model.getBestInstance(t.mainDispatchId).getState()
              , o = n.ownThroughFieldName
              , s = e[n.keyBy];
            let a, c;
            for (let u in r)
                (a = r[u][o]) && (c = i[a]) && this.getMutableChild(a, t).value.set(s, e);
            return !0
        },
        recordFieldUpdate: function(e, t, n, r, i) {},
        recordKeyByUpdate: function(e, t, n, r, i) {
            const o = this.storeConfig;
            let s = o.ownM2MIndex.getBestStore(r.mainDispatchId).get(e.__ID);
            if (!s)
                return;
            s = s.getState();
            const a = o.ownM2MIndex.storeConfig.primaryKey;
            let c;
            if (i) {
                let i;
                for (let o in s)
                    c = this.getMutableChild(s[o][a], r).value,
                    c.delete(t),
                    c.set(n, e),
                    (i = c.changesToCommit) || (i = {},
                    c.changesToCommit = i),
                    i[n] = dg.a.STALE,
                    i[t] = dg.a.STALE
            } else
                for (let u in s)
                    c = this.getMutableChild(s[u][a], r).value,
                    c.pChanges && c.pChanges[t] && (c.pChanges[t] === ws.a.DELETED || c.pState[t].__storeId !== e.__storeId) || c.delete(t),
                    c.set(n, e)
        },
        recordDelete: function(e, t) {}
    };
    const KI = Pm(Im);
    function YI(e, t) {
        const n = ET(e);
        n.MainValue = zI,
        n.PendingValue = KI,
        function(e) {
            const t = {
                ...DI.getByName("hydrateIndex", c.a),
                [l.m]: e.pendingTrxPriority
            };
            e.pendingExtraTrxLogic ? e.pendingExtraTrxLogic.push(t) : e.pendingExtraTrxLogic = [t],
            e.storeConfig.VF.isRefModel || (e.pendingExtraTrxLogic.push({
                ...DI.getByName("addThroughModelTrigger", c.a),
                [l.m]: e.pendingTrxPriority
            }),
            e.pendingExtraTrxLogic.push({
                ...DI.getByName("removeThroughModelTrigger", c.q),
                [l.m]: e.pendingTrxPriority
            }))
        }(n);
        const r = n.storeConfig;
        return r.throughIndex = e.ownRefModelThroughVF.getIndex(t).mainStore,
        r.throughFieldName = e.ownRefModelThroughFieldName,
        r.ownThroughIndex = e.ownModelThroughVF.getIndex(t).mainStore,
        r.ownThroughFieldName = e.ownModelThroughFieldName,
        r.isM2M = !0,
        n
    }
    function WI(e, t) {
        class n {
        }
        Object(L.a)(n, oI),
        vI(n),
        n.init = e.init;
        const r = n.prototype
          , i = e.prototype;
        return r.getRecordAccessors = i.getRecordAccessors,
        r.getRecordAccessorsMap = i.getRecordAccessorsMap,
        r.checkCacheMissingForResolve = i.checkCacheMissingForResolve,
        function(e, t) {
            const n = t.storeConfig;
            class r extends e {
                addIndex(e) {
                    if (this.isRefModel)
                        return this;
                    const t = this.throughModelUniqueIndexName
                      , r = e ? e.mainDispatchId : null;
                    if (t && !this.getUniqueIndex(r)) {
                        const r = this.throughModelUniqueIndexPriority
                          , i = {
                            mainTrxPriority: r,
                            pendingTrxPriority: r,
                            storeConfig: {
                                name: t,
                                VF: this,
                                fieldNames: this.throughModelUniqueConstraint.fieldNames,
                                unique: !0
                            }
                        };
                        e ? e.getModelMutation(this.throughModel).createIndex(i) : yy(i, n.getStore(this.throughModel))
                    }
                    if (e) {
                        const t = e.getModelMutation(this.model)
                          , n = e.getModelMutation(this.refModel);
                        let i, o = t.getIndex(this.fieldIndexName);
                        o ? (i = o.storeConfig,
                        i.isM2M = !0,
                        i.VF = this.refModelVF) : o = t.createIndex(YI(this.refModelVF, r));
                        let s = n.getIndex(this.refFieldIndexName);
                        s ? (i = s.storeConfig,
                        i.isM2M = !0,
                        i.VF = this) : s = n.createIndex(YI(this, r)),
                        o.storeConfig.ownM2MIndex = s.mainStore,
                        s.storeConfig.ownM2MIndex = o.mainStore
                    } else {
                        const e = yy(YI(this.refModelVF, null), n.getStore(this.model))
                          , t = yy(YI(this, null), n.getStore(this.refModel))
                          , r = e.storeConfig;
                        r.ownM2MIndex = t,
                        t.storeConfig.ownM2MIndex = e,
                        r.throughModelTrigger = new PI(this.ownFieldIndexPriority,this),
                        this.throughModel.triggers.add(r.throughModelTrigger)
                    }
                    return this
                }
                processCreateVFData(e, t, n, r, i, o) {
                    if (r.isCommitOnly && this.throughModel.inDatabase)
                        return super.processCreateVFData(e, t, n, r, i, o);
                    let s;
                    if (o)
                        s = n,
                        n = null;
                    else if (!(s = n[this.bestVFName]))
                        return;
                    let a = r.getModelMutation(this.ownRefModel);
                    if (!(s = a.preprocessOwnRefModelCreate(s, this, e, n)))
                        return;
                    a = a.getMutationType(Gr.a);
                    const {ownRefFieldName: c, ownModelThroughFieldName: u, ownRefModelThroughFieldName: l, ownModelThroughVF: {refModelVFName: d}, ownRefModelThroughVF: {refModelVFName: h}} = this
                      , f = e[this.ownFieldName];
                    if (!f)
                        throw uI(this);
                    const p = r.getModelMutation(this.throughModel);
                    let g, m = n ? n[d] : null;
                    if (m) {
                        if (m = p.preprocessOwnRefModelCreate(m, this, e, n),
                        !m)
                            return void a.forManyAddRecord(s, i);
                        Array.isArray(m) || (m = Object.values(m));
                        for (let e of m)
                            e[u] = f
                    }
                    Array.isArray(s) || (s = Object.values(s));
                    const y = a.mutation.model;
                    let v, b;
                    e: for (let _ = 0; _ < s.length; _++)
                        if (v = s[_],
                        Object(he.U)(v)) {
                            if (b || (b = p.getMutationType(Gr.a)),
                            void 0 === b.addRecord({
                                [u]: f,
                                [l]: v[c]
                            }, i))
                                return
                        } else {
                            if ((g = v[c]) || (y.ensureRecordDataHasPkValue(v),
                            g = v[c]),
                            m)
                                for (let e of m)
                                    if (e[l] === g) {
                                        if (s[_] = a.addRecord(v, i),
                                        void 0 === s[_])
                                            return;
                                        continue e
                                    }
                            if (!v[h] && (b || (b = p.getMutationType(Gr.a)),
                            void 0 === b.addRecord({
                                [u]: f,
                                [l]: g
                            }, i)))
                                return;
                            if (s[_] = a.addRecord(v, i),
                            void 0 === s[_])
                                return
                        }
                }
                prepareIncludeQuery(e) {
                    if (e.isVerified)
                        return e;
                    if (this.ownFieldVFPath)
                        return super.prepareIncludeQuery(e);
                    {
                        e.isVerified = !0;
                        const t = e.parent
                          , n = t.query.cloneForExecute(t).includeM2MThroughRecords(this.bestVFName, t).getInclude(this.ownModelThroughVF.bestVFName);
                        return n.getQueryPayload(t).isVerified = !1,
                        n.prepareQuery(t),
                        e
                    }
                }
                prepareIncludeQueryIndex(e) {
                    let t = e.queryIndex;
                    return t && (t.MainValue = zI,
                    t.PendingValue = KI),
                    (t = e.originalQueryIndex) && (t.MainValue = zI,
                    t.PendingValue = KI),
                    e
                }
                mergeQueryResults(e) {
                    if (this.isComputed)
                        return void super.mergeQueryResults(e);
                    const t = e.parent.recordsResults;
                    if (!t)
                        return;
                    const n = e.recordsResults
                      , r = e.originalQuery ? e.originalQuery.queryAlias || this.bestVFName : e.query.queryAlias || this.bestVFName;
                    let i;
                    if (!n) {
                        for (let e in t)
                            i = t[e],
                            i[r] || (i[r] = null);
                        return
                    }
                    const o = e.linkedPayload ? e.linkedPayload.parent.records : this.throughModel.getState()
                      , s = this.ownRefFieldIndexKeyBy
                      , {ownModelThroughFieldName: a, ownRefModelThroughFieldName: c} = this;
                    let u, l, d;
                    for (let h in o)
                        d = o[h].getState(),
                        u = t[d[a]],
                        l = n[d[c]],
                        i = u[r],
                        l ? (i || (u[r] = i = {}),
                        i[l.__record[s]] = l) : i || (u[r] = null)
                }
            }
            r.isManyToMany = !0;
            const i = r.prototype;
            return i.getUniqueIndex = NI,
            i.markCacheCompleteFromQueryArg = RI,
            Object.defineProperties(i, AT.b),
            Object(he.z)(r, he.r.VIRTUAL_FIELD),
            r
        }(n, t)
    }
    Object(L.a)(KI, HI);
    const $I = {
        [Ro.a.PERM_READ_ID]: Ro.b.PERM_READ_ROLES_DATA,
        [Ro.a.PERM_UPDATE_ID]: Ro.b.PERM_UPDATE_ROLES_DATA,
        [Ro.a.PERM_DELETE_ID]: Ro.b.PERM_DELETE_ROLES_DATA
    }
      , XI = [Ro.a.PERM_READ_ID, Ro.a.PERM_UPDATE_ID, Ro.a.PERM_DELETE_ID];
    function JI(e, t) {
        if (e.mainDispatchId) {
            const t = e.mainStore;
            e.subscribe({
                complete: () => e = t
            })
        }
        const n = e.storeConfig.storesMap;
        let r, i, o, s, a, c;
        const u = e => function() {
            return e.getter(this, n.get(this))
        }
        ;
        return class extends t {
            markCacheCompleteFromQueryArg() {}
            processMutationAutoload() {}
            processQueryAutoload() {}
            processCreateVFData() {}
            static init(t, n) {
                if (!r) {
                    const t = e.storeConfig.types;
                    r = t.get(qo.a.PERMISSION_USER_CAN),
                    i = t.ModelID.use(tv.b.PERMISSION),
                    o = e.get(tv.b.PERMISSION),
                    s = o.fields[ev.a.PERMISSION].getMainInstance(),
                    a = e.get(tv.b.ROLES_PERMISSIONS),
                    c = a.fields.permissionId.getMainInstance(),
                    o = o.getMainInstance(),
                    a = a.getMainInstance()
                }
                const u = {
                    field: n,
                    fieldIsPk: !1,
                    fieldName: n.name,
                    id: Object(oe.b)(),
                    inDatabase: !1,
                    isComputed: !1,
                    model: t,
                    modelAutoload: !1,
                    modelAutoloadOnClient: !1,
                    modelAutoloadOnServer: !1,
                    modelName: t.__typename,
                    modelPk: t.primaryKey,
                    modelVFApiCreate: !1,
                    modelVFApiRead: !1,
                    modelVFApiUpdate: !1,
                    modelVFName: $I[n.name],
                    onDelete: bI.a.NO_ACTION,
                    onUpdate: bI.a.NO_ACTION,
                    refField: c,
                    refFieldConstraint: null,
                    refFieldIndexName: "c_permissionId",
                    refFieldIsAutoIncrement: !1,
                    refFieldIsPk: !1,
                    refFieldName: "permissionId",
                    refModel: a,
                    refModelAutoload: !1,
                    refModelAutoloadOnClient: !1,
                    refModelAutoloadOnServer: !1,
                    refModelName: tv.b.ROLES_PERMISSIONS,
                    refModelPk: ev.a.ROLES_PERMISSIONS,
                    refModelVFApiCreate: !1,
                    refModelVFApiRead: !1,
                    refModelVFApiUpdate: !1,
                    refModelVFName: null
                }
                  , l = new this;
                return l.VFName = u.modelVFName,
                l.foreignField = u,
                l.instanceId = "".concat(u.id, "_model"),
                l.isMany = !0,
                l.isManyToMany = !1,
                l.isRefModel = !1,
                l.isMetaVF = !0,
                l.modelVF = l,
                l
            }
            static defineVFs(e) {
                e = e.getMainInstance();
                const t = n.get(e).storeConfig
                  , {fields: r, virtualFields: i} = t;
                let o, s, a;
                for (let n of XI)
                    (o = r[n]) && (s || (s = {}),
                    a = this.init(e, o),
                    s[a.VFName] = {
                        get: u(a),
                        enumerable: !1
                    },
                    i[a.VFName] = a);
                return s && Object.defineProperties(t.Record.prototype, s),
                i
            }
            get(e, t) {
                let n = e[this.ownFieldName];
                if (console.log("RAW VALUE = ", n),
                !n)
                    return null;
                console.log("index = ", this.getIndex(t));
                let r = this.getIndex(t).get(n);
                if (console.log("VAL FROM INDEX = ", r),
                !r)
                    return null;
                const i = r.value;
                return i.pChanges ? i.pSize ? i.pState : null : i.size ? i.state : null
            }
            getter(e, t) {
                return this.get(e, t ? t.mainDispatchId : null)
            }
            getValue(e, t) {
                return this.get(e, t)
            }
            getWithIndex(e, t) {
                return this.get(t, e.mainDispatchId)
            }
        }
    }
    function ZI(e) {
        const t = function(e) {
            const t = e.storeConfig
              , n = t.getStore;
            class r {
            }
            Object.defineProperties(r.prototype, AT.a),
            Object(he.z)(r, he.r.VIRTUAL_FIELD),
            Object(L.a)(r, oI),
            r.init = sI;
            const i = r.prototype;
            return i.addIndex = function(e) {
                if (this.ownRefFieldIndexIsModelState)
                    return this.ownRefFieldIndexPriority !== Lm.g && (this.ownRefFieldIndexPriority = Lm.g),
                    this;
                let n;
                if (e) {
                    const t = e.getModelMutation(this.ownRefFieldIndexModel);
                    n = t.getIndex(this.ownRefFieldIndexName),
                    n ? n.storeConfig.VF = this : n = t.createIndex(ET(this))
                } else
                    n = yy(ET(this), t.getStore(this.ownRefFieldIndexModel));
                return this.isRefModel && function(e, t) {
                    const n = e.storeConfig;
                    n.pkChangesModel && e.value.updatePkChangesConfig(n.pkChangesModel, function(e, t) {
                        return t = t.mainStore,
                        function(n, r) {
                            e(n, r, t)
                        }
                    }(n.pkChangesMethod, t))
                }(n, t.getStore(this.model)),
                this
            }
            ,
            i.getRecordAccessors = function(e) {
                var n, r;
                return e || this.accessorsMethods || (this.accessorsMethods = (n = this,
                r = t.getPluginStoreConfig(this.ownModel).storesMap,
                {
                    query: {
                        value: function(e) {
                            return n.query(this, e)
                        },
                        configurable: !0,
                        writable: !0,
                        enumerable: !1
                    },
                    subscribe: {
                        value: function(e) {
                            return n.subscribe(this, e)
                        },
                        configurable: !0,
                        writable: !0,
                        enumerable: !1
                    },
                    subscribeToCreateDelete: {
                        value: function(e) {
                            return n.subscribeToCreateDelete(this, e)
                        },
                        configurable: !0,
                        writable: !0,
                        enumerable: !1
                    },
                    accessor: {
                        get() {
                            return n.getter(this, r.get(this))
                        },
                        set(e) {
                            n.setter(this, e, r.get(this))
                        },
                        configurable: !0,
                        enumerable: !0
                    },
                    recordResultWithIndex: {
                        accessor: {
                            get() {
                                return n.getWithIndex(this.__children[n.VFName].VFRecordResultIndex, this.__record) || null
                            },
                            set: void 0,
                            enumerable: !0,
                            configurable: !0
                        },
                        subscribe(e) {}
                    }
                })),
                this.accessorsMethods
            }
            ,
            i.getRecordAccessorsMap = function(e) {
                var t, n;
                return e || this.accessorsMap || (this.accessorsMap = (t = this,
                n = this.ownModelVFName,
                {
                    query: "".concat(n, "Query"),
                    subscribe: "".concat(n, "Subscribe"),
                    subscribeToCreateDelete: "".concat(n, "SubscribeToCreateDelete"),
                    accessor: t.VFName
                })),
                this.accessorsMap
            }
            ,
            i.checkCacheMissingForResolve = function(e, t, r) {
                const i = this.ownModelCacheMissingFieldName;
                for (let n of e)
                    if (!1 !== t[n][i])
                        return !1;
                const {ownFieldName: o, ownRefModelPk: s} = this;
                let a, c, u, l = this.getIndex(r);
                if (l = this.ownRefFieldIndexIsModelState ? n(l).value : l.value,
                this.isMany) {
                    let n, r;
                    for (let i of e)
                        if (a = t[i][o],
                        a && (n = l.get(a)))
                            for (r in c || (c = {}),
                            n = n.value.getState(),
                            n)
                                u = n[r],
                                c[u[s]] = u
                } else {
                    let n = !1;
                    for (let r of e)
                        if (a = t[r][o],
                        u = l.get(a))
                            if (c || (c = {}),
                            null !== a)
                                c[u[s]] = u;
                            else if (!n) {
                                n = !0;
                                const e = u.getState();
                                for (let t in e)
                                    u = e[t],
                                    c[u[s]] = u
                            }
                }
                return c || !0
            }
            ,
            r
        }(e)
          , n = WI(t, e)
          , r = pI(t, e);
        return {
            BELONGS_TO: r,
            BELONGS_TO_MANY: gI(n),
            BELONGS_TO_MANY_REF: mI(n),
            HAS_ONE: CI(t, e),
            HAS_MANY: AI(t, e),
            PERM_REC_VF: JI(e, r)
        }
    }
    const ex = (e, t) => {
        t.addValue(e)
    }
    ;
    const tx = Xm.a.initModule("@isomorix/core/logic");
    tx.addSource(fS);
    const nx = function(e) {
        e.setPackageName("@isomorix/core").setDefaultModuleNames("@isomorix/core/apiLog").registerExtension("../ModelMixin")
    };
    var rx = n(280);
    function ix(e) {
        e.setPackageName("@isomorix/core-data-source").setDefaultModuleNames("@isomorix/core/dataSource"),
        function(e) {
            const t = e.registerExtension("../ModelMixin").Class.prototype;
            t.compileRawSchemas = function(e, t) {
                const n = {};
                for (const r in e)
                    n[r] = e[r].getManager().compileRawSchema(t);
                return Object(wr.a)(n)
            }
            ,
            t.checkForDuplicateExternalAccountId = function(e, t, n, r) {
                const i = this.query();
                return i.select([i.primaryKey, "name"]).where("entityId", e).andWhere("type", t).andWhere(["props", "externalAccountId"], n),
                r && i.andWhereNot(i.primaryKey, r),
                i.fetchDirect().pipe(Object(Y.a)(e => e.resp && e.resp.length ? e.resp[0] : null))
            }
        }(e),
        function(e) {
            const t = e.storesMap
              , n = e.getRecordBuilder().registerExtension("module:logic.RecordPropsMixin").registerExtension("../RecordMixin")
              , r = e.plugin.getMainInstance()
              , i = n.Class.prototype;
            Object(rx.a)(e, i),
            i.getManager = function(e) {
                const n = Object(Eb.a)(t, this, e);
                if (!n)
                    return null;
                if (!n.manager && !e) {
                    if ("string" === typeof this.manager)
                        return null;
                    n.manager = this.manager.init(this, r, t),
                    ( (e, t) => {
                        e.completeSub || (e.doComplete = () => {
                            e.persistRawSchema$ && (e.persistRawSchema$.complete(),
                            e.persistRawSchema$ = void 0,
                            e.persistRawSchema = void 0),
                            e.manager && ("function" === typeof e.manager.complete && e.manager.complete(),
                            e.manager = void 0),
                            e.completeSub = void 0,
                            e.doComplete = void 0
                        }
                        ,
                        e.completeSub = t.mainStore.subscribe({
                            complete: e.doComplete
                        }))
                    }
                    )(n, t.get(this))
                }
                return n.manager
            }
            ,
            i.saveRawSchema = function(e) {
                return this.setLocalState({
                    rawSchema: e
                }, !0)
            }
            ,
            i.persistRawSchema = function(e) {
                return e !== t.get(this).value.persistedState.rawSchema ? this.setState({
                    rawSchema: e
                }) : Object(V.a)(!0)
            }
        }(e)
    }
    var ox = n(149);
    const sx = ["props", "serverProps", "serverConfig"]
      , ax = (e, t, n) => {
        for (let r of sx)
            e[r] && (t[r] = n ? {
                ...e[r]
            } : e[r]);
        return t
    }
    ;
    var cx = n(1022);
    const ux = ["aiDescription", "aiGroupId", "apiCreate", "apiRead", "apiUpdate", "description", "displayName", "groupId", "name", "notNullable", "permRead", "permUpdate", "primary"]
      , lx = ["isAutoIncrement", "isBigIncrement", "encodingDisabled", "canAutoGenerate", "decodedKind"];
    function dx(e, t, n, r) {
        const i = t.modelsByObjectId[n]
          , {types: o} = e
          , s = {
            externalId: r.externalId || r.key
        };
        s.id = r.id || s.externalId || r.name;
        for (const a of ux)
            "undefined" !== typeof r[a] && (s[a] = r[a]);
        if (ax(r, s, !0),
        r.primary) {
            s.type = o.ModelID.createName(i.name),
            s.apiUpdate = !1,
            s.permUpdate = Uo.a.NEVER,
            s.primary = !0;
            for (const e of lx)
                "undefined" !== typeof r[e] && (s[e] = r[e]);
            this.compilePrimaryFieldSchema(e, t, n, r, s)
        } else if (r.type === xn.B.ENUM)
            e.compileMgr.registerEnumField(i, s, r);
        else if (r.foreignField)
            this.compileForeignFieldSchema(e, t, n, r, s);
        else if (s.type = o.createName(r.type, r.typeMin, r.typeMax, r.typeScale),
        !s.type)
            throw new Error('Field "'.concat(s.name, '" ("').concat(s.displayName, '") on model "').concat(i.displayName, '" has an unrecognized type: ').concat(r.type));
        return i.fields[s.name] = s,
        s.description && (e.schemaData.modelDescriptions[i.name].fields[s.name] = s.description),
        "boolean" !== typeof s.aiDescription && "string" !== typeof s.aiDescription || (e.schemaData.modelAiDescriptions[i.name].fields[s.name] = s.aiDescription),
        i.props.fieldKeysToName[s.id] = s.name,
        s
    }
    const hx = dx;
    const fx = (e, t) => {
        const {constraints: n} = e;
        if (!n)
            return e.constraints = {},
            t;
        let r = t
          , i = 1;
        for (; n[r]; )
            r = "".concat(t, "_").concat(i),
            i++;
        return r
    }
    ;
    const px = ["aiDescription", "apiCreate", "apiDelete", "apiRead", "apiUpdate", "description", "displayName", "displayNameMany", "permCreate", "permDelete", "permRead", "permUpdate", "trackHistory", "trackAccess"]
      , gx = ["createdAt", "createdAtKey", "lastModifiedAtKey", "endpointMany", "endpointOne", "fieldsCount", "fieldsSyncCount", "icon", "refFieldsSyncCount", "isCustomObject", "primaryKey"];
    function mx(e, t, n) {
        const {rawModels: r, modelsByObjectId: i} = t
          , o = r[n]
          , s = this.getPrefixedModelName(o.name)
          , a = {
            name: s,
            externalId: this.convertObjectIdToModelId(o.id),
            primaryKey: o.primaryKey || "id",
            pkIsAutoIncrement: !0,
            manyName: this.getPrefixedModelName(o.manyName),
            assignUID: !1,
            entitySlug: this.entitySlug,
            fields: {},
            constraints: {}
        };
        a.id = a.externalId,
        ax(o, a, !0);
        let {props: c} = a;
        c || (c = {},
        a.props = c),
        c.dataSourceUid = this.uid,
        c.fieldKeysToName = {},
        c.objectId = o.id,
        c.dataSourceType = this.dataSourceType,
        e.modelIdsToName[a.externalId] = s;
        for (let u of px)
            "undefined" !== typeof o[u] && (a[u] = o[u]);
        for (let u of gx)
            "undefined" !== typeof o[u] && (c[u] = o[u]);
        return a.displayName || (a.displayName = this.stripModelNamePrefix(a.name)),
        a.displayNameMany || (a.displayNameMany = this.stripModelNamePrefix(a.manyName)),
        !1 !== a.trackHistory ? (a.trackHistory = !0,
        a.trackAccess = !0) : !1 !== a.trackAccess && (a.trackAccess = !0),
        e.compileMgr.registerModel(a, o),
        i[n] = a,
        a
    }
    const yx = mx;
    var vx = n(345);
    const bx = "syncing_initial"
      , _x = "syncing_more"
      , Sx = "external_error_fatal"
      , Ox = "external_error_temporary"
      , Tx = "active"
      , Ix = {
        on_demand: 1,
        second: 1,
        minute: 60,
        hour: 3600,
        day: 86400,
        week: 604800,
        month: 2592e3,
        year: 31536e3
    }
      , xx = {
        all: "toId",
        createdAt: "toTs",
        date: "toTs",
        id: "toId",
        lastModifiedAt: "toTs"
    };
    function wx(e) {
        if (!e.errorMessage)
            return e;
        if (e.errorOrigStatus)
            switch (e.status) {
            case Sx:
            case Ox:
                e.status = e.errorOrigStatus
            }
        e.errorMessage = void 0,
        e.errorCode = void 0,
        e.errorFirstTs = void 0,
        e.errorLastTs = void 0,
        e.errorNextRetryTs = void 0,
        e.errorCount = void 0,
        e.errorOrigStatus = void 0
    }
    const Mx = e => {
        var t, n;
        return e.intervalValue && e.intervalUnit && (e.interval = (t = e.intervalValue,
        n = e.intervalUnit,
        t * Ix[n])),
        e
    }
      , Ax = (e, t) => "number" === typeof e.maxCount ? e.maxCount : t
      , Ex = {
        count: !0,
        defaultStrategy: !0,
        interval: !0,
        intervalUnit: !0,
        intervalValue: !0,
        isPaused: !0,
        maxCount: !0,
        strategy: !0,
        toId: !0,
        toTs: !0
    }
      , Cx = {
        hasAll: !1,
        count: 0,
        lastSyncAt: 0,
        status: bx
    };
    const Nx = {};
    const Rx = ["rawSyncState", "pSyncState", "rawSchema"];
    const Px = e => (e = Object(ve.f)(e)).length > 64 ? e.substring(0, 64) : e
      , Dx = e => (e = Object(ve.d)(e)).length > 64 ? e.substring(0, 64) : e;
    var Fx = n(281);
    const kx = (e, t, n) => {
        const r = n.getState();
        if (t.allStatusCodes[r[ev.a.DATA_SOURCE]])
            return;
        const {rawSchema: i} = r;
        let o;
        o = i ? e.getUnsavedPublishValues(!0) ? Fx.a.DATA_SOURCE_HAS_UNSAVED_CHANGES : 0 !== i.fieldsSyncCount || r.syncState && r.syncState.models && !(Object.keys(r.syncState.models).length < 1) ? Fx.a.READY : Fx.a.NO_SELECTED_OBJECTS : Fx.a.NO_SELECTED_OBJECTS,
        t.allStatusCodes[r[ev.a.DATA_SOURCE]] = o
    }
      , jx = ["rawSchema", "schema", "syncState", "rawSyncState", "pSyncState"];
    const Lx = (e, t, n, r) => {
        const i = e.fields
          , o = t.fields
          , s = r.fields
          , a = new Array(s.length);
        let c, u;
        for (let d = 0; d < s.length; d++)
            if (u = s[d],
            c = i[u]) {
                if (!(c = o[n[c.id || c.externalId || u]]))
                    return;
                a[d] = c.name
            } else
                switch (u) {
                case Ro.a.VALID_TO_TS:
                    a[d] = Ro.a.VALID_TO_TS;
                    break;
                case "historyId":
                case e.historyPrimaryKey:
                    if (!t.trackHistory)
                        return;
                    a[d] = t.historyPrimaryKey || u;
                    break;
                default:
                    return
                }
        t.constraints || (t.constraints = {});
        const l = {
            ...r
        };
        l.fields = a,
        r.unique ? t.constraints["c_".concat(a.join("_"))] = l : t.constraints["i_".concat(a.join("_"))] = l
    }
    ;
    const Vx = {
        defaultCompileFieldSchema: hx,
        defaultInitCompileModelSchema: yx,
        carryForwardSystemConstraints: function(e, t, n) {
            var r;
            const {prevSchemaData: i} = e;
            if (!i)
                return;
            const {prevModelIdsToName: o} = e
              , s = o && o[t.id || t.externalId] || t.name
              , a = null === (r = i.models) || void 0 === r ? void 0 : r[s]
              , c = null === a || void 0 === a ? void 0 : a.constraints;
            if (c)
                for (const u in c)
                    c[u].isSystem && Lx(a, t, n, c[u])
        },
        compileFieldSchema: dx,
        compileForeignFieldSchema: function(e, t, n, r, i) {
            const o = r.foreignField
              , {refModelId: s, manyToManyVFId: a, ...c} = o
              , u = t.modelsByObjectId[n];
            let l = e.schemaData.models[e.modelIdsToName[s]] || t.modelsByObjectId[s];
            if (i.description || (i.description = "The ID of the ".concat(l.displayName, " this record is associated with.")),
            i.type = e.types.ModelID.createName(l.name),
            c.modelName = u.name,
            c.refModelName = l.name,
            c.fieldName = i.name,
            c.fieldIndexName = "c_".concat(i.name),
            i.foreignField = c,
            u.constraints[c.fieldIndexName] = {
                fields: [i.name]
            },
            c.refModelRelationship === iO.a.HAS_ONE && (u.constraints[c.fieldIndexName].unique = !0),
            c.refFieldName || (c.refFieldName = l.primaryKey),
            !a)
                return i;
            const d = t.rawManyToManyVFs && t.rawManyToManyVFs[a];
            if (!d)
                return i;
            const {modelThroughFieldId: h, refModelThroughFieldId: f} = d;
            if (!h || !f)
                return i;
            const p = u.props.fieldIdsToName || u.props.fieldKeysToName
              , {fields: g} = u;
            g[i.name] = i,
            p[i.id] = i.name;
            const m = g[p[h]]
              , y = g[p[f]];
            if (!m || !y)
                return i;
            const v = m.foreignField
              , b = y.foreignField
              , {schemaData: _} = e
              , S = _.models[v.refModelName];
            if (l = _.models[b.refModelName],
            !S || !l)
                return i;
            const O = {
                ...d,
                modelName: S.name,
                modelVFName: d.modelVFName,
                modelThroughVFName: d.modelThroughVFName,
                fieldName: v.refFieldName,
                refModelName: l.name,
                refModelVFName: d.refModelVFName,
                refModelThroughVFName: d.refModelThroughVFName,
                refFieldName: b.refFieldName,
                throughModelName: u.name
            };
            O.fieldIndexName = fx(S, "c_".concat(O.fieldName)),
            S.constraints[O.fieldIndexName] = {
                fields: [O.fieldName],
                isLocalOnly: !0,
                relationshipType: iO.a.BELONGS_TO_MANY
            },
            O.refFieldIndexName = fx(l, "c_".concat(O.refFieldName)),
            l.constraints[O.refFieldIndexName] = {
                fields: [O.refFieldName],
                isLocalOnly: !0,
                relationshipType: iO.a.BELONGS_TO_MANY_REF
            },
            O.id = Object(cx.a)(S.id, h, l.id, f),
            m.notNullable && y.notNullable || (O.throughModelUniqueIndexName = null),
            null !== O.throughModelUniqueIndexName && (u.constraints || (u.constraints = {}),
            O.throughModelUniqueIndexName = "c_".concat(m.name, "_").concat(y.name),
            u.constraints[O.throughModelUniqueIndexName] = {
                fields: [m.name, y.name],
                unique: !0
            });
            const T = e.schema.serializeForeignField(O, !0);
            return _.manyToManyVFs ? _.manyToManyVFs.push(T) : _.manyToManyVFs = [T],
            i
        },
        compileModelSyncState: function(e, t, n, r, i) {
            let o;
            if (r && i)
                o = {
                    ...r,
                    ...n,
                    ...i
                };
            else {
                if (!r)
                    return i ? this.resetModelSyncState({
                        ...n,
                        ...i
                    }) : this.resetModelSyncState({
                        ...n
                    });
                o = {
                    ...r,
                    ...n
                }
            }
            if (r.strategy !== o.strategy)
                return this.resetModelSyncState(o);
            if (i && i.status)
                switch (i.status) {
                case bx:
                    return this.resetModelSyncState(o);
                case Tx:
                    if (o.errorOrigStatus)
                        o.status = o.errorOrigStatus,
                        wx(o);
                    else {
                        const {inProgress: e} = o;
                        e && !e.isCatchup && (o.status = e.isFromHighest ? bx : _x)
                    }
                    break;
                case Sx:
                case Ox:
                    break;
                default:
                    wx(o)
                }
            if (Ax(o, t) !== Ax(r, e))
                return o.status = _x,
                Mx(o);
            if ("all" === o.strategy)
                return Mx(o);
            {
                const e = xx[o.strategy];
                return o[e] < r[e] && (o.status = _x),
                Mx(o)
            }
        },
        compilePrimaryFieldSchema: function(e, t, n, r, i) {
            return i
        },
        compileSchema: function(e) {
            const t = e.dataSourcePayloads[this.dataSource.__ID];
            if (!t)
                return Object(D.c)();
            const {objectIds: n} = t
              , r = new Array(n.length);
            let i = 0;
            return Object(vx.a)(n, n => {
                r[i] = this.compileModelSchema(e, t, n),
                i++
            }
            ).pipe(Object(P.a)( () => Object(wr.a)(r)))
        },
        compileSyncState: function(e, t, n) {
            t || (t = this.dataSource);
            const r = t.getState()
              , i = r[ev.a.DATA_SOURCE]
              , {rawSchema: o} = r;
            if (!o || 0 === o.fieldsSyncCount || r.status === XS.b.PENDING_DELETE || !o.customObjects)
                return n && (n[i] = null),
                null;
            const s = r.rawSyncState.models
              , a = r.pSyncState ? {
                ...r.rawSyncState,
                ...r.pSyncState,
                models: {}
            } : {
                ...r.rawSyncState,
                models: {}
            }
              , c = r.syncState ? r.syncState.maxCount : null
              , u = r.syncState && r.syncState.models || Nx
              , l = r.pSyncState && r.pSyncState.models || Nx
              , d = a.models
              , h = a.maxCount || 0;
            for (let f in e)
                s[f] && (d[f] = this.compileModelSyncState(c, h, s[f], u[f], l[f]));
            return n && (n[i] = a),
            a
        },
        convertModelIdToObjectId: function(e) {
            return e.replace("".concat(this.accountId, "__"), "")
        },
        convertObjectIdToModelId: function(e) {
            return "".concat(this.accountId, "__").concat(e)
        },
        finalizeCompileModelSchema: function(e, t, n) {
            const r = t.modelsByObjectId[n]
              , {constraints: i, fields: o} = r
              , s = t.rawModels[n].fieldGroups;
            if (s) {
                let e, t;
                for (const n in o)
                    (t = o[n].groupId) && s[t] && (e ? e[t] || (e[t] = s[t]) : e = {
                        [t]: s[t]
                    });
                e && (r.fieldGroups = e)
            }
            r.constraints = void 0,
            e.schema.normalizeFieldOrder(o);
            const a = e.schema.serializeModel(r);
            return Object.keys(i).length && (a.constraints = i),
            e.schemaData.models[r.name] = a,
            r
        },
        finalizeCompileSchema: function(e) {
            const t = e.dataSourcePayloads[this.dataSource.__ID];
            if (!t)
                return Object(D.c)();
            const {objectIds: n} = t;
            return Object(vx.a)(n, n => {
                this.finalizeCompileModelSchema(e, t, n)
            }
            )
        },
        genUniqueFieldName: function(e, t) {
            let {name: n} = t
              , r = ""
              , i = 1;
            this.prefersSnakeCase && (r = "_",
            i = 2),
            n = this.maybeTrimSchemaName(n, i);
            let o, s = 2;
            for (; ; ) {
                if (10 === s && (i++,
                n = this.maybeTrimSchemaName(n, i)),
                o = "".concat(n).concat(r).concat(s),
                !e[o.toLowerCase()])
                    return this.isSchemaNameTooLong(o),
                    t.name = o,
                    e[o.toLowerCase()] = t,
                    o;
                s++
            }
            return t
        },
        getPrefixedModelName: function(e) {
            return this.modelPrefixRegex.test(e) ? e : "".concat(this.modelPrefix).concat(Object(iu.b)(e))
        },
        getUnsavedPublishValues: function(e) {
            const t = this.dataSource
              , n = t.getState()
              , r = t.getPersistedState();
            let i = null;
            for (let o of Rx)
                if (n[o] !== r[o]) {
                    if (e)
                        return !0;
                    i || (i = {}),
                    i[o] = n[o]
                }
            return e ? !!i : i
        },
        initCompileModelSchema: mx,
        initCompileSchema: function(e) {
            const {dataSource: t} = this
              , n = t.getState()
              , r = n[ev.a.DATA_SOURCE]
              , {rawSchema: i} = n;
            if (e.prevSyncStates[r] = n.syncState,
            !i || 0 === i.fieldsSyncCount || n.status === XS.b.PENDING_DELETE || !i.customObjects)
                return e.syncStates[r] = null,
                Object(D.c)();
            const {customObjects: o} = i
              , s = []
              , a = {
                modelsByObjectId: {},
                objectIds: s,
                rawModels: o,
                rawManyToManyVFs: i.manyToManyVFs
            };
            e.dataSourcePayloads[r] = a;
            for (let c in o)
                o[c].fieldsSyncCount > 0 && s.push(c);
            return Object(vx.a)(s, t => {
                this.initCompileModelSchema(e, a, t)
            }
            ).pipe(Object(Y.a)( () => {
                this.compileSyncState(e.modelIdsToName, t, e.syncStates)
            }
            ), s.length > 5 ? Object(T.a)() : Qs.a)
        },
        isSchemaNameTooLong: function(e, t) {
            return t ? e.length > 64 - t : e.length > 64
        },
        joinSchemaNameParts: function() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                t[n] = arguments[n];
            if (this.prefersSnakeCase)
                return t.join("_");
            let r;
            for (let i of t)
                r ? r += Object(iu.b)(i) : r = i;
            return r
        },
        maybeTrimSchemaName: function(e, t) {
            return t ? e.length > 64 - t ? e.substring(0, 64 - t) : e : e.length > 64 ? e.substring(0, 64) : e
        },
        prepareToCompileSchema: function(e, t) {
            const n = this.dataSource.getState();
            if (n.status === XS.b.PENDING_DELETE)
                return void (e.allStatusCodes[n[ev.a.DATA_SOURCE]] = Fx.a.DATA_SOURCE_PENDING_DELETE);
            const r = [];
            for (let i of jx)
                "undefined" === typeof n[i] && r.push(i);
            if (r.length) {
                const i = this.plugin.switchTo(this.dataSource.__typename);
                t.push(i.select(r).where(ev.a.DATA_SOURCE, n[ev.a.DATA_SOURCE]).fetchOneRecord({
                    mutation: e.compileMgr.getMutation()
                }).pipe(Object(Y.a)(t => kx(this, e, t))))
            } else
                kx(this, e, this.dataSource)
        },
        resetModelSyncState: function(e) {
            for (const t in e)
                Ex[t] || (e[t] = void 0);
            for (const t in Cx)
                e[t] = Cx[t];
            switch (e.strategy) {
            case "all":
                e.toId = 1,
                e.trackLowestId = !0;
                break;
            case "id":
            case "createdAt":
            case "date":
                e.trackLowestId = !0;
                break;
            default:
                e.trackLowestId = !1
            }
            return Mx(e)
        },
        setDataSource: function(e) {
            const {entity: t} = e;
            if (!t)
                throw new Error("The Entity must be available to instantiate the DataSource manager.");
            let {entityId: n, schemaPrefix: r, schemaPrefixGlobal: i, props: o, type: s} = e.getState();
            this.dataSource = e,
            this.dataSourceType = s,
            this.entityId = n,
            this.uid = e.__UID;
            let a = o && "boolean" === typeof o.prefersSnakeCase ? o.prefersSnakeCase : void 0;
            const c = t.getState();
            this.entity = t,
            this.entitySlug = c.slug,
            this.accountId = o && (o.externalAccountId || o.opAccountId) || null;
            let u = ""
              , l = Object(iu.b)(Object(ve.f)(i || c.slug));
            if (i && (u = l),
            r && (l += Object(iu.b)(r),
            u += Object(iu.b)(r)),
            this.displayNamePrefix = u,
            this.modelPrefixRegex && this.modelPrefix === l || (this.modelPrefix = l,
            this.modelPrefixRegex = new RegExp("^".concat(this.modelPrefix))),
            "boolean" !== typeof a && c.props && "boolean" === typeof c.props.prefersSnakeCase && (a = c.props.prefersSnakeCase),
            this.setPrefersSnakeCase(a),
            Object(he.R)(e)) {
                const t = e.getMainInstance();
                e.subscribe({
                    complete: () => {
                        this.dataSource = t,
                        this.entity = t.entity,
                        this.entityId = t.entityId,
                        this.uid = t.__UID
                    }
                })
            }
            return this
        },
        setPrefersSnakeCase: function(e) {
            return this.prefersSnakeCase = !1 !== e,
            this.formatSchemaName = !1 === this.prefersSnakeCase ? Px : Dx,
            this
        },
        stripModelNamePrefix: function(e) {
            return e.replace(this.modelPrefixRegex, "")
        },
        subscribeToUnsavedPublishFields: function() {
            return this.dataSource.subscribeTo(Rx)
        }
    };
    class Ux {
        constructor(e, t) {
            this.plugin = t,
            this.types = t.types,
            this.autoSyncRefModels = !0,
            this.syncMgr = void 0,
            Object(ox.b)(this, "plugin"),
            this.setDataSource(e)
        }
        static init(e, t, n) {
            return new this(e,t,n)
        }
    }
    Object(L.a)(Ux, Vx);
    const qx = (e, t) => Object(P.a)(n => {
        const r = "rawSchema" === t;
        if (!n)
            return Object(D.c)();
        if ("string" === typeof n)
            try {
                n = JSON.parse(n)
            } catch (s) {
                return console.log("INVALID JSON RETURNED. RAW = ", n),
                Object(D.c)()
            }
        if (!r && !n[t])
            return Object(D.c)();
        const i = e.plugin.mutation().commitOnly().switchTo(tv.b.DATA_SOURCE)
          , o = {};
        return r ? (n.rawSchema && (o.rawSchema = n.rawSchema,
        o.rawSyncState = n.rawSyncState),
        n.rawDataCounts && (o.rawDataCounts = n.rawDataCounts),
        n.props && (o.props = n.props)) : o[t] = n[t],
        i.update(e.dataSource, o),
        i.execute(!0).pipe(Object(Or.a)(n))
    }
    );
    var Qx = n(298);
    var Bx = n(242);
    const Gx = {
        compileRawDataCounts: function() {
            return this.postToDataSourceEndpoint({
                actionType: "compileRawDataCounts"
            }).pipe(Object(P.a)(e => {
                if (200 !== e.statusCode || !e.data)
                    return Object(D.c)();
                if (!e.data.inFlight)
                    return Object(V.a)(e.data);
                const t = this.dataSource
                  , n = t.rawDataCounts
                  , r = this.plugin.switchTo(t.__typename);
                return r.query().select("rawDataCounts").where(r.primaryKey, t.__ID).andWhere(["rawDataCounts", "lastCompileAt"], ">", n && n.lastCompileAt || 100).subscribeToOne().pipe(Object(Rb.a)(), Object(te.a)(), Object(Z.a)(B(6e5)), Object(Qx.a)(null, null))
            }
            ), qx(this, "rawDataCounts"), Object(Or.a)(this.dataSource), Object(N.a)(e => (console.log("GOT ERROR IN compileRawDataCounts() = \n".concat(e.message)),
            Object(D.c)())))
        },
        compileRawSchema: function() {
            if (this._compileRawSchema$)
                return this._compileRawSchema$;
            const e = new U.a;
            this._compileRawSchema$ = e;
            const t = () => {
                this._compileRawSchema$ === e && (this._compileRawSchema$ = void 0),
                e.next(this.dataSource),
                e.complete()
            }
            ;
            return this.postToDataSourceEndpoint({
                actionType: "compileRawSchema"
            }).pipe(Object(P.a)(e => {
                if (!e || 200 !== e.statusCode)
                    return Object(D.c)();
                const t = this.dataSource
                  , n = this.plugin.switchTo(t.__typename).query().select(["rawSchema", "rawDataCounts", "rawSyncState", "props"]);
                n.where(n.primaryKey, t.__ID);
                const {rawSchema: r, props: i} = t.getState();
                return n.andWhere(e => {
                    r ? e.where(["rawSchema", "compileId"], "!=", r.compileId) : e.whereNotNull("rawSchema");
                    const t = i && i.compileRawSchemaErrorTs;
                    return t ? e.orWhere(["props", "compileRawSchemaErrorTs"], "!=", t) : e.orWhereExists(["props", "compileRawSchemaErrorTs"]),
                    e
                }
                ),
                n.subscribeToOne().pipe(Object(Rb.a)(), Object(te.a)())
            }
            ), qx(this, "rawSchema")).subscribe({
                next: t,
                error: t
            }),
            this._compileRawSchema$
        },
        postToDataSourceEndpoint: function(e) {
            return "undefined" === typeof e.id && (e.id = this.dataSource.__ID),
            this.entity.getConnection(u.a.REST).postByName(Bx.a.API_DATA_SOURCE_ROUTE, e)
        },
        updateCredentials: function(e) {
            return this.postToDataSourceEndpoint({
                actionType: "updateCredentials",
                payload: {
                    credentials: e
                }
            }).pipe(Object(P.a)(e => {
                if (200 !== e.statusCode || !e.data || !e.data.valid)
                    return Object(V.a)(e);
                const {data: t} = e
                  , n = this.plugin.mutation().commitOnly().switchTo(tv.b.DATA_SOURCE);
                let r = this.dataSource.props;
                return r = r ? {
                    ...r
                } : {},
                r.externalAccountId = t.accountId,
                t.features && (r.externalFeatures = t.features),
                n.update(this.dataSource, {
                    credentials: t.credentials,
                    props: r
                }),
                n.execute(!0).pipe(Object(Or.a)(e))
            }
            ))
        }
    };
    Object(L.a)(Ux, Gx);
    const zx = {
        [l.e]: "description",
        [l.s]: "type",
        [l.j]: "name"
    }
      , Hx = {
        [l.e]: "description",
        [l.s]: "type"
    };
    function Kx(e, t, n, r) {
        if ("string" !== typeof n && "function" !== typeof n)
            return n;
        if (!(n = t.type.getValue(n))) {
            const e = t.model.name;
            throw new Error("The method ".concat(arguments[2], " cannot be used on the ").concat(e, " Model because the method is not defined on the ").concat(t.type.name, " enum."))
        }
        if ("function" !== typeof (n = n.value) || !n[l.d]) {
            if (r)
                return r;
            const e = t.model.name;
            throw new Error("The method ".concat(arguments[2], " cannot be used to create a ").concat(e, " record because it is not a function with a ").concat(l.d, " property on its prototype from which the field values for the ").concat(e, " record could be determined."))
        }
        const i = n[l.d];
        r ? r.method = n : r = {
            method: n
        },
        r[e.fieldName] = e.toGlobalId(r[e.fieldName]);
        for (let o in zx)
            r[zx[o]] || (r[zx[o]] = i[o]);
        return r
    }
    function Yx(e) {
        class t extends e.Mutation.Update {
            setAddRecord() {
                const e = this.mutation
                  , {fields: t, dispatchId: n} = e
                  , r = super.setAddRecord().addRecord
                  , i = t.method.type;
                return this.addRecord = function(o, s, a, c, u, d, h, f) {
                    if ("string" === typeof u) {
                        if (!a || "method" !== u)
                            return r.call(this, o, s, a, c, u, d, h, f);
                        u = null;
                        const t = i.getInternalValue(a);
                        if (!t)
                            return g = a,
                            void (p = e).errorRecordState({
                                method: '"method": The method "'.concat(Object(pO.a)(g), '" is not a recognized method for the ').concat(p.modelName, " `method` field.")
                            }, Gr.c);
                        a = {
                            method: t
                        }
                    }
                    var p, g;
                    if (a.method) {
                        o = o.getBestInstance(n);
                        const r = function(e, t, n) {
                            let r;
                            if ("function" === typeof n.method)
                                r = n.method[l.d];
                            else {
                                if ("string" === typeof n.method)
                                    return null;
                                r = n.method
                            }
                            const i = t.method && t.method !== n.method;
                            let o, s = null;
                            for (let a in Hx)
                                o = Hx[a],
                                n[o] || !r[a] || !i && t[o] || (n[o] = r[a],
                                s = e[o].validate(n, s));
                            return n.name || t.name || !r[l.j] || (n.name = r[l.j],
                            s = e.name.validate(n, s)),
                            s
                        }(t, o.getState(), a);
                        if (r)
                            return void e.errorRecordState(r, Gr.c)
                    }
                    return r.call(this, o, s, a, c, u, d, h, f)
                }
                ,
                this
            }
        }
        return t
    }
    function Wx(e, t) {
        const n = this.model.IDType
          , r = this.fields.method
          , i = n.fieldName
          , o = e[i];
        let s, a = 0;
        const c = t.length;
        let u = !0;
        if (c > 1) {
            let e = !0;
            for (; a < c && (e || u); )
                s = Kx(n, r, t[a]),
                t[a] = s,
                s.prevId && (e = !1),
                s.entryParentId && (u = !1),
                s.parentId = o,
                a++;
            if (e) {
                s = t[0];
                let e = n.toGlobalId(s[i]);
                for (s[i] = e,
                a = 1; a < c; )
                    s = t[a],
                    s.prevId = e,
                    e = n.toGlobalId(s[i]),
                    s[i] = e,
                    a++
            }
        } else
            t[0] = Kx(n, r, t[0]),
            t[0].entryParentId && (u = !1);
        return u && !e.childrenEntry && (t[0].entryParentId = o),
        t
    }
    function $x(e, t) {
        let {children: n, next: r, prev: i, childrenEntry: o, parent: s} = t;
        const {model: {IDType: a}, primaryKey: c, fields: {method: u}} = this
          , l = a.toGlobalId(t[c]);
        s && (s = Kx(a, u, s),
        t.parent = s,
        s[c] = a.toGlobalId(s[c]),
        t.parentId = s[c]),
        o && (o = Kx(a, u, o),
        t.childrenEntry = o,
        o.entryParentId = l,
        o.parentId = l),
        n && Array.isArray(n) && this.prepareChildren(t, n),
        r && (r = Kx(a, u, r),
        t.next = r,
        t.parentId && (s || (t.parentId = a.toGlobalId(t.parentId)),
        r.parentId = t.parentId),
        r.prevId = l),
        i && (i = Kx(a, u, i),
        t.prev = i,
        i[c] = a.toGlobalId(i[c]),
        t.prevId = i[c],
        t.parentId && (s || r || (t.parentId = a.toGlobalId(t.parentId)),
        i.parentId = t.parentId))
    }
    function Xx(e, t, n, r) {
        if (this.isCommitOnly)
            return e;
        if (Array.isArray(e)) {
            if (t.ownModelName === this.modelName && "children" === t.VFName)
                return this.prepareChildren(n, e);
            {
                const n = this.fields.method
                  , r = this.model.IDType
                  , i = r.fieldName
                  , o = t.ownModelName;
                let s, a = !1, c = null;
                for (let t = 0; t < e.length; t++) {
                    if (s = e[t],
                    s = "object" !== typeof s ? Kx(r, n, s) : s,
                    s.type || (s.type = o),
                    !a)
                        if (s.prevId) {
                            if (a = !0,
                            t > 1) {
                                let n = t;
                                for (; n > 0; )
                                    n--,
                                    e[n].prevId = null
                            }
                        } else
                            s.prevId = c,
                            c = r.toGlobalId(s[i]),
                            s[i] = c;
                    e[t] = s
                }
                return e
            }
        }
        return "object" !== typeof e && (e = Kx(this.model.IDType, this.fields.method, e)),
        e.type || (e.type = t.ownModelName),
        e
    }
    function Jx(e) {
        class t extends e.Mutation {
        }
        return t.prototype.prepareChildren = Wx,
        t.prototype.prepareRecursiveVFData = $x,
        t.prototype.preprocessOwnRefModelCreate = Xx,
        t.Create = function(e) {
            class t extends e.Mutation.Create {
                setAddRecord() {
                    const e = this.mutation;
                    if (e.isCommitOnly)
                        return super.setAddRecord();
                    const t = super.setAddRecord().addRecord
                      , n = e.fields.method
                      , r = e.model.IDType;
                    return this.addRecord = function(i, o, s) {
                        if (i.method)
                            try {
                                Kx(r, n, i.method, i)
                            } catch (a) {
                                return void e.errorRecordState({
                                    method: '"method": '.concat(a.message)
                                }, Gr.a)
                            }
                        return e.prepareRecursiveVFData(e, i),
                        t.call(this, i, o, s)
                    }
                    ,
                    this
                }
            }
            return t
        }(e),
        t.Update = Yx(e),
        t
    }
    const Zx = {
        [f.f]: f.f,
        [f.g]: f.g,
        [f.b]: f.b,
        [f.e]: f.e,
        [f.c]: f.c
    }
      , ew = (e, t, n) => 'Unable to add default dispatcher indicated by logic "'.concat(e[l.d][l.j], '" to the "').concat(t.modelName, '" model record because its ').concat(l.a, " property is not a string or Array of strings. The default dispatcher can only be added when that is the case. Got: ").concat(n);
    function tw(e, t, n, r, i, o) {
        if (!e)
            return Object(V.a)(null);
        let s;
        if (Object(he.U)(e))
            s = e;
        else if (Array.isArray(e)) {
            for (s of e)
                if (s)
                    break
        } else
            for (let a in e)
                if (s = e[a])
                    break;
        return s ? s.dispatchTo(e, t, n, r, i, o) : Object(V.a)(e)
    }
    function nw(e) {
        const t = e.types
          , n = e.storeConfig
          , r = e.modelName
          , i = e.storesMap
          , o = new Map;
        n.getVFDescriptions = void 0,
        n.typeEnum = t.LogicTypeEnum.getByModelName(r),
        n.methodEnum = t.LogicMethodEnum.getByModelName(r),
        n.itemEnum = t.LogicItemEnum.getByModelName(r),
        n.componentEnum = t.LogicComponentEnum.getByModelName(r);
        const s = e.setMutation(Jx(e), "module:logic.Mutation").registerExtension("module:logic.ModelMixin").Class.prototype
          , a = s.initComplete;
        s.initComplete = function() {
            a && a.call(this),
            function(e) {
                const t = e.recordStore;
                let n, r, i, o, s = t.storeMgr, a = s.logicArray;
                for (i of a)
                    o = i[l.s],
                    o && (n || (n = [])) && (n.push(i),
                    s.removeLogic(i[l.h], !0, "all"));
                for (i of (s = t.pendingStoreMgr,
                a = s.logicArray,
                a))
                    o = i[l.s],
                    o && (r || (r = [])) && (r.push(i),
                    s.removeLogic(i[l.h], !0, "all"));
                e.typePendingRecordLogic = r || null,
                e.typeMainRecordLogic = n || null
            }(n),
            function(e, t) {
                const {virtualFields: n} = e
                  , {prev: r, next: i, parent: o, children: s} = n;
                let {syncRecursiveVFsLogic: a} = e;
                a || (a = Object(lv.a)(e, t),
                e.syncRecursiveVFsLogic = a),
                a.registerVF(r),
                a.registerVF(i),
                a.registerVF(o),
                a.registerVF(s);
                let c = a.getOwnOptions(r);
                c.opsMap = Zx,
                c = a.getOwnOptions(i),
                c.opsMap = Zx,
                c = a.getOwnOptions(o),
                c.opsMap = Zx,
                c = a.getOwnOptions(s),
                c.opsMap = Zx,
                e.recordStore.addPendingLogic(a)
            }(n, i),
            function(e, t) {
                const n = e.recordStore
                  , r = e.methodEnum.getValues()
                  , {recordAccessors: i, recordDispatchers: o} = e
                  , s = {
                    ...i
                };
                let a, c, u, d;
                for (let f of r)
                    if (c = f.value,
                    a = c[l.d],
                    a && (u = a[l.f]))
                        if (d = a[l.a],
                        !0 !== u)
                            c = Object(x.f)(c),
                            u.call(c, n, t, o, i);
                        else if (Array.isArray(d))
                            for (let t of d) {
                                if ("string" !== typeof t)
                                    throw new Error(ew(c, e, t));
                                o[t] || (o[t] = !0)
                            }
                        else {
                            if ("string" !== typeof d)
                                throw new Error(ew(c, e, d));
                            o[d] || (o[d] = !0)
                        }
                const h = e.Record;
                for (let l in i)
                    s[l] || Object.defineProperty(h.prototype, l, i[l])
            }(n, i)
        }
        ,
        s.findById = function(e, t) {
            const n = i.get(this)
              , r = n.get(e);
            if (r)
                return Object(V.a)(r);
            const s = t ? "".concat(t.mainDispatchId, "__").concat(e) : "".concat(n.mainDispatchId, "__").concat(e);
            let a = o.get(s);
            return a || (a = n.instance.query().selectAll(!0).where(n.storeConfig.primaryKey, e).fetchOneRecord({
                mutation: t
            }).pipe(Object(Y.a)(e => (o.delete(s),
            e)), Object(_g.a)()),
            a.subscribe(),
            o.set(s, a)),
            a
        }
        ,
        s.dispatchToRecords = tw
    }
    var rw = n(196)
      , iw = n(136);
    const ow = iw.a.findExistingBuilder(c.n);
    ow.use().setPrepareOp().setPriority(rw.a + 50).setLogicMgr(iw.a, "./mutation").setName("manageGroupLogicLeaderChanges").setId().setPure(!0),
    ow.add((function(e) {
        const t = e.meta.store.value
          , {mutationType: n} = t;
        if (n === Gr.b)
            return e;
        const r = t.getState()
          , {isGroupLogicLeader: i} = r;
        if (null === i)
            return e;
        if (n === Gr.a) {
            if (r.parentId) {
                if (!r.groupLogicLeaderId) {
                    const t = e.meta.instance
                      , n = t.getParentWhere(null, "isGroupLogicLeader", !0)
                      , i = n ? n.__ID : r.parentId;
                    r.groupLogicLeaderId !== i && (t.groupLogicLeaderId = i)
                }
            } else
                !0 !== i && (e.meta.instance.isGroupLogicLeader = !0);
            return e
        }
        const {pChanges: o} = t;
        if (o && (o.groupLogicLeaderId || o.isGroupLogicLeader)) {
            const n = e.meta.instance;
            r.isGroupLogicLeader ? t.getPrev("isGroupLogicLeader") ? n.addChildrenToGroupLogicLeader(e, n) : n.convertToGroupLogicLeader(e) : n.addChildrenToGroupLogicLeader(e, n.groupLogicLeader)
        }
        return e
    }
    ), !0);
    const sw = {
        MANAGE_GROUP_LOGIC_LEADER_CHANGES: ow.getPrevId()
    };
    function aw(e, t, n) {
        if (!t && !(t = this.groupLogicLeader))
            return this;
        const r = this.children;
        if (r)
            for (let i in r)
                r[i].joinGroupLogicLeader(e, t, n);
        return this
    }
    const cw = {};
    function uw(e, t, n, r, i) {
        t || (t = this),
        n || (n = cw);
        const o = e.primaryKey
          , s = t.getState();
        return e.createOne({
            ...s,
            ...n,
            [o]: void 0,
            prevId: i ? i[o] : null,
            parentId: r ? r[o] : null,
            entryParentId: n.entryParentId || null,
            originId: s[o],
            props: s.props ? {
                ...s.props
            } : null,
            localProps: s.localProps ? {
                ...s.localProps
            } : null,
            groupLogicLeaderId: r ? r.isGroupLogicLeader ? r[o] : r.groupLogicLeaderId : null
        })
    }
    function lw(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1
          , n = arguments.length > 2 ? arguments[2] : void 0
          , r = arguments.length > 3 ? arguments[3] : void 0
          , i = arguments.length > 4 ? arguments[4] : void 0;
        const o = this.cloneLogic(e, this, n, r, i);
        if (t > 0) {
            t--;
            let r = this.childrenEntry;
            if (r) {
                let i = r.cloneDepth(e, t, n, o, null);
                for (i.entryParentId = o.__ID; r = r.next; )
                    i = r.cloneDepth(e, t, n, o, i)
            }
        }
        return o
    }
    function dw(e, t, n, r, i) {
        const o = this.cloneLogic(e, this, n, r, i);
        let s = this.childrenEntry;
        if (s && t(s, e, n, o, null)) {
            let r = s.cloneFilter(e, t, n, o, null);
            for (r.entryParentId = o.__ID; s = s.next; )
                t(s, e, n, o, r) && (r = s.cloneFilter(e, t, n, o, r))
        }
        return o
    }
    function hw(e, t, n, r, i) {
        const o = this.cloneLogic(e, this, n, r, i);
        let s = this.childrenEntry;
        if (s) {
            let r;
            for (r in t)
                if (s[r] !== t[r])
                    return o;
            let i, a = s.cloneWhere(e, t, n, o, null);
            for (a.entryParentId = o.__ID; s = s.next; ) {
                for (r in i = !0,
                t)
                    if (s[r] !== t[r]) {
                        i = !1;
                        break
                    }
                i && (a = s.cloneWhere(e, t, n, o, a))
            }
        }
        return o
    }
    function fw(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        const r = this.getModelMutation(e)
          , i = this.getVFValue("childrenEntry", r.dispatchId);
        if (i) {
            let e, o = i;
            for (; o; )
                e = o,
                o = n ? o.prev : o.next;
            return n ? e.createPrev(r, t) : e.createNext(r, t)
        }
        return this.createChildrenEntry(r, t)
    }
    function pw(e, t) {
        const n = this.getModelMutation(e);
        if (this.getVFValue("children", n.dispatchId))
            throw new Error("Unable to createChildrenEntry() because one or more children already exist. Use the `createChild()` method instead, or call createPrev() or createNext() on an existing child followed by setAsParentEntry(). Or, if only 1 child exists, call setAsParentEntry() on it rather than creating a new entry directly.");
        const r = this.__ID;
        return t ? "object" !== typeof t && (t = {
            [n.primaryKey]: t
        }) : t = {},
        t.parentId = r,
        t.entryParentId = r,
        n.createOne(t)
    }
    function gw(e, t) {
        const n = this.getModelMutation(e)
          , r = n.primaryKey;
        t && "string" !== typeof t || (t = {
            [r]: t
        }),
        t[r] = n.model.IDType.toGlobalId(t[r]);
        let i = this.getVFValue("next", n.dispatchId);
        return i && n.update(i, {
            prevId: t[r]
        }),
        i = this.getBestInstance(n.dispatchId).getState(),
        t.prevId = i[r],
        t.parentId = i.parentId,
        n.createOne(t)
    }
    function mw(e, t) {
        const n = this.getModelMutation(e);
        let r = this.getVFValue("prev", n.dispatchId);
        if (r)
            return r.createNext(n, t);
        t && "string" !== typeof t || (t = {
            [n.primaryKey]: t
        });
        const i = n.getMutableRecord(this);
        return t.parentId = i.parentId,
        r = n.createOne(t),
        i.prevId = r.__ID,
        r
    }
    const yw = Object(V.a)(null)
      , vw = Object(Y.a)(e => {
        if (Array.isArray(e))
            for (let t = 0; t < e.length; t++)
                e[t] = e[t] ? e[t].payload : e[t];
        else
            for (let t in e)
                e[t] && (e[t] = e[t].payload);
        return e
    }
    )
      , bw = Object(Y.a)(e => e ? e.payload : null)
      , _w = () => bw;
    function Sw(e, t) {
        const n = e.storesMap
          , r = (e, t, r, i) => !!i && ("function" === typeof t && (t = t(i) || {}),
        n.get(i).dispatch(e, t, r))
          , i = (e, t, r, i) => {
            if (!i)
                return !1;
            const o = n.get(i);
            return o.mainStore.__hasLogicRecordInit ? o.getActionByType(c.m, r, !0) || !1 : (o.mainStore.__hasLogicRecordInit = !0,
            "function" === typeof t && (t = t(i) || {}),
            o.dispatch(e, t, r))
        }
          , o = (e, t, n, r, i, o) => n ? (e[t] = r ? i ? sn(r, n.meta.asObservable()) : on(r, n.meta.asObservable()) : n.meta.asObservable(),
        n.meta.dispatchId) : (e[t] = yw,
        o);
        t.dispatchCurrent = function(e, t, n, r, i) {
            return this.dispatchTo(this, e, t, n, r, i)
        }
        ,
        t.dispatchTo = function(e, t, s, a, u, l) {
            if (!e)
                return yw;
            const d = t === c.m ? i : r;
            let h, f;
            if ("undefined" === typeof a && (a = n.get(this).mainDispatchId),
            Object(he.U)(e))
                return h = d(t, s, a, e),
                h ? u ? l ? sn(u, h).pipe(_w()) : on(u, h).pipe(_w()) : h.meta.pipe(_w()) : yw;
            if (Array.isArray(e)) {
                const n = e.length;
                if (!n)
                    return Object(V.a)(e);
                f = new Array(n);
                let r = 0;
                for (; r < n; )
                    a = o(f, r, d(t, s, a, e[r]), u, l, a),
                    r++
            } else {
                for (let n in e)
                    a = o(f || (f = {}), n, d(t, s, a, e[n]), u, l, a);
                if (!f)
                    return Object(V.a)(e)
            }
            return Object(wr.a)(f).pipe(vw)
        }
    }
    const Ow = (e, t) => e.indexOf(t) > -1
      , Tw = (e, t) => e === t
      , Iw = () => !0
      , xw = (e, t, n, r, i, o) => {
        let s = o ? e.parent : e.children;
        if (!s)
            return null;
        let a = Tw
          , c = Tw;
        if (n ? Array.isArray(r) ? (c = Ow,
        "method" === n && (r = e.methodEnum.toInternalValues(r))) : "method" === n && "function" !== typeof r && (r = e.methodEnum.getInternalValue(r)) : c = Iw,
        t ? Array.isArray(t) ? (a = Ow,
        t = e.typeEnum.toInternalValues(t)) : t = e.typeEnum.getInternalValue(t) : a = Iw,
        o)
            for ((!i || "number" !== typeof i || i < 0) && (i = 999999); s && i >= 0; ) {
                if (a(t, s.type) && c(r, s[n]))
                    return s;
                s = s.parent,
                i--
            }
        else {
            const e = s;
            for (let i in e)
                if (s = e[i],
                a(t, s.type) && c(r, s[n]))
                    return s
        }
        return null
    }
    ;
    function ww(e, t) {
        return xw(this, e, t ? "name" : null, t)
    }
    function Mw(e, t, n) {
        return xw(this, e, t, n)
    }
    function Aw(e, t, n) {
        return xw(this, e, t ? "name" : null, t, n, !0)
    }
    function Ew(e, t, n, r) {
        return xw(this, e, t, n, r, !0)
    }
    function Cw(e) {
        const t = e ? e.meta.getSession() : this.getSession();
        let n = t && t.location;
        return n && e ? n.getBestInstance(e.meta.mainDispatchId) : n || null
    }
    function Nw(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this;
        return this.typeEnum.getInternalValue(e) === t.type
    }
    function Rw(e) {
        return this.getModel().getSession(e) || null
    }
    function Pw(e, t, n) {
        return this.getVFModelMutation(e, n || this.type).createOne(t)
    }
    function Dw(e, t, n) {
        return this.getVFModelMutation(e, n || this.type).create(t)
    }
    function Fw() {
        return this[this.type]
    }
    function kw(e, t, n) {
        const r = this.getVFValue("children", n);
        if (!r)
            return !1;
        const i = r.getState();
        let o;
        for (let s in i)
            if (o = e(i[s], t, n),
            !0 === o) {
                if ("boolean" !== typeof i[s].walk(e, t, n))
                    return null
            } else if (!1 !== o)
                return null;
        return !1
    }
    function jw(e) {
        return e.getMutationAction().meta.removeLogic(sw.MANAGE_GROUP_LOGIC_LEADER_CHANGES),
        e
    }
    const Lw = (e, t, n) => {
        if (!n)
            return;
        let r;
        for (let i of n)
            r = i[l.s],
            r && r !== t && e.removeLogic(i, !0, !0)
    }
      , Vw = (e, t, n) => {
        if (n)
            for (let r of n)
                r[l.s] === t && e.addLogic(r, !0, !0)
    }
    ;
    const Uw = c.l;
    function qw(e) {
        const t = e.getRecordBuilder();
        t.registerExtension("module:logic.RecordPropsMixin").registerExtension("module:logic.RecordMixin").setPendingValue(function(e) {
            return e || (e = uv.b),
            class extends e {
                set(e, t) {
                    if ("method" === e || "type" === e) {
                        const n = this.get(e)
                          , r = super.set(e, t);
                        return n !== r && ("method" === e ? this.store.instance.logicMethodChanged(n, r) : this.store.instance.logicTypeChanged(n, r)),
                        r
                    }
                    return super.set(e, t)
                }
            }
        }(t.PendingValue)).addPendingLogic(iw.a);
        const n = e.recordDispatchers
          , r = e.storesMap;
        n[Uw] || (n[Uw] = !0),
        n[c.r] || (n[c.r] = !0),
        function(e) {
            const t = e.storesMap
              , n = e.storeConfig
              , r = e.plugin.getMainInstance()
              , i = e.getRecordBuilder().Class.prototype;
            function o(e, n) {
                return e ? t.get(this).parentInstance.getModelByName(e, n) : t.get(this).parentInstance
            }
            i.logicTypeChanged = function(e, r) {
                r = this.typeEnum.getValue(r).name;
                let i = t.get(this);
                Lw(i, r, i.storeMgr.logicArray),
                Vw(i, r, n.typePendingRecordLogic),
                i = i.mainStore,
                Lw(i, r, i.storeMgr.logicArray),
                Vw(i, r, n.typeMainRecordLogic)
            }
            ,
            i.logicMethodChanged = function(e, n) {
                if (e !== n) {
                    const r = t.get(this);
                    e && r.removePendingLogic(e, !0, !0),
                    n && r.addPendingLogic(n, !0, !0)
                }
            }
            ,
            i.getMutationAction = function() {
                const e = t.get(this);
                return e.value.mutation ? e.getAction(e.value.mutation.dispatchId) : null
            }
            ,
            i.getMutableVFRecord = function(e, n, r) {
                const i = t.get(this)
                  , o = i.parentInstance
                  , s = t.get(o).storeConfig
                  , a = s.virtualFields[n]
                  , c = o.switchTo(a.ownRefModel).mutation(e.meta.dispatchId);
                if (a.isMany) {
                    const e = a.get(this, i);
                    if (e) {
                        if (r) {
                            const t = r[a.keyBy || s.primaryKey];
                            return e[t] ? c.getMutableRecord(e[t]) : null
                        }
                        {
                            const t = {
                                ...e
                            };
                            for (let e in t)
                                t[e] = c.getMutableRecord(t[e]);
                            return t
                        }
                    }
                    return null
                }
                {
                    const e = a.get(this, i);
                    return e ? c.getMutableRecord(e) : e
                }
            }
            ,
            i.getModelByName = o,
            i.getModel = o,
            i.getModelMutation = function(e, t, n) {
                const r = this.getPluginMutation(e, n);
                return r ? t ? r.switchTo(t) : r.switchTo(this.__typename) : null
            }
            ,
            i.getPluginMutation = function(e, n) {
                let i = t.get(this).value.mutation;
                return i ? i.controller : Object(he.P)(e) ? e.controller : (i = r.mutation(e.meta.dispatchId, n),
                i ? i.executeWhen(e) : i)
            }
            ,
            i.getVFModelMutation = function(e, n) {
                return t.get(this).parentInstance.getVFModelMutation(e, n || this.type)
            }
            ,
            i.convertToGroupLogicLeader = function(e, n) {
                if (this.isGroupLogicLeader)
                    return this;
                const r = this.getMutableRecord(e, t.get(this));
                return r.isGroupLogicLeader = !0,
                jw(r),
                this.addChildrenToGroupLogicLeader(e, r, n)
            }
            ,
            i.joinGroupLogicLeader = function(e, n) {
                let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                  , {isGroupLogicLeader: i, groupLogicLeaderId: o} = this.getState();
                if (i && !r)
                    return this;
                const s = n.__ID;
                if (s === o)
                    return this;
                const a = this.getMutableRecord(e, t.get(this));
                return a.groupLogicLeaderId = n.__ID,
                i && (a.isGroupLogicLeader = !1),
                jw(a),
                this.addChildrenToGroupLogicLeader(e, n, r)
            }
            ,
            i.setAsParentEntry = function(e) {
                let n = this.parent;
                if (!n)
                    return !1;
                let r = n.childrenEntry;
                r && (r = r.getMutableRecord(e, t.get(r)),
                r.entryParentId = null);
                const i = this.getMutableRecord(e, t.get(this));
                return i.entryParentId = n.__ID,
                i
            }
            ,
            Object(rx.a)(e, i),
            Sw(e, i),
            i.addChildrenToGroupLogicLeader = aw,
            i.cloneDepth = lw,
            i.cloneFilter = dw,
            i.cloneLogic = uw,
            i.cloneWhere = hw,
            i.createChild = fw,
            i.createChildrenEntry = pw,
            i.createNext = gw,
            i.createPrev = mw,
            i.getChildByType = ww,
            i.getChildWhere = Mw,
            i.getLocation = Cw,
            i.getParentByType = Aw,
            i.getParentWhere = Ew,
            i.getSession = Rw,
            i.isTypeOf = Nw,
            i.createVFRecord = Pw,
            i.createVFRecords = Dw,
            i.getVFRecord = Fw,
            i.walk = kw,
            i.getPlugin = function(e) {
                return r.getBestInstance(e || this.__dispatchId)
            }
            ,
            i.getCorePlugin = function(e) {
                const t = r.getPlugin(KS.c);
                return e || (e = this.__dispatchId),
                e ? t.getBestInstance(e) : t
            }
        }(e),
        function(e) {
            !function(e, t) {
                const n = e.storesMap;
                t.isServer = {
                    value: e.isServer,
                    writable: !1,
                    enumerable: !1
                },
                t.__hasLogicRecordInit = {
                    get() {
                        return !!n.get(this).mainStore.__hasLogicRecordInit
                    },
                    set: void 0,
                    configurable: !1,
                    enumerable: !1
                }
            }(e, e.getRecordBuilder().accessors)
        }(e),
        t.Class.prototype.findById = function(e, t) {
            return r.get(this).parentInstance.findById(e, t)
        }
    }
    const Qw = mv.getBuilder(c.n);
    let Bw = (e, t) => e.parentId === t;
    function Gw(e, t) {
        const {payload: n} = e
          , {mutation: r} = n
          , {records: i, recordDataType: o} = r
          , s = e.meta.store.storeConfig;
        if (!s.pluginInitIsComplete) {
            if (e.meta.store.parentInstance.hasActionByType(c.o))
                return Object(Ov.a)(null, e, t);
            s.pluginInitIsComplete = !0
        }
        const a = (e => e.meta.getSession().coreLogicId)(e);
        let u, l, d, h;
        for (let c in o)
            o[c] !== Gr.b && (u = i[c]) && (d = u.getState()).type === YS.a.ROUTE && !d.props.isApiLike && !u.__hasLogicRecordInit && (h = u.routerLogic) && Bw(h, a) && (l ? l.push(u) : l = [u]);
        return l && console.log("DISPATCHING TO RECORDS:\n  - ".concat(l.map(e => "".concat(e.type, " - ").concat(e.name)).join("\n  - "))),
        Object(Ov.a)(l ? r.model.dispatchToRecords(l, c.m, {
            mutation: r
        }, r.mainDispatchId) : null, e, t)
    }
    function zw(e) {
        e.addLogic(Gw),
        function(e) {
            var t;
            (t = e).registerExtension("module:logic.ModelRecordShared").getRecordBuilder().registerExtension("module:logic.ModelRecordShared"),
            function(e) {
                const t = e.storeConfig
                  , n = t.modelAccessors
                  , r = t.recordAccessors
                  , i = {
                    get: () => t.typeEnum,
                    enumerable: !1,
                    configurable: !1
                };
                n.typeEnum = i,
                r.typeEnum = i;
                const o = {
                    get: () => t.methodEnum,
                    enumerable: !1,
                    configurable: !1
                };
                n.methodEnum = o,
                r.methodEnum = o;
                const s = {
                    get: () => t.itemEnum,
                    enumerable: !1,
                    configurable: !1
                };
                n.itemEnum = s,
                r.itemEnum = s;
                const a = {
                    get: () => t.componentEnum,
                    enumerable: !1,
                    configurable: !1
                };
                n.componentEnum = a,
                r.componentEnum = a
            }(t),
            nw(e),
            qw(e)
        }(e),
        function(e) {
            const t = e.Mutation.prototype
              , n = t.preprocessOwnRefModelCreate;
            t.preprocessOwnRefModelCreate = function(e, t, r, i) {
                if (!this.isCommitOnly && t.ownModelName === tv.b.ENTITY) {
                    const t = r.__ID
                      , {model: {IDType: n}, fields: {method: i}} = this;
                    for (let r = 0; r < e.length; r++)
                        e[r] = Kx(n, i, e[r]),
                        e[r].entityId = t
                }
                return n.call(this, e, t, r, i)
            }
            ;
            const r = t.prepareChildren;
            t.prepareChildren = function(e, t) {
                t = r.call(this, e, t);
                const n = e.entityId;
                if (n)
                    for (let r of t)
                        r.entityId = n;
                return t
            }
        }(e)
    }
    Qw.useRelative("ensureMutationIsExecuting", 1).setName("dispatchLogicRecordInit"),
    Qw.setModuleName("@isomorix/coreLogic/model/logic/mutation").done(Gw, !0);
    const Hw = (e, t, n) => e.where("name", t.name).andWhere("tld", t.tld || null).andWhere("subName", n ? "www" : t.subName || null)
      , Kw = (e, t, n, r) => {
        if (n) {
            let r;
            return t.doNotUpdateSsl || n.ssl === t.ssl || (r = {
                ssl: t.ssl
            }),
            t.publicPath !== n.publicPath && (r || (r = {}),
            r.publicPath = t.publicPath),
            r ? e.switchTo(tv.b.DOMAIN).update(n, r) : n
        }
        return e.switchTo(tv.b.DOMAIN).createOne({
            name: t.name,
            tld: t.tld,
            subName: r ? "www" : t.subName,
            ssl: t.ssl,
            userId: t.userId,
            publicPath: t.publicPath
        })
    }
    ;
    var Yw = n(282);
    const {CREATED: Ww} = ws.a;
    function $w(e, t, n, r, i) {
        const o = e[t];
        if (!o)
            return !1;
        const {state: s} = e;
        let a, c, u = !1;
        for (let l in o)
            o[l] === Ww && (a = s[l],
            (c = a[n]) ? (c[r] = a,
            i || (u = !0)) : i && (u ? u[l] = a : u = {
                [l]: a
            }));
        return u
    }
    const Xw = Xm.b.init().setPackageName("@isomorix/core-plugin").setModuleName("@isomorix/core/plugin/model/trxLogic")
      , Jw = Xm.b.init().setPackageName("@isomorix/core-plugin").setModuleName("@isomorix/core/plugin/model/trxLogic");
    function Zw(e) {
        return $w(e.meta.store.value, "allChanges", "pluginInstance", "pluginRecord"),
        e
    }
    function eM(e) {
        const t = e.meta;
        return t.trxOp !== h.l || t.isCommitOnlyTrx ? ($w(t.store.value, "changes", "pluginInstance", "pluginRecord"),
        e) : e
    }
    Zw[l.d] = {
        [l.j]: "mainTrxGiveRecordToInstance",
        [l.n]: !0,
        [l.k]: h.l,
        [l.a]: c.n,
        [l.l]: Xw.packageName,
        [l.i]: Xw.moduleName,
        [l.m]: Lm.g + 10,
        [l.e]: "Iterates over the changes and provides each new Plugin with the record for its plugin, replacing the plain Object that it uses initially, or replacing a pending record with the main record.\n\nThis is done via trxLogic so that it can be assured that all virtual field references are also committed (i.e., models/endpoint), since some things may be cached by the Plugin to avoid repeated VF lookups.",
        [h.l]: Zw
    },
    Xw.add(Zw[l.d]),
    eM[l.d] = {
        [l.j]: "pendingTrxGiveRecordToInstance",
        [l.n]: !0,
        [l.k]: [h.j, h.l],
        [l.a]: c.n,
        [l.l]: Jw.packageName,
        [l.i]: Jw.moduleName,
        [l.m]: Lm.g + 10,
        [l.e]: "Iterates over the changes and provides each new Plugin with the record for its plugin, replacing the plain Object that it uses initially, or replacing a pending record with the main record.\n\nThis is done via trxLogic so that it can be assured that all virtual field references are also committed (i.e., models/endpoint), since some things are cached by the Plugin to avoid repeated VF lookups.",
        [h.j]: eM,
        [h.l]: eM
    },
    Jw.add(eM[l.d]);
    const tM = (e, t) => {
        let n = e.storeConfig;
        return n ? n[t] ? !e.mainDispatchId && n[t].mainDispatchId ? n.loadRoles$.pipe(Object(j_.a)(e.getAction(n[t].mainDispatchId, !0).meta.asObservable()), Object(Or.a)(void 0)) : n[t] : null : (e.storeConfig = {},
        null)
    }
      , nM = (e, t) => {
        const n = e.storeConfig
          , r = n[t];
        e.mainDispatchId ? (n[t] = new U.a,
        e.subscribe({
            complete: () => {
                nM(e.mainStore, t)
            }
        })) : n[t] = void 0,
        r.next(e.instance),
        r.complete()
    }
      , rM = (e, t) => {
        const n = e.mainStore
          , r = e.storeConfig;
        return new S.a(i => r[t] ? r[t].subscribe(i) : Object(V.a)(e.closed ? n.instance : e.instance).subscribe(i))
    }
    ;
    var iM = n(275);
    function oM() {}
    function sM() {
        return !1
    }
    const aM = e => {
        e.markCacheCompleteFromQueryArg = oM,
        e.processMutationAutoload = oM,
        e.processQueryAutoload = oM,
        e.checkCacheMissingForResolve = sM
    }
    ;
    function cM(e) {
        e.registerExtension("../ModelMixin");
        const t = e.parentStore.storeConfig
          , n = e.Class.prototype
          , r = (e, t, n) => {
            const r = e.getSlugIndex().value;
            let i, o, s, a = !1;
            if (!0 === n && (a = !0,
            n = void 0),
            "string" === typeof t) {
                if (i = r.get(t),
                !0 === n)
                    return i;
                if (i)
                    return Object(V.a)(i);
                o = [t]
            } else {
                s = {};
                for (let e of t)
                    i = r.get(e),
                    s[e] = i,
                    a || i || (o || (o = []),
                    o.push(e));
                if (!o)
                    return a ? s : Object(V.a)(s)
            }
            const c = {};
            "number" === typeof n ? c.dispatchId = n : n ? (c.mutation = n,
            c.dispatchId = c.mutation.mainDispatchId) : c.dispatchId = e.__dispatchId;
            const {dispatchId: u} = c;
            let l = e.query().selectAll("autoload").whereIn("slug", o);
            return s ? (l = l.fetchAllRecords(c),
            u || (l = l.pipe(Object(iM.a)(!0))),
            l.pipe(Object(Y.a)( () => {
                const {records: e} = c;
                if (e)
                    for (let t in e)
                        s[e[t].slug] = e[t];
                return s
            }
            ))) : (l = l.fetchOneRecord(c),
            u ? l : l.pipe(Object(iM.a)(!0)))
        }
        ;
        n.getBySlug = function(e) {
            return r(this, e, !0)
        }
        ,
        n.findBySlug = function(e, t) {
            return r(this, e, t)
        }
        ,
        n.getSlugIndex = function(e) {
            return this.getIndex("c_slug", e, !0)
        }
        ;
        const i = n.initComplete;
        n.initComplete = function() {
            t.getModelStoreConfig(this).isInitComplete || (i.call(this),
            function(e) {
                const t = e.types.get(qo.a.VF_RELATIONSHIP_TYPE)
                  , n = t.getInternalValue(iO.a.HAS_MANY)
                  , r = t.getInternalValue(iO.a.BELONGS_TO);
                class i extends n {
                    static init(e) {
                        const t = e.virtualFields.coreLogic;
                        if (!t)
                            return;
                        const n = {
                            ...t.foreignField,
                            modelAutoload: !1,
                            modelAutoloadOnClient: !1,
                            modelAutoloadOnServer: !1,
                            refModelAutoload: !1,
                            refModelAutoloadOnClient: !1,
                            refModelAutoloadOnServer: !1,
                            modelVFName: null,
                            modelVFApiCreate: !1,
                            modelVFApiUpdate: !1,
                            modelVFApiRead: !1,
                            onDelete: bI.a.NO_ACTION,
                            onUpdate: bI.a.NO_ACTION,
                            refModelVFName: "apps"
                        }
                          , r = super.init(n);
                        e.registerVF(r),
                        r.isMetaVF = !0,
                        r.extraWrapperKeys = ["name", "type"],
                        r.extraWrapperValues = [Bx.a.APP, YS.a.ROUTER];
                        const i = o.init(n);
                        return i.isMetaVF = !0,
                        t.model.registerVF(i),
                        r
                    }
                    _findApps(e) {
                        if (!e)
                            return e;
                        let t, n = null;
                        for (let r in e)
                            t = e[r].getState(),
                            "app" === t.name && t.type === YS.a.ROUTER && (n || (n = {}),
                            n[r] = e[r]);
                        return n
                    }
                    get(e, t) {
                        return this._findApps(super.get(e, t))
                    }
                    getter(e, t) {
                        return this._findApps(super.getter(e, t))
                    }
                    executeIncludeQuery(e) {
                        const t = e.query;
                        if (!t.parentQueryArg)
                            return null;
                        return t.parentQueryArg.prepareWrapperQueryArg(e) ? (t.queryArgs.length < 3 && t.andWhere("name", "app").andWhere("type", YS.a.ROUTER),
                        t.executeQuery(e)) : null
                    }
                    query(e, t) {
                        t || null === t || (t = e.__dispatchId);
                        const n = s.init(t ? this.ownRefModel.getBestInstance(t) : this.ownRefModel);
                        return n.VF = this,
                        n.record = e,
                        n
                    }
                }
                aM(i.prototype);
                class o extends r {
                }
                aM(o.prototype),
                o.prototype.processCreateVFData = oM,
                o.prototype.processUpdateVFData = oM;
                class s extends KT {
                    _normalizeQueryForVF(e, t, n, r) {
                        let i = this;
                        return this.isRootQuery && this.VF && (i = HT(this, this.VF, this.record),
                        i.andWhere("name", "app").andWhere("type", YS.a.ROUTER),
                        i.VF = void 0,
                        i.record = void 0),
                        i[r || ye.GET](e, t, n)
                    }
                }
                i.init(e)
            }(this))
        }
    }
    var uM = n(366)
      , lM = n(197);
    var dM = n(871);
    const hM = {
        inProcessStatuses: [dM.a.PROCESSING],
        firstProcessingStatus: dM.a.PROCESSING
    };
    function fM(e) {
        return e || (e = {}),
        (e.query || this.getJobsInProcessQuery()).fetch(e)
    }
    function pM(e) {
        e.setPackageName("@isomorix/core").setDefaultModuleNames("@isomorix/core/entityJobQueue"),
        function(e, t) {
            const n = 1 === (t = t ? {
                ...hM,
                ...t
            } : {
                ...hM
            }).inProcessStatuses.length
              , r = e.Class.prototype;
            r.fetchJobsInProcess = fM,
            r.getJobsInProcessQuery = function(e) {
                const r = this.query();
                return n ? r.where("status", t.inProcessStatuses[0]) : r.whereIn("status", t.inProcessStatuses),
                e ? r : r.selectAll(!0)
            }
        }(e),
        function(e) {
            const t = e.getRecordBuilder().Class.prototype;
            Object(rx.a)(e, t)
        }(e)
    }
    function gM(e) {
        const t = this.query().where("status", dM.a.PROCESSING).andWhere("entityId", this.getSession().entityId);
        return e ? t : t.selectAll(!0)
    }
    const mM = e => (e.querySelect || e.selectAll(!0),
    e.include("permissionsData", yM),
    e)
      , yM = e => e.selectAll(!0).includeAll("permission", !0);
    const vM = mM
      , bM = e => _M(e.include("user", e => e.selectAll(!0).includeAll("meta", !0)))
      , _M = e => (e.querySelect || e.selectAll(!0),
    e.include("role", mM));
    const SM = {
        loadByID: function e(t, n) {
            let r;
            return Object(he.S)(t) ? (r = t.getModelByName(tv.b.USER_ROLE).query(),
            e(r, n)) : (r = t,
            r.selectAll(!0).where(r.primaryKey, n || ":userRoleID"),
            bM(r))
        },
        includePermissions: _M,
        includeUserAndPermissions: bM
    };
    function OM() {
        return this.props.themeType
    }
    function TM(e) {
        return this.setThemeType("light" === this.getThemeType() ? "dark" : "light", e)
    }
    let IM;
    IM = (e, t) => {
        t.findThemeType = function(e) {
            const t = this.plugin.pluginInstance;
            let n = t.localStorage.getItem("theme");
            return n || (n = t.Cookie.get("theme")) || !e || (n = "undefined" !== typeof window && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"),
            n || void 0
        }
        ,
        t.setThemeType = function(e, t) {
            const n = this.plugin.pluginInstance;
            return n.localStorage.setItem("theme", e),
            n.Cookie.set("theme", e),
            ( (e, t, n) => {
                let {props: r} = e;
                return r.themeType === t ? Object(V.a)(e) : n ? ((e = n.switchTo(e.__typename).getMutableRecord(e)).getMutableProps().themeType = t,
                Object(qs.a)( () => n.ofComplete().pipe(Object(Or.a)(e)))) : e.setProps({
                    themeType: t
                }, {
                    disableHistoryUpdate: !0
                })
            }
            )(this, e, t)
        }
        ,
        t.getThemeType = OM,
        t.toggleThemeType = TM
    }
    ;
    var xM = n(389);
    function wM(e, t) {
        const n = this.getState();
        return n.timeZone && n.timeZone !== n.timeZoneLocal ? Object(Mi.a)(e, n.timeZone, t) : Object(xM.a)(e, t)
    }
    const MM = e => {
        let t, n;
        return e.subscribe(e => {
            t = e,
            n && (n.next(e),
            n.complete())
        }
        ),
        new S.a(e => {
            if ("undefined" === typeof t)
                return n = e,
                () => {
                    n = void 0
                }
                ;
            e.next(t),
            e.complete()
        }
        )
    }
    ;
    function AM(e) {
        e.setPackageName("@isomorix/core-session").setDefaultModuleNames("@isomorix/core/session").registerExtension("../ModelMixin").getRecordBuilder().registerExtension("module:logic.RecordPropsMixin").registerExtension("../RecordMixin"),
        function(e) {
            e.isServer;
            const t = e.storesMap
              , n = e.plugin.getMainInstance()
              , r = e.getRecordBuilder()
              , i = r.accessors;
            i.isServer = e.pluginStore.storeConfig.pluginAccessors.isServer,
            i.userModelsReady = {
                get: () => n.pluginRecord.userModelsReady,
                set: void 0,
                configurable: !1,
                enumerable: !1
            };
            const o = r.Class.prototype;
            Object(rx.a)(e, o),
            IM(e, o),
            o.registerUser = function(e, t) {
                const r = this.__dispatchId;
                let i;
                return this.loadUserModels().pipe(Object(P.a)( () => {
                    const t = r ? n.getBestInstance(r).switchTo(tv.b.USER) : n.switchTo(tv.b.USER);
                    let {password: o, ...s} = e;
                    const a = t.getIndex("c_email").get(s.email);
                    if (a && a.getPersistedState()[t.primaryKey]) {
                        const e = new Error("register");
                        return e.code = 409,
                        e.user = a,
                        Object(V.a)(e)
                    }
                    return i = t.mutation(),
                    i.execute(),
                    i.create(e => e.addDirective(fe.a.USER_CREATE, {
                        password: o
                    }).values(s).returnPayload())
                }
                ), Object(P.a)(o => {
                    if (o instanceof Error)
                        return Object(V.a)(o);
                    const {extensions: s} = o;
                    if (s && 200 !== s.statusCode || !o.records) {
                        const e = new Error("register");
                        return e.user = null,
                        e.code = s && s.statusCode || 500,
                        r ? Object(V.a)(e) : i.ofComplete(!0).pipe(Object(Or.a)(e))
                    }
                    let a = Object.values(o.records)[0];
                    if (!t)
                        return r ? Object(V.a)(a) : i.ofComplete(!0).pipe(Object(Or.a)(a.getMainInstance()));
                    i = n.mutation(i.dispatchId);
                    const c = i.switchTo(tv.b.SESSION).getMutableRecord(this);
                    return i.execute(),
                    c.login({
                        email: a.email,
                        password: e.password
                    }).pipe(Object(P.a)(e => e instanceof Error ? (e.user = r ? a : a.getMainInstance(),
                    r ? Object(V.a)(e) : i.ofComplete(!0).pipe(Object(Or.a)(e))) : r ? Object(V.a)(c) : i.ofComplete(!0).pipe(Object(Or.a)(this))))
                }
                ))
            }
            ,
            o.loadUserModels = function() {
                return this.plugin.loadUserModels(this.__dispatchId).pipe(Object(Or.a)(this))
            }
            ,
            o.addUserRoleChangeListener = function(e) {
                const n = Object(Eb.a)(t, this);
                return n.userRoleChangeListeners ? n.userRoleChangeListeners.indexOf(e) < 0 && n.userRoleChangeListeners.push(e) : n.userRoleChangeListeners = [e],
                this
            }
            ,
            o.removeUserRoleChangeListener = function(e) {
                const n = Object(Eb.a)(t, this, !0)
                  , r = n && n.userRoleChangeListeners && n.userRoleChangeListeners.indexOf(e);
                return r > -1 && n.userRoleChangeListeners.splice(r, 1),
                this
            }
            ,
            o.switchToRole = function(e, t, r) {
                const {userRole: i} = this;
                if (!i)
                    return Object(V.a)(!1);
                let o, s;
                switch (typeof t) {
                case "function":
                    o = t;
                    break;
                case "number":
                    r = t
                }
                if (r || (r = this.__dispatchId),
                "string" === typeof e) {
                    const {user: t} = i;
                    let a = t.roles[e];
                    if (!a || !(s = t.rolesData[a.__ID])) {
                        let i = t.rolesDataQuery().where("role", t => t.where("slug", e)).selectAll(!0);
                        a || this.plugin.roles[e] || i.include("role", e => vM(e).selectAll(!0));
                        const s = {
                            dispatchId: r
                        };
                        return MM(i.fetchOneRecord(s).pipe(Object(P.a)(e => {
                            if (e) {
                                if (r)
                                    return this.switchToRole(e, o, r);
                                {
                                    const t = n.mutation(s.dispatchId);
                                    return t.switchTo(this.__typename).getMutableRecord(this).switchToRole(e, o, r),
                                    t.execute(!0).pipe(Object(Y.a)(e => !e.isCancelling))
                                }
                            }
                            return Object(V.a)(!1)
                        }
                        )))
                    }
                } else
                    s = e;
                if (s.__ID === i.__ID)
                    return o && o("You are already using the ".concat(i.role.props.name, " role.")),
                    Object(V.a)(!0);
                const a = n.mutation(r);
                a.switchTo(this.__typename).update(this, {
                    userRoleId: s.__ID
                });
                const c = a.switchTo(i.__typename);
                c.update(i, {
                    isActive: !1
                }),
                c.update(s, {
                    isActive: !0
                });
                const u = s.role.props.name;
                return MM(a.execute(!r).pipe(Object(Y.a)(e => e.isCancelling ? (o && o({
                    messagePriority: "immediate",
                    children: "Oops! An unknown error occurred switching to the ".concat(u, " role. Please try again."),
                    action: "Ok",
                    disableAutohide: !0
                }),
                !1) : (o && o("You are now using the ".concat(u, " role.")),
                !0))))
            }
            ,
            o.findUserRoleAndPermissions = function(e, r, i) {
                const {userRole: o} = this
                  , s = t.get(this).value;
                let a, c = Object(he.P)(e) ? e : null;
                if (o) {
                    const {user: e, role: t} = o;
                    if (t) {
                        if (t.isMissingPermissions)
                            a = [t.permissionsQuery().selectAll(!0)];
                        else if (e)
                            return Object(V.a)(r ? r(i, this, c) : this)
                    } else
                        a = [vM(o.roleQuery())];
                    e || (a || (a = []),
                    a.push(o.userQuery().selectAll(!0).includeAll("meta", !0)))
                } else {
                    if (!s.get("userRoleId"))
                        return r ? Object(V.a)(r(i, this, c)) : Object(V.a)(this);
                    a = [SM.includeUserAndPermissions(this.userRoleQuery())]
                }
                let u = !1;
                c || (c = n.mutation(e || s.store.mainDispatchId),
                1 === c.executeCount && (u = !0));
                for (let t = 0; t < a.length; t++)
                    a[t] = a[t].fetch({
                        mutation: c
                    });
                if (a = a.length > 1 ? Object(wr.a)(a) : a[0],
                r)
                    return a.pipe(Object(Y.a)( () => r(i, this, c)));
                const l = s.store.mainDispatchId ? this : c.getMutableRecord(this);
                return u ? a.pipe(Object(P.a)( () => c.execute()), Object(Or.a)(l)) : a.pipe(Object(Y.a)( () => (e !== c && c.execute(),
                l)))
            }
            ,
            o.subscribeToUserRole = function() {
                const e = t.get(this).mainStore;
                return e.pipe(Object(H.a)(e => !e.isOptimistic && !!e.allChanges.userRoleId), Object(Sb.a)(e.value), $(r => {
                    if (!r.get("userRoleId"))
                        return Object(D.c)();
                    const i = e.instance.userRole;
                    return i ? Object(V.a)(i) : t.get(n.switchTo(tv.b.USER_ROLE)).pipe(Object(Y.a)(t => t.get(e.get("userRoleId"))), Object(Rb.a)(), Object(te.a)())
                }
                ))
            }
            ,
            o.savePosition = function(e, n, r) {
                const i = t.get(this);
                n || (n = i.mainDispatchId),
                console.log("UPDATING POSITION = ", e);
                const o = i.parentInstance.mutation(n)
                  , s = o.update(this, this.preparePositionUpdate(e, null, r));
                return o.execute(!n).pipe(Object(Or.a)(n ? s : i.mainStore.instance))
            }
            ,
            o.preparePositionUpdate = function(e, t, n) {
                t || (t = {});
                const {coords: r} = e;
                return "boolean" === typeof n && this.isWatchingPosition !== n && (t.isWatchingPosition = n),
                t.latitude = r.latitude,
                t.longitude = r.longitude,
                t.speed = r.speed,
                t.heading = r.heading,
                t.coordinateAccuracy = r.accuracy,
                t.lastCoordinateAt = Math.round(Date.now() / 1e3),
                t
            }
            ,
            o.prepareIpPositionUpdate = function(e, t, n) {
                t || (t = {});
                const r = this.getState();
                return e.error || "number" !== typeof e.latitude ? (t.city = null,
                t.country = null,
                t.countryState = null,
                t.postalCode = null,
                t.latitude = 0,
                t.longitude = 0) : (t.city = e.city,
                t.country = e.country_code,
                t.countryState = e.region_code,
                t.postalCode = e.postal,
                t.latitude = parseFloat(e.latitude),
                t.longitude = parseFloat(e.longitude)),
                t.coordinateAccuracy = In.e,
                t.lastCoordinateAt = Math.round(Date.now() / 1e3),
                n || (r.isWatchingPosition && (t.isWatchingPosition = !1),
                "number" === typeof r.heading && (t.heading = null),
                "number" === typeof r.speed && (t.speed = null),
                r.address && (t.address = null)),
                t
            }
            ,
            o.formatDate = wM
        }(e)
    }
    const EM = Xm.a.init().setPackageName("@isomorix/core-session").setModuleName("@isomorix/core/session/model/logic").setEnv("client");
    mv.findExistingBuilder(c.n).useRelative(mv.findByName("ensureMutationIsExecuting", c.n), -10).setLogicMgr(EM, "./mutation").setName("augmentDispatchRecord").setPure(!0).add((function(e) {
        const {mutation: t} = e.payload
          , n = e.meta.getSession();
        if (!n)
            return e;
        const {primaryKey: r, dispatchRecord: i, model: o} = t
          , s = n[r];
        return t.dispatchRecord = function(e, t) {
            const n = i.call(this, e, t);
            return n && t !== Gr.b && n[r] === s && o.setSession(n),
            n
        }
        ,
        e
    }
    ), !0);
    var CM = n(860);
    const NM = Xm.a.init().setPackageName("@isomorix/core-session").setModuleName("@isomorix/core/session/record/logic").addSource(lv.b)
      , RM = NM.getBuilder(c.n, "./mutation");
    class PM extends O.a {
        constructor(e) {
            super(),
            this.__action = e
        }
        processChange(e) {
            const t = this.__action
              , {meta: {store: n}, payload: {mutation: r}} = t;
            if (r.isCancelling)
                return this.__action = void 0,
                Object(V.a)(null);
            if (!e && n.get("userRoleId"))
                return n.instance.findUserRoleAndPermissions(r).pipe(Object(P.a)( () => this.processChange(!0)));
            this.__action = void 0;
            const i = n.storeConfig;
            let o, s, a = i && i.userRoleChangeListeners;
            if (!a || !a.length)
                return Object(V.a)(null);
            a = a.slice();
            for (let c of a)
                Object(CM.a)(o = c(t)) && (s ? s.push(o) : s = [o]);
            return s ? Object(wr.a)(s) : Object(V.a)(null)
        }
        _next(e) {
            if (e.isCancelling)
                return void (this.__action = void 0);
            const {meta: {store: {value: t}}, payload: n} = this.__action;
            n.isLogin || n.isLogout || t.changes && t.changes.userRoleId || t.pChanges && t.pChanges.userRoleId ? n.mutation.addToFollowupQueries(this.processChange()) : this.__action = void 0
        }
    }
    RM.useRelative("trxOptimisticExecute", 10).setName("manageUserRoleChange").setPure(!0),
    RM.setCancelOp(e => {
        var t;
        const n = null === (t = e.payload.mutation.getRecordQuery(e.meta.instance)) || void 0 === t ? void 0 : t.payload.extensions;
        return n && 403 === n.statusCode && "undefined" !== typeof window && window.location.reload(),
        e
    }
    ),
    RM.add((function(e) {
        return e.meta.store.get(ev.a.SESSION) && e.payload.mutation.ofConnectorComplete().subscribe(new PM(e)),
        e
    }
    ), !0);
    var DM = n(1011);
    const FM = e => {
        if (!e || !e.userId)
            throw new Error("An options Object is required to getBy() or subscribeTo() UserMeta, and at a minimum it must contain a `userId` value.");
        if ("string" === typeof e.keys) {
            const {keys: t, ...n} = e;
            return n.key = t,
            n
        }
        return e
    }
      , kM = (e, t) => {
        const n = e.query().selectAll().where("userId", t.userId);
        return "undefined" !== typeof t.pluginId && n.andWhere("pluginId", t.pluginId),
        "undefined" !== typeof t.userRoleId && n.andWhere("userRoleId", t.userRoleId),
        t.key ? n.andWhere("key", t.key) : t.keys && n.andWhereIn("key", t.keys),
        n
    }
      , jM = function(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "get";
        return (t.key ? e["".concat(n, "OneRecord")]({
            dispatchId: t.dispatchId
        }) : e["".concat(n, "AllRecords")]({
            dispatchId: t.dispatchId
        })) || null
    }
      , LM = (e, t, n) => (e = FM(e),
    jM(kM(t.getMainInstance(), e), e, n));
    const VM = (e, t, n) => e && e[t] ? e : e ? (e[t] = n,
    e) : {
        [t]: n
    }
      , UM = (e, t) => {
        if (!e.directiveVariables)
            return t;
        const n = e.directiveVariables
          , r = e.definedDirectives;
        let i, o, s;
        for (let a in n)
            for (s in o = r[a].args,
            i = n[a],
            i)
                t = VM(t, i[s], o[s].type);
        return t
    }
      , qM = (e, t) => {
        let n, r;
        for (let i of e)
            i.isParent ? ((n = i.compareValueParam) && (r = i.compareValueType),
            t = UM(i, t),
            t = qM(i, t)) : (n = i.valueParam) && (r = i.valueType),
            n && (t = VM(t, n, r));
        return t
    }
    ;
    function QM(e, t) {
        return e && e.queryHasVariables ? function(e, t) {
            return e && e.queryHasVariables && e.queryHaving && (t = qM(e.queryHaving, t)),
            t || null
        }(e, t = function(e, t) {
            return UM(e, t) || null
        }(e, t = function(e, t) {
            if (e && e.includeVFs && e.queryHasVariables) {
                const {includeVFs: n} = e;
                for (let e in n)
                    t = QM(n[e].query, t)
            }
            return t || null
        }(e, t = function(e, t) {
            if (!e || !e.queryHasVariables)
                return t || null;
            if (e.queryCalc)
                t = qM(e.queryCalc, t);
            else if (e.querySelect) {
                const {querySelect: n} = e;
                for (let e in n)
                    t = UM(n[e], t)
            }
            return t || null
        }(e, t = function(e, t) {
            if (!e || !e.queryHasVariables || !e.queryArgs)
                return t || null;
            const {queryArgs: n} = e;
            let r;
            for (let i of n)
                Object(he.M)(i) ? (r = i.valueParam) && (t = VM(t, r, i.fieldType)) : t = QM(i.query, t);
            return t || null
        }(e, t))))) : t || null
    }
    const BM = /^\s\(\d+\)$/
      , GM = /^Unnamed\s/
      , zM = (e, t) => e ? (e.indexOf(t) < 0 && e.push(t),
    e) : [t]
      , HM = (e, t) => {
        if (!e) {
            e = {};
            for (let n in t)
                e[n] = Object.keys(t[n]);
            return e
        }
        let n, r, i;
        for (let o in t)
            if (n = e[o])
                for (i in r = t[o],
                r)
                    n.indexOf(i) < 0 && n.push(i);
            else
                e[o] = Object.keys(t[o]);
        return e
    }
      , KM = (e, t) => Object(Y.a)(n => (e[t] = n && n[t] || null,
    e))
      , YM = e => {
        const {pagination: t} = e;
        if (t) {
            const {limit: n, offset: r} = t;
            t.limit = void 0,
            t.offset = void 0;
            const i = e.toGraphql(!0);
            return t.limit = n,
            t.offset = r,
            i
        }
        return e.toGraphql(!0)
    }
    ;
    function WM(e) {
        e.registerExtension("../ModelMixin");
        const t = e.plugin.getMainInstance()
          , n = e.Class.prototype
          , {storesMap: r} = e;
        let i, o;
        const s = e => o && o.get(e) || null
          , a = (e, t) => {
            if (t) {
                o || (o = new Map);
                for (let n of t)
                    o.set(n, e)
            }
        }
          , c = (e, t) => {
            if (t && o)
                for (let n of t)
                    o.get(n) === e && o.delete(n)
        }
        ;
        n.prepareRecordCreate = function(e, n) {
            const r = t.getSession();
            if (r) {
                if (e.entityId = r.entityId,
                e.pluginId = r.pluginId,
                !e.userId) {
                    const {userRole: t} = r;
                    t && (e.userId = t.userId)
                }
            } else
                e.pluginId || (e.pluginId = t.__ID);
            let i;
            if (!e.query) {
                if (!e.modelName || !e.graphql)
                    throw new Error("Invalid state to create ".concat(this.__typename, " record: props.modelAndFieldNames must exist. Provide a state.query instance to create it automatically, or state.modelName and state.graphql."));
                if (!(i = t.switchTo(e.modelName)))
                    throw new Error("The model ".concat(e.modelName, " is not a recognized model. Unable to create PersistentQuery record."));
                if (e.props && e.props.modelAndFieldNames)
                    return e.name || (e.name = this.getDefaultRecordName(i)),
                    e.name = this.getUniqueRecordName(e),
                    e;
                try {
                    const t = i.query().fromGraphql(e.graphql);
                    t.getOrInitQueryCalc(),
                    i.addRemoveQuery(t, !0),
                    e.query = t
                } catch (s) {
                    return null
                }
            }
            try {
                e.graphql = YM(e.query)
            } catch (s) {
                return null
            }
            if (e.query.queryHasVariables && !e.variableValuesMap) {
                const t = QM(e.query);
                if (t) {
                    const r = {};
                    for (const e in t)
                        r[e] = Pi(e, t[e]);
                    const i = n ? n.graphiqlVariables || n.variableValues : null;
                    i && function(e, t, n) {
                        for (const i in e)
                            if (n[i])
                                if (Jr.b[i] && "number" === typeof e[i])
                                    t[i] = e[i];
                                else
                                    try {
                                        t[i] = n[i].parseValue(e[i])
                                    } catch (r) {}
                    }(i, r, t),
                    e.variableValuesMap = {
                        [In.b]: r
                    }
                }
            }
            e.name || (e.name = this.getDefaultRecordName(e.query.model)),
            e.name = this.getUniqueRecordName(e),
            e.props || (e.props = {});
            const o = {};
            return e.props.modelAndFieldNames = Js(e.query, {}, o),
            e.props.VFInstanceIds = Object.keys(o).length ? o : void 0,
            e.modelName = e.query.modelName,
            e
        }
        ,
        n.prepareRecordUpdate = function(e, t, n) {
            if (!t.query)
                return t;
            let r;
            try {
                r = YM(t.query)
            } catch (u) {
                return null
            }
            let {graphql: i, props: o, modelName: s} = e.getState();
            if ((t.modelName || s !== t.query.modelName) && (t.modelName = t.query.modelName),
            i === r)
                return t;
            t.graphql = r;
            let a = {};
            const c = Js(t.query, {}, a);
            return Object.keys(a).length || (a = void 0),
            o && !t.props && o.modelAndFieldNames && !!a === !!o.VFInstanceIds && (!a || yt()(o.VFInstanceIds, a)) && yt()(o.modelAndFieldNames, c) || (n ? t.props || (t.props = {}) : t.props = t.props ? {
                ...o,
                ...t.props
            } : {
                ...o
            },
            t.props.modelAndFieldNames = c,
            t.props.VFInstanceIds = a),
            t
        }
        ,
        n.createDuplicateRecordQuery = function() {
            return this.getDuplicateRecordQuery().clone().noDestroy(!1)
        }
        ,
        n.getDuplicateRecordQuery = function() {
            return i || (i = this.getMainInstance().query().noDestroy(!0).where("userId", ":userId").andWhere("modelName", ":modelName").andWhere("entityId", ":entityId").andWhere("name", ":name").andWhereNot("id", ":notId"),
            this.addRemoveQuery(i, !0)),
            i
        }
        ,
        n.getUniqueRecordName = function(e, t) {
            const n = this.getDuplicateRecordQuery()
              , r = {
                userId: e.userId,
                entityId: e.entityId,
                modelName: e.modelName,
                notId: t || null
            }
              , i = this.__dispatchId;
            let {name: o} = e
              , s = 0;
            const a = o.match(/^.*(\(\d+\))$/);
            for (a && a[1] && (o = o.replace(/\s?\(\d+\)$/, ""),
            s = parseInt(a[1].replace("(", "").replace(")", ""))); r.name = 0 === s ? o : "".concat(o, " (").concat(s, ")"),
            n.getOneRecord({
                variables: r,
                dispatchId: i
            }); )
                s++;
            return r.name
        }
        ,
        n.getDefaultRecordName = function(e) {
            let n;
            if ("string" !== typeof e)
                n = e;
            else if (!(n = t.switchTo(e)))
                throw new Error("The model ".concat(e, " is not a recognized model."));
            return Object(ve.g)(n.schema.displayNameMany || "Unknown")
        }
        ,
        n.isRecordNameDefault = function(e, t) {
            if (GM.test(t))
                return !0;
            const n = this.getDefaultRecordName(e);
            return t === n || BM.test(t.replace(n, ""))
        }
        ,
        n.activateQueries = function(e) {
            let n = r.get(this);
            if (!n)
                return t.switchTo(tv.b.PERSISTENT_QUERY).activateQueries(e);
            const i = n.getState()
              , o = {};
            let u, l, d, h, f = void 0, p = void 0, g = void 0, m = void 0;
            for (let t = 0; t < e.length; t++)
                u = e[t],
                l = i[u],
                (d = s(u)) ? (l ? o[u] = l : d = d.pipe(KM(o, u)),
                p = zM(p, d)) : l ? (o[u] = l,
                !l.isActivated && (h = l.props) && h.modelAndFieldNames && (g = HM(g, h.modelAndFieldNames),
                m = zM(m, u))) : f = zM(f, u);
            if (!f && !p && !g)
                return Object(V.a)(o);
            if (d = p ? Object(wr.a)(p) : Object(V.a)(this),
            f)
                d = d.pipe(Object(P.a)( () => this.query().selectAll("autoload").whereIn(this.primaryKey, f).findAllRecords()), Object(iM.a)(!0), Object(Y.a)(e => {
                    for (u of f)
                        l = e && e[u],
                        o[u] = l || null,
                        l && !l.isActivated && (h = l.props) && h.modelAndFieldNames && (g = HM(g, h.modelAndFieldNames));
                    return o
                }
                ));
            else if (!g)
                return d.pipe(Object(Or.a)(o));
            {
                let e;
                d = d.pipe(Object(P.a)( () => g ? (e = t.mutation(),
                e.activateModels(Object.keys(g)).pipe(Object(P.a)( () => {
                    let t;
                    for (u in o)
                        o[u] && (t || (t = {}),
                        t[u] = o[u]);
                    return t && e.switchTo(this).update(t, {
                        localProps: "merge"
                    }, {
                        localProps: {
                            modelAndFieldNamesActivated: !0
                        }
                    }, !0),
                    e.execute(!0)
                }
                ))) : Object(D.c)()))
            }
            let y = !1;
            return d = d.pipe(Object(Y.a)( () => (y = !0,
            c(d, f),
            c(d, m),
            o)), Object(_g.a)()),
            a(d, f),
            a(d, m),
            d.subscribe(),
            Object(qs.a)( () => y ? Object(V.a)(o) : d)
        }
        ,
        n.addModelNameNameArgsToQuery = function(e, t) {
            const n = Yn.a.checkoutSet();
            for (const r of t)
                n.has(r) || (n.add(r),
                e.orWhereExists(["props", "modelAndFieldNames", r]));
            return Yn.a.checkinSet(n),
            e
        }
    }
    const $M = {
        set: void 0,
        enumerable: !1,
        configurable: !0,
        get: function() {
            const {localProps: e} = this;
            return !(!e || !e.modelAndFieldNamesActivated)
        }
    }
      , XM = {}
      , JM = (e, t, n) => {
        let r = e[t][n];
        for (; ; ) {
            if ("undefined" !== typeof r)
                return r;
            if (!e[t = e[t].__parentKey])
                return e[In.b][n];
            r = e[t][n]
        }
        return r
    }
      , ZM = e => {
        const t = {};
        for (let n in e)
            "__parentKey" !== n && (t[n] = e[n]);
        return t
    }
    ;
    let eA, tA, nA;
    eA = {},
    tA = n(47),
    nA = () => {}
    ;
    const rA = {
        [tv.b.API_LOG]: nx,
        [tv.b.CORE_LOGIC]: function(e) {
            e.setPackageName("@isomorix/core-logic").setDefaultModuleNames("@isomorix/core/coreLogic"),
            zw(e)
        },
        [tv.b.DATA_SOURCE]: function(e) {
            ix(e)
        },
        [tv.b.DOMAIN]: function(e) {
            e.setPackageName("@isomorix/core-domain").setDefaultModuleNames("@isomorix/core/domain").registerExtension("../ModelMixin").getRecordBuilder().registerExtension("../RecordMixin"),
            function(e) {
                const t = e.storesMap;
                e.Class.prototype.findOrCreate = function(e) {
                    const n = this.query().selectAll("autoload")
                      , r = t.get(this);
                    "boolean" !== typeof e.ssl && (e.ssl = "localhost" !== e.name),
                    e.subName || (e.subName = null),
                    e.tld || (e.tld = null),
                    e.publicPath || (e.publicPath = null);
                    let {mutation: i, includeWww: o} = e;
                    o ? n.where(t => Hw(t, e)).orWhere(t => Hw(t, e, !0)) : Hw(n, e);
                    let s, a, c = !1, u = !1;
                    return i || (i = r.value.mutation) || (c = !0,
                    i = r.parentInstance.mutation({
                        dispatchId: e.dispatchId
                    }),
                    u = !e.dispatchId && !r.mainDispatchId),
                    n.findAllRecords({
                        mutation: i
                    }).pipe(Object(P.a)(t => {
                        if (t) {
                            let e;
                            for (let n in t)
                                e = t[n],
                                o && "www" === e.subName ? a = e : s = e
                        }
                        return s = Kw(i, e, s),
                        o && (a = Kw(i, e, a, !0)),
                        c ? a ? i.execute(u).pipe(Object(Or.a)(u ? {
                            domain: s.getMainInstance(),
                            www: a.getMainInstance()
                        } : {
                            domain: s,
                            www: a
                        })) : i.execute(u).pipe(Object(Or.a)(u ? s.getMainInstance() : s)) : Object(V.a)(a ? {
                            www: a,
                            domain: s
                        } : s)
                    }
                    ))
                }
            }(e),
            function(e) {
                const t = e.storesMap
                  , n = e.getRecordBuilder()
                  , r = n.accessors
                  , i = n.Class.prototype;
                r.fqdn = {
                    get() {
                        const e = this.getState();
                        let t = e.subName ? "".concat(e.subName, ".") : "";
                        return t += e.name,
                        e.tld && (t += ".".concat(e.tld)),
                        t
                    },
                    set: void 0,
                    enumerable: !1,
                    configurable: !1
                },
                r.nameAndTld = {
                    get() {
                        const e = this.getState();
                        let t = e.name;
                        return e.tld && (t += ".".concat(e.tld)),
                        t
                    },
                    set: void 0,
                    enumerable: !1,
                    configurable: !1
                };
                const o = (e, n, r, i) => {
                    const o = t.get(r)
                      , s = o.getState()
                      , a = o.parentInstance.query().selectAll(!0).where("name", s.name);
                    s.tld ? a.andWhere("tld", s.tld) : a.andWhereNull("tld");
                    let c = "AllRecords";
                    Array.isArray(e) ? a.andWhereIn("subName", e) : "string" === typeof e ? (a.andWhere("subName", e),
                    c = "OneRecord") : a.andWhereNotNull("subName");
                    const u = {};
                    return Object(he.P)(n) ? u.mutation = n : u.dispatchId = n || o.mainDispatchId,
                    a["".concat(i).concat(c)](u)
                }
                  , s = e => {
                    const n = t.get(e)
                      , r = n.getState()
                      , i = n.parentInstance.query().where("name", r.name);
                    return r.tld ? i.andWhere("tld", r.tld) : i.andWhereNull("tld"),
                    i
                }
                ;
                i.createSubdomainsQuery = function(e) {
                    const t = s(this);
                    return Array.isArray(e) ? t.andWhereIn("subName", e) : "string" === typeof e ? t.andWhere("subName", e) : t.andWhereNotNull("subName"),
                    t
                }
                ,
                i.createPrimaryDomainQuery = function(e) {
                    return e ? s(this) : s(this).andWhereNull("subName")
                }
                ,
                i.createValidSslCertsQuery = function(e) {
                    const t = new Date
                      , n = this.sslCertsQuery().where("status", aO.a.VALID).andWhere("notBefore", "<", t).andWhere("notAfter", ">", t);
                    return e && n.orderBy("notAfter", "desc").limit(1),
                    n
                }
                ,
                i.getSubdomains = function(e, t) {
                    return o(e, t, this, "get")
                }
                ,
                i.findSubdomains = function(e, t) {
                    return o(e, t, this, "find")
                }
                ,
                i.fetchSubdomains = function(e, t) {
                    return o(e, t, this, "fetch")
                }
            }(e)
        },
        [tv.b.ENTITY]: function(e) {
            !function(e) {
                e.setPackageName("@isomorix/core").setDefaultModuleNames("@isomorix/core/entity")
            }(e),
            cM(e),
            Object(uM.a)(e)
        },
        [tv.b.ENTITY_JOB]: function(e) {
            pM(e),
            e.Class.prototype.getJobsInProcessQuery = gM
        },
        [tv.b.LOCATION]: Yw.a,
        [tv.b.PERMISSION]: e => (e.storeConfig.mutationIndexName = void 0,
        iA(e)),
        [tv.b.PERSISTENT_QUERY]: function(e) {
            e.setPackageName("@isomorix/core").setDefaultModuleNames("@isomorix/core/persistentQuery"),
            WM(e),
            function(e) {
                const t = e.plugin.getMainInstance()
                  , {storesMap: n} = e
                  , r = e.getRecordBuilder().registerExtension("module:logic.RecordPropsMixin").registerExtension("../RecordMixin")
                  , i = r.Class.prototype;
                Object(rx.a)(e, i);
                const o = r.accessors;
                let s;
                o.isActivated = $M,
                o.model = {
                    get() {
                        return t.switchTo(this.modelName)
                    },
                    enumerable: !1,
                    configurable: !1
                },
                o.isNameDefault = {
                    get() {
                        const e = n.get(this).getState();
                        return a().isRecordNameDefault(e.modelName, e.name)
                    },
                    set: void 0,
                    enumerable: !1,
                    configurable: !1
                };
                const a = () => s || (s = t.switchTo(tv.b.PERSISTENT_QUERY));
                i.activateModelsAndFields = function() {
                    if (this.isActivated)
                        return Object(V.a)(this);
                    const e = n.get(this)
                      , t = e.get(ev.a.PERSISTENT_QUERY);
                    return e.parentInstance.activateQueries([t]).pipe(Object(Y.a)(e => e[t]))
                }
                ,
                i.prepareUpdate = function(e, t) {
                    return a().prepareRecordUpdate(this, e, t)
                }
                ,
                i.getVariableValue = function(e, t) {
                    return this.getVariableValues(e, t)
                }
                ,
                i.getVariableValues = function(e, t, n) {
                    if (!n && !(n = this.variableValuesMap))
                        return null;
                    let r = n[In.b];
                    if (!e) {
                        r = ZM(r);
                        const e = {
                            [In.b]: r
                        };
                        let t, i;
                        for (let o in n)
                            if (o !== In.b) {
                                for (i in t = {},
                                r)
                                    t[i] = JM(n, o, i);
                                e[o] = t
                            }
                        return e
                    }
                    if (n[e]) {
                        if (e === In.b)
                            return t ? r[t] : ZM(r);
                        if (t)
                            return JM(n, e, t);
                        {
                            const t = {};
                            for (let i in r)
                                "__parentKey" !== i && (t[i] = JM(n, e, i));
                            return t
                        }
                    }
                }
                ,
                i.clone = function(e, t) {
                    const r = n.get(this)
                      , i = t ? r.parentInstance.getBestInstance(t) : r.parentInstance
                      , o = r.getState();
                    e || (e = XM);
                    const s = o.props ? pt()(o.props) : {};
                    return {
                        ...o,
                        [ev.a.PERSISTENT_QUERY]: i.IDType.toGlobalId(),
                        localProps: void 0,
                        createdAt: Math.round(Date.now() / 1e3),
                        [Ro.d]: null,
                        ...e,
                        props: e.props ? _t()(s, e.props) : s,
                        variableValuesMap: e.variableValuesMap ? e.variableValuesMap : pt()(o.variableValuesMap)
                    }
                }
                ,
                i.toQuery = function() {
                    const e = n.get(this);
                    try {
                        return t.switchTo(e.get("modelName")).query().fromGraphql(e.get("graphql"))
                    } catch (r) {
                        return null
                    }
                }
            }(e)
        },
        [tv.b.PLUGIN]: function(e) {
            e.mainTrxPriority !== Lm.g && (Xw[0][l.m] = e.mainTrxPriority + 10,
            Jw[0][l.m] = e.pendingTrxPriority + 10),
            e.setPackageName("@isomorix/core-plugin").setDefaultModuleNames("@isomorix/core/plugin").addMainExtraTrxLogic(Xw).addPendingExtraTrxLogic(Jw),
            function(e) {
                const t = e.pluginStore.storeConfig
                  , n = t.storesMap
                  , r = e.plugin.getMainInstance()
                  , i = e.recordAccessors;
                i.isServer = t.pluginAccessors.isServer,
                i.userModelsReady = {
                    get() {
                        let e = n.get(this).storeConfig;
                        if (!e || "boolean" !== typeof e.loadUserModelsComplete) {
                            e || (e = {},
                            n.get(this).storeConfig = e);
                            const t = Object(tv.c)();
                            e.loadUserModelsComplete = !0;
                            for (let n of t)
                                r.switchTo(n) || (e.loadUserModelsComplete = !1)
                        }
                        return e.loadUserModelsComplete
                    },
                    set: void 0,
                    configurable: !1,
                    enumerable: !1
                },
                i.models = {
                    get() {
                        return this.schema.models
                    },
                    set: void 0,
                    configurable: !1,
                    enumerable: !1
                },
                i.directives = {
                    get() {
                        return this.schema.directives
                    },
                    set: void 0,
                    configurable: !1,
                    enumerable: !1
                },
                i.modelDescriptions = {
                    get() {
                        return this.schema.modelDescriptions
                    },
                    set: void 0,
                    configurable: !1,
                    enumerable: !1
                },
                i.directiveDescriptions = {
                    get() {
                        return this.schema.directiveDescriptions
                    },
                    set: void 0,
                    configurable: !1,
                    enumerable: !1
                };
                const o = e.getRecordBuilder().registerExtension("../RecordMixin").Class.prototype;
                o.loadUserModels = function(e) {
                    let t = n.get(this);
                    const i = tM(t, "loadUserModels$");
                    if (i)
                        return i;
                    const o = t.storeConfig;
                    if (o.loadUserModelsComplete)
                        return Object(V.a)(this);
                    let s, {mainDispatchId: a} = t;
                    e ? (s = !0,
                    !0 === e && (e = a)) : e = a;
                    const c = r.getBestInstance(e);
                    o.loadUserModels$ = new U.a,
                    o.loadUserModels$.mainDispatchId = a;
                    const u = c.mutation();
                    let l = u.activateModels(Object(tv.c)()).pipe(Object(P.a)( () => u.execute()));
                    return a || (s ? (o.loadUserModels$.mainDispatchId = u.mainDispatchId,
                    t = n.get(u.switchTo(t.parentInstance).getMutableRecord(this))) : l = l.pipe(Object(j_.a)(n.get(u).getAction(u.dispatchId).meta.mainActionMeta.asObservable()))),
                    l.pipe(Object(Y.a)( () => {
                        o.loadUserModelsComplete = !0,
                        nM(t, "loadUserModels$")
                    }
                    )).subscribe(),
                    rM(t, "loadUserModels$")
                }
                ,
                o.loadRoles = function(e) {
                    let t = n.get(this);
                    const r = tM(t, "loadRoles$");
                    if (r)
                        return r;
                    const i = t.storeConfig;
                    let o, s;
                    if (!e) {
                        const {roles: e} = this
                          , t = this.isMissingRoles;
                        if (e) {
                            let n;
                            for (let r in e)
                                n = t ? !e[r].isMissingPermissions : e[r].isMissingPermissions,
                                n && (o || (o = [])) && o.push(e[r].__ID);
                            if (t)
                                s = !0;
                            else if (!o)
                                return Object(V.a)(this)
                        } else if (!1 === t)
                            return Object(V.a)(this)
                    }
                    let {mainDispatchId: a} = t;
                    return i.loadRoles$ = new U.a,
                    i.loadRoles$.mainDispatchId = a,
                    this.loadUserModels(!0).subscribe(e => {
                        const n = e.rolesQuery().selectAll("autoload").include("permissionsData", e => e.selectAll("autoload").includeAll("permission", !0));
                        o && (s ? n.andWhereNotIn(n.primaryKey, o) : n.andWhereIn(n.primaryKey, o));
                        const r = {
                            dispatchId: e.__dispatchId
                        }
                          , a = () => {
                            nM(t, "loadRoles$"),
                            i.loadRoles$ ? i.loadRoles$.subscribe(e => {
                                e.isMissingRoles = !1
                            }
                            ) : this.isMissingRoles = !1
                        }
                        ;
                        (t.mainDispatchId ? n.fetch(r).pipe(Object(Y.a)(a)) : n.fetch(r).pipe(Object(j_.a)(r.action.meta.mainActionMeta.asObservable()), Object(Y.a)(a))).subscribe()
                    }
                    ),
                    rM(t, "loadRoles$")
                }
            }(e)
        },
        [tv.b.SESSION]: function(e) {
            AM(e),
            e.addPendingLogic(EM).getRecordBuilder().addPendingLogic(NM),
            Object(DM.a)(e)
        },
        [tv.b.SSL_CERT]: function(e) {
            e.setPackageName("@isomorix/core-ssl-cert").setDefaultModuleNames("@isomorix/core/sslCert").registerExtension("../ModelMixin").getRecordBuilder().registerExtension("../RecordMixin")
        },
        [tv.b.USER]: function(e) {
            e.setPackageName("@isomorix/core-user").setDefaultModuleNames("@isomorix/core/user"),
            function(e) {
                e.registerExtension("../ModelMixin");
                const t = e.storesMap
                  , n = e.Class.prototype;
                n.fetchMissingFromRecords = function(e, n, r) {
                    n || (n = "userId");
                    const i = this.getState();
                    let o, s;
                    const a = e => {
                        s = e[n],
                        (s = e[n]) && !i[s] && (o ? o.indexOf(s) < 0 && o.push(s) : o = [s])
                    }
                    ;
                    if (Array.isArray(e))
                        e.forEach(a);
                    else
                        for (let t in e)
                            a(e[t]);
                    if (!o)
                        return Object(V.a)(null);
                    const c = t.get(this);
                    let u;
                    (r || (r = c.mainDispatchId)) && (u = c.parentInstance.mutation(r, !0)) && u.execute();
                    const l = this.query().selectAll("autoload").whereIn(this.primaryKey, o).fetchAllRecords({
                        dispatchId: r,
                        mutation: u
                    });
                    return r ? l : l.pipe(Object(iM.a)(!0))
                }
                ,
                n.checkIfUserIsUnique = function(e, t, n) {
                    const r = this.query().count("*", "total").where("email", t);
                    return n && r.andWhereNot(this.primaryKey, n),
                    r.fetchDirect().pipe(Object(Y.a)(e => {
                        let {resp: t} = e;
                        return t && t[0] && 0 === t[0].total
                    }
                    ))
                }
            }(e),
            function(e) {
                const t = e.storesMap
                  , n = e.storeConfig
                  , r = e.plugin.getMainInstance()
                  , i = e.getRecordBuilder().registerExtension("../RecordMixin")
                  , o = (e, t, n) => (e || (e = {}),
                e.userId = t.__ID,
                r.switchTo(tv.b.USER_META)["".concat(n, "By")](e))
                  , s = i.Class.prototype;
                s.loadRoles = function(e) {
                    if (!e && !this.isMissingRolesData && !this.isMissingRoles)
                        return Object(V.a)(this);
                    const i = t.get(this);
                    let o = i.storeConfig;
                    if (o) {
                        if (o.loadRoles$) {
                            const {mainDispatchId: e} = o.loadRoles$;
                            return e && !i.mainDispatchId ? o.loadRoles$.pipe(Object(j_.a)(i.getAction(e, !0).meta.asObservable()), Object(Or.a)(this)) : o.loadRoles$
                        }
                    } else
                        o = {},
                        i.storeConfig = o;
                    const {rolesData: s} = this
                      , a = i.parentInstance.switchTo(tv.b.USER_ROLE).query();
                    if (a.selectAll("autoloadOnClient").where("userId", i.value.get(n.primaryKey)),
                    !e && s) {
                        const e = Object.values(s);
                        for (let t = 0; t < e.length; t++)
                            e[t] = e[t].__ID;
                        a.andWhereNotIn(a.primaryKey, e)
                    }
                    const c = i.mainDispatchId ? r.pluginRecord.getBestInstance(i.mainDispatchId) : r.pluginRecord
                      , {roles: u} = c;
                    let l;
                    if (!e && u) {
                        l = Object.values(u);
                        for (let e = 0; e < l.length; e++)
                            l[e] = l[e].__ID;
                        a.include("role", e => vM(e.selectAll("autoload").whereNotIn(e.primaryKey, l)))
                    } else
                        SM.includePermissions(a);
                    o.loadRoles$ = new U.a,
                    o.loadRoles$.mainDispatchId = i.mainDispatchId;
                    const d = {
                        dispatchId: i.mainDispatchId
                    }
                      , h = () => {
                        this.isMissingRolesData = !1,
                        this.isMissingRoles = !1;
                        const {loadRoles$: e} = o;
                        return o.loadRoles$ = void 0,
                        e.next(this),
                        e.complete(),
                        this
                    }
                    ;
                    return (i.mainDispatchId ? a.fetch(d).pipe(Object(Y.a)(h)) : a.fetch(d).pipe(Object(j_.a)(d.action.meta.mainActionMeta.asObservable()), Object(Y.a)(h))).subscribe(),
                    new S.a(e => o.loadRoles$ ? o.loadRoles$.subscribe(e) : Object(V.a)(this).subscribe(e))
                }
                ,
                s.getFullName = function(e, t) {
                    const {firstName: n, lastName: r} = this.getState();
                    return n && r ? e ? "".concat(Object(iu.b)(n), " ").concat(Object(iu.b)(r)) : "".concat(n, " ").concat(r) : n ? e ? Object(iu.b)(n) : n : r ? e ? Object(iu.b)(r) : r : "undefined" === typeof t ? null : t
                }
                ,
                s.getInitials = function(e, t) {
                    const {firstName: n, lastName: r} = this.getState();
                    if (!n && !r)
                        return "undefined" === typeof t ? null : t;
                    let i;
                    return n ? (i = n.substring(0, 1),
                    e && (i = i.toUpperCase())) : i = "",
                    r && (i += e ? r.substring(0, 1).toUpperCase() : r.substring(0, 1)),
                    i
                }
                ,
                s.getMetaBy = function(e) {
                    return o(e, this, "get")
                }
                ,
                s.findMetaBy = function(e) {
                    return o(e, this, "find")
                }
                ,
                s.fetchMetaBy = function(e) {
                    return o(e, this, "fetch")
                }
                ,
                s.subscribeToMeta = function(e) {
                    return e || (e = {}),
                    e.userId = this.__ID,
                    r.switchTo(tv.b.USER_META).subscribeTo(e)
                }
            }(e)
        },
        [tv.b.USER_META]: function(e) {
            e.setPackageName("@isomorix/core").setDefaultModuleNames("@isomorix/core/userMeta"),
            function(e) {
                e.registerExtension("../ModelMixin");
                const t = e.Class.prototype;
                t.getBy = function(e) {
                    return LM(e, this, "get")
                }
                ,
                t.findBy = function(e) {
                    return LM(e, this, "find")
                }
                ,
                t.fetchBy = function(e) {
                    return LM(e, this, "fetch")
                }
                ,
                t.subscribeTo = function(e) {
                    e = FM(e);
                    const t = this.getMainInstance();
                    return new S.a(n => {
                        const r = kM(t, e).noDestroy()
                          , {key: i} = e;
                        let o, s = !0;
                        return o = (i ? r.findOneRecord({
                            dispatchId: e.dispatchId
                        }) : r.findAllRecords({
                            dispatchId: e.dispatchId
                        })).pipe(Object(iM.a)(!0), Object(P.a)( () => (s = !1,
                        null === o ? (r.destroy(),
                        Xt.a) : r.localSubscribe()))).subscribe(e => {
                            e.size ? i ? n.next(Object.values(e.getState())[0]) : n.next(e.getState()) : n.next(null)
                        }
                        ),
                        s && e.emitInitial && n.next(jM(r, e)),
                        () => {
                            o.unsubscribe(),
                            o = null,
                            s || r.destroy()
                        }
                    }
                    )
                }
            }(e)
        }
    }
      , iA = e => (e.setDefaultModuleNames("@isomorix/core/".concat(Object(ou.a)(e.modelName))),
    e);
    for (let jR in tv.b)
        rA[tv.b[jR]] || (rA[tv.b[jR]] = iA);
    const oA = tx.getBuilder(c.o, "./init");
    {
        const e = (e, t) => {
            const {payload: n} = e;
            tA && (t = tA(t));
            const r = n.pluginBuilder;
            n.__PRELOAD_STATE__ = t;
            const i = r.pluginRecord.slug;
            return function(e, t) {
                const {payload: n} = e
                  , r = n.pluginBuilder;
                n.modelsExistInDb = !0,
                n.fromCache = !0;
                const i = r.pluginRecord;
                for (let o in t)
                    i[o] = t[o];
                "string" === typeof i.schemaData && (i.schemaData = JSON.parse(i.schemaData))
            }(e, t[i]),
            n.initHistoryDisabled = !0 === n.initHistoryDisabled,
            n.session = t.__SESSION__,
            nA(i, n.session),
            e
        }
          , t = (t, n) => {
            e(t, n);
            const {payload: r} = t
              , {session: i} = r;
            if (!i)
                return Object(T.b)();
            if (!i.isApiKey)
                try {
                    let e = !1;
                    const n = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    if (i.timeZoneLocal !== n ? (i.timeZoneLocal !== i.timeZone && i.timeZone || (i.timeZone = n),
                    i.timeZoneLocal = n,
                    e = !0) : i.timeZone || (i.timeZone = i.timeZoneLocal,
                    e = !0),
                    e) {
                        const e = "update".concat(tv.a).concat(tv.b.SESSION);
                        r.sessionGqlUpdate$ = t.meta.store.storeConfig.connections[u.a.GRAPHQL](t).mutation({
                            query: "mutation ".concat(e, " {\n                ").concat(e, "(\n                  query: [{where: {").concat(ev.a.SESSION, ': "').concat(i[ev.a.SESSION], '"}}]\n                  payload: {timeZone: "').concat(i.timeZone, '", timeZoneLocal: "').concat(i.timeZoneLocal, '"}\n                ) {\n                  id\n                }\n              }')
                        }).pipe(Object(N.a)(e => (console.warn("ERROR updating session timezone: ".concat(e.message)),
                        Object(D.c)())), Object(_g.a)()),
                        r.sessionGqlUpdate$.subscribe( () => {
                            r.sessionGqlUpdate$ = void 0
                        }
                        )
                    }
                } catch (a) {}
            const {entity: o} = i;
            if (!o || !o.props)
                return Object(T.b)();
            const s = Object(lM.b)(t, o, r.types);
            return s ? s.pipe(Object(T.a)()) : Object(T.b)()
        }
        ;
        oA.useProps("preparePluginState").setDescription(eA.preparePluginState).setPure(!1).add((function(e) {
            return Object(T.b)().pipe(Object(P.a)( () => t(e, e.payload.__PRELOAD_STATE__)), Object(Or.a)(e))
        }
        ), !0)
    }
    oA.useProps("prepareSharedCore").setPure(!0).add((function(e) {
        return e.payload.pluginBuilder.setSharedCore(),
        e
    }
    ), !0),
    oA.useProps("defineScalarAndEnumTypes", 1).setName("defineScalarAndEnumTypes").setDescription(eA.defineScalarAndEnumTypes).setPure(!1).add((function e(t, n) {
        if (!n)
            return new S.a(n => {
                e(t, n)
            }
            );
        const {types: r} = t.payload
          , o = t.meta.store;
        i.b.schedule( () => {
            !function(e) {
                e.get(MT) || e.JSON.define({
                    name: MT,
                    description: void 0,
                    max: 1e4,
                    isSerializable: !1,
                    JSDOC_TYPE: "Object"
                })
            }(r),
            wT(r, o.storeConfig)
        }
        , 0),
        MO(r, ZI(o), i.b),
        i.b.schedule( () => {
            !function(e, t) {
                const n = e.storeConfig.types.get(qo.a.PERMISSION_USER_CAN).getLazyValues();
                for (let r in t)
                    switch (r) {
                    case "ANY":
                    case "ANY_USER":
                    case "NEVER":
                        break;
                    default:
                        n[t[r]] = ex
                    }
            }(o, Uo.a),
            n.complete()
        }
        , 0)
    }
    ), !0),
    oA.useProps("prepareMutationBases").setPure(!0).add((function(e) {
        return e.payload.pluginBuilder.setPluginMutationBase().setModelMutationBase(),
        e
    }
    ), !0);
    const sA = /History$/
      , aA = e => {
        let t, n;
        for (let r in e)
            t = e[r],
            (n = rA[r]) ? n(t) : sA.test(r) && rA[r.replace(sA, "")] && iA(t)
    }
    ;
    function cA(e, t) {
        return this.controller.executeWhen(e, t),
        this
    }
    function uA(e) {
        return this.controller.disableExecuteWhen(e),
        this
    }
    function lA(e, t) {
        return this.controller.hasExecuteWhen(e, t)
    }
    function dA(e) {
        const t = e.modelMutationBase.instanceMethods;
        t.executeWhen = cA,
        t.disableExecuteWhen = uA,
        t.hasExecuteWhen = lA
    }
    oA.useRelative("initModelBuilders", 10).setName("prepareCoreModels").setDescription(eA.initModelBuilders).setActionType(c.c, !0).setPure(!1).add((function(e, t) {
        const {payload: n} = e
          , {models: r} = n;
        if (!t)
            return aA(r),
            e;
        i.b.schedule( () => aA(r), 0),
        i.b.schedule( () => {
            t.complete()
        }
        , 0)
    }
    ), !0),
    oA.useProps("saveModels").setPure(!1).add((function(e, t) {
        const {meta: n, payload: r} = e
          , i = n.store.storeConfig
          , o = n.instance;
        let s = r.mutation;
        r.mutation = null;
        let a, c, u = o.getSession(), l = Object(T.b)().pipe(Object(P.a)( () => (s && !s.isComplete || (s = n.instance.mutation()),
        s.commitOnly(r.fromCache),
        ({coreLogic: c, ...a} = i.pluginRecord),
        s.switchTo(tv.b.PLUGIN).dispatchModel(),
        Object(T.b)())), Object(P.a)( () => (i.pluginRecord = s.switchTo(tv.b.PLUGIN).createOne(a),
        Object(T.b)())), Object(P.a)( () => {
            const e = i.pluginRecord.getMainInstance();
            if (s.ofComplete(!0).subscribe( () => {
                i.pluginRecord = e
            }
            ),
            c) {
                const e = s.switchTo(tv.b.CORE_LOGIC);
                return e.dispatchModel(),
                Object(T.b)().pipe(Object(P.a)( () => (e.create(c),
                Object(T.b)())))
            }
            return Object(T.b)()
        }
        ));
        if (u && !Object(he.U)(u)) {
            let e;
            if (l = l.pipe(Object(P.a)( () => (e = s.switchTo(r.models[tv.b.SESSION]),
            e.dispatchModel(),
            u.location && s.switchTo(tv.b.LOCATION).dispatchModel(),
            u.entity && s.switchTo(tv.b.ENTITY).dispatchModel(),
            Object(T.b)())), Object(P.a)( () => {
                u = s.switchTo(r.models[tv.b.SESSION]).createOne(u),
                o.setSession(u);
                const {userRole: e} = u;
                return e && (e.role.isMissingPermissionsData = !1,
                e.role.isMissingPermissions = !1),
                Object(T.b)()
            }
            ), Object(P.a)( () => s.executeNow()), Object(T.a)()),
            vT.a && window.isReload && u.location) {
                const e = u.location
                  , t = window.location;
                let n;
                e.pathname = t.pathname,
                e.search = t.search,
                e.hash = t.hash,
                l = l.pipe(r.sessionGqlUpdate$ ? Object(P.a)( () => r.sessionGqlUpdate$ || Object(D.c)()) : Qs.a, Object(P.a)( () => (n = o.mutation(),
                o.switchTo(tv.b.SESSION).query().selectAll(!0).where(ev.a.SESSION, u[ev.a.SESSION]).includeFields("location", !0).fetchOneRecord({
                    mutation: n
                }))), Object(P.a)( () => n.execute()), Object(T.a)())
            }
        } else
            l = l.pipe(Object(P.a)( () => s.executeNow()), Object(T.a)());
        return Object(Ov.a)(l, e, t)
    }
    ), !0);
    var hA = n(284)
      , fA = n(176);
    function pA() {
        return this._mutation = void 0,
        !0
    }
    const gA = Object(hA.a)({
        [f.b](e, t) {
            const n = this._mutation;
            return this._mutation = void 0,
            this[l.n] ? (n.execute(),
            e) : Object(Ov.a)(n.execute(), e, t)
        },
        [l.h]: "__autoExecuteMutation____*",
        [l.j]: "__autoExecuteMutation__",
        [l.n]: !1,
        [l.a]: "*",
        [l.o]: pA,
        [l.p]: pA
    });
    function mA(e) {
        const {pluginStoreConfigs: t, pastTimestamps: n, futureTimestamps: r, emitTimeTravelEvent: i, timeTravelLocationData: o, storesMap: s} = e
          , a = e.pluginMutationBase.instanceMethods
          , u = e.getStore;
        a._registerAsUndoable = function() {
            const s = this.__pluginSlug
              , a = t[s]
              , c = a.storesMap.get(a.plugin).storeMgr.getChild(this.mainDispatchId).network;
            if (!c.isUndoable && (c.isUndoable = !0,
            !c.isUndo && !c.isRedo)) {
                const t = e.currentTimestamp;
                if (t && (r[0] === t ? i("remove", t) : n.push(t)),
                e.currentTimestamp = this.ts,
                r.length) {
                    for (let e of r)
                        i("remove", e);
                    r.length = 0
                }
            }
            if (console.log({
                currentTimestamp: e.currentTimestamp,
                futureTimestamps: r,
                pastTimestamps: n,
                locationData: e.timeTravelLocationData,
                currentMutations: e.currentMutations,
                pastMutations: e.pastMutations,
                futureMutations: e.futureMutations
            }),
            this.isUndoRedo)
                return this;
            if (o) {
                const e = this.getSession()
                  , t = e ? e.location : void 0;
                t && o.set(this.ts, t.historyItem)
            }
            if (1 === e.pluginsCount)
                a.plugin._doRegisterUndoableMutation(this.ts, this);
            else {
                const {ts: e} = this;
                let n;
                for (let r in t)
                    (n = t[r].plugin) && n._doRegisterUndoableMutation(e, r === s ? this : void 0)
            }
            return i("register", this.ts),
            this
        }
        ,
        a.executeWhen = function(e, t) {
            if (this.isExecuting)
                return this;
            if (!1 === this._executeWhenLogic)
                return this.execute(),
                this;
            let n, r;
            t ? ((n = t[l.k]) || (t[l.k] = n = f.b),
            "number" !== typeof (r = t[l.m]) && (t[l.m] = r = 2e3),
            "boolean" !== typeof t[l.n] && (t[l.n] = !!this._executeWhenLogic)) : (n = f.b,
            r = 2e3);
            let i = e.meta;
            if (!i.willExecuteOp(n, r))
                return this.execute(),
                this;
            i.store || (i = u(i.instance).getAction(i.dispatchId).meta);
            let o = this._executeWhenLogic && i.getLogic("__autoExecuteMutation____*");
            if (o && o._mutation === this)
                return this.execute(),
                this;
            if (o = i.cloneLogicProps(gA, {
                _mutation: this,
                [n]: gA[f.b]
            }),
            o[l.m] = r,
            t) {
                for (let e in t)
                    o[e] = t[e];
                this._executeWhenLogic || (this._executeWhenLogic = o)
            } else
                this._executeWhenLogic ? o[l.n] = !0 : this._executeWhenLogic = o;
            return i.addOrReplaceLogic(o),
            this
        }
        ,
        a.disableExecuteWhen = function(e) {
            if (this.isExecuting || this._executeWhenLogic)
                return this;
            if ("number" === typeof this._disableExecuteWhenCount)
                !1 !== e ? this._disableExecuteWhenCount++ : this._disableExecuteWhenCount > 0 && this._disableExecuteWhenCount--;
            else {
                if (!1 === e)
                    return this;
                this._disableExecuteWhenCount = 1
            }
            return this._disableExecuteWhenCount > 0 ? this._executeWhenLogic = !1 : !1 === this._executeWhenLogic && (this._executeWhenLogic = void 0),
            this
        }
        ,
        a.hasExecuteWhen = function(e, t) {
            if (!this._executeWhenLogic)
                return !1;
            if (!e)
                return !0;
            let n = e.meta;
            n.store || (n = u(n.instance).getAction(n.dispatchId).meta);
            const r = n.getLogic("__autoExecuteMutation____*");
            return !!r && (!0 === t ? !r[l.n] : !1 !== t || r[l.n])
        }
        ,
        a.activateModels = function(e, t) {
            const n = s.get(this)
              , r = n.getState()
              , i = {};
            t || (t = n.storeConfig.pluginRecord.schema);
            let o, a, u = null, l = !0;
            for (let s of e)
                if (o = r[s])
                    i[s] = o;
                else {
                    if (i[s] = null,
                    a = t.models[s])
                        Object(fA.d)(a) || (l = !1);
                    else {
                        if (!Object(fA.d)(s) || !(a = t.models[Object(fA.c)(s)]) || !a.trackHistory) {
                            i[s] = null;
                            continue
                        }
                        a = a.initHistory()
                    }
                    u || (u = {}),
                    u[s] = a
                }
            return u ? n.dispatch(c.c, {
                mutation: this,
                fromCache: !0,
                isHistoryOnly: l,
                modelSchemas: u,
                schema: t,
                entity: t.entity ? this.getMutableRecord(t.entity) : null
            }, this.mainDispatchId).meta.pipe(Object(Y.a)( () => {
                const e = n.getState();
                for (let t in i)
                    i[t] || (i[t] = e[t] || null);
                return i
            }
            )) : Object(V.a)(i)
        }
    }
    const yA = e => 1 === e.length ? e[0] : Object(wr.a)(e);
    function vA(e, t) {
        const {pluginStoreConfigs: n, pastTimestamps: r, futureTimestamps: i, getCoreStore: o, getPluginStoreConfig: s, emitTimeTravelEvent: a} = e
          , c = Object(Y.a)(t => !t.isCancelling || (e.plugin.removeTimeTravelTs(),
        !1))
          , u = Object(Y.a)(t => {
            for (let n of t)
                if (n.isCancelling)
                    return e.plugin.removeTimeTravelTs(),
                    !1;
            return !0
        }
        )
          , l = (t, r, i, s) => {
            let a, l = void 0, d = void 0, h = void 0;
            for (let e in n)
                if ((a = n[e].plugin) && (d = s ? a._doRedo(i, l) : a._doUndo(i, l),
                d))
                    if (h)
                        h.push(d);
                    else {
                        l = d.dispatchId,
                        h = [d];
                        const e = o().getAction(l, !0).meta.network;
                        s ? e.isRedo = !0 : e.isUndo = !0
                    }
            if (!d) {
                const e = s ? "redo" : "undo";
                throw new Error("Invalid ".concat(e, " request: The timestamp ").concat(i, " was registered as undoable, but there are no mutations for this timestamp in order to ").concat(e, " it."))
            }
            return ( (t, n, r, i) => {
                if (n)
                    return void t.push(Object(qs.a)( () => {
                        e.currentTimestamp = r;
                        const {length: t} = i;
                        if (1 === t)
                            return i[0].executeNow(),
                            i[0].ofComplete(!0).pipe(c);
                        {
                            const e = new Array(t);
                            let n = 0;
                            for (; n < t; )
                                e[n] = i[n].ofComplete(!0),
                                i[n].executeNow(),
                                n++;
                            return Object(wr.a)(e).pipe(u)
                        }
                    }
                    ));
                let o = !1;
                const s = Object(qs.a)( () => {
                    e.currentTimestamp = r;
                    const n = []
                      , s = t[a]
                      , c = s ? [] : void 0
                      , u = s ? [] : void 0;
                    for (let e = 0; e < i.length; e++)
                        s && (c[e] = i[e].ofOptimisticComplete(),
                        u[e] = i[e].ofCancelling()),
                        i[e].executeNow(),
                        n[e] = i[e].ofComplete(!0);
                    return s ? ((1 === u.length ? u[0] : Es(...u)).subscribe( () => {
                        o || (o = !0,
                        s.__cancel(),
                        e.plugin.removeTimeTravelTs())
                    }
                    ),
                    Object(wr.a)([yA(c).pipe(Object(j_.a)(s)), yA(n)]).pipe(Object(Y.a)(e => !(o || !e[0])))) : yA(n).pipe(Object(Y.a)( () => {
                        if (o)
                            return !1;
                        for (let t of i)
                            if (t.isCancelling)
                                return e.plugin.removeTimeTravelTs(),
                                !1;
                        return !0
                    }
                    ))
                }
                );
                s.__cancel = () => {
                    if (!o) {
                        o = !0;
                        for (let e of i)
                            e.cancel();
                        t[a] && t[a].__cancel()
                    }
                }
                ;
                const a = t.push(s)
            }
            )(t, r, i, h),
            h
        }
          , d = (e, t, n) => {
            if (!e || !e.length)
                return;
            const {id: r, mutationType: i} = n;
            let o;
            for (let s of e)
                if ((o = s.switchTo(t, !0)) && o.recordDataType[r] === i) {
                    if (i !== Gr.c || !n.state)
                        return o;
                    const e = o.prevRecordState[r];
                    if (!e)
                        continue;
                    const {state: t} = n;
                    let s = !0;
                    for (let n in t)
                        if (e[n] !== t[n]) {
                            s = !1;
                            break
                        }
                    if (s)
                        return o
                }
        }
        ;
        t.removeTimeTravelTs = function(t) {
            let o, s = e.currentTimestamp;
            if (t)
                if (t === s)
                    i.length ? i[0] === s ? (i.splice(0, 1),
                    (s = i[0]) || (s = r.pop())) : s = i[0] : s = r.pop(),
                    e.currentTimestamp = s || null;
                else if ((o = r.indexOf(t)) > -1)
                    r.splice(o, 1);
                else {
                    if (!((o = i.indexOf(t)) > -1))
                        return !1;
                    i.splice(o, 1)
                }
            else
                e.currentTimestamp = null,
                i.length && (i.length = 0),
                r.length && (r.length = 0),
                s = void 0;
            if (e.timeTravelLocationData && (t ? e.timeTravelLocationData.delete(t) : e.timeTravelLocationData.clear()),
            1 === e.pluginsCount)
                n[this.__pluginSlug].plugin._doRemoveTimeTravelTs(t, s);
            else {
                let e;
                for (let r in n)
                    (e = n[r].plugin) && e._doRemoveTimeTravelTs(t, s)
            }
            return a("remove", t),
            !0
        }
        ,
        t.timeTravel = function(t, n) {
            const o = e.currentTimestamp;
            if (!o)
                return null;
            let s, c = !1;
            if (t < 0) {
                const e = i[0] === o ? t : t + 1;
                if (0 === e) {
                    if (i[0] === o && !r.length)
                        return null;
                    s = o
                } else if (!(s = r[r.length + e]) && (!n || !(s = r[0])))
                    return null
            } else if (t < 1e6) {
                if (c = !0,
                !(s = i[t - 1]) && (!n || !(s = i[i.length - 1])))
                    return null
            } else if (t === o)
                c = i[0] === o,
                s = o;
            else if (s = t,
            i.indexOf(t) >= 0)
                c = !0;
            else if (r.indexOf(t) < 0)
                return null;
            return (e => {
                let t, n = !1, r = !0;
                return e[0].subscribe(e => {
                    if (n = !0,
                    r = e,
                    t) {
                        for (let e of t)
                            e.next(r),
                            e.complete();
                        t = void 0
                    }
                }
                ),
                new S.a(e => {
                    n ? (e.next(r),
                    e.complete()) : t ? t.push(e) : t = [e]
                }
                )
            }
            )(( (t, n) => {
                let o;
                const s = []
                  , {currentTimestamp: c} = e;
                if (n)
                    for (i[0] !== c && r.push(c),
                    o = i.shift(),
                    l(s, o === t, o, n); t !== o; )
                        r.push(o),
                        o = i.shift(),
                        l(s, !1, o, n);
                else
                    for (o = c,
                    i[0] === c && (o = r.pop()),
                    i.unshift(o),
                    l(s, o === t, o, !1); t !== o; )
                        o = r.pop(),
                        i.unshift(o),
                        l(s, !1, o, !1);
                return a(n ? "redo" : "undo", o),
                s
            }
            )(s, c))
        }
        ,
        t.subscribeToTimeTravelEvents = function(t) {
            return e.timeTravelEvents$ || (e.timeTravelEvents$ = new U.a),
            t ? e.timeTravelEvents$.asObservable().subscribe(t) : e.timeTravelEvents$.asObservable()
        }
        ,
        t.getTimeTravelTimestamps = function(t, n) {
            const o = e.currentTimestamp;
            if (!o)
                return n ? 0 : null;
            if ("current" === t)
                return n ? 1 : o;
            if ("past" === t)
                return i[0] === o ? n ? r.length : r.length ? [...r] : null : n ? r.length + 1 : [...r, o];
            if ("future" === t)
                return n ? i.length : i.length ? [...i] : null;
            if (t && "all" !== t) {
                let e;
                return e = i[0] === o ? "firstPast" === t ? r[r.length - 1] : o : "firstPast" === t ? o : i[0],
                e ? n ? 1 : e : null
            }
            return i[0] === o ? n ? r.length + i.length : [...r, ...i] : n ? r.length + 1 + i.length : [...r, o, ...i]
        }
        ,
        t.getTimeTravelMutations = function(e) {
            const t = s(this);
            if (!e)
                return {
                    current: t.currentMutations,
                    past: t.pastMutations.length ? t.pastMutations : null,
                    future: t.futureMutations.length ? t.futureMutations : null
                };
            if (t.currentMutations && t.currentMutations.ts === e)
                return t.currentMutations;
            let n = t.futureMutations;
            if (n[0] && n[0].ts <= e) {
                for (let t of n)
                    if (t.ts === e)
                        return t;
                return
            }
            n = t.pastMutations;
            let r = n.length - 1;
            for (; r >= 0; )
                if (n[r].ts === e)
                    return n[r]
        }
        ,
        t.getTimeTravelMutationByRecordState = function(t) {
            const {id: n, future: o} = t;
            let s = e.getPluginStoreConfig(this);
            const a = s.plugin.types.ModelID.decodeGlobalId(n);
            if (!a)
                return;
            if (a.pluginSlug !== s.plugin.__pluginSlug && (s = e.getPluginStoreConfigBySlug(a.pluginSlug),
            !s))
                return;
            const {modelName: c} = a;
            let u = d(s.currentMutations, c, t);
            if (u)
                return u;
            if (console.log({
                futureTimestamps: i,
                pastTimestamps: r,
                currentTimestamp: e.currentTimestamp,
                futureMutations: s.futureMutations,
                pastMutations: s.pastMutations,
                currentMutations: s.currentMutations
            }),
            o)
                ;
            else {
                const e = s.pastMutations;
                if (!e.length)
                    return;
                let n = e.length - 1;
                for (; n >= 0; ) {
                    if (u = d(e[n], c, t),
                    u)
                        return u;
                    n--
                }
            }
        }
        ,
        t.getTimeTravelLocationData = function(t) {
            return t ? e.timeTravelLocationData ? e.timeTravelLocationData.get(t) : void 0 : e.timeTravelLocationData
        }
    }
    function bA(e) {
        const t = e.sharedCore.instanceMethods;
        !function(e, t) {
            const n = e.getPluginStoreBySlug
              , r = e.getPluginStore;
            t.getModelByName = function(e, t) {
                if (!t)
                    return r(this).get(e);
                const i = n(t, this.__dispatchId);
                return i ? i.get(e) : void 0
            }
        }(e, t),
        function(e, t) {
            const n = e.getPluginStoreBySlug;
            t.getPlugin = function(e) {
                const t = n(e || this.__pluginSlug, this.__dispatchId);
                return t ? t.instance : void 0
            }
        }(e, t),
        function(e, t) {
            let n, r;
            const i = e.getCoreStore
              , o = e.getPluginStore;
            if (e.isServer)
                n = function(e) {
                    const t = e ? i(e) : o(this);
                    return t.mainDispatchId && t.getAction(t.mainDispatchId).meta.getSession() || null
                }
                ,
                r = function(e) {
                    const t = o(this);
                    if (t.mainDispatchId)
                        return void t.mainStore.getAction(t.mainDispatchId).meta.setSession(e);
                    const n = e.__dispatchId;
                    n && i(n).instance.setSession(e)
                }
                ;
            else {
                const {storesMap: t} = e;
                let o = (t, n) => Object(he.U)(e.session) ? (o = (t, n) => n || (n = t.__dispatchId) ? e.session.getBestInstance(n) : e.session,
                o(t, n)) : e.session;
                n = function(e) {
                    return o(this, e)
                }
                ;
                let s = (n, r) => {
                    Object(he.U)(r) ? (e.session = r.getMainInstance(),
                    i().network.setSession(e.session),
                    s = (e, n) => {
                        let r = t.get(n);
                        r.mainDispatchId && r.getAction(r.mainDispatchId).meta.network.setSession(n)
                    }
                    ,
                    s(n, r)) : e.session = r
                }
                ;
                r = function(e) {
                    s(this, e)
                }
            }
            t.getSession = n,
            t.setSession = r
        }(e, t),
        vA(e, t),
        t.switchTo = t.getModelByName
    }
    class _A extends UO {
        constructor(e) {
            let t;
            t = "boolean" === typeof e ? fm({
                isServer: e
            }) : e || fm({
                isServer: "undefined" === typeof window
            }),
            Eg(t),
            t.init();
            const n = t.stores
              , r = {}
              , i = t.BaseNetwork.isServer;
            super(i),
            this.sharedCore = {
                instanceMethods: {}
            },
            this.pluginMutationBase = {
                instanceMethods: {},
                instanceAccessors: {}
            },
            this.modelMutationBase = {
                instanceMethods: {},
                instanceAccessors: {}
            };
            const o = this;
            let s, a = e => (s = o.storesMap.get(o.plugin),
            a = e => e ? s.getBestStore(e) : s,
            a(e));
            function c(e) {
                const t = r[e.__pluginSlug];
                if (!t)
                    throw new Error('Unable to get the storeConfig for the plugin with slug "'.concat(e.__pluginSlug, '": it is not a slug that identifies a plugin that is registered with the current Core instance.'));
                return t
            }
            this.coreMetaFields = void 0,
            this.bcrypt = void 0,
            this.currentTimestamp = null,
            this.pastTimestamps = [],
            this.futureTimestamps = [],
            this.timeTravelEvents$ = null,
            this.emitTimeTravelEvent = (e, t) => {
                o.timeTravelEvents$ && o.timeTravelEvents$.next({
                    event: e,
                    ts: t
                }),
                "remove" === e && (t ? o.timeTravelLocationData.delete(t) : o.timeTravelLocationData.clear())
            }
            ,
            this.timeTravelLocationData = i ? void 0 : new Map,
            this.pluginStoreConfigs = r,
            this.pluginsCount = 0,
            this.privateData = t,
            this.session = void 0,
            this.registerPluginStoreConfig = function(e) {
                r[e.pluginRecord.slug] = e,
                o.pluginsCount++
            }
            ,
            this.getStore = function(e) {
                return c(e).storesMap.get(e)
            }
            ,
            this.getPluginStoreConfig = c,
            this.getStoreById = function(e) {
                return n.get(e)
            }
            ,
            this.getPluginStore = function(e, t) {
                const n = c(e);
                return t = t || e.__dispatchId,
                n.storesMap.get(n.plugin).getBestStore(t)
            }
            ,
            this.getPluginStoreBySlug = function(e, t) {
                const n = r[e];
                if (n)
                    return t ? n.storesMap.get(n.plugin).getBestStore(t) : n.storesMap.get(n.plugin)
            }
            ,
            this.getPluginStoreConfigBySlug = function(e) {
                return r[e]
            }
            ,
            this.getCoreStore = function(e) {
                return a(e)
            }
            ,
            this.getCore = function(e) {
                return e ? o.plugin.getBestInstance(e) : o.plugin
            }
            ,
            this.getSiblingMutation = function(e, t) {
                if (e.__pluginSlug === KS.c)
                    return t ? e.getModelMutation(t) : e;
                const n = a(e.mainDispatchId);
                let r = n.value.mutation;
                return r || (r = n.instance.mutation(e.mainDispatchId),
                r.action.meta.addSiblingTrx(e.dispatchId)),
                t ? r.getModelMutation(t) : r
            }
        }
    }
    const SA = "JobQueueRecordStatusEnum";
    function OA(e) {
        !function(e) {
            e.Enum.define({
                name: SA,
                values: Object.values(dM.a)
            })
        }(e)
    }
    function TA(e) {
        OA(e.types)
    }
    class IA extends yT {
        static createStoreConfig(e) {
            return new _A(e)
        }
        static createPrivateData(e) {
            return fm({
                isServer: !!e
            })
        }
        static init(e) {
            const t = super.init(e)
              , n = t.storeConfig;
            return t.setPluginRecord(EO(n.pluginRecord)).setNetwork(n.privateData.storeNetwork).setPackageName("@isomorix/core").setModuleName("@isomorix/core").addPackage(HS).addPackage(zS).addPackage(NO.a).addPackage(TA),
            n.registerPluginStoreConfig(n),
            n.isServer && CO(n),
            t
        }
        addDefaultLogic() {
            return this.addLogic(void 0).addLogic(tx).addMainLogic(void 0),
            super.addDefaultLogic()
        }
        _setMixinObject(e, t, n) {
            return t ? this.setStoreConfig(e, t) : Object.keys(this.storeConfig[e].instanceMethods).length || n(this.storeConfig),
            this
        }
        setSharedCore(e) {
            return this._setMixinObject("sharedCore", e, bA)
        }
        setPluginMutationBase(e) {
            return this._setMixinObject("pluginMutationBase", e, mA)
        }
        setModelMutationBase(e) {
            return this._setMixinObject("modelMutationBase", e, dA)
        }
        createInstance() {
            const e = super.createInstance()
              , t = this.payload.session;
            return t && e.setSession(t),
            e
        }
    }
    IA.preparePluginRecord = EO;
    const xA = ["models", "modelDescriptions", "modelAiDescriptions", "directives", "directiveDescriptions"];
    function wA(e) {
        switch (e) {
        case !0:
        case "true":
        case "1":
        case 1:
            return !0;
        case !1:
        case "false":
        case 0:
            return !1;
        default:
            return e
        }
    }
    const MA = /,\s?/
      , AA = (e, t, n) => {
        let r = e[t];
        if ("string" === typeof n) {
            if (!MA.test(n))
                return r ? r.indexOf(n) < 0 && r.push(n) : e[t] = [n],
                e;
            if (n = n.split(MA),
            !r)
                return e[t] = n,
                e
        } else if (!r)
            return e[t] = [...n],
            e;
        for (let i of n)
            r.indexOf(i) < 0 && r.push(i);
        return e
    }
    ;
    const EA = {
        fetchTypesData: function(e) {
            let t, n = this.typesDataToFetch;
            if (!n) {
                n = {},
                this.typesDataToFetch = n,
                this.typesDataToFetch$ = Object(qs.a)( () => "undefined" === typeof t ? e.asObservable() : Object(V.a)(t));
                const e = new U.a;
                let t;
                e.subscribe();
                const r = () => {
                    this.typesDataToFetch = void 0,
                    this.typesDataToFetch$ = void 0,
                    this.restApi.getTypes(n).pipe(Object(Y.a)(e => {
                        if (t = e || null,
                        !t || t.errors || !t.data)
                            return t;
                        const {data: n} = t;
                        if (this.add(n),
                        n.modelNames && (this.clientModelNames = n.modelNames),
                        n.modelNamesToDisplayName && (this.clientModelNames = Object.keys(n.modelNamesToDisplayName),
                        this.clientModelNames.sort(),
                        this.clientModelNamesToDisplayName = n.modelNamesToDisplayName),
                        !n.types)
                            return t;
                        const {types: r} = n
                          , {types: i} = this;
                        let o, s, a, c;
                        for (let t in r)
                            if (o = i.get(t))
                                if (s = r[t],
                                s && "string" !== typeof s) {
                                    if (o.description = s.description || null,
                                    a = s.values)
                                        for (c of a)
                                            c.description && o.updateValueDescription(c.name, c.description)
                                } else
                                    o.description = s || null;
                        return t
                    }
                    )).subscribe(e)
                }
                ;
                i.b.schedule(r, 2)
            }
            for (let r of xA)
                e[r] && !0 !== n[r] && (t = wA(e[r]),
                "boolean" !== typeof t ? AA(n, r, e[r]) : t && (n[r] = !0));
            return e.modelNames && (n.modelNames = !0),
            e.modelNamesToDisplayName && (n.modelNamesToDisplayName = !0),
            e.types && AA(n, "types", e.types),
            this.typesDataToFetch$
        },
        setRestApi: function(e) {
            return this.restApi = e,
            this
        },
        setClientSchemaData: function(e) {
            return this.clientSchemaData = e,
            this
        },
        setAsClientPrimary: function() {
            return this.__types.setFetchInfoFn(e => this.fetchTypesData({
                types: e
            })),
            this
        }
    };
    const CA = {
        name: In.f,
        primary: !0,
        unique: !1,
        isSearch: !1,
        isLocalOnly: !1,
        isStore: !0,
        includeNull: !1,
        indexStoreKeyByFieldName: null,
        indexStorePriority: Lm.g,
        relationshipType: null,
        fields: ["id"]
    }
      , NA = {
        ...CA,
        fields: ["historyId"]
    }
      , RA = {
        name: Ro.e,
        unique: !0,
        primary: !1,
        isSearch: !1,
        isLocalOnly: !1,
        isStore: !0,
        includeNull: !1,
        indexStoreKeyByFieldName: null,
        indexStorePriority: Lm.c,
        relationshipType: null,
        fields: [Ro.d]
    }
      , PA = {
        ...CA,
        name: "c_id",
        primary: !1,
        indexStorePriority: Lm.c,
        relationshipType: iO.a.HAS_MANY
    }
      , DA = {
        name: "i_".concat(Ro.a.VALID_TO_TS),
        type: null,
        primary: !1,
        unique: !1,
        isSearch: !1,
        isLocalOnly: !1,
        isStore: !1,
        includeNull: !1,
        indexStoreKeyByFieldName: null,
        indexStorePriority: Lm.c,
        relationshipType: null,
        fields: [Ro.a.VALID_TO_TS]
    }
      , FA = {
        ...DA,
        name: "i_id_".concat(Ro.a.VALID_TO_TS),
        fields: ["id", Ro.a.VALID_TO_TS]
    }
      , kA = {
        ...DA,
        name: Ro.c,
        fields: [Ro.a.TS_FIELD]
    }
      , jA = {
        ...DA,
        includeOnHistory: !0,
        name: "i_last_modified_at",
        fields: ["last_modified_at"]
    }
      , LA = {
        ...DA,
        name: "i_externalRawDataStatus",
        fields: ["externalRawDataStatus"]
    };
    const VA = {
        getExternalRawDataStatus: function() {
            return this.externalRawDataStatusConstraint || (this.externalRawDataStatusConstraint = (new this).setData(LA.name, LA))
        },
        getHistoryStandardPk: function(e) {
            if ("id" === e)
                return this.historyStandardPkConstraint || (this.historyStandardPkConstraint = (new this).setData(PA.name, PA));
            const t = (new this).setData("c_".concat(e), PA);
            return t.fields = [e],
            t
        },
        getHistoryValidTo: function() {
            return this.historyValidToConstraint || (this.historyValidToConstraint = (new this).setData(DA.name, DA))
        },
        getLastModifiedAt: function() {
            return this.lastModifiedAtConstraint || (this.lastModifiedAtConstraint = (new this).setData(jA.name, jA))
        },
        getPrimary: function(e) {
            if ("id" === e)
                return this.primaryConstraint || (this.primaryConstraint = (new this).setData(CA.name, CA));
            if ("historyId" === e)
                return this.historyPrimaryConstraint || (this.historyPrimaryConstraint = (new this).setData(NA.name, NA));
            {
                const t = (new this).setData(CA.name, CA);
                return t.fields = [e],
                t
            }
        },
        getStandardPkAndValidTo: function(e) {
            return "id" !== e ? (new this).setData("i_".concat(e, "_").concat(Ro.a.VALID_TO_TS), {
                ...FA,
                name: "i_".concat(e, "_").concat(Ro.a.VALID_TO_TS),
                fields: [e, Ro.a.VALID_TO_TS]
            }) : this.standardPkAndValidToConstraint || (this.standardPkAndValidToConstraint = (new this).setData(FA.name, FA))
        },
        getUidNonUnique: function() {
            return this.uidNonUniqueConstraint || (this.uidNonUniqueConstraint = (new this).setData(RA.name, RA),
            this.uidNonUniqueConstraint.unique = !1),
            this.uidNonUniqueConstraint
        },
        getUidUnique: function() {
            return this.uidConstraint || (this.uidConstraint = (new this).setData(RA.name, RA))
        },
        getTs: function() {
            return this.tsConstraint || (this.tsConstraint = (new this).setData(kA.name, kA))
        }
    };
    var UA = n(1001);
    const qA = {
        keyBy: {
            get() {
                return this.indexStoreKeyByFieldName
            },
            set(e) {
                this.indexStoreKeyByFieldName = e
            }
        },
        fieldNames: {
            get() {
                return this.fields
            },
            set(e) {
                this.fields = e
            }
        },
        indexStore: {
            get() {
                return this.isStore
            },
            set(e) {
                this.isStore = e
            }
        }
    };
    for (const jR in qA)
        qA[jR].enumerable = !1,
        qA[jR].configurable = !0;
    const QA = {
        inDatabase: {
            get() {
                return !this.isLocalOnly
            },
            set(e) {
                this.isLocalOnly = !e
            },
            enumerable: !1
        }
    };
    const BA = {
        getState: function() {
            return this
        },
        getMainInstance: function() {
            return this
        }
    };
    function GA() {
        for (let e in this)
            this.hasOwnProperty(e) && (this[e] = void 0)
    }
    function zA(e, t) {
        return t.prototype.destroy = GA,
        Object.defineProperties(t, e.sharedAccessors),
        Object.defineProperties(t.prototype, e.sharedAccessors),
        function(e) {
            Object.defineProperties(e.prototype, QA),
            Object(L.a)(e, BA)
        }(t),
        t
    }
    const HA = {
        addToHistory: function(e) {
            if (!this.primary && !this.unique && !this.indexStoreKeyByFieldName && !this.relationshipType)
                return e && (e.constraints[this.name] = this),
                this;
            const t = (new this.constructor).setData(this.name, this);
            return t.primary = !1,
            t.unique = !1,
            t.indexStoreKeyByFieldName = null,
            t.relationshipType = null,
            e && (e.constraints[this.name] = t),
            t
        },
        setData: function(e, t) {
            return this.name = e,
            Object(UA.m)(this, t, null, UA.a),
            "SPATIAL" === t.type ? (this.type = t.type,
            this.isStore = !1,
            this.indexStoreKeyByFieldName = null,
            this.relationshipType = null,
            this.indexStorePriority = Lm.c) : (this.isStore = !1 !== t.isStore,
            this.type = t.type || null,
            this.indexStoreKeyByFieldName = t.indexStoreKeyByFieldName || null,
            this.indexStorePriority = t.indexStorePriority || Lm.c,
            this.relationshipType = t.relationshipType || null),
            this.fields = t.fields,
            this
        }
    };
    const KA = ["FIELD"];
    function YA(e, t) {
        e || (e = t.name),
        this.name = e;
        const n = this.__schema;
        n.directives[this.name] = this,
        Object(UA.m)(this, t, UA.c),
        this.locations = t.locations || KA,
        this.permUse = t.permUse ? this.__permUserCanEnum.getInternalValue(t.permUse) : this.__permAny;
        const {args: r} = t
          , i = n.directiveDescriptions;
        if (this.entitySlug = t.entitySlug || null,
        r) {
            const t = {};
            this.args = t;
            const o = n.DirectiveArg;
            let s, a;
            i[e] ? (this.description = i[e].directive,
            s = i[e].args) : this.description = null;
            for (let e in r)
                a = (new o).setData(e, r[e]),
                a.description = s ? s[e] : null,
                t[e] = a
        } else
            this.args = null,
            this.description = i[e] ? i[e].directive : null;
        return this
    }
    function WA() {
        const e = this.__schema.directiveDescriptions[this.name];
        if (e && (this.description = e.directive,
        this.args)) {
            const {args: t} = e
              , {args: n} = this;
            for (let e in t)
                n[e].description = t[e]
        }
        return this
    }
    function $A(e, t) {
        return this.name = e,
        this.defaultValue = "undefined" === typeof t.defaultValue ? null : t.defaultValue,
        Object(UA.m)(this, t, null, UA.b),
        this.permUse = t.permUse ? this.__permUserCanEnum.getInternalValue(t.permUse) : this.__permAny,
        this.type = "string" === typeof t.type ? this.__types.fromString(t.type) : t.type,
        this
    }
    var XA = n(241)
      , JA = n(70);
    var ZA = n(1002);
    const eE = {
        addTsFields: function(e) {
            let {tsFieldInstances: t} = this;
            if (!t) {
                const e = this.__types;
                t = [this.initTsField(Ro.a.TS_FIELD, e.TimestampSeconds.use()), this.initTsField(Ro.a.TS_CREATE_FIELD, e.TimestampSeconds.use()), this.initTsField(Ro.a.TS_ACTION_FIELD, e.get(qo.a.TS_ACTION_TYPE)), this.initTsField(Ro.a.TS_SESSION_ID_FIELD, e.ModelID.use(tv.b.SESSION)), this.initTsField(Ro.a.TS_UPDATE_COUNT_FIELD, e.Int.use(0))],
                this.tsFieldInstances = t
            }
            let n = 0;
            for (; n < 5; )
                e.setField(t[n]),
                n++
        },
        addValidToField: function(e) {
            let {validToInstance: t} = this;
            t || (t = this.initMetaField(Ro.a.VALID_TO_TS, ZA.a, !1),
            t.displayName = "valid to timestamp",
            t.apiCreate = !1,
            t.apiUpdate = !1,
            t.autoloadOnClient = !1,
            t.autoload = t[JA.a],
            t.description = Object(Ro.f)(t.name),
            t.updateType(this.__types.TimestampSeconds.use(), !0, ZA.a),
            this.validToInstance = t),
            e.setField(t)
        },
        initMetaField: function(e, t, n) {
            const r = new this;
            for (let i of UA.f)
                r[i] = !n;
            return r.autoload = r[JA.a],
            r.defaultValue = t,
            r.displayName = e,
            r.foreignField = null,
            r.id = e,
            r.isCacheField = n,
            r.isLocalOnly = n,
            r.isMetaField = !0,
            r.name = e,
            r.notEnumerable = !0,
            r.notNullable = !1,
            r.order = null,
            r.permRead = this.__permAny,
            r.permUpdate = this.__permAny,
            r.primary = !1,
            r.resolver = XA.a.FIELD,
            r
        },
        initPrimary: function(e, t, n) {
            const r = new this;
            return r.name = e,
            r.id = e,
            r.externalId = null,
            r.displayName = e,
            r.type = n,
            r.apiCreate = !0,
            r.apiRead = !0,
            r.apiUpdate = !1,
            r.autoloadOnClient = !0,
            r.autoloadOnServer = !0,
            r.autoload = !0,
            r.defaultValue = null,
            r.isLocalOnly = t,
            r.isMetaField = !1,
            r.isCacheField = !1,
            r.isAutoIncrement = n.isAutoIncrement,
            r.canAutoGenerate = n.canAutoGenerate,
            r.encodingDisabled = n.encodingDisabled,
            r.decodedKind = n.PERSISTENT_KIND,
            r.foreignField = null,
            r.order = 1,
            r.notEnumerable = !1,
            r.notNullable = !0,
            r.permRead = this.__permAny,
            r.permUpdate = this.__permNever,
            r.primary = !0,
            r.resolver = XA.a.FIELD,
            r.validator = n.getFieldValidator(r),
            r.description = "The ID of the ".concat(n.modelName, "."),
            r
        },
        initTsField: function(e, t) {
            let n = !1
              , r = null;
            e === Ro.a.TS_UPDATE_COUNT_FIELD && (n = !0,
            r = 0);
            const i = this.initMetaField(e, r, !1);
            return i.apiCreate = !1,
            i.apiUpdate = !1,
            i.autoloadOnClient = !1,
            i.autoload = i[JA.a],
            i.description = Object(Ro.f)(e),
            i.updateType(t, n, r),
            i
        }
    };
    const tE = {
        fromGlobalId: function(e) {
            return e ? this.type.fromGlobalId(e) : e
        },
        fromGlobalIdMany: function(e) {
            return this.type.fromGlobalIdMany(e)
        },
        toGlobalId: function(e) {
            return this.type.toGlobalId(e)
        },
        setData: function(e, t) {
            return this.name = e,
            this.displayName = t.displayName || e,
            t.externalId ? (this.externalId = t.externalId,
            this.id = t.id || this.externalId) : this.id = t.id || this.name,
            t.props && (this.props = t.props),
            t.serverProps && (this.serverProps = t.props),
            t.serverConfig && (this.serverConfig = t.serverConfig),
            this.groupId = t.groupId,
            this.aiGroupId = t.aiGroupId,
            this.type = "string" === typeof t.type ? this.__types.fromString(t.type) : t.type,
            Object(UA.n)(this, t, UA.e, this.__permAny),
            Object(UA.m)(this, t, UA.f, UA.d),
            this.autoload = this[JA.a],
            this.defaultValue = "undefined" === typeof t.defaultValue ? null : t.defaultValue,
            this.order = t.order,
            this.resolver = t.resolver || XA.a.FIELD,
            this.isMetaField = !1,
            this.isCacheField = !1,
            this.foreignField = void 0,
            this.dynamicForeignField = void 0,
            this.dynamicForeignFieldName = t.dynamicForeignFieldName || void 0,
            this.predicateFieldName = void 0,
            this.predicateForFieldName = void 0,
            this.primary && (this.decodedKind = t.decodedKind ? t.decodedKind : ei.a.INT,
            this.decodedKind === ei.a.INT ? (this.isAutoIncrement = !1 !== t.isAutoIncrement,
            this.isBigIncrement = !0 === t.isBigIncrement) : (this.isAutoIncrement = !1,
            this.isBigIncrement = !1),
            this.encodingDisabled = !0 === t.encodingDisabled,
            this.canAutoGenerate = !1 !== t.canAutoGenerate,
            this.autoloadOnClient = !0,
            this.autoloadOnServer = !0,
            this.autoload = !0,
            this.permUpdate = this.__permNever,
            this.apiUpdate = !1,
            this.notNullable = !0,
            this.type.updateFromField(this)),
            this.validator = this.type.getFieldValidator(this),
            this
        },
        updateType: function(e, t, n) {
            return "string" === typeof e && (e = this.__types.get(e)),
            e === this.type && t === this.notNullable && n === this.defaultValue || (this.type = e,
            this.notNullable = t,
            this.defaultValue = n,
            e.isSerializable || (this.isLocalOnly = !0,
            this.apiCreate = !1,
            this.apiRead = !1,
            this.apiUpdate = !1,
            this.autoloadOnClient = !1,
            this.autoloadOnServer = !1,
            this.autoload = !1),
            this.validator = e.getFieldValidator(this)),
            this
        },
        validate: function(e, t, n, r) {
            const {name: i} = this;
            try {
                e[i] = this.validator(e[i], this, e, t)
            } catch (o) {
                t || (t = {});
                const s = n ? "".concat(n, ".").concat(i) : i;
                let a = '"'.concat(s, '": ').concat(o.message);
                if (!r) {
                    let t = !1;
                    for (let n in e)
                        n !== i && "string" === typeof e[n] && (t || (t = !0,
                        a += "\n\n    Additional record data:\n"),
                        a += "      - ".concat(n, ": ").concat(e[n], "\n"))
                }
                t[s] = a
            }
            return t
        }
    };
    const nE = /\s\|\|.+$/
      , rE = {
        fieldsAndVFNames: {
            get() {
                if (this._fieldsAndVFNames)
                    return this._fieldsAndVFNames;
                const {fields: e, virtualFields: t} = this
                  , n = {}
                  , r = [];
                let i, o;
                for (i in e)
                    o = "".concat(e[i].displayName, " ||").concat(i),
                    n[o] = i,
                    r.push(o);
                for (i in t)
                    t[i].VFName && (o = Object(ve.g)(i, Object(iu.a)(i)),
                    o = "".concat(o, " ||").concat(i),
                    n[o] = i,
                    r.push(o));
                Object(pa.d)(r, !0, !0);
                const {length: s} = r
                  , a = new Array(s);
                for (let c = 0; c < s; c++)
                    o = r[c],
                    r[c] = o.replace(nE, ""),
                    a[c] = n[o];
                return this._fieldsAndVFDisplayNames = r,
                this._fieldsAndVFNames = a,
                a
            },
            set: void 0,
            enumerable: !1
        },
        fieldsAndVFDisplayNames: {
            get() {
                return this._fieldsAndVFNames && this._fieldsAndVFDisplayNames
            },
            set: void 0,
            enumerable: !1
        },
        historySchema: {
            get() {
                return this.__schema.models[this.historyName]
            },
            set: void 0,
            enumerable: !1
        },
        primaryField: {
            get() {
                return this.fields[this.primaryKey]
            },
            set: void 0,
            enumerable: !1
        },
        standardSchema: {
            get() {
                return this.__schema.models[this.standardName]
            },
            set: void 0,
            enumerable: !1
        }
    }
      , iE = e => e.relationshipType && (e.relationshipType === iO.a.BELONGS_TO_MANY || e.relationshipType === iO.a.BELONGS_TO_MANY_REF);
    const oE = (e, t, n) => {
        for (let r in n)
            e[r] && (e[r][t] = n[r])
    }
    ;
    const sE = Object(Ro.f)(Ro.d);
    const aE = {
        QUERY_ONE: "queryOne",
        QUERY_MANY: "queryMany",
        QUERY_CALC: "queryCalc",
        CREATE_ONE: "createOne",
        CREATE_MANY: "createMany",
        UPDATE_ONE: "updateOne",
        UPDATE_MANY: "updateMany",
        DELETE_ONE: "deleteOne",
        DELETE_MANY: "deleteMany",
        SUBSCRIBE_ONE: "subscribeOne",
        SUBSCRIBE_MANY: "subscribeMany",
        SUBSCRIBE_CALC: "subscribeCalc"
    }
      , cE = {
        [aE.QUERY_ONE]: !1,
        [aE.QUERY_MANY]: !0,
        [aE.QUERY_CALC]: !0,
        [aE.CREATE_ONE]: !1,
        [aE.CREATE_MANY]: !0,
        [aE.UPDATE_ONE]: !1,
        [aE.UPDATE_MANY]: !0,
        [aE.DELETE_ONE]: !1,
        [aE.DELETE_MANY]: !0,
        [aE.SUBSCRIBE_ONE]: !1,
        [aE.SUBSCRIBE_MANY]: !0,
        [aE.SUBSCRIBE_CALC]: !0
    }
      , uE = {
        [aE.QUERY_ONE]: "get",
        [aE.QUERY_MANY]: "get",
        [aE.QUERY_CALC]: "calc",
        [aE.CREATE_ONE]: "create",
        [aE.CREATE_MANY]: "create",
        [aE.UPDATE_ONE]: "update",
        [aE.UPDATE_MANY]: "update",
        [aE.DELETE_ONE]: "delete",
        [aE.DELETE_MANY]: "delete",
        [aE.SUBSCRIBE_ONE]: "subscribeTo",
        [aE.SUBSCRIBE_MANY]: "subscribeTo",
        [aE.SUBSCRIBE_CALC]: "subscribeToCalc"
    };
    const lE = Object.create(null);
    const dE = {
        activateIndexes: function(e) {
            const {constraints: t} = this;
            let n, r, i, o = 0, s = e ? e.getModel(this.name) : this.modelInstance;
            for (let a in t)
                r = t[a],
                a === In.f || !r.isStore || "SPATIAL" === r.type || iE(r) || s.getIndex(r.name) || r.isHistoryOnly && !this.isHistory || (i = {
                    mainTrxPriority: r.indexStorePriority,
                    pendingTrxPriority: r.indexStorePriority,
                    storeConfig: {
                        name: r.name,
                        unique: r.unique,
                        fieldNames: r.fieldNames,
                        keyBy: r.keyBy,
                        includeNull: r.includeNull
                    }
                },
                e ? (n || (n = e.switchTo(this.name),
                s = n.model),
                n.createIndex(i)) : this.__schema.createModelIndexStore(s, i),
                o++);
            return o
        },
        addPrimaryField: function(e) {
            return this.IDType = this.__types.ModelID.use(this.name),
            this.IDType.fieldName = this.primaryKey,
            e || (e = this.__schema.Field.initPrimary(this.primaryKey, this.isLocalOnly, this.IDType),
            this.setField(e)),
            this.constraints[In.f] = this.__schema.Constraint.getPrimary(e.name),
            this.fieldsToIndexName[e.name] = In.f,
            this
        },
        addUidField: function() {
            const e = this.__schema
              , t = e.Field.initMetaField(Ro.d, null, !1);
            return t.apiUpdate = !1,
            t.notNullable = !0,
            t.permUpdate = this.__permNever,
            t.autoload = !0,
            t.autoloadOnClient = !0,
            t.autoloadOnServer = !0,
            t.description = sE,
            t.updateType(this.__types.ModelUID.use(this.name), !0, null),
            this.setField(t),
            this.constraints[Ro.e] = this.isHistory ? e.Constraint.getUidNonUnique() : e.Constraint.getUidUnique(),
            this.UIDType = t.type,
            this
        },
        addTrackingFields: function() {
            return this.__schema.Field.addTsFields(this),
            this
        },
        addVFCacheField: function(e) {
            let t = "Whether the Record is missing ";
            e.isMany ? t += "one or more of its ".concat(e.VFName, " records.") : t += "its ".concat(e.VFName, " record.");
            const n = this.__schema.Field.initMetaField("isMissing".concat(Object(iu.b)(e.VFName)), !0, !0);
            return n.description = t,
            n.updateType(this.__types.Boolean.use(), !0, !0),
            this.setField(n),
            e.ownModelCacheMissingField = n,
            n
        },
        buildInterimUpdateData: function() {
            this.interimUpdateConstratsData = null,
            this.interimUpdateFieldNames = null
        },
        compileNewVFs: function() {
            if (0 === this.VFsToActivateCount)
                return;
            const e = this.__schema
              , {models: t} = e
              , n = e.getCoreSchema().models
              , {fields: r, name: i} = this;
            this.VFsToActivateCount = 0;
            const o = e.__types.get(qo.a.VF_RELATIONSHIP_TYPE);
            let s, a, c;
            for (let u in r)
                (s = r[u].foreignField) && !s.modelVF && ((a = t[i]) && a.modelInstance && ((c = t[s.refModelName]) || (c = n[s.refModelName])) && c.modelInstance ? (Object(cx.d)(s, o),
                Object(cx.g)(s, a, c),
                e.finalizeAndAddToNewVFs(s),
                c.IDType.isAutoIncrement && a.modelInstance.registerPkChangesModel(u, c.modelInstance)) : this.VFsToActivateCount++)
        },
        fetchDescriptions: function(e) {
            const t = {};
            if (e && "standard" !== e)
                if ("both" === e)
                    t.modelDescriptions = [this.name],
                    t.modelAiDescriptions = [this.name];
                else {
                    if ("ai" !== e)
                        return Object(D.c)();
                    t.modelAiDescriptions = [this.name]
                }
            else
                t.modelDescriptions = [this.name];
            return this.__schema.fetchTypesData(t)
        },
        getInputTypeName: function(e) {
            return "".concat(this.graphqlName).concat(Object(iu.b)(e), "Input")
        },
        getRecursiveQueryFilterEnumName: function() {
            return "".concat(this.graphqlName, "RecursiveQueryFilterEnum")
        },
        getUpdateTypesInputName: function() {
            return "".concat(this.graphqlName, "UpdateTypesInput")
        },
        getVFInputTypeName: function(e, t) {
            return "".concat(this.graphqlName).concat(Object(iu.b)(e), "VF").concat(Object(iu.b)(t), "Input")
        },
        initHistory: function() {
            const {id: e, externalId: t, fields: n, constraints: r, name: i, manyName: o, displayName: s, displayNameMany: a, primaryKey: c, __schema: u} = this;
            this.name = Object(fA.a)(i);
            let l, d, h, f = u.models[this.name];
            if (f)
                return this.name = i,
                null;
            this.manyName = Object(fA.b)(i),
            this.displayName = Object(fA.a)(s),
            this.displayNameMany = Object(fA.b)(s),
            this.isHistory = !0,
            this.trackHistory = !1,
            this.id = "".concat(e, "__history"),
            this.externalId = null,
            f = new this.constructor(u).setData(this.name, this, !0),
            this.id = e,
            this.externalId = t,
            this.isHistory = !1,
            this.trackHistory = !0,
            this.name = i,
            this.manyName = o,
            this.displayName = s,
            this.displayNameMany = a,
            f.standardName = i,
            f.permCreate = u.__permNever,
            f.permUpdate = u.__permNever,
            f.apiCreate = !1,
            f.apiUpdate = !1,
            f.trackHistory = !1,
            f.primaryKey = this.historyPrimaryKey || Object(ve.c)("history", c, !0),
            f.description = u.getHistoryModelDescription(f.name);
            for (let g in n)
                l = n[g],
                l.isCacheField || l.isMetaField || (l.primary ? (h = l,
                d = {
                    fieldName: g,
                    modelName: f.name,
                    modelVFName: Object(ve.c)("current", this.displayName, !0),
                    modelVFApiCreate: !1,
                    refFieldName: g,
                    refModelName: i,
                    refModelVFName: "".concat(this.displayName, "Histories"),
                    refModelVFApiCreate: !1,
                    refModelVFApiUpdate: !1,
                    isLocalOnly: !0
                },
                h.primary = !1,
                l = (new u.Field).setData(g, h),
                l.foreignField = Object(cx.c)(d),
                l.description = h.description,
                h.primary = !0) : (d = l.foreignField) && (h = l,
                h.foreignField = null,
                l = (new u.Field).setData(g, h),
                l.description = h.description,
                h.foreignField = d),
                f.setField(l));
            f.addPrimaryField(),
            u.Field.addValidToField(f);
            let p = u.Constraint.getHistoryValidTo();
            f.constraints[p.name] = p,
            p = u.Constraint.getStandardPkAndValidTo(this.primaryKey),
            f.constraints[p.name] = p,
            this.trackAccess && (p = u.Constraint.getTs(),
            f.constraints[p.name] = p),
            f.constraints["c_".concat(c)] = u.Constraint.getHistoryStandardPk(c),
            f.VFsToActivateCount = 1;
            for (let g in r)
                r[g].includeOnHistory && r[g].addToHistory(f);
            return f
        },
        setData: function(e, t, n) {
            e || (e = t.name);
            const r = this.__schema;
            if (r.models[e] = this,
            this.name = e,
            this.manyName = t.manyName || "".concat(e, "s"),
            this.displayName = t.displayName || this.name,
            this.displayNameMany = t.displayNameMany || this.manyName,
            this.graphqlName = this.displayName,
            t.externalId ? (this.externalId = t.externalId,
            this.id = t.id || this.externalId) : (this.externalId = null,
            this.id = t.id || this.name),
            this.entitySlug = t.entitySlug || null,
            this.props = t.props || null,
            t.serverProps && (this.serverProps = t.serverProps),
            t.serverConfig && (this.serverConfig = t.serverConfig),
            t.historyPrimaryKey && (this.historyPrimaryKey = t.historyPrimaryKey),
            this.VFsToActivateCount = 0,
            this.autoloadFields = [],
            this.dynamicForeignFields = null,
            this.virtualFields = {},
            this.fields = {},
            this.fieldGroups = t.fieldGroups,
            this.constraints = {},
            this.fieldsToConstraintName = {},
            this.fieldsToIndexName = {},
            this.beforeFieldUpdate = {},
            this.afterFieldUpdate = {},
            this.pkChangesModels = {},
            this.recursiveVFs = null,
            Object(UA.m)(this, t, UA.l, UA.i),
            Object(UA.n)(this, t, UA.j, this.__permAny),
            Object(UA.n)(this, t, UA.k, null),
            this.setGraphqlNames(t),
            !n) {
                this.syncOrder = t.syncOrder,
                this.lastChangeAt = t.lastChangeAt || 0;
                const {fields: n, constraints: i} = t
                  , o = r.Field;
                this.primaryKey = t.primaryKey || "id";
                const {autoloadFields: s, fieldsToConstraintName: a, fieldsToIndexName: c, beforeFieldUpdate: u, afterFieldUpdate: l, pkChangesModels: d} = this
                  , h = this.constraints;
                let f, p, g, m;
                if (i) {
                    const e = r.Constraint;
                    for (let t in i)
                        p = (new e).setData(t, i[t]),
                        h[t] = p
                }
                f = this.fields;
                const y = r.modelDescriptions[e];
                let v = r.modelAiDescriptions
                  , b = lE
                  , _ = lE;
                y && (this.description = y.model,
                b = y.fields || lE),
                v && (v = v[e]) && (this.aiDescription = v.model,
                _ = v.fields || lE);
                let S = null;
                for (let t in n) {
                    if (g = n[t],
                    g.primary && g.encodingDisabled && r.__types.ModelID.useDecoded(this.name),
                    p = (new o).setData(t, g),
                    p.description = b[t],
                    p.aiDescription = _[t],
                    f[t] = p,
                    p.primary)
                        this.addPrimaryField(p),
                        p.description || (p.description = "The ID of the ".concat(this.name));
                    else if (m = g.foreignField)
                        m = Object(cx.e)(m),
                        m.modelName = e,
                        m.fieldName = t,
                        p.foreignField = Object(cx.c)(m),
                        h[m.fieldIndexName].relationshipType = iO.a.BELONGS_TO,
                        this.VFsToActivateCount++;
                    else if (m = g.dynamicForeignField) {
                        m = Object(cx.e)(m, !0);
                        const e = {}
                          , n = m.nameToPredicateValue;
                        for (let t in n)
                            e[n[t]] = t;
                        m.predicateValueToName = e,
                        m.predicateType || (m.predicateType = "field"),
                        p.dynamicForeignField = m,
                        S ? S[t] = p : S = {
                            [t]: p
                        }
                    }
                    a[t] = null,
                    c[t] = null,
                    u[t] = null,
                    l[t] = null,
                    d[t] = null,
                    p.autoload && s.push(t)
                }
                if (S) {
                    for (const e in f)
                        p = f[e],
                        p.dynamicForeignField ? (p.predicateFieldName = p.dynamicForeignField.predicate,
                        f[p.predicateFieldName].predicateForFieldName = e) : p.dynamicForeignFieldName && (p.predicateFieldName = f[p.dynamicForeignFieldName].dynamicForeignField.predicate);
                    this.dynamicForeignFields = S
                }
                if (this.props) {
                    let e;
                    f.externalRawDataStatus && this.props.dataSourceUid && (e = r.Constraint.getExternalRawDataStatus(),
                    this.constraints[e.name] = e),
                    f.last_modified_at && this.props.includeLastModifiedAtIndex && (e = r.Constraint.getLastModifiedAt(),
                    this.constraints[e.name] = e),
                    this.props.includeTsFieldIndex && (this.trackHistory || this.trackAccess) && (e = r.Constraint.getTs(),
                    this.constraints[e.name] = e)
                }
                f[this.primaryKey] ? c[this.primaryKey] = In.f : this.addPrimaryField()
            }
            return this.assignUID ? this.addUidField() : this.UIDType = null,
            this.trackHistory ? (this.historyPrimaryKey = t.historyPrimaryKey,
            this.historyName = Object(fA.a)(this.name),
            this.addTrackingFields()) : (this.trackAccess || this.isHistory) && this.addTrackingFields(),
            this
        },
        setField: function(e) {
            const {name: t} = e;
            return this.fields[t] = e,
            this.fieldsToConstraintName[t] = null,
            this.fieldsToIndexName[t] = null,
            this.beforeFieldUpdate[t] = null,
            this.afterFieldUpdate[t] = null,
            this.pkChangesModels[t] = null,
            e.autoload && this.autoloadFields.push(t),
            this
        },
        setGraphqlNames: function(e) {
            const {graphqlOpsToModelName: t, graphqlOpsToIsMany: n} = this.__schema
              , {name: r, displayName: i, displayNameMany: o, hasCustomGraphqlNames: s} = this;
            let a, c, u, l, d;
            for (let h in aE)
                a = aE[h],
                c = "".concat(a, "Op"),
                u = "".concat(a, "Resolver"),
                l = cE[a],
                d = s && e[c] ? e[c] : Object(ve.c)(uE[a], l ? o : i),
                t[d] = r,
                n[d] = l,
                this[c] = d,
                this[u] = s && e[u] ? e[u] : XA.a[h];
            return this
        },
        setModelInstance: function(e) {
            return this.modelInstance = e,
            this
        },
        setVF: function(e) {
            const {foreignField: t} = e;
            return t.id || Object(cx.f)(e),
            this.virtualFields[e.bestVFName] = e,
            e.VFName && this._fieldsAndVFNames && Object(pa.c)(e.VFName, this._fieldsAndVFNames),
            e.isRecursive && e.isRefModel && !e.isManyToMany && !e.isReciprocal && (this.recursiveVFs ? this.recursiveVFs.push(e) : this.recursiveVFs = [e]),
            this
        },
        switchTo: function(e) {
            return this.__schema.models[e]
        },
        updateDescriptions: function(e) {
            const {fields: t} = this;
            if (e) {
                let e = this.__schema.modelAiDescriptions;
                e && (e = e[this.name]) && (this.aiDescription = e.model,
                (e = e.fields) && oE(t, "aiDescription", e))
            } else {
                let e = this.__schema.modelDescriptions;
                e && (e = e[this.name]) && (this.description = e.model,
                (e = e.fields) && oE(t, "description", e))
            }
            return this
        }
    };
    const hE = (e, t) => {
        for (const n in e)
            t[n] = e[n]
    }
      , fE = (e, t, n) => {
        n || e.model ? t.model = e.model : e.directive && (t.directive = e.directive),
        e.fields ? t.fields ? hE(e.fields, t.fields) : t.fields = e.fields : e.args && (t.args ? hE(e.args, t.args) : t.args = e.args)
    }
    ;
    function pE(e, t, n, r) {
        if (e) {
            for (let i in e)
                e[i] && (t[i] ? fE(e[i], t[i], r) : t[i] = e[i],
                n[i] && n[i].updateDescriptions(r));
            return t
        }
    }
    const gE = (e, t, n, r) => {
        const {fields: i} = e;
        let o, s, a, c, u, l, d, h, f;
        for (let p in t)
            if ((o = i[p]) && (s = o.props) && (a = s.enumValues) && (c = t[p])) {
                for (u = 0,
                l = a.length,
                d = new Array(l); u < l; )
                    h = a[u],
                    h = "string" === typeof h ? {
                        name: h,
                        value: h
                    } : {
                        ...h
                    },
                    h.description = c[h.name],
                    d[u] = h,
                    u++;
                o.props = {
                    ...s,
                    enumValues: d
                },
                n && (f = n.fields[p]) && (f = {
                    ...f
                },
                f.props = o.props,
                n.fields[p] = f,
                r && (f = r.fields[p]) && (f.props = o.props))
            }
    }
    ;
    const mE = e => "The ".concat(e, " model does not have a description. Add a description by editing the model in the Data Sources section.")
      , yE = (e, t) => "The ".concat(t, " field does not have a description. A description can be added for it in the Data Sources section.");
    function vE(e, t) {
        return t.id || t.externalId || e
    }
    function bE(e) {
        if (!e)
            return null;
        const t = {};
        for (let n in e)
            t[vE(n, e[n])] = n;
        return t
    }
    const _E = /^[aeiou]/i;
    function SE(e, t) {
        for (let n in e)
            t[n] = e[n];
        return t
    }
    function OE(e, t) {
        if (!e || !t)
            return t;
        const n = {};
        for (const r in t)
            e[r] || (n[r] = t[r]);
        return n
    }
    const TE = ["models", "modelDescriptions", "modelAiDescriptions", "directives", "directiveDescriptions"];
    const IE = {
        activateIndexes: function(e, t, n) {
            t || (t = this.models),
            e || (n = !0);
            const r = this.models;
            let i = 0;
            for (let o in t)
                i += r[o].activateIndexes(e);
            return n || 0 === i ? Object(T.b)() : e.processIndexesToAdd()
        },
        activateRelationships: function(e, t) {
            return e || (t = !0),
            this.compileNewVFs().pipe(Object(P.a)( () => this.processNewVFs(e, !0)), Object(P.a)(n => this.m2mVFsToActivate ? this.compileNewM2MVFs().pipe(Object(P.a)( () => this.processNewVFs(e, t))) : t ? Object(V.a)(n) : e.processIndexesToAdd()))
        },
        activateSchema: function(e, t) {
            return this.activateRelationships(e).pipe(Object(P.a)( () => this.activateIndexes(e, t)))
        },
        add: function(e) {
            e || (e = this.schemaData);
            const {models: t, directives: n, manyToManyVFs: r} = e;
            if (pE(e.modelDescriptions, this.modelDescriptions, this.models),
            pE(e.modelAiDescriptions, this.modelAiDescriptions, this.models, !0),
            pE(e.directiveDescriptions, this.directiveDescriptions, this.directives),
            t) {
                const e = this.Model;
                for (const n in t)
                    new e(this).setData(n, t[n])
            }
            if (n) {
                const e = this.Directive;
                for (let t in n)
                    new e(this).setData(t, n[t])
            }
            if (!r)
                return this;
            let {m2mVFsToActivate: i} = this;
            if (i)
                for (let o of r)
                    i.push(Object(cx.c)(Object(cx.e)(o), !0));
            else {
                i = new Array(r.length);
                for (let e = 0; e < i.length; e++)
                    i[e] = Object(cx.c)(Object(cx.e)(r[e]), !0);
                this.m2mVFsToActivate = i
            }
            return this
        },
        addAsync: function(e) {
            e || (e = this.schemaData);
            const {models: t, ...n} = e
              , r = this.Model;
            return Object(T.b)().pipe(Object(P.a)( () => (this.add(n),
            Object(T.b)())), t ? Object(j_.a)(Object(vx.a)(Object.keys(t), e => new r(this).setData(e, t[e]))) : Qs.a, Object(T.a)())
        },
        addToNewVFs: function(e) {
            let {newVFs: t} = this;
            return t ? Object(pa.a)(e.modelVF, t, "ownRefFieldIndexPriority") : (t = [e.modelVF],
            this.newVFs = t),
            Object(pa.a)(e.refModelVF, t, "ownRefFieldIndexPriority"),
            this
        },
        addVFCacheField: function(e) {
            return e.VFName && this.models[e.ownModelName].addVFCacheField(e),
            this
        },
        applyModelDescriptions: function(e, t, n) {
            pE(e, n ? this.modelAiDescriptions : this.modelDescriptions, this.models, n);
            {
                if (!t)
                    return this;
                const {models: e} = this;
                for (const n in t)
                    e[n] && gE(e[n], t[n])
            }
        },
        compileNewM2MVFs: function() {
            return new S.a(e => {
                const {models: t, m2mVFsToActivate: n, types: r} = this;
                if (!n)
                    return Object(V.a)(this);
                let o = null;
                const s = r.get(qo.a.VF_RELATIONSHIP_TYPE);
                let a, c, u, l, d, h;
                const f = n.length;
                let {manyToManyVFs: p} = this
                  , g = 0
                  , m = 0
                  , y = 0;
                const v = () => {
                    for (y = 0,
                    m += 30,
                    (m > f || f - m < 10) && (m = f); g < m; )
                        a = n[g],
                        (h = t[a.throughModelName]) && h.modelInstance && (c = t[a.modelName]) && c.modelInstance && (u = c.virtualFields[a.modelThroughVFName]) && (l = t[a.refModelName]) && l.modelInstance && (d = l.virtualFields[a.refModelThroughVFName]) ? (a.modelThroughVF = u,
                        a.refModelThroughVF = d,
                        Object(cx.d)(a, s),
                        Object(cx.g)(a, c, l),
                        this.finalizeAndAddToNewVFs(a),
                        p ? p.push(a.modelVF) : (p = [a.modelVF],
                        this.manyToManyVFs = p),
                        y++) : o ? o.push(a) : o = [a],
                        g++;
                    m === f ? (this.m2mVFsToActivate = o,
                    e.next(this),
                    e.complete()) : y < 10 ? v() : (y = 0,
                    i.b.schedule(v, 0))
                }
                ;
                i.b.schedule(v, 0)
            }
            )
        },
        compileNewVFs: function() {
            let e = void 0;
            const {models: t} = this;
            for (let n in t)
                t[n].VFsToActivateCount && (e ? e.push(n) : e = [n]);
            return e ? new S.a(n => {
                const r = e.length;
                let o = 0
                  , s = 0;
                const a = () => {
                    for (s += 15,
                    r - s < 5 && (s = r); o < s; )
                        t[e[o]].compileNewVFs(),
                        o++;
                    s === r ? (n.next(),
                    n.complete()) : i.b.schedule(a, 0)
                }
                ;
                i.b.schedule(a, 0)
            }
            ) : Object(V.a)(this)
        },
        createFieldIdsToName: bE,
        createModelIdsToName: bE,
        finalizeAndAddToNewVFs: function(e) {
            const {modelVF: t, refModelVF: n} = e;
            return this.addVFCacheField(t).addVFCacheField(n),
            this.addToNewVFs(e)
        },
        getFieldId: vE,
        getHistoryModelDescription: function(e) {
            return e = Object(fA.c)(e),
            "A snapshot of ".concat(_E.test(e) ? "an" : "a", " ").concat(e, " record at a moment in time.")
        },
        getModelDescription: function(e, t) {
            const n = this.modelDescriptions[e];
            return n ? t ? n.fields && n.fields[t] || yE(0, t) : n.model || mE(e) : Object(fA.d)(e) ? this.getHistoryModelDescription(e) : t ? yE(0, t) : mE(e)
        },
        getModelField: function(e, t) {
            const n = this.models[e];
            return n ? n.fields[t] : void 0
        },
        getModelId: vE,
        getModelVF: function(e, t) {
            const n = this.models[e];
            return n ? n.virtualFields[t] : void 0
        },
        getPermName: function(e) {
            return "function" === typeof e ? this.__permUserCanEnum.getValue(e).name : e
        },
        initHistory: function(e) {
            const {models: t} = this;
            e || (e = Object.keys(t));
            let n, r = null;
            for (let i of e)
                n = t[i],
                !n.isHistory && n.trackHistory && (n = n.initHistory()) && (r || (r = {})) && (r[i] = n);
            return r
        },
        merge: function(e) {
            if (e !== this)
                for (let t of TE)
                    SE(e[t], this[t]);
            return this
        },
        processNewVFs: function(e, t) {
            const n = this.newVFs;
            if (!n)
                return Object(D.c)();
            e || (t = !0),
            this.newVFs = null;
            const r = new S.a(r => {
                const o = n.length;
                let s = 0
                  , a = 0;
                const c = () => {
                    for (a += 15,
                    o - a < 5 && (a = o); s < a; )
                        n[s].register(e),
                        s++;
                    a === o ? (r.next(t ? n : e.processIndexesToAdd()),
                    r.complete()) : i.b.schedule(c, 0)
                }
                ;
                i.b.schedule(c, 0)
            }
            );
            return t ? r.pipe(Object(T.a)()) : r.pipe(Object(Rb.b)(), Object(T.a)())
        },
        removeHistory: function() {
            const {models: e} = this;
            if (!e)
                return this;
            const t = {};
            let n;
            for (const r in e)
                n = e[r],
                n.isHistory || (t[r] = n);
            return this.models = t,
            this
        },
        reset: function() {
            return this.models = {},
            this.modelDescriptions = {},
            this.modelAiDescriptions = {},
            this.directives = {},
            this.directiveDescriptions = {},
            this.graphqlOpsToModelName = {},
            this.graphqlOpsToIsMany = {},
            this.manyToManyVFs = null,
            this.m2mVFsToActivate = null,
            this
        },
        setSchemaData: function(e) {
            return this.schemaData = "string" === typeof e ? JSON.parse(e) : e,
            this.schemaData && (this.lastChangeAt = this.schemaData.lastChangeAt || 0),
            this
        },
        unmerge: function(e) {
            if (e === this)
                return this;
            for (const t of TE)
                this[t] = OE(e[t], this[t]);
            return this
        }
    };
    function xE(e) {
        const t = e.types || e.pluginRecord.types
          , n = t.get(qo.a.PERMISSION_USER_CAN)
          , r = {
            __permUserCanEnum: {
                value: n
            },
            __permAny: {
                value: n.getInternalValue(Uo.a.ANY)
            },
            __permAnyUser: {
                value: n.getInternalValue(Uo.a.ANY_USER)
            },
            __permNever: {
                value: n.getInternalValue(Uo.a.NEVER)
            },
            __types: {
                value: t
            }
        };
        for (const d in r)
            r[d].enumerable = !1,
            r[d].configurable = !0;
        class i {
            constructor(e) {
                this.entity = e || null,
                this.types = t,
                e && (this.entitySlug = e.slug,
                Object(ox.b)(this, "entity")),
                this.reset(),
                this.Model = s,
                this.Field = c,
                this.Constraint = a,
                this.Directive = u,
                this.DirectiveArg = l
            }
        }
        const o = i.prototype;
        i.sharedAccessors = r,
        Object.defineProperties(i, r),
        Object.defineProperties(o, r),
        o.createModelIndexStore = function(t, n) {
            return yy(n, e.getStore(t))
        }
        ,
        o.getCoreSchema = function() {
            return e.pluginRecord.schema
        }
        ,
        Object(L.a)(i, IE);
        const s = function(e) {
            class t {
                constructor(e) {
                    this.__schema = e
                }
            }
            return zA(e, t),
            Object(L.a)(t, dE),
            Object.defineProperties(t.prototype, rE),
            t
        }(i)
          , a = function(e) {
            class t {
            }
            return Object(L.a)(t, HA, VA),
            Object.defineProperties(t.prototype, qA),
            zA(e, t),
            t
        }(i)
          , c = function(e) {
            class t {
            }
            return zA(e, t),
            Object(L.a)(t, tE, eE),
            t
        }(i)
          , u = function(e) {
            class t {
                constructor(e) {
                    this.__schema = e
                }
            }
            return t.prototype.setData = YA,
            t.prototype.updateDescriptions = WA,
            zA(e, t),
            t
        }(i)
          , l = function(e) {
            class t {
            }
            return t.prototype.setData = $A,
            zA(e, t),
            t
        }(i);
        return i
    }
    function wE(e) {
        e.subscribeToAction(e => {
            const t = e.meta.store.storeConfig
              , n = xE(t);
            !function(e) {
                e.__hasSchemaTypesApiMixin || (e.__hasSchemaTypesApiMixin = !0,
                Object(L.a)(e, EA))
            }(n),
            t.Schema = n,
            t.pluginRecord.schema = new n,
            t.pluginRecord.schema.setAsClientPrimary()
        }
        )
    }
    const ME = "WindowStatusEnum"
      , AE = {
        BLURRED: "blurred",
        CLOSED: "closed",
        FOCUSED: "focused",
        HIDDEN: "hidden"
    };
    function EE(e) {
        !function(e) {
            e.Enum.define({
                name: ME,
                values: Object.values(AE)
            })
        }(e)
    }
    function CE(e) {
        EE(e.types)
    }
    const NE = {
        CHAT: "OpenAiChat",
        CONTEXT: "OpenAiContext",
        CONTEXT_TOOL: "OpenAiContextTool",
        TOOL: "OpenAiTool"
    }
      , RE = {};
    for (let jR in NE)
        RE[jR] = "id";
    function PE(e) {
        !function(e) {
            e.storesMap,
            e.plugin.getMainInstance();
            const t = e.getRecordBuilder().Class.prototype;
            Object(rx.a)(e, t),
            t.getMessageBy = function(e, t) {
                const {messages: n} = this;
                if (!n)
                    return null;
                for (let r of n)
                    if (Object(Le.a)(e, r) === t)
                        return r;
                return null
            }
            ,
            t.getMessageIndex = function(e) {
                const {messages: t} = this;
                if (!t)
                    return -1;
                let n = t.length - 1;
                for (; n >= 0; ) {
                    if (t[n].id === e)
                        return n;
                    n--
                }
                return -1
            }
            ,
            t.getQueryRecordUidsInMessages = function(e, t) {
                const {messages: n} = this;
                let r = n ? n.length - 1 : -1;
                if (r < 0 || e && (r = this.getMessageIndex(e)) < 0)
                    return null;
                let i, o = null;
                for (; r >= 0 && (i = n[r],
                i.queryRecordUid && (o || (o = {}),
                o[i.queryRecordUid] = i),
                i.id !== t); )
                    r--;
                return o
            }
        }(e)
    }
    const DE = Xm.a.init().setPackageName("@isomorix/openai-context").setModuleName("@isomorix/openai/context/record/logic")
      , FE = {
        PREPARE_ACTION: f.f,
        CREATE_USER_INPUT_EMBEDDING: f.f,
        SET_SYSTEM_CONTEXT: f.g,
        EXECUTE_INITIAL_MUTATION: f.g,
        PREPROCESS_MESSAGE: f.g,
        EXECUTE_CHAT_COMPLETION: f.g,
        POSTPROCESS_MESSAGE: f.b,
        EXECUTE_FINAL_MUTATION: f.b
    }
      , kE = 100
      , jE = 800
      , LE = 500;
    DE.getBuilder(c.b, "./aiChatCompletion").use().setOp(FE.EXECUTE_FINAL_MUTATION).setPriority(LE).setName("executeFinalMutation").setPure(!1).add((function(e, t) {
        const {payload: n} = e
          , {mutation: r} = n;
        if (n.mutation = null,
        !r || r.isComplete)
            return Object(Ov.a)(null, e, t);
        if (!r.isExecuting) {
            const {chat: e} = n;
            e.isInFlight && r.switchTo(e.__typename).update(e, "isInFlight", null, !1, !0),
            r.executeNow()
        }
        return Object(Ov.a)(r.ofComplete(), e, t)
    }
    ), !0);
    const VE = "openAiApiRestRoute"
      , UE = DE.getBuilder(c.b, "./aiChatCompletion");
    UE.use().setOp(FE.PREPARE_ACTION).setPriority(kE).setName("prepareAction").setPure(!0).add((function(e) {
        const {meta: t, payload: n} = e
          , r = t.store.getState();
        n.context = t.instance,
        n.plugin = n.context.plugin.pluginInstance.getBestInstance(t.mainDispatchId);
        let {message: i, chat: o} = n
          , s = "string" === typeof i;
        s ? (i = {
            id: Object(oe.b)(),
            role: "user",
            content: i
        },
        n.message = i) : i.id || (i.id = Object(oe.b)()),
        n.mutation = n.plugin.mutation(t.mainDispatchId).localOnly(!0),
        o = n.mutation.switchTo(o.__typename).getMutableRecord(o),
        n.chat = o;
        const a = o.messages;
        return a ? s || !o.getMessageBy("id", i.id) ? o.messages = [...a, i] : o.messages = [...a] : o.messages = [i],
        "function" === typeof r.prepareAction && r.prepareAction(e),
        e
    }
    ), !0);
    const qE = {
        create_chart: (e, t) => {
            t.switchTo("ChartJsChart").createOne(JSON.parse(e.content))
        }
        ,
        update_chart: (e, t) => {
            const n = JSON.parse(e.content)
              , r = t.switchTo("ChartJsChart")
              , i = r.model.get(n.id);
            r.update(i, n, !0)
        }
        ,
        create_dataset: (e, t) => {
            t.switchTo("ChartJsDataset").createOne(JSON.parse(e.content))
        }
        ,
        update_query: (e, t) => {
            const n = JSON.parse(e.content)
              , r = t.switchTo("PersistentQuery")
              , i = r.model.get(n.id);
            r.update(i, n, !0)
        }
    };
    function QE(e) {
        e.storesMap,
        e.plugin.getMainInstance();
        e.getRecordBuilder().addLogic(DE),
        function(e) {
            const t = e.storesMap
              , n = (e.plugin.getMainInstance(),
            e.getRecordBuilder().Class.prototype);
            Object(rx.a)(e, n),
            n.createChatCompletion = function(e, n, r) {
                const i = t.get(this).dispatch(c.b, e, n, r).meta
                  , o = i.store;
                let s;
                return e.ofMainActionComplete = () => o.closed ? Object(V.a)(e) : (s || (s = new S.a(t => {
                    o.subscribe({
                        complete: () => {
                            t.next(e),
                            t.complete()
                        }
                    })
                }
                ).pipe(Object(_g.a)()),
                s.subscribe()),
                s),
                i.pipe(Object(Or.a)(e))
            }
        }(e)
    }
    function BE(e) {
        e.setPackageName("@isomorix/openai-context").setDefaultModuleNames("@isomorix/openai/context").registerExtension("../ModelMixin").getRecordBuilder().registerExtension("../RecordMixin"),
        function(e) {
            e.storesMap,
            e.plugin.getMainInstance(),
            function(e) {
                e.storesMap,
                e.plugin.getMainInstance()
            }(e)
        }(e),
        QE(e)
    }
    UE.use().setOp(FE.EXECUTE_CHAT_COMPLETION).setPriority(jE).setName("executeChatCompletion").setPure(!1).add((function(e) {
        const {payload: t} = e
          , {chat: n, message: r} = t;
        let {mutation: i} = t
          , {connection: o, onChunk: s} = t;
        o || (o = (n.entity || t.plugin).getConnection(u.a.REST));
        let a, c, l = !1;
        const d = {
            id: r.id,
            chatId: n.__ID,
            content: r.content
        };
        return t.ttsEnabled && (d.ttsEnabled = !0,
        t.googleTtsVoice && (d.googleTtsVoice = "object" === typeof t.googleTtsVoice ? JSON.stringify(t.googleTtsVoice) : t.googleTtsVoice),
        !1 === t.streamTts && (d.streamTts = !1)),
        o.getByName(VE, d, !0).pipe(Object(Y.a)(t => {
            if (s && s(t),
            !0 === t)
                return l = !0,
                e;
            if ("speech" === t.role)
                return e;
            "assistant" === t.role && t.actions && "showQuery" === t.actions[0].type ? c = t.actions[0].uid : "tool" === t.role && t.content && qE[t.name] && (a ? a[t.id] || (a[t.id] = !0,
            qE[t.name](t, i)) : (a = {
                [t.id]: !0
            },
            qE[t.name](t, i)));
            const r = n.getMessageIndex(t.id);
            t.deleted ? r >= 0 && n.messages.splice(r, 1) : r < 0 ? n.messages.push(t) : n.messages[r] = t
        }
        ), Object(H.a)( () => l), Object(P.a)( () => c ? Object(z.a)(1e3).pipe(Object(te.a)(), Object(P.a)( () => i.switchTo(tv.b.PERSISTENT_QUERY).model.query().selectAll(!0).where(Ro.d, c).fetchOneRecord({
            mutation: i
        }).pipe(Object(Or.a)(e)))) : Object(V.a)(e)))
    }
    ), !0);
    function GE(e) {
        e.storesMap,
        e.plugin.getMainInstance(),
        e.getRecordBuilder();
        !function(e) {
            e.storesMap,
            e.plugin.getMainInstance();
            const t = e.getRecordBuilder();
            Object(rx.a)(e, t.Class.prototype)
        }(e)
    }
    function zE(e) {
        e.setPackageName("@isomorix/openai-tool").setDefaultModuleNames("@isomorix/openai/tool").registerExtension("../ModelMixin").getRecordBuilder().registerExtension("../RecordMixin"),
        function(e) {
            e.storesMap,
            e.plugin.getMainInstance(),
            function(e) {
                e.storesMap,
                e.plugin.getMainInstance()
            }(e)
        }(e),
        GE(e)
    }
    const HE = Xm.a.init().setPackageName("@isomorix/openai").setModuleName("@isomorix/openAi/logic")
      , KE = fS.findExistingBuilder(c.o);
    KE.useRelative(fS.findByName("initModelBuilders", c.o), 5).setName("prepareOpenAiModels").setActionType(c.c, !0).setPure(!0).setLogicMgr(HE, "./init"),
    KE.add((function(e) {
        const {payload: {models: t}} = e;
        let n, r;
        for (let o in NE)
            if (r = NE[o],
            n = t[r])
                switch (r) {
                case NE.CHAT:
                    (i = n).setPackageName("@isomorix/openai-chat").setDefaultModuleNames("@isomorix/openai/chat").registerExtension("../ModelMixin").getRecordBuilder().registerExtension("../RecordMixin"),
                    function(e) {
                        e.storesMap,
                        e.plugin.getMainInstance(),
                        function(e) {
                            e.storesMap,
                            e.plugin.getMainInstance()
                        }(e)
                    }(i),
                    PE(i);
                    break;
                case NE.CONTEXT:
                    BE(n);
                    break;
                case NE.TOOL:
                    zE(n);
                    break;
                case NE.CONTEXT_TOOL:
                    n.setPackageName("@isomorix/openai-context-tool").setDefaultModuleNames("@isomorix/openai/context-tool")
                }
        var i;
        return e
    }
    ), !0);
    const YE = "OpenAiToolMethodEnum"
      , WE = "OpenAiContextManagerEnum"
      , $E = "OpenAiContextPrepareActionEnum"
      , XE = "OpenAiContextShortcodeEnum"
      , JE = "entity_assistant";
    const ZE = {
        EXECUTE_SQL: "execute_sql",
        CREATE_USER_QUERY: "create_user_query",
        UPDATE_USER_QUERY: "update_user_query",
        DELETE_USER_QUERY: "delete_user_query",
        EXECUTE_SQL_QUERY: "execute_sql_query",
        CREATE_QUERY: "create_query",
        GET_COORDINATES: "get_coordinates"
    };
    function eC(e) {
        return this.lazyValues && this.lazyValues[e] ? this.lazyValues[e](e, this) : this.addValue({
            name: e,
            value: e
        }),
        this._nameLookup[e]
    }
    function tC(e, t) {
        !function(e, t) {
            e.Enum.define({
                name: WE,
                values: [JE],
                PERSISTENT_KIND: ei.a.STRING
            })
        }(e),
        function(e) {
            e.Enum.define({
                name: $E,
                values: ["placeholderGetLogic"],
                PERSISTENT_KIND: ei.a.STRING
            })
        }(e),
        function(e, t) {
            e.Enum.define({
                name: YE,
                values: Object.values(ZE),
                PERSISTENT_KIND: ei.a.STRING
            }).getLazyValue = eC
        }(e),
        function(e, t) {
            e.Enum.define({
                name: XE,
                values: ["dbSchema", "entityInfo"],
                PERSISTENT_KIND: ei.a.STRING
            }).getLazyValue = eC
        }(e)
    }
    var nC = n(1008)
      , rC = n(1009);
    const iC = (e, t) => {
        t.addValue(nC.b.useId(VE, YS.a.ROUTE).create(rC.a))
    }
    ;
    function oC(e, t) {
        e.getPayload().openAiOptions = t,
        e.addLogic(HE),
        tC(e.types),
        e.types.LogicMethodEnum.addLazyValueTo(t && t.logicModelName, VE, iC)
    }
    var sC = n(7)
      , aC = n.n(sC);
    function cC(e, t) {
        if (null == e)
            return {};
        var n, r, i = {}, o = Object.keys(e);
        for (r = 0; r < o.length; r++)
            n = o[r],
            t.indexOf(n) >= 0 || (i[n] = e[n]);
        return i
    }
    function uC() {
        return (uC = Object.assign ? Object.assign.bind() : function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n)
                    Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }
        ).apply(this, arguments)
    }
    function lC(e) {
        if (void 0 === e)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }
    function dC(e, t) {
        return (dC = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
            return e.__proto__ = t,
            e
        }
        )(e, t)
    }
    var hC = n(384)
      , fC = n.n(hC);
    function pC(e, t) {
        if (!e) {
            var n = new Error("loadable: " + t);
            throw n.framesToPop = 1,
            n.name = "Invariant Violation",
            n
        }
    }
    function gC(e) {
        console.warn("loadable: " + e)
    }
    var mC = aC.a.createContext();
    function yC(e) {
        return e + "__LOADABLE_REQUIRED_CHUNKS__"
    }
    var vC = {
        initialChunks: {}
    };
    var bC = function(e) {
        return e
    };
    function _C(e) {
        var t = e.defaultResolveComponent
          , n = void 0 === t ? bC : t
          , r = e.render
          , i = e.onLoad;
        function o(e, t) {
            void 0 === t && (t = {});
            var o = function(e) {
                return "function" === typeof e ? {
                    requireAsync: e,
                    resolve: function() {},
                    chunkName: function() {}
                } : e
            }(e)
              , s = {};
            function a(e) {
                return t.cacheKey ? t.cacheKey(e) : o.resolve ? o.resolve(e) : "static"
            }
            function c(e, r, i) {
                var o = t.resolveComponent ? t.resolveComponent(e, r) : n(e);
                return fC()(i, o, {
                    preload: !0
                }),
                o
            }
            var u = function(e) {
                var t = a(e)
                  , n = s[t];
                return n && "REJECTED" !== n.status || ((n = o.requireAsync(e)).status = "PENDING",
                s[t] = n,
                n.then((function() {
                    n.status = "RESOLVED"
                }
                ), (function(t) {
                    console.error("loadable-components: failed to asynchronously load component", {
                        fileName: o.resolve(e),
                        chunkName: o.chunkName(e),
                        error: t ? t.message : t
                    }),
                    n.status = "REJECTED"
                }
                ))),
                n
            }
              , l = function(e) {
                var t = function(t) {
                    return aC.a.createElement(mC.Consumer, null, (function(n) {
                        return aC.a.createElement(e, Object.assign({
                            __chunkExtractor: n
                        }, t))
                    }
                    ))
                };
                return e.displayName && (t.displayName = e.displayName + "WithChunkExtractor"),
                t
            }(function(e) {
                var n, l;
                function h(n) {
                    var r;
                    return (r = e.call(this, n) || this).state = {
                        result: null,
                        error: null,
                        loading: !0,
                        cacheKey: a(n)
                    },
                    pC(!n.__chunkExtractor || o.requireSync, "SSR requires `@loadable/babel-plugin`, please install it"),
                    n.__chunkExtractor ? (!1 === t.ssr || (o.requireAsync(n).catch((function() {
                        return null
                    }
                    )),
                    r.loadSync(),
                    n.__chunkExtractor.addChunk(o.chunkName(n))),
                    lC(r)) : (!1 !== t.ssr && (o.isReady && o.isReady(n) || o.chunkName && vC.initialChunks[o.chunkName(n)]) && r.loadSync(),
                    r)
                }
                l = e,
                (n = h).prototype = Object.create(l.prototype),
                n.prototype.constructor = n,
                dC(n, l),
                h.getDerivedStateFromProps = function(e, t) {
                    var n = a(e);
                    return uC({}, t, {
                        cacheKey: n,
                        loading: t.loading || t.cacheKey !== n
                    })
                }
                ;
                var f = h.prototype;
                return f.componentDidMount = function() {
                    this.mounted = !0;
                    var e = this.getCache();
                    e && "REJECTED" === e.status && this.setCache(),
                    this.state.loading && this.loadAsync()
                }
                ,
                f.componentDidUpdate = function(e, t) {
                    t.cacheKey !== this.state.cacheKey && this.loadAsync()
                }
                ,
                f.componentWillUnmount = function() {
                    this.mounted = !1
                }
                ,
                f.safeSetState = function(e, t) {
                    this.mounted && this.setState(e, t)
                }
                ,
                f.getCacheKey = function() {
                    return a(this.props)
                }
                ,
                f.getCache = function() {
                    return s[this.getCacheKey()]
                }
                ,
                f.setCache = function(e) {
                    void 0 === e && (e = void 0),
                    s[this.getCacheKey()] = e
                }
                ,
                f.triggerOnLoad = function() {
                    var e = this;
                    i && setTimeout((function() {
                        i(e.state.result, e.props)
                    }
                    ))
                }
                ,
                f.loadSync = function() {
                    if (this.state.loading)
                        try {
                            var e = c(o.requireSync(this.props), this.props, d);
                            this.state.result = e,
                            this.state.loading = !1
                        } catch (t) {
                            console.error("loadable-components: failed to synchronously load component, which expected to be available", {
                                fileName: o.resolve(this.props),
                                chunkName: o.chunkName(this.props),
                                error: t ? t.message : t
                            }),
                            this.state.error = t
                        }
                }
                ,
                f.loadAsync = function() {
                    var e = this
                      , t = this.resolveAsync();
                    return t.then((function(t) {
                        var n = c(t, e.props, d);
                        e.safeSetState({
                            result: n,
                            loading: !1
                        }, (function() {
                            return e.triggerOnLoad()
                        }
                        ))
                    }
                    )).catch((function(t) {
                        return e.safeSetState({
                            error: t,
                            loading: !1
                        })
                    }
                    )),
                    t
                }
                ,
                f.resolveAsync = function() {
                    var e = this.props
                      , t = (e.__chunkExtractor,
                    e.forwardedRef,
                    cC(e, ["__chunkExtractor", "forwardedRef"]));
                    return u(t)
                }
                ,
                f.render = function() {
                    var e = this.props
                      , n = e.forwardedRef
                      , i = e.fallback
                      , o = (e.__chunkExtractor,
                    cC(e, ["forwardedRef", "fallback", "__chunkExtractor"]))
                      , s = this.state
                      , a = s.error
                      , c = s.loading
                      , u = s.result;
                    if (t.suspense && "PENDING" === (this.getCache() || this.loadAsync()).status)
                        throw this.loadAsync();
                    if (a)
                        throw a;
                    var l = i || t.fallback || null;
                    return c ? l : r({
                        fallback: l,
                        result: u,
                        options: t,
                        props: uC({}, o, {
                            ref: n
                        })
                    })
                }
                ,
                h
            }(aC.a.Component))
              , d = aC.a.forwardRef((function(e, t) {
                return aC.a.createElement(l, Object.assign({
                    forwardedRef: t
                }, e))
            }
            ));
            return d.displayName = "Loadable",
            d.preload = function(e) {
                d.load(e)
            }
            ,
            d.load = function(e) {
                return u(e)
            }
            ,
            d
        }
        return {
            loadable: o,
            lazy: function(e, t) {
                return o(e, uC({}, t, {
                    suspense: !0
                }))
            }
        }
    }
    var SC = _C({
        defaultResolveComponent: function(e) {
            return e.__esModule ? e.default : e.default || e
        },
        render: function(e) {
            var t = e.result
              , n = e.props;
            return aC.a.createElement(t, n)
        }
    })
      , OC = SC.loadable
      , TC = SC.lazy
      , IC = _C({
        onLoad: function(e, t) {
            e && t.forwardedRef && ("function" === typeof t.forwardedRef ? t.forwardedRef(e) : t.forwardedRef.current = e)
        },
        render: function(e) {
            var t = e.result
              , n = e.props;
            return n.children ? n.children(t) : null
        }
    })
      , xC = IC.loadable
      , wC = IC.lazy
      , MC = "undefined" !== typeof window;
    var AC = OC;
    AC.lib = xC,
    TC.lib = wC;
    let EC = !1;
    var CC = n(192)
      , NC = n(398);
    const RC = (e, t, n) => t ? e ? (e.push(t),
    e) : n ? Array.isArray(n) ? (n.push(t),
    n) : [n, t] : [t] : e;
    class PC {
        constructor(e, t) {
            this.componentEnum = e,
            this.dispatchId = t || null,
            this.getBest = t ? this.getBestInstance : Qs.a
        }
        static init(e, t) {
            return new this(e,t)
        }
        getBestInstance(e) {
            return e ? e.getBestInstance(this.dispatchId) : null
        }
        getInternalValue(e) {
            return this.componentEnum.getInternalValue(e)
        }
        one(e, t) {
            const n = (e = this.getBest(e)) && e.component;
            return n ? Object(sC.createElement)(n, t ? {
                ...t,
                key: e.__storeId,
                logic: e
            } : {
                key: e.__storeId,
                logic: e
            }) : null
        }
        many(e, t, n) {
            if (!e)
                return null;
            let r = null;
            if (Array.isArray(e))
                for (let i of e)
                    r = RC(r, this.one(i, t), n);
            else
                for (let i in e)
                    r = RC(r, this.one(e[i], t), n);
            return r
        }
        from(e, t) {
            if (!e)
                return null;
            const n = [];
            let r;
            for (; e; )
                (r = this.one(e, t)) && n.push(r),
                e = e.next;
            return n.length ? n : null
        }
        fromConfig(e, t) {
            if (!e)
                return e;
            if ("string" === typeof e) {
                const n = this.getInternalValue(e);
                if (!n)
                    return;
                const r = t ? {
                    ...t
                } : {};
                return r.key || (r.key = e),
                Object(sC.createElement)(n, r)
            }
            const n = this.getInternalValue(e.render || e.component);
            if (!n)
                return;
            const r = {
                key: "".concat(e.name, "_").concat(e.priority),
                props: e.props
            };
            if (t)
                for (let i in t)
                    r[i] = t[i];
            return e.render ? n(r) : Object(sC.createElement)(n, r)
        }
        providers(e, t, n) {
            if (!t || !t.length)
                return n;
            const r = this.componentEnum;
            let i, o, s, a = t.length - 1;
            for (; a >= 0; )
                i = t[a],
                o = r.getInternalValue(i.render || i.component),
                o && (s = {
                    key: "".concat(i.name, "_").concat(a),
                    props: i.props,
                    logic: e,
                    children: n
                },
                n = i.render ? o(s) : Object(sC.createElement)(o, s)),
                a--;
            return n
        }
    }
    var DC = n(1013);
    const FC = () => {}
    ;
    function kC(e) {
        return e ? e._insertCss() : FC
    }
    const jC = f.c;
    f.g,
    f.g,
    rw.b;
    var LC = n(1017);
    const VC = Xm.a.initModule("@isomorix/react-router/router/logic");
    Xm.a.initModule("@isomorix/react-router/route/logic"),
    LC.b,
    LC.a;
    LC.a;
    var UC = n(1014);
    const qC = UC.f + 25
      , QC = UC.e;
    var BC;
    function GC(e, t, n, r) {
        BC || (BC = "function" == typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103);
        var i = e && e.defaultProps
          , o = arguments.length - 3;
        if (t || 0 === o || (t = {
            children: void 0
        }),
        1 === o)
            t.children = r;
        else if (o > 1) {
            for (var s = new Array(o), a = 0; a < o; a++)
                s[a] = arguments[a + 3];
            t.children = s
        }
        if (t && i)
            for (var c in i)
                void 0 === t[c] && (t[c] = i[c]);
        else
            t || (t = i || {});
        return {
            $$typeof: BC,
            type: e,
            key: void 0 === n ? null : "" + n,
            ref: null,
            props: t,
            _owner: null
        }
    }
    var zC = n(386)
      , HC = n.n(zC)
      , KC = n(375);
    const YC = HC.a
      , WC = Object(sC.createContext)(null)
      , $C = Object(sC.createContext)(null)
      , XC = Object(sC.createContext)(null)
      , JC = Object(sC.createContext)(null)
      , ZC = Object(sC.createContext)(null)
      , eN = Object(sC.createContext)(null)
      , tN = Object(sC.createContext)(null)
      , nN = (KC.a.FOCUSED,
    aC.a.memo((function(e) {
        let {children: t, session: n} = e;
        const [r,i] = Object(sC.useState)( () => {
            const e = n.userRole;
            return e ? e.getMainInstance() : null
        }
        );
        return Object(sC.useEffect)( () => {
            const e = n.subscribeToUserRole().subscribe(i);
            return () => e.unsubscribe()
        }
        , [n]),
        GC(tN.Provider, {
            value: r
        }, void 0, t)
    }
    )))
      , rN = e => ++e;
    function iN(e) {
        const [t,n] = Object(sC.useState)(0)
          , r = Object(sC.useRef)(null);
        return r.current ? r.current[1] = t + (e || 0) : r.current = [ () => n(rN), t + (e || 0), n],
        r.current
    }
    const oN = (e, t, n) => {
        n.keys = t,
        n.record = e,
        null !== t && e && e.__ID ? (n.sub && n.sub.unsubscribe(),
        n.sub = e.subscribeToAndPersist(t).subscribe(new sN(n))) : n.sub && (n.sub.unsubscribe(),
        n.setRenderId(rN))
    }
    ;
    class sN extends O.a {
        constructor(e) {
            super(),
            this.__cache = e
        }
        doEmit(e, t) {
            t.record = e,
            t.isFirst ? t.isPendingEmit = !0 : t.setRenderId(rN)
        }
        _next(e) {
            const t = this.__cache;
            (t.keys || e !== t.record || e.__changes) && this.doEmit(e, t)
        }
        _complete() {
            const e = this.__cache;
            e.sub === this ? (this.unsubscribe(),
            this.doEmit(null, e)) : this.unsubscribe()
        }
        unsubscribe() {
            super.unsubscribe();
            const e = this.__cache;
            e && (e.sub = null,
            this.__cache = void 0)
        }
    }
    function aN(e, t) {
        const n = Object(sC.useRef)(null)
          , [r,i] = Object(sC.useState)(1);
        let o = n.current;
        return o || (o = {
            isFirst: !0,
            isPendingEmit: !1,
            record: e,
            keys: t,
            sub: null,
            setRenderId: i
        },
        n.current = o,
        oN(e, t, o)),
        Object(sC.useEffect)( () => {
            const {isFirst: n} = o;
            if (o.isFirst = !1,
            n && o.record === e && o.keys === t ? o.isPendingEmit && (o.isPendingEmit = !1,
            i(rN)) : (o.isPendingEmit = !1,
            oN(e, t, o)),
            o.sub)
                return () => {
                    o.sub && o.sub.unsubscribe(),
                    o.record = void 0,
                    o.keys = void 0
                }
        }
        , [e, t, o, i]),
        r
    }
    const cN = ["localProps", "fetchPathsInFlight"];
    var uN = n(234);
    const lN = "".concat("https://static-au03.vitalstats.app", "/").concat("static")
      , dN = "".concat(lN, "/img")
      , hN = /^(?:https|\/\/)/
      , fN = (e, t) => t ? hN.test(t) ? t : e + Object(uN.a)(t) : e;
    function pN() {
        return fN(lN, e);
        var e
    }
    function gN(e) {
        return (e => fN(dN, e))(e)
    }
    const mN = [["props", "themeType"]];
    var yN = n(28)
      , vN = n.n(yN)
      , bN = n(387)
      , _N = n.n(bN)
      , SN = n(293)
      , ON = n.n(SN)
      , TN = n(388)
      , IN = n.n(TN);
    function xN() {
        return (xN = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n)
                    Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }
        ).apply(this, arguments)
    }
    function wN(e, t) {
        e.prototype = Object.create(t.prototype),
        e.prototype.constructor = e,
        MN(e, t)
    }
    function MN(e, t) {
        return (MN = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t,
            e
        }
        )(e, t)
    }
    function AN(e, t) {
        if (null == e)
            return {};
        var n, r, i = {}, o = Object.keys(e);
        for (r = 0; r < o.length; r++)
            t.indexOf(n = o[r]) >= 0 || (i[n] = e[n]);
        return i
    }
    var EN = {
        BASE: "base",
        BODY: "body",
        HEAD: "head",
        HTML: "html",
        LINK: "link",
        META: "meta",
        NOSCRIPT: "noscript",
        SCRIPT: "script",
        STYLE: "style",
        TITLE: "title",
        FRAGMENT: "Symbol(react.fragment)"
    }
      , CN = {
        rel: ["amphtml", "canonical", "alternate"]
    }
      , NN = {
        type: ["application/ld+json"]
    }
      , RN = {
        charset: "",
        name: ["robots", "description"],
        property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"]
    }
      , PN = Object.keys(EN).map((function(e) {
        return EN[e]
    }
    ))
      , DN = {
        accesskey: "accessKey",
        charset: "charSet",
        class: "className",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        "http-equiv": "httpEquiv",
        itemprop: "itemProp",
        tabindex: "tabIndex"
    }
      , FN = Object.keys(DN).reduce((function(e, t) {
        return e[DN[t]] = t,
        e
    }
    ), {})
      , kN = function(e, t) {
        for (var n = e.length - 1; n >= 0; n -= 1) {
            var r = e[n];
            if (Object.prototype.hasOwnProperty.call(r, t))
                return r[t]
        }
        return null
    }
      , jN = function(e) {
        var t = kN(e, EN.TITLE)
          , n = kN(e, "titleTemplate");
        if (Array.isArray(t) && (t = t.join("")),
        n && t)
            return n.replace(/%s/g, (function() {
                return t
            }
            ));
        var r = kN(e, "defaultTitle");
        return t || r || void 0
    }
      , LN = function(e) {
        return kN(e, "onChangeClientState") || function() {}
    }
      , VN = function(e, t) {
        return t.filter((function(t) {
            return void 0 !== t[e]
        }
        )).map((function(t) {
            return t[e]
        }
        )).reduce((function(e, t) {
            return xN({}, e, t)
        }
        ), {})
    }
      , UN = function(e, t) {
        return t.filter((function(e) {
            return void 0 !== e[EN.BASE]
        }
        )).map((function(e) {
            return e[EN.BASE]
        }
        )).reverse().reduce((function(t, n) {
            if (!t.length)
                for (var r = Object.keys(n), i = 0; i < r.length; i += 1) {
                    var o = r[i].toLowerCase();
                    if (-1 !== e.indexOf(o) && n[o])
                        return t.concat(n)
                }
            return t
        }
        ), [])
    }
      , qN = function(e, t, n) {
        var r = {};
        return n.filter((function(t) {
            return !!Array.isArray(t[e]) || (void 0 !== t[e] && console && "function" == typeof console.warn && console.warn("Helmet: " + e + ' should be of type "Array". Instead found type "' + typeof t[e] + '"'),
            !1)
        }
        )).map((function(t) {
            return t[e]
        }
        )).reverse().reduce((function(e, n) {
            var i = {};
            n.filter((function(e) {
                for (var n, o = Object.keys(e), s = 0; s < o.length; s += 1) {
                    var a = o[s]
                      , c = a.toLowerCase();
                    -1 === t.indexOf(c) || "rel" === n && "canonical" === e[n].toLowerCase() || "rel" === c && "stylesheet" === e[c].toLowerCase() || (n = c),
                    -1 === t.indexOf(a) || "innerHTML" !== a && "cssText" !== a && "itemprop" !== a || (n = a)
                }
                if (!n || !e[n])
                    return !1;
                var u = e[n].toLowerCase();
                return r[n] || (r[n] = {}),
                i[n] || (i[n] = {}),
                !r[n][u] && (i[n][u] = !0,
                !0)
            }
            )).reverse().forEach((function(t) {
                return e.push(t)
            }
            ));
            for (var o = Object.keys(i), s = 0; s < o.length; s += 1) {
                var a = o[s]
                  , c = xN({}, r[a], i[a]);
                r[a] = c
            }
            return e
        }
        ), []).reverse()
    }
      , QN = function(e, t) {
        if (Array.isArray(e) && e.length)
            for (var n = 0; n < e.length; n += 1)
                if (e[n][t])
                    return !0;
        return !1
    }
      , BN = function(e) {
        return Array.isArray(e) ? e.join("") : e
    }
      , GN = function(e, t) {
        return Array.isArray(e) ? e.reduce((function(e, n) {
            return function(e, t) {
                for (var n = Object.keys(e), r = 0; r < n.length; r += 1)
                    if (t[n[r]] && t[n[r]].includes(e[n[r]]))
                        return !0;
                return !1
            }(n, t) ? e.priority.push(n) : e.default.push(n),
            e
        }
        ), {
            priority: [],
            default: []
        }) : {
            default: e
        }
    }
      , zN = function(e, t) {
        var n;
        return xN({}, e, ((n = {})[t] = void 0,
        n))
    }
      , HN = [EN.NOSCRIPT, EN.SCRIPT, EN.STYLE]
      , KN = function(e, t) {
        return void 0 === t && (t = !0),
        !1 === t ? String(e) : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;")
    }
      , YN = function(e) {
        return Object.keys(e).reduce((function(t, n) {
            var r = void 0 !== e[n] ? n + '="' + e[n] + '"' : "" + n;
            return t ? t + " " + r : r
        }
        ), "")
    }
      , WN = function(e, t) {
        return void 0 === t && (t = {}),
        Object.keys(e).reduce((function(t, n) {
            return t[DN[n] || n] = e[n],
            t
        }
        ), t)
    }
      , $N = function(e, t) {
        return t.map((function(t, n) {
            var r, i = ((r = {
                key: n
            })["data-rh"] = !0,
            r);
            return Object.keys(t).forEach((function(e) {
                var n = DN[e] || e;
                "innerHTML" === n || "cssText" === n ? i.dangerouslySetInnerHTML = {
                    __html: t.innerHTML || t.cssText
                } : i[n] = t[e]
            }
            )),
            aC.a.createElement(e, i)
        }
        ))
    }
      , XN = function(e, t, n) {
        switch (e) {
        case EN.TITLE:
            return {
                toComponent: function() {
                    return n = t.titleAttributes,
                    (r = {
                        key: e = t.title
                    })["data-rh"] = !0,
                    i = WN(n, r),
                    [aC.a.createElement(EN.TITLE, i, e)];
                    var e, n, r, i
                },
                toString: function() {
                    return function(e, t, n, r) {
                        var i = YN(n)
                          , o = BN(t);
                        return i ? "<" + e + ' data-rh="true" ' + i + ">" + KN(o, r) + "</" + e + ">" : "<" + e + ' data-rh="true">' + KN(o, r) + "</" + e + ">"
                    }(e, t.title, t.titleAttributes, n)
                }
            };
        case "bodyAttributes":
        case "htmlAttributes":
            return {
                toComponent: function() {
                    return WN(t)
                },
                toString: function() {
                    return YN(t)
                }
            };
        default:
            return {
                toComponent: function() {
                    return $N(e, t)
                },
                toString: function() {
                    return function(e, t, n) {
                        return t.reduce((function(t, r) {
                            var i = Object.keys(r).filter((function(e) {
                                return !("innerHTML" === e || "cssText" === e)
                            }
                            )).reduce((function(e, t) {
                                var i = void 0 === r[t] ? t : t + '="' + KN(r[t], n) + '"';
                                return e ? e + " " + i : i
                            }
                            ), "")
                              , o = r.innerHTML || r.cssText || ""
                              , s = -1 === HN.indexOf(e);
                            return t + "<" + e + ' data-rh="true" ' + i + (s ? "/>" : ">" + o + "</" + e + ">")
                        }
                        ), "")
                    }(e, t, n)
                }
            }
        }
    }
      , JN = function(e) {
        var t = e.baseTag
          , n = e.bodyAttributes
          , r = e.encode
          , i = e.htmlAttributes
          , o = e.noscriptTags
          , s = e.styleTags
          , a = e.title
          , c = void 0 === a ? "" : a
          , u = e.titleAttributes
          , l = e.linkTags
          , d = e.metaTags
          , h = e.scriptTags
          , f = {
            toComponent: function() {},
            toString: function() {
                return ""
            }
        };
        if (e.prioritizeSeoTags) {
            var p = function(e) {
                var t = e.linkTags
                  , n = e.scriptTags
                  , r = e.encode
                  , i = GN(e.metaTags, RN)
                  , o = GN(t, CN)
                  , s = GN(n, NN);
                return {
                    priorityMethods: {
                        toComponent: function() {
                            return [].concat($N(EN.META, i.priority), $N(EN.LINK, o.priority), $N(EN.SCRIPT, s.priority))
                        },
                        toString: function() {
                            return XN(EN.META, i.priority, r) + " " + XN(EN.LINK, o.priority, r) + " " + XN(EN.SCRIPT, s.priority, r)
                        }
                    },
                    metaTags: i.default,
                    linkTags: o.default,
                    scriptTags: s.default
                }
            }(e);
            f = p.priorityMethods,
            l = p.linkTags,
            d = p.metaTags,
            h = p.scriptTags
        }
        return {
            priority: f,
            base: XN(EN.BASE, t, r),
            bodyAttributes: XN("bodyAttributes", n, r),
            htmlAttributes: XN("htmlAttributes", i, r),
            link: XN(EN.LINK, l, r),
            meta: XN(EN.META, d, r),
            noscript: XN(EN.NOSCRIPT, o, r),
            script: XN(EN.SCRIPT, h, r),
            style: XN(EN.STYLE, s, r),
            title: XN(EN.TITLE, {
                title: c,
                titleAttributes: u
            }, r)
        }
    }
      , ZN = []
      , eR = function(e, t) {
        var n = this;
        void 0 === t && (t = "undefined" != typeof document),
        this.instances = [],
        this.value = {
            setHelmet: function(e) {
                n.context.helmet = e
            },
            helmetInstances: {
                get: function() {
                    return n.canUseDOM ? ZN : n.instances
                },
                add: function(e) {
                    (n.canUseDOM ? ZN : n.instances).push(e)
                },
                remove: function(e) {
                    var t = (n.canUseDOM ? ZN : n.instances).indexOf(e);
                    (n.canUseDOM ? ZN : n.instances).splice(t, 1)
                }
            }
        },
        this.context = e,
        this.canUseDOM = t,
        t || (e.helmet = JN({
            baseTag: [],
            bodyAttributes: {},
            encodeSpecialCharacters: !0,
            htmlAttributes: {},
            linkTags: [],
            metaTags: [],
            noscriptTags: [],
            scriptTags: [],
            styleTags: [],
            title: "",
            titleAttributes: {}
        }))
    }
      , tR = aC.a.createContext({})
      , nR = vN.a.shape({
        setHelmet: vN.a.func,
        helmetInstances: vN.a.shape({
            get: vN.a.func,
            add: vN.a.func,
            remove: vN.a.func
        })
    })
      , rR = "undefined" != typeof document
      , iR = function(e) {
        function t(n) {
            var r;
            return (r = e.call(this, n) || this).helmetData = new eR(r.props.context,t.canUseDOM),
            r
        }
        return wN(t, e),
        t.prototype.render = function() {
            return aC.a.createElement(tR.Provider, {
                value: this.helmetData.value
            }, this.props.children)
        }
        ,
        t
    }(sC.Component);
    iR.canUseDOM = rR,
    iR.propTypes = {
        context: vN.a.shape({
            helmet: vN.a.shape()
        }),
        children: vN.a.node.isRequired
    },
    iR.defaultProps = {
        context: {}
    },
    iR.displayName = "HelmetProvider";
    var oR = function(e, t) {
        var n, r = document.head || document.querySelector(EN.HEAD), i = r.querySelectorAll(e + "[data-rh]"), o = [].slice.call(i), s = [];
        return t && t.length && t.forEach((function(t) {
            var r = document.createElement(e);
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && ("innerHTML" === i ? r.innerHTML = t.innerHTML : "cssText" === i ? r.styleSheet ? r.styleSheet.cssText = t.cssText : r.appendChild(document.createTextNode(t.cssText)) : r.setAttribute(i, void 0 === t[i] ? "" : t[i]));
            r.setAttribute("data-rh", "true"),
            o.some((function(e, t) {
                return n = t,
                r.isEqualNode(e)
            }
            )) ? o.splice(n, 1) : s.push(r)
        }
        )),
        o.forEach((function(e) {
            return e.parentNode.removeChild(e)
        }
        )),
        s.forEach((function(e) {
            return r.appendChild(e)
        }
        )),
        {
            oldTags: o,
            newTags: s
        }
    }
      , sR = function(e, t) {
        var n = document.getElementsByTagName(e)[0];
        if (n) {
            for (var r = n.getAttribute("data-rh"), i = r ? r.split(",") : [], o = [].concat(i), s = Object.keys(t), a = 0; a < s.length; a += 1) {
                var c = s[a]
                  , u = t[c] || "";
                n.getAttribute(c) !== u && n.setAttribute(c, u),
                -1 === i.indexOf(c) && i.push(c);
                var l = o.indexOf(c);
                -1 !== l && o.splice(l, 1)
            }
            for (var d = o.length - 1; d >= 0; d -= 1)
                n.removeAttribute(o[d]);
            i.length === o.length ? n.removeAttribute("data-rh") : n.getAttribute("data-rh") !== s.join(",") && n.setAttribute("data-rh", s.join(","))
        }
    }
      , aR = function(e, t) {
        var n = e.baseTag
          , r = e.htmlAttributes
          , i = e.linkTags
          , o = e.metaTags
          , s = e.noscriptTags
          , a = e.onChangeClientState
          , c = e.scriptTags
          , u = e.styleTags
          , l = e.title
          , d = e.titleAttributes;
        sR(EN.BODY, e.bodyAttributes),
        sR(EN.HTML, r),
        function(e, t) {
            void 0 !== e && document.title !== e && (document.title = BN(e)),
            sR(EN.TITLE, t)
        }(l, d);
        var h = {
            baseTag: oR(EN.BASE, n),
            linkTags: oR(EN.LINK, i),
            metaTags: oR(EN.META, o),
            noscriptTags: oR(EN.NOSCRIPT, s),
            scriptTags: oR(EN.SCRIPT, c),
            styleTags: oR(EN.STYLE, u)
        }
          , f = {}
          , p = {};
        Object.keys(h).forEach((function(e) {
            var t = h[e]
              , n = t.newTags
              , r = t.oldTags;
            n.length && (f[e] = n),
            r.length && (p[e] = h[e].oldTags)
        }
        )),
        t && t(),
        a(e, f, p)
    }
      , cR = null
      , uR = function(e) {
        function t() {
            for (var t, n = arguments.length, r = new Array(n), i = 0; i < n; i++)
                r[i] = arguments[i];
            return (t = e.call.apply(e, [this].concat(r)) || this).rendered = !1,
            t
        }
        wN(t, e);
        var n = t.prototype;
        return n.shouldComponentUpdate = function(e) {
            return !IN()(e, this.props)
        }
        ,
        n.componentDidUpdate = function() {
            this.emitChange()
        }
        ,
        n.componentWillUnmount = function() {
            this.props.context.helmetInstances.remove(this),
            this.emitChange()
        }
        ,
        n.emitChange = function() {
            var e, t, n = this.props.context, r = n.setHelmet, i = null, o = (e = n.helmetInstances.get().map((function(e) {
                var t = xN({}, e.props);
                return delete t.context,
                t
            }
            )),
            {
                baseTag: UN(["href"], e),
                bodyAttributes: VN("bodyAttributes", e),
                defer: kN(e, "defer"),
                encode: kN(e, "encodeSpecialCharacters"),
                htmlAttributes: VN("htmlAttributes", e),
                linkTags: qN(EN.LINK, ["rel", "href"], e),
                metaTags: qN(EN.META, ["name", "charset", "http-equiv", "property", "itemprop"], e),
                noscriptTags: qN(EN.NOSCRIPT, ["innerHTML"], e),
                onChangeClientState: LN(e),
                scriptTags: qN(EN.SCRIPT, ["src", "innerHTML"], e),
                styleTags: qN(EN.STYLE, ["cssText"], e),
                title: jN(e),
                titleAttributes: VN("titleAttributes", e),
                prioritizeSeoTags: QN(e, "prioritizeSeoTags")
            });
            iR.canUseDOM ? (t = o,
            cR && cancelAnimationFrame(cR),
            t.defer ? cR = requestAnimationFrame((function() {
                aR(t, (function() {
                    cR = null
                }
                ))
            }
            )) : (aR(t),
            cR = null)) : JN && (i = JN(o)),
            r(i)
        }
        ,
        n.init = function() {
            this.rendered || (this.rendered = !0,
            this.props.context.helmetInstances.add(this),
            this.emitChange())
        }
        ,
        n.render = function() {
            return this.init(),
            null
        }
        ,
        t
    }(sC.Component);
    uR.propTypes = {
        context: nR.isRequired
    },
    uR.displayName = "HelmetDispatcher";
    var lR = ["children"]
      , dR = ["children"]
      , hR = function(e) {
        function t() {
            return e.apply(this, arguments) || this
        }
        wN(t, e);
        var n = t.prototype;
        return n.shouldComponentUpdate = function(e) {
            return !_N()(zN(this.props, "helmetData"), zN(e, "helmetData"))
        }
        ,
        n.mapNestedChildrenToProps = function(e, t) {
            if (!t)
                return null;
            switch (e.type) {
            case EN.SCRIPT:
            case EN.NOSCRIPT:
                return {
                    innerHTML: t
                };
            case EN.STYLE:
                return {
                    cssText: t
                };
            default:
                throw new Error("<" + e.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.")
            }
        }
        ,
        n.flattenArrayTypeChildren = function(e) {
            var t, n = e.child, r = e.arrayTypeChildren;
            return xN({}, r, ((t = {})[n.type] = [].concat(r[n.type] || [], [xN({}, e.newChildProps, this.mapNestedChildrenToProps(n, e.nestedChildren))]),
            t))
        }
        ,
        n.mapObjectTypeChildren = function(e) {
            var t, n, r = e.child, i = e.newProps, o = e.newChildProps, s = e.nestedChildren;
            switch (r.type) {
            case EN.TITLE:
                return xN({}, i, ((t = {})[r.type] = s,
                t.titleAttributes = xN({}, o),
                t));
            case EN.BODY:
                return xN({}, i, {
                    bodyAttributes: xN({}, o)
                });
            case EN.HTML:
                return xN({}, i, {
                    htmlAttributes: xN({}, o)
                });
            default:
                return xN({}, i, ((n = {})[r.type] = xN({}, o),
                n))
            }
        }
        ,
        n.mapArrayTypeChildrenToProps = function(e, t) {
            var n = xN({}, t);
            return Object.keys(e).forEach((function(t) {
                var r;
                n = xN({}, n, ((r = {})[t] = e[t],
                r))
            }
            )),
            n
        }
        ,
        n.warnOnInvalidChildren = function(e, t) {
            return ON()(PN.some((function(t) {
                return e.type === t
            }
            )), "function" == typeof e.type ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : "Only elements types " + PN.join(", ") + " are allowed. Helmet does not support rendering <" + e.type + "> elements. Refer to our API for more information."),
            ON()(!t || "string" == typeof t || Array.isArray(t) && !t.some((function(e) {
                return "string" != typeof e
            }
            )), "Helmet expects a string as a child of <" + e.type + ">. Did you forget to wrap your children in braces? ( <" + e.type + ">{``}</" + e.type + "> ) Refer to our API for more information."),
            !0
        }
        ,
        n.mapChildrenToProps = function(e, t) {
            var n = this
              , r = {};
            return aC.a.Children.forEach(e, (function(e) {
                if (e && e.props) {
                    var i = e.props
                      , o = i.children
                      , s = AN(i, lR)
                      , a = Object.keys(s).reduce((function(e, t) {
                        return e[FN[t] || t] = s[t],
                        e
                    }
                    ), {})
                      , c = e.type;
                    switch ("symbol" == typeof c ? c = c.toString() : n.warnOnInvalidChildren(e, o),
                    c) {
                    case EN.FRAGMENT:
                        t = n.mapChildrenToProps(o, t);
                        break;
                    case EN.LINK:
                    case EN.META:
                    case EN.NOSCRIPT:
                    case EN.SCRIPT:
                    case EN.STYLE:
                        r = n.flattenArrayTypeChildren({
                            child: e,
                            arrayTypeChildren: r,
                            newChildProps: a,
                            nestedChildren: o
                        });
                        break;
                    default:
                        t = n.mapObjectTypeChildren({
                            child: e,
                            newProps: t,
                            newChildProps: a,
                            nestedChildren: o
                        })
                    }
                }
            }
            )),
            this.mapArrayTypeChildrenToProps(r, t)
        }
        ,
        n.render = function() {
            var e = this.props
              , t = e.children
              , n = AN(e, dR)
              , r = xN({}, n)
              , i = n.helmetData;
            return t && (r = this.mapChildrenToProps(t, r)),
            !i || i instanceof eR || (i = new eR(i.context,i.instances)),
            i ? aC.a.createElement(uR, xN({}, r, {
                context: i.value,
                helmetData: void 0
            })) : aC.a.createElement(tR.Consumer, null, (function(e) {
                return aC.a.createElement(uR, xN({}, r, {
                    context: e
                }))
            }
            ))
        }
        ,
        t
    }(sC.Component);
    hR.propTypes = {
        base: vN.a.object,
        bodyAttributes: vN.a.object,
        children: vN.a.oneOfType([vN.a.arrayOf(vN.a.node), vN.a.node]),
        defaultTitle: vN.a.string,
        defer: vN.a.bool,
        encodeSpecialCharacters: vN.a.bool,
        htmlAttributes: vN.a.object,
        link: vN.a.arrayOf(vN.a.object),
        meta: vN.a.arrayOf(vN.a.object),
        noscript: vN.a.arrayOf(vN.a.object),
        onChangeClientState: vN.a.func,
        script: vN.a.arrayOf(vN.a.object),
        style: vN.a.arrayOf(vN.a.object),
        title: vN.a.string,
        titleAttributes: vN.a.object,
        titleTemplate: vN.a.string,
        prioritizeSeoTags: vN.a.bool,
        helmetData: vN.a.object
    },
    hR.defaultProps = {
        defer: !0,
        encodeSpecialCharacters: !0,
        prioritizeSeoTags: !1
    },
    hR.displayName = "Helmet";
    const fR = ["author", "description", "keywords", "title"]
      , pR = (e, t, n) => {
        const r = e.routeKeys;
        for (let i of r)
            n[i] && (e[i] = n[i]);
        e.uidPath = n.uidPath,
        e.record = t
    }
      , gR = (e, t) => {
        const n = e.getState();
        if (!n.match)
            return !1;
        const r = n.props.route;
        return r.path && (!t.uidPath || r.uidPath.length > t.uidPath.length) && pR(t, e, r),
        !0
    }
    ;
    const mR = (e, t) => {
        if (!e)
            return t;
        t || (t = []);
        for (let n in e)
            t.push(GC("link", {
                rel: "preconnect",
                crossOrigin: e[n]
            }, n));
        return t
    }
      , yR = ["appleTouchIcons", "appleStartupImages", "appleStatusBarStyle", "applicationName", "author", "charSet", "description", "favicons", "faviconsSuffix", "keywords", "manifest", "manifestIconsBasePath", "msApplication", "title", "version", "viewport"]
      , vR = ["author", "charSet", "description", "favicons", "keywords", "title", "version", "viewport"]
      , bR = (e, t) => {
        const {logic: n} = e
          , r = "".concat(e.themeType, "-theme")
          , {html: i} = e;
        i ? i.className ? i.className += " ".concat(r) : i.className = r : e.html = {
            className: r
        },
        e.href = e.location.href,
        e.pathname = e.location.pathname,
        e.webAppThemeColor = e.palette.base.primary.dark,
        function(e, t) {
            t ? t.routeKeys || (t.routeKeys = fR) : t = {
                routeKeys: fR
            };
            const n = e.getState()
              , r = n.props.route;
            let i;
            if (pR(t, e, r),
            t.title && Object(DC.d)(n) && n.match && !n.match.isExact && t.location && ({title: i} = t),
            e.walk(gR, t),
            t.record === e)
                t.relPath = "/";
            else {
                let e = t.pathname;
                e || (e = t.location ? t.location.pathname : t.record.props.route.absPath),
                t.relPath = Object(uN.a)(e.replace(Object(uN.b)(r.absPath), "")),
                t.title === i && (t.title = t.location.title || t.location.pathToTitle(t.relPath))
            }
        }(n, e);
        const o = t.pwaDisabled ? vR : yR;
        for (let s of o)
            e[s] || (e[s] = t[s]);
        return e.version || (e.version = "1.0"),
        e.viewport || (e.viewport = "viewport-fit=cover, width=device-width, initial-scale=1.0, shrink-to-fit=no"),
        n.itemEnum.renderItems(t.children, e),
        e.layoutTitle || (e.layoutTitle = e.location.pathToTitle(e.relPath)) || (e.layoutTitle = n.props.route.title || "Home"),
        e.children = mR(t.preConnect, mR(e.preConnect, e.children)),
        e
    }
      , _R = ["pathname"]
      , SR = [["props", "palette"], ["props", "head"], ["localProps", "fetchPathsInFlight"]]
      , OR = aC.a.memo((function(e) {
        let {children: t, insertCss: n, logic: r, location: i, renderer: o, session: s} = e;
        const a = aN(i, _R)
          , c = aN(r, SR)
          , u = function(e) {
            const [t,n] = iN();
            return Object(sC.useEffect)( () => {
                if (!e)
                    return;
                let n = !!Object(Le.a)(cN, e);
                const r = e.subscribeTo(cN).subscribe( () => {
                    n = !n,
                    n || t()
                }
                );
                return () => r.unsubscribe()
            }
            , [e]),
            n
        }(r)
          , l = gN()
          , d = pN();
        let h = function(e) {
            const t = Object(sC.useContext)(ZC) || e
              , n = aN(t, mN);
            return Object(sC.useMemo)( () => t ? t.getThemeType() : null, [t, n])
        }(s);
        const f = Object(sC.useRef)(!0);
        f.current && (f.current = !1,
        h = s.getThemeType() || s.findThemeType(!0),
        s.setThemeType(h));
        const {localProps: p} = r
          , g = p && p.fetchPathsInFlight || null
          , [m,y] = Object(sC.useMemo)( () => {
            const {props: e} = r
              , t = bR({
                fetchPathsInFlight: g,
                imgLocation: l,
                staticAssetsLocation: d,
                insertCss: n,
                location: i,
                logic: r,
                renderer: o,
                session: s,
                palette: e.palette,
                themeType: h
            }, e.head);
            return [t, r.itemEnum.renderItem(e.head, t)]
        }
        , [l, n, i, a, r, c, g, u, o, s, h]);
        return aC.a.createElement(aC.a.Fragment, null, y, GC(WC.Provider, {
            value: m
        }, void 0, t))
    }
    ))
      , TR = aC.a.memo((function(e) {
        let {children: t} = e;
        const n = Object(sC.useContext)(tN)
          , r = iN();
        if (r[3] !== n) {
            const e = n ? n.user : null;
            r[3] = n,
            r[4] && r[4].user === e || (r[4] = {
                user: e
            })
        }
        const i = r[4];
        return Object(sC.useEffect)( () => {
            const {user: e} = r[4];
            if (!e)
                return;
            const t = e.subscribe( () => {
                r[4] = {
                    user: e
                },
                r[0]()
            }
            );
            return () => t.unsubscribe()
        }
        , [r, i.user]),
        GC(eN.Provider, {
            value: i
        }, void 0, t)
    }
    ))
      , IR = Object(sC.createContext)(null);
    const xR = {
        isHydrate: !0,
        firstRenderSrc$: void 0,
        ofFirstRender$: void 0
    }
      , wR = () => {
        xR.isHydrate && (xR.isHydrate = !1)
    }
    ;
    var MR, AR, ER;
    MR = VC,
    AR = function(e) {
        const t = e.meta.instance.getMutableRecord(e).getMutableLocalProps();
        return t.insertCss = kC,
        t.realMessageQueue || (t.realMessageQueue = {}),
        t.messageQueue = (e => {
            const t = t => "addMessage" === t ? n => {
                e[t] && e[t]("string" === typeof n ? {
                    children: n
                } : n)
            }
            : () => {
                e[t] && e[t]()
            }
            ;
            return {
                addMessage: t("addMessage"),
                hideMessage: t("hideMessage"),
                popMessage: t("popMessage"),
                resetQueue: t("resetQueue"),
                restartTimer: t("restartTimer"),
                startTimer: t("startTimer"),
                stopTimer: t("stopTimer")
            }
        }
        )(t.realMessageQueue),
        t.Renderer = PC,
        t.queryUiMgr && !t.queryUiMgr.get("addMessage") && t.queryUiMgr.value.set("addMessage", t.messageQueue.addMessage),
        e
    }
    ,
    NC.a.use().setOp(QC).setPriority(qC).setActionType(c.m).setPure(!0).setName("prepareReactRouterProps").setType(DC.b).setLogicMgr(MR, "./init").setDescription(ER).add(AR, !0),
    NC.a.use().setName("hydrate").setOp(jC).setPriority(1e3).setActionType(c.m).setType(DC.b).setPure(!0).setLogicMgr(VC, "./init"),
    NC.a.add((function(e) {
        const {meta: t, payload: n} = e;
        let {rootProps: r} = n;
        const {localProps: i, props: {htmlContainerId: o}} = t.store.getState();
        r || (r = i.rootProps ? {
            ...i.rootProps
        } : {}),
        r.logic = t.instance.getMainInstance(),
        r.session = t.getSession().getMainInstance(),
        r.insertCss = i.insertCss;
        let s = n.renderer || i.renderer;
        s || (s = i.Renderer.init(r.logic.componentEnum, null)),
        r.Head = OR;
        let a = CC.hydrate;
        const c = document.getElementById(o);
        return window.isReload && c.firstChild && (Object(CC.unmountComponentAtNode)(c),
        a = CC.render),
        t.mainActionMeta.pipe(Object(R.a)(5)).subscribe( () => {
            r.location = r.session.location,
            r.plugin = r.session.plugin.pluginInstance,
            a(function(e, t, n, r) {
                return GC(iR, {
                    context: e.helmetContext
                }, "helmetProvider", GC(YC.Provider, {
                    value: {
                        insertCss: e.insertCss
                    }
                }, void 0, GC(IR.Provider, {
                    value: t
                }, void 0, GC(JC.Provider, {
                    value: e.logic
                }, void 0, GC(ZC.Provider, {
                    value: e.session
                }, void 0, GC($C.Provider, {
                    value: e.location
                }, void 0, GC(XC.Provider, {
                    value: e.plugin
                }, void 0, GC(n, {
                    session: e.session
                }, void 0, GC(r, {}, void 0, Object(sC.createElement)(e.logic.component, e))))))))))
            }(r, s, nN, TR), c, wR),
            a === CC.render && console.log("App Re-Rendered"),
            (n.onRender || i.onRender) && setTimeout(n.onRender || i.onRender, 100)
        }
        ),
        e
    }
    ), !0);
    n(195);
    const CR = {}
      , NR = {}
      , RR = {};
    let PR = null;
    const DR = (e, t) => {
        const n = NR[e];
        RR[e] = void 0,
        NR[e] = void 0,
        CR[e] = t,
        t.error ? console.log("[".concat(e, "]: SDK init failed")) : console.log("[".concat(e, "]: SDK ready")),
        n && (n.next(t),
        n.complete())
    }
    ;
    window.__PRELOAD_STATE_READY__ = !0,
    window.toMainInstance = () => Object(iM.a)(!0);
    let FR = (EC ? Object(V.a)(!0) : new S.a(e => {
        EC ? (e.next(!0),
        e.complete()) : function(e, t) {
            void 0 === e && (e = function() {}
            );
            var n = void 0 === t ? {} : t
              , r = n.namespace
              , i = void 0 === r ? "" : r
              , o = n.chunkLoadingGlobal
              , s = void 0 === o ? "__LOADABLE_LOADED_CHUNKS__" : o;
            if (!MC)
                return gC("`loadableReady()` must be called in browser only"),
                e(),
                Promise.resolve();
            var a = null;
            if (MC) {
                var c = yC(i)
                  , u = document.getElementById(c);
                if (u) {
                    a = JSON.parse(u.textContent);
                    var l = document.getElementById(c + "_ext");
                    if (!l)
                        throw new Error("loadable-component: @loadable/server does not match @loadable/component");
                    JSON.parse(l.textContent).namedChunks.forEach((function(e) {
                        vC.initialChunks[e] = !0
                    }
                    ))
                }
            }
            if (!a)
                return gC("`loadableReady()` requires state, please use `getScriptTags` or `getScriptElements` server-side"),
                e(),
                Promise.resolve();
            var d = !1;
            new Promise((function(e) {
                window[s] = window[s] || [];
                var t = window[s]
                  , n = t.push.bind(t);
                function r() {
                    a.every((function(e) {
                        return t.some((function(t) {
                            return t[0].indexOf(e) > -1
                        }
                        ))
                    }
                    )) && (d || (d = !0,
                    e()))
                }
                t.push = function() {
                    n.apply(void 0, arguments),
                    r()
                }
                ,
                r()
            }
            )).then(e)
        }( () => {
            if (!0 === window.__PRELOAD_STATE_READY__)
                return EC = !0,
                e.next(!0),
                void e.complete();
            const t = () => {
                EC = !0,
                e.next(!0),
                e.complete(),
                window.removeEventListener("__PRELOAD_STATE__", t)
            }
            ;
            window.addEventListener("__PRELOAD_STATE__", t)
        }
        )
    }
    )).pipe(Object(Y.a)( () => {
        FR = Object(V.a)(!0)
    }
    ), Object(_g.a)());
    FR.subscribe();
    const kR = (e, t) => (e || (e = PR)) && CR[e] ? CR[e][t] : null;
    window.initVitalStatsSDK = function(e) {
        e = (e => {
            if (!e || !e.slug || !e.apiKey)
                throw new Error("Missing required options: slug and/or apiKey");
            return e.slug = e.slug.toLowerCase(),
            e.appUrl || (e.appUrl = "https://".concat(e.slug, ".vitalstats.app")),
            e.isDefault ? PR = e.slug : e.isDefault = !1,
            "boolean" !== typeof e.enableHistoryModels && (e.enableHistoryModels = !1),
            e
        }
        )(e);
        const {slug: t} = e;
        return RR[t] ? RR[t] : !CR[t] || CR[t].error || e.forceRecreate ? (CR[t] = void 0,
        function(e) {
            const {appUrl: t, slug: n, apiKey: i} = e
              , o = new U.a;
            NR[n] = o,
            RR[n] = Object(qs.a)( () => CR[n] ? Object(V.a)(CR[n]) : NR[n].asObservable());
            const a = "".concat(n, "__vsuid");
            let c;
            const u = s.a.create({
                customizePlugin: function(t) {
                    const r = t.builder;
                    r.setStoreConfig("clientConnections", c.__CONNECTIONS__).setPackageName("@isomorix/vitalstats-main").setModuleName("@isomorix/vitalstats-main").addDefaultLogic().addPackage(wE).addPackage(CE).addPackage(oC),
                    r.setPayload("coreApiKey", i),
                    r.setPayload("__PRELOAD_STATE__", c),
                    e.enableHistoryModels || r.setPayload("initHistoryDisabled", !0),
                    c = void 0,
                    console.log("[".concat(n, "]: customizing SDK...")),
                    r.subscribeToAction(e => {
                        const t = e.meta.store.mainStore;
                        e.meta.mainActionMeta.subscribe({
                            complete: () => {
                                DR(n, {
                                    store: t,
                                    plugin: t.instance
                                })
                            }
                        })
                    }
                    )
                },
                CoreBuilder: IA,
                devLoader: r.a
            });
            e.isDefault && (window.enableDevMode = u.enableDevMode);
            let l = 0;
            const d = () => {
                FR.pipe(Object(P.a)( () => fetch(t, {
                    method: "POST",
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/json",
                        "Api-Key": i
                    },
                    body: JSON.stringify({
                        sessionUid: localStorage.getItem(a) || !0,
                        href: window.location.href
                    })
                })), Object(D.b)()).subscribe({
                    next: e => {
                        if (e && 200 === e.statusCode) {
                            const {data: t} = e;
                            c = t.preloadState,
                            localStorage.setItem(a, c.__SESSION__[Ro.d]),
                            u.init()
                        } else if ((!e || e.statusCode >= 500) && l < 5)
                            l++,
                            B(Math.min(2e3 * l, 8e3)).subscribe( () => {
                                CR[n] || NR[n] !== o || d()
                            }
                            );
                        else {
                            const t = new Error("Failed to fetch preload state");
                            t.statusCode = e && e.statusCode,
                            DR(n, {
                                plugin: null,
                                store: null,
                                error: t
                            })
                        }
                    }
                    ,
                    error: e => {
                        DR(n, {
                            plugin: null,
                            store: null,
                            error: e
                        })
                    }
                })
            }
            ;
            d()
        }(e),
        RR[t]) : Object(V.a)(CR[t])
    }
    ,
    window.getVitalStatsPlugin = function(e) {
        return kR(e, "plugin")
    }
    ,
    window.getVitalStatsStore = function(e) {
        return kR(e, "store")
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(391);
    function i(e, t, n) {
        var i;
        return i = e && "object" === typeof e ? e : {
            bufferSize: e,
            windowTime: t,
            refCount: !1,
            scheduler: n
        },
        function(e) {
            return e.lift(function(e) {
                var t, n, i = e.bufferSize, o = void 0 === i ? Number.POSITIVE_INFINITY : i, s = e.windowTime, a = void 0 === s ? Number.POSITIVE_INFINITY : s, c = e.refCount, u = e.scheduler, l = 0, d = !1, h = !1;
                return function(e) {
                    var i;
                    l++,
                    !t || d ? (d = !1,
                    t = new r.a(o,a,u),
                    i = t.subscribe(this),
                    n = e.subscribe({
                        next: function(e) {
                            t.next(e)
                        },
                        error: function(e) {
                            d = !0,
                            t.error(e)
                        },
                        complete: function() {
                            h = !0,
                            n = void 0,
                            t.complete()
                        }
                    }),
                    h && (n = void 0)) : i = t.subscribe(this),
                    this.add((function() {
                        l--,
                        i.unsubscribe(),
                        i = void 0,
                        n && !h && c && 0 === l && (n.unsubscribe(),
                        n = void 0,
                        t = void 0)
                    }
                    ))
                }
            }(i))
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(163)
      , i = n(164);
    function o(e) {
        return Object(r.a)(e) ? "observable" : !!Object(i.a)(e) && "promise"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    let r = () => !0
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(52);
    function i(e, t, n) {
        return void 0 === n && (n = Number.POSITIVE_INFINITY),
        "function" === typeof t ? Object(r.a)((function() {
            return e
        }
        ), t, n) : ("number" === typeof t && (n = t),
        Object(r.a)((function() {
            return e
        }
        ), n))
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var r = n(14)
      , i = n(22)
      , o = n(228)
      , s = n(120);
    function a(e) {
        return function(t) {
            return 0 === e ? Object(s.b)() : t.lift(new c(e))
        }
    }
    var c = function() {
        function e(e) {
            if (this.total = e,
            this.total < 0)
                throw new o.a
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new u(e,this.total))
        }
        ,
        e
    }()
      , u = function(e) {
        function t(t, n) {
            var r = e.call(this, t) || this;
            return r.total = n,
            r.count = 0,
            r
        }
        return r.a(t, e),
        t.prototype._next = function(e) {
            var t = this.total
              , n = ++this.count;
            n <= t && (this.destination.next(e),
            n === t && (this.destination.complete(),
            this.unsubscribe()))
        }
        ,
        t
    }(i.a)
}
, function(e, t, n) {
    "use strict";
    function r(e, t) {
        if (t) {
            if ("string" === typeof e)
                return t[e];
            for (let n of e)
                if (!(t = t[n]))
                    return t;
            return t
        }
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return i
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    ));
    n(286);
    var r = n(17);
    const i = e => e.kind && e.kind === r.a.VARIABLE
      , o = (e, t) => {
        let n;
        for (let r of t)
            if (r.variable.name.value === e) {
                n = r;
                break
            }
        return n
    }
      , s = e => e.kind === r.a.LIST
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = n(62).a
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(295)
      , i = n(101);
    function o() {
        for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t];
        var n = e[e.length - 1];
        return Object(i.a)(n) ? (e.pop(),
        function(t) {
            return Object(r.a)(e, t, n)
        }
        ) : function(t) {
            return Object(r.a)(e, t)
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(14)
      , i = n(57);
    function o(e) {
        return function(t) {
            return t.lift(new s(e))
        }
    }
    var s = function() {
        function e(e) {
            this.notifier = e
        }
        return e.prototype.call = function(e, t) {
            var n = new a(e)
              , r = Object(i.c)(this.notifier, new i.a(n));
            return r && !n.seenValue ? (n.add(r),
            t.subscribe(n)) : n
        }
        ,
        e
    }()
      , a = function(e) {
        function t(t) {
            var n = e.call(this, t) || this;
            return n.seenValue = !1,
            n
        }
        return r.a(t, e),
        t.prototype.notifyNext = function() {
            this.seenValue = !0,
            this.complete()
        }
        ,
        t.prototype.notifyComplete = function() {}
        ,
        t
    }(i.b)
}
, function(e, t, n) {
    "use strict";
    function r(e, t, n) {
        const r = e.get(t);
        if (r) {
            let e = r.storeConfig;
            return e || n || (r.storeConfig = e = {}),
            e
        }
    }
    n.d(t, "a", (function() {
        return r
    }
    ))
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    n(234),
    n(159);
    var r = n(397)
      , i = n(58)
      , o = n(166)
      , s = n(136);
    n(162),
    n(242);
    function a(e, t) {
        const n = e.getMutableLocalProps();
        return n.routeCache ? !t && n.routeCache.fetchedPaths || (n.routeCache.fetchedPaths = {}) : n.routeCache = {
            fetchedPaths: {}
        },
        n
    }
    o.a.useRelative(s.a.findByName("trxPrepare", i.n), 50).setName("routePropsMutationWait").setActionType(i.n).setId().setOpMethod( (e, t) => {
        const n = e.payload.buildRoutesAction.meta;
        return n.closed ? e : Object(r.a)(n.asObservable(), e, t)
    }
    ).done()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        PENDING_SETUP: "pending_setup",
        QUEUED: "queued",
        PROCESSING: "processing",
        COMPLETE: "complete",
        ERROR: "error"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return m
    }
    ));
    var r = n(14)
      , i = n(121)
      , o = n(26)
      , s = n(22)
      , a = n(38);
    function c() {
        return function(e) {
            return e.lift(new u(e))
        }
    }
    var u = function() {
        function e(e) {
            this.connectable = e
        }
        return e.prototype.call = function(e, t) {
            var n = this.connectable;
            n._refCount++;
            var r = new l(e,n)
              , i = t.subscribe(r);
            return r.closed || (r.connection = n.connect()),
            i
        }
        ,
        e
    }()
      , l = function(e) {
        function t(t, n) {
            var r = e.call(this, t) || this;
            return r.connectable = n,
            r
        }
        return r.a(t, e),
        t.prototype._unsubscribe = function() {
            var e = this.connectable;
            if (e) {
                this.connectable = null;
                var t = e._refCount;
                if (t <= 0)
                    this.connection = null;
                else if (e._refCount = t - 1,
                t > 1)
                    this.connection = null;
                else {
                    var n = this.connection
                      , r = e._connection;
                    this.connection = null,
                    !r || n && r !== n || r.unsubscribe()
                }
            } else
                this.connection = null
        }
        ,
        t
    }(s.a)
      , d = function(e) {
        function t(t, n) {
            var r = e.call(this) || this;
            return r.source = t,
            r.subjectFactory = n,
            r._refCount = 0,
            r._isComplete = !1,
            r
        }
        return r.a(t, e),
        t.prototype._subscribe = function(e) {
            return this.getSubject().subscribe(e)
        }
        ,
        t.prototype.getSubject = function() {
            var e = this._subject;
            return e && !e.isStopped || (this._subject = this.subjectFactory()),
            this._subject
        }
        ,
        t.prototype.connect = function() {
            var e = this._connection;
            return e || (this._isComplete = !1,
            (e = this._connection = new a.a).add(this.source.subscribe(new f(this.getSubject(),this))),
            e.closed && (this._connection = null,
            e = a.a.EMPTY)),
            e
        }
        ,
        t.prototype.refCount = function() {
            return c()(this)
        }
        ,
        t
    }(o.a)
      , h = function() {
        var e = d.prototype;
        return {
            operator: {
                value: null
            },
            _refCount: {
                value: 0,
                writable: !0
            },
            _subject: {
                value: null,
                writable: !0
            },
            _connection: {
                value: null,
                writable: !0
            },
            _subscribe: {
                value: e._subscribe
            },
            _isComplete: {
                value: e._isComplete,
                writable: !0
            },
            getSubject: {
                value: e.getSubject
            },
            connect: {
                value: e.connect
            },
            refCount: {
                value: e.refCount
            }
        }
    }()
      , f = function(e) {
        function t(t, n) {
            var r = e.call(this, t) || this;
            return r.connectable = n,
            r
        }
        return r.a(t, e),
        t.prototype._error = function(t) {
            this._unsubscribe(),
            e.prototype._error.call(this, t)
        }
        ,
        t.prototype._complete = function() {
            this.connectable._isComplete = !0,
            this._unsubscribe(),
            e.prototype._complete.call(this)
        }
        ,
        t.prototype._unsubscribe = function() {
            var e = this.connectable;
            if (e) {
                this.connectable = null;
                var t = e._connection;
                e._refCount = 0,
                e._subject = null,
                e._connection = null,
                t && t.unsubscribe()
            }
        }
        ,
        t
    }(i.b);
    s.a;
    var p = function() {
        function e(e, t) {
            this.subjectFactory = e,
            this.selector = t
        }
        return e.prototype.call = function(e, t) {
            var n = this.selector
              , r = this.subjectFactory()
              , i = n(r).subscribe(e);
            return i.add(t.subscribe(r)),
            i
        }
        ,
        e
    }();
    function g() {
        return new i.a
    }
    function m() {
        return function(e) {
            return c()((t = g,
            function(e) {
                var r;
                if (r = "function" === typeof t ? t : function() {
                    return t
                }
                ,
                "function" === typeof n)
                    return e.lift(new p(r,n));
                var i = Object.create(e, h);
                return i.source = e,
                i.subjectFactory = r,
                i
            }
            )(e));
            var t, n
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return d
    }
    ));
    var r = n(14)
      , i = 1
      , o = function() {
        return Promise.resolve()
    }()
      , s = {};
    function a(e) {
        return e in s && (delete s[e],
        !0)
    }
    var c = function(e) {
        var t = i++;
        return s[t] = !0,
        o.then((function() {
            return a(t) && e()
        }
        )),
        t
    }
      , u = function(e) {
        a(e)
    }
      , l = function(e) {
        function t(t, n) {
            var r = e.call(this, t, n) || this;
            return r.scheduler = t,
            r.work = n,
            r
        }
        return r.a(t, e),
        t.prototype.requestAsyncId = function(t, n, r) {
            return void 0 === r && (r = 0),
            null !== r && r > 0 ? e.prototype.requestAsyncId.call(this, t, n, r) : (t.actions.push(this),
            t.scheduled || (t.scheduled = c(t.flush.bind(t, null))))
        }
        ,
        t.prototype.recycleAsyncId = function(t, n, r) {
            if (void 0 === r && (r = 0),
            null !== r && r > 0 || null === r && this.delay > 0)
                return e.prototype.recycleAsyncId.call(this, t, n, r);
            0 === t.actions.length && (u(n),
            t.scheduled = void 0)
        }
        ,
        t
    }(n(156).a)
      , d = new (function(e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }
        return r.a(t, e),
        t.prototype.flush = function(e) {
            this.active = !0,
            this.scheduled = void 0;
            var t, n = this.actions, r = -1, i = n.length;
            e = e || n.shift();
            do {
                if (t = e.execute(e.state, e.delay))
                    break
            } while (++r < i && (e = n.shift()));
            if (this.active = !1,
            t) {
                for (; ++r < i && (e = n.shift()); )
                    e.unsubscribe();
                throw t
            }
        }
        ,
        t
    }(n(155).a))(l)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return c
    }
    ));
    var r = n(58)
      , i = n(6)
      , o = n(23)
      , s = n(876);
    const a = s.a.initModule("@isomorix/model-record-shared/logic")
      , c = s.a.initModule("@isomorix/model-record-shared/logic").addSource(a);
    let u;
    u = {};
    const l = c.getBuilder(r.n, "./mutation").setPure(!0);
    l.use().setName("trxPrepare").setPrepareOp().setPriority(200).setTrxSync(i.k).setDescription(u.trxPrepare).add((function(e) {
        return e
    }
    ), !0),
    l.useRelative(1100).setName("trxOptimisticExecute").setTrxSync(i.h).setDescription(u.trxOptimisticExecute).add((function(e) {
        return e
    }
    ), !0),
    l.use().setName("beforeEachCommit").setOp([o.g, o.e]).setPriority(1).setDescription(u.beforeEachCommit).addTo(a),
    l.useRelative(999).setName("trxOptimisticCommit").setTransformOp().setTrxSync(i.f).setTrxSync(i.j).setDescription(u.trxOptimisticCommit).add((function(e) {
        return e
    }
    ), !0),
    l.useRelative(1).setName("beforeEachNotify").setDescription(u.beforeEachNotify).addTo(a),
    l.useRelative(99).setName("trxOptimisticNotify").setTrxSync(i.i).setDescription(u.trxOptimisticNotify).add((function(e) {
        return e
    }
    ), !0),
    l.useRelative(1).setName("afterEachCommit").setOp([o.g, o.e]).setDescription(u.afterEachCommit).addTo(a),
    l.useRelative(100).setName("trxOptimisticComplete").setTransformOp().setTrxSync(i.g).setDescription(u.trxOptimisticComplete).add((function(e) {
        return e
    }
    ), !0),
    l.useRelative(100).setName("trxExecute").setTrxSync(i.d).setDescription(u.trxExecute).add((function(e) {
        return e
    }
    ), !0),
    l.use().setName("trxCommit").setFinalizeOp().setPriority(1e3).setTrxSync(i.a).setTrxSync(i.l).setDescription(u.trxCommit).add((function(e) {
        return e
    }
    ), !0),
    l.useRelative(100).setName("trxNotify").setTrxSync(i.e).setDescription(u.trxNotify).add((function(e) {
        return e
    }
    ), !0),
    l.useRelative(100).setName("trxComplete").setTrxSync(i.b).setDescription(u.trxComplete).add((function(e) {
        return e
    }
    ), !0),
    l.setPure(!1)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    ));
    const r = (e=21) => crypto.getRandomValues(new Uint8Array(e)).reduce( (e, t) => e += (t &= 63) < 36 ? t.toString(36) : t < 62 ? (t - 26).toString(36).toUpperCase() : t > 62 ? "-" : "_", "")
      , i = /-/g;
    function o() {
        const e = "s_".concat(r().replace(i, "_"));
        return i.lastIndex = 0,
        e
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return p
    }
    )),
    n.d(t, "b", (function() {
        return g
    }
    ));
    var r = n(1)
      , i = n(399)
      , o = n(395)
      , s = n(79)
      , a = n(296)
      , c = n(165)
      , u = n(154);
    class l extends Array {
        static initModule(e) {
            return (new this).setModuleName(e).setLogicBuilder(this.LogicBuilder).setEnumType(this.enumType).setOps(this.ops).setValidateOptions(this.validateOptions)
        }
        static init() {
            return (new this).setLogicBuilder(this.LogicBuilder).setEnumType(this.enumType).setOps(this.ops).setValidateOptions(this.validateOptions)
        }
        parseModuleName(e) {
            return Object(o.a)(this, e, this.moduleName, this.packageName)
        }
        createNewInstance() {
            const e = new this.constructor;
            return e.enumType = this.enumType,
            e.env = this.env,
            e.LogicBuilder = this.LogicBuilder,
            e.moduleName = this.moduleName,
            e.ops = this.ops,
            e.packageName = this.packageName,
            e.validateOptions = this.validateOptions,
            e
        }
        setPackageName(e) {
            return this.packageName = e,
            this
        }
        setModuleName(e) {
            return this.moduleName = Object(o.a)(this, e, this.moduleName, this.packageName, "packageName"),
            this
        }
        setOps(e) {
            return this.ops = e,
            this
        }
        setLogicBuilder(e) {
            return this.LogicBuilder = e,
            this
        }
        setEnumType(e) {
            return this.enumType = e,
            this
        }
        setValidateOptions(e) {
            if (!e) {
                if (this.validateOptions)
                    return this;
                if (!this.ops)
                    throw new Error("Unable to setValidate(), a validate function was not provided and it could not be created automatically because ops are not set either.")
            }
            return this.validateOptions = e,
            this
        }
        setEnv(e) {
            return this.env = e,
            this
        }
        addSource(e) {
            return e ? (this.sources ? this.sources.indexOf(e) < 0 && this.sources.push(e) : this.sources = [e],
            this) : this
        }
        useSources(e) {
            const t = this.sources;
            if (!t)
                return this;
            let n;
            for (let r of t)
                if (!e || r.env === e)
                    for (n of r)
                        this.add(n);
            return this
        }
        addBuilder(e) {
            const t = e.DEFAULTS[r.a];
            if (!t)
                throw new Error("Unable to addBuilder to this LogicMgr because there is no ACTION_TYPE property associated with the builder. Builders are cached by the ACTION_TYPE that they are associated with.");
            let n = this.builders;
            if (n || (n = {},
            this.builders = n),
            Array.isArray(t))
                for (let r of t) {
                    if ("string" !== typeof r)
                        throw new Error("Unable to addBuilder to this LogicMgr because the builder uses an Array of action types and an entry in the Array is a ".concat(typeof r, ". Each entry must be a string."));
                    n[r] = e
                }
            else {
                if ("string" !== typeof t)
                    throw new Error("Unable to addBuilder to this LogicMgr because the builder uses an ACTION_TYPE that is a ".concat(typeof t, ". The ACTION_TYPE must be a string or an Array of strings in order to cache the builder on this LogicMgr."));
                n[t] = e
            }
            e.setPackageName(this.packageName);
            let i = e.DEFAULTS[r.p];
            if (!i)
                return e.setModuleName(this.moduleName);
            if (!i.startsWith(this.moduleName))
                throw new Error("Unable to add builder to this LogicMgr because the builder uses module ".concat(i, " and this LogicMgr has a module of ").concat(this.moduleName, ". A LogicMgr can only have builders associated with it that are sub-modules of the LogicMgr."));
            return e
        }
        getBuilder(e, t) {
            let n, i = this.builders;
            i || (i = {},
            this.builders = i),
            n = this.findExistingBuilder(e);
            const s = this.LogicBuilder;
            if (n)
                if (n instanceof s) {
                    if (n.logicMgr === this)
                        return t = Object(o.a)(this, t, this.moduleName, this.packageName),
                        n.DEFAULTS[r.p] !== t && (n = n.createNewInstance(),
                        n.DEFAULTS[r.p] = t),
                        n;
                    n = s.init({
                        ...n.DEFAULTS
                    }).setLogicMgr(this, t)
                } else
                    n = s.init(n.DEFAULTS ? {
                        ...n.DEFAULTS
                    } : void 0).setLogicMgr(this, t);
            else
                n = s.init().setActionType(e).setLogicMgr(this, t);
            return i[e] = n,
            n
        }
        getExistingBuilder(e) {
            return this.builders && this.builders[e] || null
        }
        findExistingBuilder(e) {
            let t = this.builders && this.builders[e];
            if (t)
                return t;
            const n = this.sources;
            if (n)
                for (let r of n)
                    if (t = r.findExistingBuilder(e))
                        return t;
            return null
        }
        getById(e, t) {
            let n;
            for (let i = 0; i < this.length; i++)
                if (n = this[i],
                n[r.m] === e)
                    return t ? Object(s.d)(n, this.ops) : n;
            return null
        }
        getByName(e, t, n) {
            let o;
            for (let a = 0; a < this.length; a++)
                if (o = this[a],
                o[r.q] === e && (!t || Object(i.h)(o[r.a], t)))
                    return n ? Object(s.d)(o, this.ops) : o;
            return null
        }
        getByActionType(e, t) {
            const n = [];
            if (t)
                for (let o of this)
                    Object(i.h)(o[r.a], e) || n.push(o);
            else
                for (let o of this)
                    Object(i.h)(o[r.a], e) && n.push(o);
            return n.length ? n : null
        }
        findById(e, t) {
            let n = this.getById(e, t);
            if (n || !this.sources)
                return n;
            const r = this.sources;
            for (let i of r)
                if (n = i.findById(e, t))
                    return n;
            return null
        }
        findByName(e, t, n) {
            let r = this.getByName(e, t, n);
            if (!r) {
                const i = this.sources;
                if (i)
                    for (let o of i)
                        if (r = o.findByName(e, t, n))
                            return r
            }
            return r
        }
        _prepareToAdd(e) {
            if ("function" === typeof e && (e = Object(s.f)(e)),
            e[r.m])
                return e;
            if (!e[r.a] || !e[r.q])
                throw new Error("Unable to add logic:\n  name = ".concat(e[r.q], "\n  actionType = ").concat(e[r.a], "\n  packageName = ").concat(e[r.u], "\n  module = ").concat(e[r.p], '\nIts "').concat(r.m, '" property could not be determined automatically because it is missing "').concat(r.a, '" or "').concat(r.q, '" properties, or both. This LogicMgr is associated with package "').concat(this.packageName, '" and module "').concat(this.moduleName, '".'));
            return e[r.m] = Object(a.a)(e[r.q], e[r.a]),
            e
        }
        add(e) {
            if (!e)
                return this;
            if (Array.isArray(e))
                for (let t of e)
                    t && this.push(this._prepareToAdd(t));
            else
                this.push(this._prepareToAdd(e));
            return this
        }
        addOrReplaceSingle(e) {
            if (!e)
                return this;
            const t = (e = this._prepareToAdd(e))[r.m];
            for (let n = 0; n < this.length; n++)
                if (this[n][r.m] === t)
                    return this[n] = e,
                    this;
            return this.push(e),
            this
        }
        addOrReplace(e) {
            if (Array.isArray(e)) {
                for (let t of e)
                    this.addOrReplaceSingle(t);
                return this
            }
            return this.addOrReplaceSingle(e)
        }
        addByName(e, t) {
            const n = this.findByName(e, t);
            if (!n)
                throw new Error('The logic with name "'.concat(e, '" and actionType "').concat(t, '" could not be found, so it cannot be added to this LogicMgr.'));
            return this.add(n),
            this
        }
    }
    l.LogicBuilder = c.a,
    l.enumType = void 0,
    l.ops = s.c,
    l.validateOptions = {
        ops: s.c
    },
    u.a.createStandaloneLogicValidator(l.validateOptions);
    var d = n(54)
      , h = n(284)
      , f = n(139);
    class p extends l {
    }
    p.LogicBuilder = f.a,
    p.ops = d.h,
    p.validateOptions = h.b;
    class g extends l {
    }
    g.LogicBuilder = f.b,
    g.ops = d.k,
    g.validateOptions = h.c
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "b", (function() {
        return s
    }
    ));
    var r = n(191);
    const i = e => "object" === typeof e && null !== e && e.constructor === Object;
    Object.prototype.hasOwnProperty;
    const o = (e, t, n) => {
        if (!e)
            return t || null;
        t ? n === t && (t = {
            ...t
        }) : t = {};
        for (let r in e)
            t[r] && i(e[r]) ? t[r] = o(e[r], t[r], n ? n[r] : void 0) : t[r] = e[r];
        return t
    }
      , s = (e, t, n, r) => !e || i(e) ? o(e, n, r) : a(e, t, n, r)
      , a = (e, t, n, s) => {
        if (!e)
            throw new Error("No path provided to addToObjectAtPath()");
        if (n ? s === n && (n = {
            ...n
        }) : n = {},
        "string" === typeof e)
            i(t) && i(n[e]) ? n[e] = o(t, n[e], s ? s[e] : null) : n[e] = t;
        else {
            let i = n
              , o = s
              , c = 0;
            const u = e.length - 1;
            for (; c < u; )
                o = Object(r.b)(o, i, e[c]) ? o[e[c]] : null,
                i = i[e[c]],
                c++;
            a(e[u], t, i, o)
        }
        return n
    }
}
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(e, t, n) {
    "use strict";
    (function(e) {
        n.d(t, "c", (function() {
            return r
        }
        )),
        n.d(t, "a", (function() {
            return i
        }
        )),
        n.d(t, "b", (function() {
            return a
        }
        ));
        const r = t => ("string" !== typeof t && (t = "" + t),
        e.from(t, "utf8").toString("base64"))
          , i = t => e.from(t, "base64").toString("utf8")
          , o = /^([\da-zA-Z+/]{4})*(([\da-zA-Z+/]{2}==)|([\da-zA-Z+/]{3}=))?$/
          , s = /^\d+$/
          , a = e => !(!e || s.test(e) || !(e => "string" === typeof e && o.test(e))(e))
    }
    ).call(this, n(592).Buffer)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return h
    }
    ));
    var r = n(140)
      , i = n(154)
      , o = n(181)
      , s = n(392)
      , a = n(1)
      , c = n(33);
    let u = 0;
    const l = {
        ops: [a.r, a.f],
        opsAliases: null,
        streamId: null,
        streamName: null,
        logicFilter: () => !0,
        network: Object(s.a)(),
        getDispatchId: () => ++u
    }
      , d = e => "Invariant: opsAliases can only alias '".concat(a.l, "', '").concat(a.e, "', and '").concat(a.f, "' one time each. Only '").concat(a.r, "' can be aliased multiple times. But '").concat(e, "' was aliased more than one time. Or you are attempting to use '").concat(a.l, "', '").concat(a.e, "', or '").concat(a.f, "' as something other than its built-in meaning (i.e., you cannot alias '").concat(a.l, "' to stand for something different than '").concat(a.l, "')");
    class h extends i.a {
        constructor(e, t, n, r, i) {
            super(e, t, n, r),
            this.parent = i,
            this.opsDepsPool = void 0,
            this.opIdx = -2,
            this.children = c.a.checkoutMap(),
            this._state = void 0,
            this.waitingFor = void 0,
            this.neededBy = void 0
        }
        static parseOptions(e, t) {
            let n;
            e ? (e.ops || (e.ops = [...l.ops]),
            n = {
                ...l,
                Manager: h,
                ManagerInner: o.a,
                ...e
            }) : n = {
                ...l,
                Manager: h,
                ManagerInner: o.a,
                ops: [...l.ops]
            };
            const {ops: r, opsAliases: i} = n;
            let s = r.length
              , c = r[s - 1];
            c !== a.f && (!i || i && i[c] !== a.f) && (r.push(a.f),
            s++);
            let u = a.l
              , f = a.e;
            if (i) {
                let e;
                for (c in i)
                    if (({[c]: e} = i),
                    e === a.l || e === a.e || e === a.f) {
                        if (i[e] && i[e] !== e)
                            throw new Error(d(e));
                        i[e] = c
                    }
                i[a.l] ? u = i[a.l] : i[a.l] = a.l,
                i[a.f] || (i[a.f] = a.f),
                i[a.e] ? f = i[a.e] : i[a.e] = a.e
            }
            const p = {};
            let g = 0;
            for (; g < s; )
                c = r[g],
                c === f || c === u ? (r.splice(g, 1),
                s--) : (p[c] = g,
                t && (t[c] = 0),
                i && !i[c] && (i[c] = !1),
                g++);
            return n.opsIdxMap = p,
            n
        }
        static create(e) {
            return new this(this.parseOptions(e)).init()
        }
        static createAsOuterManager(e, t, n) {
            const r = new h(n);
            return r.addLogic(t),
            r.setAsOuterManager(e),
            r.init()
        }
        init() {
            return this
        }
        get ManagerInner() {
            return this.options.ManagerInner
        }
        setAsOuterManager(e) {
            return this.isOuter = !0,
            e && this.setDestination(e),
            this
        }
        getChild(e) {
            if (!this.closed)
                return this.children.get(e)
        }
        clone(e, t, n, i, o) {
            const {options: s} = this;
            let u;
            u = t ? {
                ...s,
                ...t,
                ops: s.ops,
                opsAliases: s.opsAliases,
                opsIdxMap: s.opsIdxMap
            } : s;
            const {logicObservers: l, logicArray: d, network: h} = this
              , f = c.a.checkoutMap()
              , p = d ? [...d] : [];
            if (e) {
                let t = this.validateLogic(e, !0);
                if (t) {
                    let e, n, i;
                    for (n of (Array.isArray(t) || (t = [t]),
                    t))
                        l.has(n[a.m]) ? (e = this.getLogicIdx(n[a.m], p),
                        i = p[e],
                        i[a.v] === n[a.v] ? p[e] = n : (p.splice(e, 1),
                        Object(r.a)(n, p, a.v))) : Object(r.a)(n, p, a.v)
                }
            }
            let g, m, y;
            i ? y = new u.Manager(u,p,f,o,this) : (y = new u.Manager(u,p,f),
            y.opsDepsPool = this.opsDepsPool);
            const {opIdx: v} = this;
            for (let r of p)
                ({[a.m]: m} = r),
                g = l.get(m),
                !g || n || "number" === typeof g ? f.set(m, v) : i ? f.set(m, h.createLogicObserver(y, r, v, g)) : f.set(m, h.cloneLogicObserver(y, r, v, g));
            return i ? y : (n || h.cloneDeps(this, y, y, !0),
            y.init())
        }
        createChildManager(e, t, n) {
            const {children: r} = this;
            let i = r.get(e);
            return i || (i = this.clone(t, n, !1, !0, e),
            r.set(e, i),
            this.network.registerChildManager(i),
            i.init())
        }
        createManagerInner(e, t, n) {
            let r;
            n ? r = this.opsIdxMap[n] - 1 : (n = this.ops[0],
            r = -1);
            const {children: i} = this;
            let o = i.get(t) || null;
            if (o)
                return !1;
            let s, u = void 0, l = void 0, d = 0;
            const {logicArray: h, logicObservers: f, options: {logicFilter: p}, network: g} = this;
            for (let m of h)
                p(e, m) && (m[a.d] && (m = this.callLogicInit(m, e)),
                m && (l || (l = c.a.checkoutMap(),
                u = [],
                o = new this.ManagerInner(this,u,l,t,e,n),
                i.set(t, o)),
                s = m[a.m],
                l.set(s, g.createLogicObserver(o, m, r, f.get(s))),
                u[d] = m,
                d++));
            return o ? o.init() : o
        }
        next(e) {
            const t = this.network.getDispatchId(e, this);
            if (t) {
                const n = this.createManagerInner(e, t);
                n ? this.network.registerChildManager(n, e) : !1 !== n && this.destination.next(e)
            } else
                !1 !== t && this.destination.next(e)
        }
        complete() {
            if (!this.isStopped) {
                this.hasCompleted = !0;
                const {children: e} = this;
                if (0 === e.size)
                    this._complete();
                else if (!this.isOuter) {
                    const {children: e} = this;
                    for (let[,t] of e)
                        t.complete()
                }
            }
        }
        notifyNext(e, t) {
            this.destination.next(e)
        }
        notifyError(e, t) {
            this._error(e)
        }
        notifyComplete(e) {
            e.unsubscribe(this)
        }
        unsubscribe() {
            if (!this.closed) {
                if (this.pendingUnsubscribe) {
                    if (!this.isReadyForUnsubscribe)
                        return
                } else {
                    this.pendingUnsubscribe = !0;
                    const {children: e} = this;
                    if (e.size > 0) {
                        for (let[,t] of e)
                            t.unsubscribe(this);
                        return
                    }
                }
                this._doUnsubscribe()
            }
        }
        _doUnsubscribe() {
            const {parent: e} = this
              , {network: t} = this;
            super._doUnsubscribe(),
            c.a.checkinMap(this.children),
            this.closeoutDeps(this),
            this.children = void 0,
            this._state = void 0,
            e ? (e.childManagerComplete(this, t),
            this.parent = void 0) : this.opsDepsPool = void 0
        }
        childManagerComplete(e, t) {
            this.closed || (this.children.delete(e.dispatchId),
            0 === this.children.size && (this.pendingUnsubscribe ? (this.isReadyForUnsubscribe = !0,
            this.unsubscribe()) : this.hasCompleted && (this.isReadyForUnsubscribe = !0,
            this._complete())),
            t.childManagerComplete(e, this))
        }
        getLogicObserver(e, t) {
            if (t) {
                const n = this.getChild(t);
                return n ? n.getLogicObserver(e) : void 0
            }
            return this.logicObservers.get(e)
        }
        getLogicState(e) {
            let {_state: t} = this;
            return t ? t[e] : void 0
        }
        setLogicState(e, t) {
            let {_state: n} = this;
            return n || (this._state = n = {}),
            n[e] = t,
            t
        }
        removeLogicState(e) {
            let {_state: t} = this;
            return !!t && (t[e] = void 0,
            !0)
        }
        addLogic(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
              , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const r = !0 !== (arguments.length > 3 ? arguments[3] : void 0) ? this.validateLogic(e) : e;
            return !!r && ("all" === t && this.parent ? this.parent.addLogic(r, t, n, !0) : this._addLogic(r, t, n))
        }
        removeLogic(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
              , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const r = !0 !== (arguments.length > 3 ? arguments[3] : void 0) ? this.determineLogicId(e) : e;
            return !!r && ("all" === t && this.parent ? this.parent.removeLogic(r, t, n, !0) : this._removeLogic(r, t, n))
        }
        replaceLogic(e, t) {
            let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
              , r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
              , i = t
              , o = e;
            return !!(!0 === (arguments.length > 4 ? arguments[4] : void 0) || (i = this.validateLogic(t)) && (o = this.determineLogicId(e)) && i[a.m] === o) && ("all" === n && this.parent ? this.parent.replaceLogic(o, i, n, r, !0) : this._replaceLogic(o, i, n, r))
        }
        addOrReplaceLogic(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
              , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , r = e;
            return !(!0 !== (arguments.length > 3 ? arguments[3] : void 0) && !(r = this.validateLogic(e, !0))) && ("all" === t && this.parent ? this.parent.addOrReplaceLogic(r, t, n, !0) : this._addLogic(r, t, n, !0))
        }
        _addLogic(e, t, n, i, o) {
            let s = !1;
            if (t)
                if (!o && Array.isArray(e))
                    for (let r of e)
                        this._addLogic(r, t, !1, i, !0) && (s = !0);
                else
                    this.logicObservers.has(e[a.m]) ? i && this._replaceLogic(e[a.m], e, t, n, !0) && (s = !0) : (Object(r.a)(e, this.logicArray, a.v),
                    this.logicObservers.set(e[a.m], this.network.createLogicObserver(this, e, this.opIdx, this.parent ? this.parent.logicObservers.get(e[a.m]) : void 0)),
                    s = !0);
            if (n) {
                const {children: r} = this;
                for (let[,o] of r)
                    o._addLogic(e, t, n, i) && (s = !0)
            }
            return s
        }
        _removeLogic(e, t, n, r) {
            if (!e)
                return !1;
            let i = !1;
            if (r) {
                const {logicObservers: t} = this;
                if (t.has(e)) {
                    const {logicArray: n} = this;
                    let r = this.getLogicIdx(e)
                      , o = t.get(e);
                    const s = n[r];
                    this.callLogicRemoveReplace(s) && (t.has(e) && (o = t.get(e),
                    n[r] && n[r][a.m] === e || (r = this.getLogicIdx(e)),
                    "number" !== typeof o && o.unsubscribe(),
                    t.delete(e),
                    n.splice(r, 1)),
                    i = !0)
                }
                return i
            }
            if (t)
                if (Array.isArray(e))
                    for (let o of e)
                        this._removeLogic(o, t, n, !0) && (i = !0);
                else
                    i = this._removeLogic(e, t, n, !0);
            if (n) {
                const {children: r} = this;
                for (let[,o] of r)
                    o._removeLogic(e, t, n) && (i = !0)
            }
            return i
        }
        _replaceLogic(e, t, n, i, o) {
            const {logicObservers: s} = this;
            let c = !1;
            if (o || n && s.has(e)) {
                let i = this.getLogicIdx(e);
                const {logicArray: u} = this
                  , l = u[i];
                let d = s.get(e);
                if (c = this.callLogicRemoveReplace(l, t),
                !0 === c && s.has(e)) {
                    d = s.get(e),
                    u[i] && u[i][a.m] === e || (i = this.getLogicIdx(e));
                    const n = "number" === typeof d;
                    let o = t[a.x];
                    if (n || o)
                        if (!n && o) {
                            const {opsDeps: n} = d;
                            let r = !1;
                            if (n)
                                for (let e in n)
                                    if (n[e]) {
                                        r = !0;
                                        break
                                    }
                            r ? d.logic = t : (d.unsubscribe(),
                            s.set(e, this.opIdx))
                        } else
                            n && !o && s.set(e, this.network.createLogicObserver(this, t, d, this.parent ? this.parent.logicObservers.get(e) : void 0));
                    else
                        d.logic = t;
                    l[a.v] === t[a.v] ? u[i] = t : (u.splice(i, 1),
                    Object(r.a)(t, u, a.v))
                } else
                    c = !(!0 !== c || !o) && this._addLogic(t, n, !1, o)
            }
            if (!o && i) {
                const {children: r} = this;
                for (let[,o] of r)
                    o._replaceLogic(e, t, n, i) && (c = !0)
            }
            return c
        }
        callLogicRemoveReplace(e, t) {
            const n = e[a.y];
            if (!n)
                return !0;
            const {[a.A]: r} = e;
            let i;
            try {
                i = e[a.x] ? !!n.call(r || e, t) : !!n.call(r || e, this, t)
            } catch (o) {
                throw o
            }
            return i
        }
        addDependency(e, t) {
            let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
              , r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            if ("all" === n && this.parent)
                return this.parent.addDependency(e.parent ? e.parent : e, t, n, r);
            {
                if (this.closed || e.closed)
                    return !1;
                let i = !1;
                if (n && (n = !0,
                i = this._addDependency(e, t)),
                r) {
                    const {children: o} = this
                      , {children: s} = e;
                    let a;
                    if (this.isOuter)
                        for (let[e,n] of o)
                            (a = s.get(e)) && n._addDependency(a, t) && (i = !0);
                    else
                        for (let[e,c] of o)
                            (a = s.get(e)) && c.addDependency(a, t, n, r) && (i = !0)
                }
                return i
            }
        }
        _addDeps(e, t, n, r) {
            if (!e.addToNeededBy(this, t, r))
                return !1;
            let i, {waitingFor: o} = n;
            return o ? (i = o.get(e),
            i || (i = c.a.checkoutSet(),
            o.set(e, i)),
            i.add(t)) : (n.waitingFor = o = c.a.checkoutMap(),
            i = c.a.checkoutSet(),
            i.add(t),
            o.set(e, i)),
            !0
        }
        addToNeededBy(e, t, n) {
            if (this.closed)
                return !1;
            let r, {neededBy: i} = n;
            return i ? (r = i.get(e),
            r || (r = c.a.checkoutSet(),
            i.set(e, r)),
            r.add(t)) : (n.neededBy = i = c.a.checkoutMap(),
            r = c.a.checkoutSet(),
            r.add(t),
            i.set(e, r)),
            !0
        }
        deleteFromNeededBy(e, t) {
            if (this.closed)
                return;
            let n = this;
            if (t.otherLogic && (n = this.logicObservers.get(t.otherLogic),
            !n || n.closed))
                return;
            const {neededBy: r} = n;
            if (r) {
                const i = r.get(e);
                i && (i.delete(t),
                0 === i.size && (c.a.checkinSet(i),
                r.delete(e),
                r.size || (c.a.checkinMap(r),
                n.neededBy = void 0)))
            }
        }
        deleteFromWaitingFor(e, t) {
            if (this.closed)
                return;
            let n = this;
            if (t.logic && (n = this.logicObservers.get(t.logic),
            !n || n.closed))
                return;
            const {waitingFor: r} = n;
            if (r) {
                const i = r.get(e);
                i && (i.delete(t),
                0 === i.size && (c.a.checkinSet(i),
                r.delete(e),
                r.size || (c.a.checkinMap(r),
                n.waitingFor = void 0)))
            }
        }
        closeoutDeps(e) {
            const {neededBy: t, waitingFor: n} = e;
            let r, i, o;
            if (n) {
                for ([r,o] of (e.waitingFor = void 0,
                n)) {
                    for (i of o)
                        r.deleteFromNeededBy(this, i);
                    c.a.checkinSet(o)
                }
                c.a.checkinMap(n)
            }
            if (t) {
                for ([r,o] of (e.neededBy = void 0,
                t)) {
                    for (i of o)
                        r.deleteFromWaitingFor(this, i);
                    c.a.checkinSet(o)
                }
                c.a.checkinMap(t)
            }
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "b", (function() {
        return o
    }
    ));
    const r = {
        enumerable: !1
    };
    function i(e, t, n) {
        let i;
        if (t)
            for (i in t)
                e.prototype[i] = t[i],
                Object.defineProperty(e.prototype, i, r);
        if (n)
            for (i in n)
                e[i] = n[i],
                Object.defineProperty(e, i, r);
        return e
    }
    function o(e, t) {
        return i(e, t.instanceMethods, t.staticMethods),
        function(e, t, n) {
            t && Object.defineProperties(e.prototype, t),
            n && Object.defineProperties(e, n)
        }(e, t.instanceAccessors, t.staticAccessors),
        e
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "j", (function() {
        return a
    }
    )),
    n.d(t, "k", (function() {
        return c
    }
    )),
    n.d(t, "l", (function() {
        return u
    }
    )),
    n.d(t, "i", (function() {
        return l
    }
    )),
    n.d(t, "f", (function() {
        return d
    }
    )),
    n.d(t, "d", (function() {
        return h
    }
    )),
    n.d(t, "e", (function() {
        return f
    }
    )),
    n.d(t, "a", (function() {
        return p
    }
    )),
    n.d(t, "c", (function() {
        return g
    }
    )),
    n.d(t, "b", (function() {
        return m
    }
    )),
    n.d(t, "g", (function() {
        return y
    }
    )),
    n.d(t, "h", (function() {
        return v
    }
    )),
    n.d(t, "m", (function() {
        return b
    }
    )),
    n.d(t, "n", (function() {
        return _
    }
    ));
    var r = n(160)
      , i = n(3)
      , o = n(161)
      , s = n(241);
    const a = ["permCreate", "permRead", "permUpdate", "permDelete"]
      , c = ["permRecCreate", "permRecRead", "permRecUpdate", "permRecDelete"]
      , u = ["apiCreate", "apiRead", "apiUpdate", "apiDelete", "pkIsAutoIncrement", "trackAccess"]
      , l = ["assignUID", "trackHistory", "hasCustomGraphqlNames", "isLocalOnly", "isHistory"]
      , d = ["apiCreate", "apiRead", "apiUpdate", "autoloadOnClient", "autoloadOnServer"]
      , h = ["isLocalOnly", "primary", "notEnumerable", "notNullable"]
      , f = ["permRead", "permUpdate"]
      , p = ["includeNull", "includeOnHistory", "isHistoryOnly", "isLocalOnly", "isSearch", "isSystem", "isSystemAuto", "primary", "unique"]
      , g = ["apiCreate", "apiRead", "apiUpdate", "apiDelete"]
      , m = ["isList", "notNullable"]
      , y = {
        modelAutoloadOnClient: !1,
        modelAutoloadOnServer: !1,
        modelRelationship: r.a.BELONGS_TO,
        modelVFApiCreate: !0,
        modelVFApiRead: !0,
        modelVFApiUpdate: !1,
        modelVFResolver: s.a.VF_ONE,
        refFieldIndexName: i.f,
        refFieldName: "id",
        refModelAutoloadOnClient: !1,
        refModelAutoloadOnServer: !1,
        refModelRelationship: r.a.HAS_MANY,
        refModelVFApiCreate: !0,
        refModelVFApiRead: !0,
        refModelVFApiUpdate: !0,
        refModelVFResolver: s.a.VF_MANY,
        isLocalOnly: !1,
        isReciprocal: !1,
        onUpdate: o.a.CASCADE,
        onDelete: o.a.CASCADE
    }
      , v = {
        ...y,
        fieldName: "id",
        fieldIndexName: "c_id",
        modelRelationship: r.a.BELONGS_TO_MANY,
        modelVFApiUpdate: !0,
        modelVFResolver: s.a.VF_M2M,
        refFieldIndexName: "c_id",
        refModelRelationship: r.a.BELONGS_TO_MANY_REF,
        refModelVFResolver: s.a.VF_M2M,
        onUpdate: o.a.NO_ACTION,
        onDelete: o.a.NO_ACTION
    };
    function b(e, t, n, r) {
        let i;
        if (n)
            for (i of n)
                e[i] = !1 !== t[i];
        if (r)
            for (i of r)
                e[i] = !0 === t[i]
    }
    function _(e, t, n, r) {
        const i = e.__permUserCanEnum;
        for (let o of n)
            e[o] = t[o] ? i.getInternalValue(t[o]) : r
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return i
    }
    ));
    const r = 2147483647
      , i = -2147483648
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(14)
      , i = n(57);
    function o(e) {
        return function(t) {
            var n = new s(e)
              , r = t.lift(n);
            return n.caught = r
        }
    }
    var s = function() {
        function e(e) {
            this.selector = e
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new a(e,this.selector,this.caught))
        }
        ,
        e
    }()
      , a = function(e) {
        function t(t, n, r) {
            var i = e.call(this, t) || this;
            return i.selector = n,
            i.caught = r,
            i
        }
        return r.a(t, e),
        t.prototype.error = function(t) {
            if (!this.isStopped) {
                var n = void 0;
                try {
                    n = this.selector(t, this.caught)
                } catch (s) {
                    return void e.prototype.error.call(this, s)
                }
                this._unsubscribeAndRecycle();
                var r = new i.a(this);
                this.add(r);
                var o = Object(i.c)(n, r);
                o !== r && this.add(o)
            }
        }
        ,
        t
    }(i.b)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    )),
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    )),
    n.d(t, "d", (function() {
        return s
    }
    )),
    n.d(t, "e", (function() {
        return a
    }
    )),
    n.d(t, "f", (function() {
        return c
    }
    )),
    n.d(t, "g", (function() {
        return u
    }
    )),
    n.d(t, "h", (function() {
        return l
    }
    )),
    n.d(t, "i", (function() {
        return d
    }
    )),
    n.d(t, "j", (function() {
        return h
    }
    )),
    n.d(t, "k", (function() {
        return f
    }
    )),
    n.d(t, "m", (function() {
        return p
    }
    )),
    n.d(t, "l", (function() {
        return g
    }
    )),
    n.d(t, "q", (function() {
        return m
    }
    )),
    n.d(t, "n", (function() {
        return y
    }
    )),
    n.d(t, "o", (function() {
        return v
    }
    )),
    n.d(t, "p", (function() {
        return b
    }
    )),
    n.d(t, "r", (function() {
        return _
    }
    )),
    n.d(t, "s", (function() {
        return S
    }
    )),
    n.d(t, "t", (function() {
        return O
    }
    )),
    n.d(t, "u", (function() {
        return T
    }
    )),
    n.d(t, "v", (function() {
        return I
    }
    )),
    n.d(t, "w", (function() {
        return x
    }
    )),
    n.d(t, "z", (function() {
        return w
    }
    )),
    n.d(t, "x", (function() {
        return M
    }
    )),
    n.d(t, "y", (function() {
        return A
    }
    )),
    n.d(t, "A", (function() {
        return E
    }
    )),
    n.d(t, "D", (function() {
        return C
    }
    )),
    n.d(t, "C", (function() {
        return N
    }
    )),
    n.d(t, "E", (function() {
        return R
    }
    )),
    n.d(t, "F", (function() {
        return P
    }
    )),
    n.d(t, "G", (function() {
        return D
    }
    )),
    n.d(t, "H", (function() {
        return F
    }
    )),
    n.d(t, "I", (function() {
        return k
    }
    )),
    n.d(t, "B", (function() {
        return j
    }
    ));
    const r = "AddressScalar"
      , i = "BooleanScalar"
      , o = "ColorScalar"
      , s = "CountryScalar"
      , a = "CountryStateScalar"
      , c = "CurrencyScalar"
      , u = "DateScalar"
      , l = "DateTimeScalar"
      , d = "DecimalScalar"
      , h = "EmailScalar"
      , f = "FloatScalar"
      , p = "GeoPointScalar"
      , g = "GeometryScalar"
      , m = "JSONScalar"
      , y = "IDScalar"
      , v = "ImageScalar"
      , b = "IntScalar"
      , _ = "LatitudeScalar"
      , S = "LongitudeScalar"
      , O = "LongtextScalar"
      , T = "MediumtextScalar"
      , I = "ModelIDScalar"
      , x = "ModelUIDScalar"
      , w = "PhoneScalar"
      , M = "PercentFractionScalar"
      , A = "PercentLiteralScalar"
      , E = "PostalCodeScalar"
      , C = "StringScalar"
      , N = "SlugScalar"
      , R = "TextScalar"
      , P = "TimestampScalar"
      , D = "TimestampSecondsScalar"
      , F = "TimeZoneScalar"
      , k = "UrlScalar"
      , j = {
        ADDRESS: r,
        BOOLEAN: i,
        COLOR: o,
        COUNTRY: s,
        COUNTRY_STATE: a,
        CURRENCY: c,
        DATE: u,
        DATE_TIME: l,
        DECIMAL: d,
        EMAIL: h,
        ENUM: "EnumScalar",
        FLOAT: f,
        GEOMETRY: g,
        GEO_POINT: p,
        JSON: m,
        ID: y,
        IMAGE: v,
        INT: b,
        LATITUDE: _,
        LONGITUDE: S,
        LONGTEXT: O,
        MEDIUMTEXT: T,
        MODEL_ID: I,
        MODEL_UID: x,
        PERCENT_FRACTION: M,
        PERCENT_LITERAL: A,
        PHONE: w,
        POSTAL_CODE: E,
        STRING: C,
        SLUG: N,
        TEXT: R,
        TIME: "TimeScalar",
        TIMESTAMP: P,
        TIMESTAMP_SECONDS: D,
        TIME_ZONE: F,
        URL: k
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(14)
      , i = n(22)
      , o = n(38);
    function s(e) {
        return function(t) {
            return t.lift(new a(e))
        }
    }
    var a = function() {
        function e(e) {
            this.callback = e
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new c(e,this.callback))
        }
        ,
        e
    }()
      , c = function(e) {
        function t(t, n) {
            var r = e.call(this, t) || this;
            return r.add(new o.a(n)),
            r
        }
        return r.a(t, e),
        t
    }(i.a)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return r
    }
    )),
    n.d(t, "a", (function() {
        return i
    }
    )),
    n.d(t, "c", (function() {
        return o
    }
    ));
    const r = "RECURSIVE_PARENT_ANCHOR_LOGIC_ID"
      , i = "RECURSIVE_CHILD_ANCHOR_LOGIC_ID"
      , o = "SYNC_RECURSIVE_VFS_LOGIC"
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return s
    }
    ));
    var r = n(26)
      , i = n(82)
      , o = n(185);
    function s(e, t) {
        return void 0 === e && (e = 0),
        void 0 === t && (t = i.a),
        (!Object(o.a)(e) || e < 0) && (e = 0),
        t && "function" === typeof t.schedule || (t = i.a),
        new r.a((function(n) {
            return n.add(t.schedule(a, e, {
                subscriber: n,
                counter: 0,
                period: e
            })),
            n
        }
        ))
    }
    function a(e) {
        var t = e.subscriber
          , n = e.counter
          , r = e.period;
        t.next(n),
        this.schedule({
            subscriber: t,
            counter: n + 1,
            period: r
        }, r)
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return m
    }
    )),
    n.d(t, "b", (function() {
        return T
    }
    ));
    var r = n(277)
      , i = n(31)
      , o = n(297)
      , s = n(26)
      , a = n(58)
      , c = n(11)
      , u = n(15)
      , l = n(139)
      , d = n(23)
      , h = n(163)
      , f = n(864);
    const p = (e, t, n) => {
        if (!e)
            return;
        ("function" === typeof e ? e[u.d][u.a] : e[u.a]) === a.m ? t && t.push(e) : n.push(e)
    }
    ;
    function g(e, t, n) {
        if (e)
            if (Array.isArray(e))
                for (let r of e)
                    p(r, t, n);
            else
                p(e, t, n)
    }
    function m(e, t, n) {
        const r = n ? null : []
          , i = [];
        if (Array.isArray(t))
            for (let o of t)
                g(o, r, i);
        else
            g(t, r, i);
        !function(e, t, n) {
            t && t.length && e.addPendingLogic(t, !1, !0),
            n && n.length && e.addPendingLogic(n, !0, !0)
        }(e, r, i)
    }
    const y = (e, t) => {
        if (!t)
            return e;
        t.complete()
    }
      , v = (e, t, n) => n ? (m(e.meta.store, n),
    y(e, t)) : y(e, t)
      , b = (e, t, n, r) => {
        if (!t && !e.meta.getCurrentLogic()[u.n])
            return new s.a(t => {
                b(e, {
                    complete: () => {
                        t.next(e),
                        t.complete()
                    }
                }, n, r)
            }
            );
        const a = ( (e, t, n) => {
            if (n) {
                if ("function" !== typeof n || n[u.d])
                    return t ? Object(i.a)(n) : n;
                {
                    const r = n(e);
                    return r ? t ? Object(h.a)(r) ? r : Object(i.a)(r) : r : t ? Object(c.c)() : null
                }
            }
            return t ? Object(c.c)() : null
        }
        )(e, t, n);
        let l;
        return r ? (l = e.meta.instance.itemEnum.initItems(Array.isArray(r) ? r : [r], e, !0, !!t),
        l.push(a)) : l = a,
        ( (e, t, n) => {
            if (!t)
                return v(e, t, n);
            (Array.isArray(n) ? Object(o.a)(n) : n).subscribe(n => v(e, t, n))
        }
        )(e, t, l)
    }
      , _ = ["props", "onLogicInit"];
    function S(e, t) {
        return "undefined" === typeof t && (t = _),
        function(n, r) {
            return b(n, r, e, t ? Object(f.a)(t, n.meta.instance) : null)
        }
    }
    class O extends l.a {
        useId(e, t, n) {
            const r = this.use().setId(e).setName(e).setType(t);
            return n && r.setPackageName(n.packageName).setModuleName("".concat(n.moduleName, "/init")),
            r
        }
        create(e, t) {
            return this.done(S(e, t), !0)
        }
        setPure(e) {
            return this.setProp(u.n, e),
            this
        }
    }
    O.DEFAULTS = {
        ...l.a.DEFAULTS,
        [u.k]: d.f,
        [u.m]: 1,
        [u.a]: a.m,
        [u.g]: r.a.CORE_LOGIC_METHOD
    },
    O.prototype.create = function(e, t) {
        return this.done(S(e, t), !0)
    }
    ,
    O.prototype.setDefaultDescription = function() {
        return this
    }
    ;
    const T = O.init()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return d
    }
    ));
    var r = n(72)
      , i = n(398)
      , o = n(58)
      , s = n(162)
      , a = n(870)
      , c = n(195)
      , u = n(397);
    const l = Object(c.b)({
        resolved: {},
        chunkName: () => "isomorix-router-props",
        isReady(e) {
            const t = this.resolve(e);
            return !0 === this.resolved[t] && !!n.m[t]
        },
        importAsync: () => n.e(4).then(n.bind(null, 405)),
        requireAsync(e) {
            const t = this.resolve(e);
            return this.resolved[t] = !1,
            this.importAsync(e).then(e => (this.resolved[t] = !0,
            e))
        },
        requireSync(e) {
            const t = this.resolve(e);
            return n(t)
        },
        resolve() {
            return 405
        }
    });
    function d(e, t) {
        const {meta: n} = e
          , i = n.store.get("props");
        return e.type === o.m && i && i.route && i.route.absPath && !n.instance.__isLocalOnly ? (n.store.get("type") === s.a.ROUTER && Object(a.a)(n.instance.getMutableRecord(e)),
        Object(u.a)(null, e, t)) : (console.log("ADDING LOADER LOGIC.."),
        l(e).pipe(Object(r.a)(t => t.addToRecordFromLoadable(e, t))))
    }
    i.a.use().setPrepareOp().setPriority(100).setName("routerPropsLogicLoader").setActionType([o.d, o.m]).setId(),
    i.a.done(d, !0)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    ));
    var r = n(235);
    function i(e) {
        const t = typeof e;
        if (null === e || "undefined" === t || "string" === t)
            return e;
        if ("object" === t)
            try {
                return JSON.stringify(e)
            } catch (n) {
                return e
            }
        if ("boolean" === t)
            return e ? "true" : "false";
        if ("number" === t)
            return "".concat(e);
        if ("function" === t)
            throw new TypeError("The value " + Object(r.a)(e) + " is a function, which is not capable of being represented as JSON.");
        throw new TypeError("The value " + Object(r.a)(e) + " is of unknown type and cannot be represented as JSON.")
    }
    function o(e) {
        if ("string" !== typeof e)
            return e;
        try {
            const t = JSON.parse(e);
            return t && "object" === typeof t ? t : e
        } catch (t) {
            let n = e.charAt(0);
            if (" " === n) {
                let t = 1;
                for (; " " === n; )
                    n = e.charAt(t),
                    t++
            }
            if ("{" === n || "[" === n)
                throw new Error("The value is not valid JSON.");
            return e
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return y
    }
    ));
    var r = n(297)
      , i = n(31)
      , o = n(52)
      , s = n(74)
      , a = n(190)
      , c = n(872)
      , u = n(279)
      , l = n(869)
      , d = n(278)
      , h = n(195);
    const f = Object(h.b)({
        resolved: {},
        chunkName: () => "clientSessionMgr",
        isReady(e) {
            const t = this.resolve(e);
            return !0 === this.resolved[t] && !!n.m[t]
        },
        importAsync: () => n.e(1).then(n.bind(null, 406)),
        requireAsync(e) {
            const t = this.resolve(e);
            return this.resolved[t] = !1,
            this.importAsync(e).then(e => (this.resolved[t] = !0,
            e))
        },
        requireSync(e) {
            const t = this.resolve(e);
            return n(t)
        },
        resolve() {
            return 406
        }
    })
      , {LOGIN_LOCAL_STRATEGY: p, LOGOUT_LOCAL_STRATEGY: g, USER_UPDATE_PASSWORD: m} = u.a;
    function y(e) {
        const t = e.plugin.getMainInstance()
          , n = e.storesMap
          , u = e.getRecordBuilder().Class.prototype;
        u.login = function(e) {
            if (!e || !e.email || !e.password)
                throw new Error("Missing required `payload` to use to authenticate the user. An Object containing at minimum an `email` and `password` must be provided.");
            let t, a;
            return this.loadUserModels().pipe(Object(o.a)( () => {
                t = n.get(this).parentInstance.mutation();
                const i = this.__ID
                  , o = t.update(n => n.where(t.primaryKey, i).addDirective(p, {
                    email: e.email,
                    password: e.password
                }).returnPayload());
                return a = t.records[i],
                t.getRecordPayload(this, !0).isLogin = !0,
                Object(r.a)({
                    controller: t.execute(),
                    payload: o
                })
            }
            ), Object(o.a)(e => {
                let {payload: n} = e
                  , r = this;
                return null === n.resp && (r = new Error("login"),
                r.code = 500),
                this.__dispatchId ? Object(i.a)(r) : t.ofComplete(!0).pipe(Object(s.a)(r))
            }
            ))
        }
        ,
        u.logout = function() {
            const e = n.get(this)
              , t = e.parentInstance.mutation();
            return t.update(n => n.select("userRoleId").where(t.primaryKey, e.value.get(t.primaryKey)).addDirective(g)),
            t.getRecordPayload(this, !0).isLogout = !0,
            t.execute(!e.mainDispatchId).pipe(Object(s.a)(this))
        }
        ,
        u.updatePassword = function(e) {
            if (!e.current || !e.password)
                return Object(i.a)({
                    statusCode: 400,
                    statusMessage: "Missing required current and new password.",
                    data: null
                });
            if (!e.email && !this.userRoleId)
                return Object(i.a)({
                    statusCode: 403,
                    statusMessage: "Unauthorized",
                    data: null
                });
            const t = n.get(this)
              , a = t.mainDispatchId
              , c = t.parentInstance.mutation()
              , u = c.update(t => t.where(c.primaryKey, this.__ID).addDirective(m, {
                email: e.email,
                password: e.password,
                current: e.current
            }).returnPayload());
            return Object(r.a)({
                controller: c.execute(),
                payload: u
            }).pipe(Object(o.a)(e => {
                let {payload: t} = e;
                const {extensions: n} = t;
                let r;
                return r = n ? {
                    statusCode: n.statusCode,
                    statusMessage: n.statusMessage,
                    data: null
                } : {
                    statusCode: 500,
                    statusMessage: "An unknown error occurred.",
                    data: null
                },
                a ? Object(i.a)(r) : c.ofComplete(!0).pipe(Object(s.a)(r))
            }
            ))
        }
        ,
        u.ofDeviceReady = function() {
            const e = Object(l.a)(n, this);
            if (e.ofDeviceReady$)
                return e.ofDeviceReady$;
            const t = n.get(this).mainStore
              , r = t.get("localProps");
            return r && r.deviceReady ? (e.ofDeviceReady$ = Object(i.a)(t.instance),
            e.ofDeviceReady$) : (e.ofDeviceReady$ = t.instance.subscribeTo([["localProps", "deviceReady"]]).pipe(Object(a.a)(n => {
                let {localProps: r} = n;
                return !(!r || !r.deviceReady) && (e.ofDeviceReady$ = Object(i.a)(t.instance),
                !0)
            }
            ), Object(d.a)(), Object(c.a)()),
            e.ofDeviceReady$.subscribe(),
            e.ofDeviceReady$)
        }
        ,
        u.initClientSession = function() {
            f().pipe(Object(o.a)(e => e ? e.initClientSession(this, t, n) : this.setLocalProps({
                deviceReady: !0
            }))).subscribe({
                error: e => {
                    console.log("GOT ERROR INITIALIZING/MANAGING CLIENT SESSION = ".concat(e.message))
                }
            })
        }
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return r
    }
    ));
    const r = {
        GRAPHQL_WS: "vitalstats"
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "b", (function() {
        return i
    }
    )),
    n.d(t, "a", (function() {
        return o
    }
    )),
    n.d(t, "d", (function() {
        return s
    }
    )),
    n.d(t, "e", (function() {
        return a
    }
    )),
    n.d(t, "c", (function() {
        return c
    }
    ));
    var r = n(162);
    const i = r.a.ROUTER
      , o = r.a.ROUTE
      , s = e => !!e && e.type === i
      , a = e => !!e && (e.type === o || e.type === i)
      , c = [i, o]
}
, function(e, t, n) {
    "use strict";
    n.d(t, "e", (function() {
        return o
    }
    )),
    n.d(t, "f", (function() {
        return s
    }
    )),
    n.d(t, "c", (function() {
        return a
    }
    )),
    n.d(t, "d", (function() {
        return c
    }
    )),
    n.d(t, "a", (function() {
        return u
    }
    )),
    n.d(t, "b", (function() {
        return l
    }
    )),
    n.d(t, "i", (function() {
        return d
    }
    )),
    n.d(t, "j", (function() {
        return h
    }
    )),
    n.d(t, "g", (function() {
        return f
    }
    )),
    n.d(t, "h", (function() {
        return p
    }
    ));
    var r = n(23)
      , i = n(196);
    const o = r.f
      , s = i.a + 25
      , a = r.f
      , c = i.a + 35
      , u = r.f
      , l = i.a + 25
      , d = r.g
      , h = i.a + 25
      , f = d
      , p = i.b - 50
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    )),
    n.d(t, "b", (function() {
        return c
    }
    ));
    var r = n(292);
    const i = (e, t, n) => Object(r.a)(e, t).update(e, "permDenied", null, n, !0)
      , o = (e, t) => !e.getState().permDenied && (i(e, t, !0),
    !0)
      , s = (e, t) => {
        const n = e.getState()
          , r = !!n[t.fieldName] && !n[t.fieldName](t.userRole, e);
        if (n.permDenied !== r)
            i(e, t, r);
        else if (t.onlyDescendOnChange)
            return !1;
        return !r || (e.walk(o, t, t.dispatchId),
        !1)
    }
    ;
    function a(e, t) {
        if (t || (t = {}),
        e = Object(r.b)(e, t),
        "undefined" === typeof t.userRole) {
            const n = e.getSession(t.dispatchId);
            t.userRole = n && n.userRole || null
        }
        return t.fieldName || (t.fieldName = "permUse"),
        s(e, t) && e.walk(s, t, t.dispatchId),
        t
    }
    function c(e, t) {
        const n = e.getSession(t ? t.meta.dispatchId : void 0)
          , r = n && n.userRole || null
          , i = !e.permUse(r, e);
        return t && e.permDenied !== i && ((e = e.getMutableRecord(t)).permDenied = i),
        i
    }
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return Lt
    }
    ));
    var r = n(31)
      , i = n(1004)
      , o = n(0)
      , s = n(1e3)
      , a = n(17)
      , c = n(9)
      , u = n(235);
    const l = e => function(t, n, r, i) {
        if ("undefined" === typeof t)
            throw new Error("".concat(this.name, " is a required field."));
        return e.call(this, t, n, r, i)
    }
      , d = e => function(t, n, r, i) {
        return "undefined" !== typeof t ? e.call(this, t, n, r, i) : null === n.defaultValue ? n.defaultValue : n.type.parseValue(n.defaultValue)
    }
      , h = e => function(t, n, r, i) {
        return null === t ? t : e.call(this, t, n, r, i)
    }
      , f = e => function(t, n, r, i) {
        if (null === t)
            throw new Error("".concat(this.name, " cannot be null."));
        return e.call(this, t, n, r, i)
    }
    ;
    const p = {
        fieldWithoutDefault: l,
        fieldWithDefault: d,
        nullableField: h,
        notNullableField: f,
        nullableFieldWithDefault: e => d(h(e)),
        notNullableFieldWithDefault: e => d(f(e)),
        notNullableFieldWithoutDefault: e => l(f(e))
    };
    function g(e, t) {
        class n extends t {
            constructor(t) {
                super(t);
                const {configDefaults: n} = this.constructor;
                for (let e in n)
                    this[e] = t[e];
                e.add(this.name, this)
            }
            fetchInfo() {
                return e.fetchInfo([this.name])
            }
            hasFromPersistent() {
                return this.fromPersistent !== b
            }
            toConfig() {
                const e = super.toConfig()
                  , {configDefaults: t} = this.constructor;
                for (let n in t)
                    e[n] = this[n];
                return e
            }
            destroy() {
                const {configDefaults: e} = this.constructor;
                if (e)
                    for (let t in e)
                        this[t] = void 0
            }
            get pluginSlug() {
                return e.pluginSlug
            }
        }
        return n.define = function(t) {
            let r;
            if ("string" === typeof t) {
                if (r = e.get(t))
                    return this.definitionExisted(t, r);
                if ((t = this.parseConfigString(t))instanceof n)
                    return t
            }
            const {configDefaults: i} = this;
            for (let e in i)
                t.hasOwnProperty(e) || (t[e] = i[e]);
            return i.parseValue && !t.parseValue && (t.parseValue = i.parseValue),
            i.serialize && !t.serialize && (t.serialize = i.serialize),
            i.parseLiteral && !t.parseLiteral && (t.parseLiteral = i.parseLiteral),
            this.ensureValidConfig(t),
            (r = e.get(t.name)) ? this.definitionExisted(t, r) : (r = new this(t),
            r)
        }
        ,
        n.get = function(t) {
            return e.get(t)
        }
        ,
        n.has = function(t) {
            return e.has(t)
        }
        ,
        n.add = function(t, n) {
            return e.add(t, n)
        }
        ,
        Object(s.a)(n, void 0, m),
        n.configDefaults = _,
        n
    }
    const m = {
        definitionExisted: function(e, t) {
            return t
        },
        parseConfigString: function(e) {
            return {
                name: e
            }
        },
        ensureValidConfig: function(e) {
            if (!e.name)
                throw new Error("Unable to define " + this.type + " Scalar. A name is required. Got: " + Object(u.a)(e.name));
            return e
        }
    };
    function y(e) {
        return e
    }
    function v(e, t, n) {
        const r = t.length;
        let i, o, s, a = 0;
        for (; a < r; ) {
            if (o = t[a],
            s = e[n](o),
            s !== o)
                if (0 === a)
                    i = [s];
                else if (i)
                    i[a] = s;
                else {
                    i = [];
                    let e = 0;
                    for (; e < a; )
                        i[e] = t[e],
                        e++;
                    i[a] = s
                }
            else
                i ? i[a] = o : i = [o];
            a++
        }
        return i
    }
    function b(e) {
        return e
    }
    const _ = {
        validateMinMax: function(e) {
            const t = "string" === typeof e ? e.length : e;
            if (t < this.min)
                throw "string" === typeof e ? new TypeError("The text is less than the minimum required (".concat(this.min, " characters).")) : new TypeError("The number is less than the minimum value (".concat(this.min, ")."));
            if (t > this.max)
                throw "string" === typeof e ? new TypeError("The text is longer than the maximum allowed (".concat(this.max, " characters).")) : new TypeError("The number is greater than the maximum allowed (".concat(this.max, ")."));
            return e
        },
        getFieldValidatorMethod: function() {
            return this.fieldValidatorMethod || (this.fieldValidatorMethod = (e, t, n, r) => this.parseValue(e, t, n, r)),
            this.fieldValidatorMethod
        },
        getFieldValidator: function(e) {
            const t = function(e) {
                return e.notNullable ? null === e.defaultValue || "undefined" === typeof e.defaultValue ? "notNullableFieldWithoutDefault" : "notNullableFieldWithDefault" : "nullableFieldWithDefault"
            }(e);
            return this[t] || (this[t] = p[t](this.getFieldValidatorMethod())),
            this[t]
        },
        toGlobalId: function(e) {
            return e
        },
        toGlobalIdMany: function(e) {
            return e ? Array.isArray(e) ? v(this, e, "toGlobalId") : this.toGlobalId(e) : e
        },
        fromGlobalId: function(e) {
            return e
        },
        fromGlobalIdMany: function(e) {
            return e ? Array.isArray(e) ? v(this, e, "fromGlobalId") : this.fromGlobalId(e) : e
        },
        isValidGlobalId: function(e) {
            return !0
        },
        toPersistent: y,
        toPersistentMany: function(e) {
            return this.toPersistent !== y && e && Array.isArray(e) ? v(this, e, "toPersistent") : e
        },
        fromPersistent: b,
        toASTValue: function(e) {
            return Object(c.b)(e)
        },
        getSchemaTypeDef: function() {
            return this.description ? '"""'.concat(this.description, '"""\nscalar ').concat(this.name) : "scalar ".concat(this.name)
        },
        getSchemaResolver: function() {
            return this
        },
        toString: function() {
            return this.name
        },
        serializeMany: function(e) {
            return e && Array.isArray(e) ? v(this, e, "serialize") : e
        },
        getComparisonValue: function(e) {
            return e
        },
        getComparisonValueMany: function(e) {
            return e
        },
        specifiedByUrl: null,
        KIND: a.a.STRING,
        PERSISTENT_KIND: null,
        DATE_TIME_TYPE: null,
        OBJECT_TYPE: null,
        JSDOC_TYPE: null,
        isAutoIncrement: !1,
        isBigIncrement: !1,
        isCurrency: !1,
        canAutoGenerate: !1,
        isEncrypted: !1,
        isSerializable: !0,
        min: null,
        max: null,
        digits: null,
        scale: null,
        regex: null,
        regexErrorMsg: null,
        modelName: null,
        modelDisplayName: null,
        fieldName: null
    };
    var S = n(85);
    const O = ["name", "description", "isDeprecated", "deprecationReason", "astNode", "value"]
      , T = ["name", "description", "deprecationReason", "astNode", "value"]
      , I = {
        name: (e, t) => {
            const {name: n} = e;
            if (!n)
                throw new Error('Cannot add value to enum "' + t + '" because the provided valueConfig does not provide a name for the value. Got: ' + Object(u.a)(e.name));
            if ("number" === typeof n)
                throw new Error('The ENUM value "' + n + '" for ENUM "' + t + '" is a number. This is not supported for ENUM fields by graphql, it must be a string.');
            if (n.indexOf("-") > -1)
                throw new Error('The ENUM field "' + n + '" on ENUM "' + t + '" contains a dash. This is not supported for ENUM fields by graphql.')
        }
        ,
        description: (e, t) => {
            e.description || (e.description = void 0)
        }
        ,
        isDeprecated: (e, t) => {
            if (e.hasOwnProperty("isDeprecated"))
                throw new Error("".concat(t, ".").concat(e.name, ' should provide "deprecationReason" instead of "isDeprecated".'));
            e.isDeprecated = Boolean(e.deprecationReason)
        }
        ,
        deprecationReason: (e, t) => {
            e.deprecationReason || (e.deprecationReason = void 0)
        }
        ,
        astNode: (e, t) => {
            e.astNode || (e.astNode = void 0)
        }
        ,
        value: (e, t) => {
            e.hasOwnProperty("value") || (e.value = e.name)
        }
    };
    function x(e, t, n) {
        if ("string" === typeof e)
            e = {
                name: e
            };
        else {
            if (!e || "object" !== typeof e) {
                const n = e ? e.name : e;
                throw new Error("".concat(t, ".").concat(n, ' must refer to an object with a "value" key representing an internal value but got: ').concat(Object(u.a)(e)))
            }
            if (!e.name)
                throw new Error("The enum `" + t + "` contains a value that does not define a name, and a name could not be inferred automatically. The value is: " + Object(u.a)(e))
        }
        if (n)
            for (let r of T)
                I[r](e, t);
        else
            for (let r of O)
                I[r](e, t);
        return e
    }
    function w(e, t) {
        return t ? t.hasOwnProperty(e.name) || (t[e.name] = {
            ...e
        }) : t = {
            [e.name]: {
                ...e
            }
        },
        t
    }
    function M(e, t, n, r, i) {
        return "undefined" !== typeof n && t.value !== n && (r ? i = w(t, i) : i || (i = !0),
        e._valueLookup.delete(t.value),
        e._valueLookup.set(n, t),
        t.value = n),
        i
    }
    const A = ["description", "isDeprecated", "deprecationReason", "astNode"];
    var E = n(121);
    function C(e) {
        if (e.Enum)
            return e.Enum;
        const t = g(e, S.a);
        class n extends t {
            static ensureValidConfig(e) {
                let {values: t, prepareValueConfig: n, name: r} = e;
                if (!t)
                    throw new Error('Unable to define the Enum "' + e.name + '" because no values were included.');
                if (Array.isArray(t)) {
                    const i = {};
                    for (let o of t)
                        o = x(n.call(e, o), r, !0),
                        i[o.name] = o;
                    e.values = i
                } else {
                    let i;
                    for (let o in t)
                        i = t[o],
                        "string" === typeof i ? i = {
                            name: o,
                            value: i
                        } : i && "object" === typeof i && !i.name && (i.name = o),
                        t[o] = x(n.call(e, i, o), r, !0)
                }
                return super.ensureValidConfig(e)
            }
            getLazyValues(e) {
                return e || this.lazyValues || (this.lazyValues = {}),
                this.lazyValues
            }
            getLazyValue(e) {
                if (this.lazyValues && this.lazyValues[e])
                    return this.lazyValues[e](e, this),
                    this._nameLookup[e]
            }
            destroy() {
                super.destroy(),
                this._values && (this._values.length = 0,
                this._values = void 0,
                this._nameLookup = void 0,
                this._valueLookup.clear(),
                this._valueLookup = void 0,
                this.lazyValues = void 0)
            }
        }
        return n.KIND = a.a.ENUM,
        n.configDefaults = {
            ...t.configDefaults,
            ...k
        },
        Object(s.a)(n, P, N),
        e.Enum = n,
        n
    }
    const N = {
        definitionExisted: function(e, t) {
            return e && "object" === typeof e && t.addValues(e.values),
            t
        }
    };
    function R(e, t, n, r, i) {
        t = x(t, e.name);
        let o = e._nameLookup[t.name];
        return o ? n ? function(e, t, n, r, i) {
            let o = (i = M(e, n, t.value, r, i)) && r && i.hasOwnProperty(n.name);
            for (let s of A)
                t.hasOwnProperty(s) && t[s] !== n[s] && (r && !o && (i = w(n, i),
                o = !0),
                n[s] = t[s]);
            return i
        }(e, t, o, r, i) : i : (e._values.push(t),
        e._valueLookup.set(t.value, t),
        e._nameLookup[t.name] = t,
        !r || (s = t,
        (a = i) ? a.hasOwnProperty(s.name) || (a[s.name] = null) : a = {
            [s.name]: null
        },
        a));
        var s, a
    }
    const P = {
        getValue: function(e) {
            return this._valueLookup.get(e) || "string" === typeof e && (this._nameLookup[e] || this.getLazyValue(e)) || void 0
        },
        addLazyValue: function(e, t) {
            return this.lazyValues || (this.lazyValues = {}),
            this.lazyValues[e] = t,
            this
        },
        addLazyValues: function(e, t) {
            let {lazyValues: n} = this;
            if (n || (n = {},
            this.lazyValues = n),
            "function" === typeof t)
                for (let r of e)
                    n[r] = t;
            else
                for (let r in e)
                    n[r] = e[r];
            return this
        },
        addValue: function(e, t) {
            e = this.prepareValueConfig(e);
            const n = this._getChanges$(!0)
              , r = R(this, e, t, n);
            return n && r && n.next(r),
            !!r
        },
        addValues: function(e, t) {
            const n = this._getChanges$(!0);
            let r = void 0;
            if (Array.isArray(e))
                for (let i of e)
                    i = this.prepareValueConfig(i),
                    r = R(this, i, t, n, r);
            else {
                let i;
                for (let o in e) {
                    if (i = this.prepareValueConfig(e[o], o),
                    "string" === typeof i)
                        i = {
                            name: o,
                            value: i
                        };
                    else if (i.name) {
                        if (i.name !== o)
                            throw new Error("An invalid value config was provided to the enum ".concat(this.name, ". An Object containing key:value pairs was provided, but value.name is not the same as the value's key in the Object. You do not need to provide a name for each value when providing an Object of values. Its key in the Object will serve as its name. But if value.name is provided, it must match the key in the Object. Provided value: ").concat(Object(u.a)(i)))
                    } else
                        i.name = o;
                    r = R(this, i, t, n, r)
                }
            }
            return n && r && n.next(r),
            !!r
        },
        removeValue: function(e) {
            if (Object.prototype.hasOwnProperty.call(this._nameLookup, e)) {
                const t = this._nameLookup[e];
                delete this._nameLookup[e];
                const n = this._values.indexOf(t);
                n > -1 && this._values.splice(n, 1),
                this._valueLookup.delete(t);
                const r = this._getChanges$(!0);
                return r && r.next({
                    [e]: {
                        ...t
                    }
                }),
                !0
            }
            return !1
        },
        updateValueDescription: function(e, t) {
            const n = this.getValue(e);
            if (!n)
                return;
            if (n.description === t)
                return !1;
            const r = this._getChanges$(!0);
            if (r) {
                const e = w(n);
                n.description = t,
                r.next(e)
            } else
                n.description = t;
            return !0
        },
        updateInternalValue: function(e, t) {
            const n = this.getValue(e);
            if (!n || n.value === t)
                return !1;
            const r = this._getChanges$(!0)
              , i = M(this, n, t, r);
            return r && i && r.next(i),
            !!i
        },
        updateInternalValues: function(e) {
            const t = this._getChanges$(!0);
            let n, r = !1;
            for (let i in e)
                (n = this.getValue(i)) && (r = M(this, n, e[i], t, r));
            return t && r && t.next(r),
            !!r
        },
        subscribeToChanges: function(e) {
            const t = this._getChanges$();
            return e ? t.subscribe(e) : t
        },
        pipeChanges: function() {
            const e = this._getChanges$();
            return arguments.length ? e.pipe(...arguments) : e
        },
        getName: function(e) {
            var t;
            return null === (t = this.getValue(e)) || void 0 === t ? void 0 : t.name
        },
        getInternalValue: function(e) {
            const t = this.getValue(e);
            return t ? t.value : void 0
        },
        toInternalValues: function(e) {
            let t;
            if (Array.isArray(e))
                for (let n = 0; n < e.length; n++)
                    t = this.getValue(e[n]),
                    e[n] = t ? t.value : void 0;
            else
                for (let n in e)
                    t = this.getValue(e[n]),
                    e[n] = t ? t.value : void 0;
            return e
        },
        _getChanges$: function(e) {
            let t = this._changes$;
            return e ? t && t.observers.length ? t : null : (t || (t = new E.a,
            this._changes$ = t),
            t)
        }
    };
    const D = (e, t) => e[t.name] = t.value;
    const F = (e, t) => "The enum value ".concat(Object(u.a)(e), ' is not defined on the "').concat(t, '" enum, so it cannot be provided as a value.');
    const k = {
        KIND: a.a.ENUM,
        parseValue: function(e) {
            const t = this.getValue(e);
            if (!t)
                throw new TypeError(F(e, this.name));
            return t.value
        },
        serialize: function(e) {
            if (null === e || "undefined" === typeof e)
                return e;
            const t = this._valueLookup.get(e);
            if (t)
                return t.name;
            if ("string" !== typeof e)
                throw new TypeError(F(e, this.name));
            return e
        },
        parseLiteral: S.a.prototype.parseLiteral,
        toPersistent: function(e) {
            return "undefined" === typeof e || null === e ? e : this.serialize(e)
        },
        fromPersistent: function(e) {
            return "string" !== typeof e ? null : this.parseValue(e)
        },
        getSchemaTypeDef: function() {
            let e = ""
              , t = this.description;
            t && (e += '"""'.concat(t, '"""\n')),
            e += "enum ".concat(this.name, " {\n");
            const n = this.getValues();
            for (let r of n)
                (t = r.description) && (e += '  """'.concat(t, '"""\n')),
                e += "  ".concat(r.name, "\n");
            return e += "}",
            e
        },
        getSchemaResolver: function() {
            return this.getValues().reduce(D, {})
        },
        toASTValue: function(e) {
            return Object(c.c)(e)
        },
        prepareValueConfig: function(e, t) {
            return e
        }
    };
    var j = n(285)
      , L = n(194);
    function V(e) {
        if (e.String)
            return e.String;
        class t extends e.Scalar {
            static ensureValidConfig(e) {
                return e.name || (e.name = this.createName(e.min, e.max)),
                e.description || e.regex || (e.description = this.createDescription(e.name, e.min, e.max)),
                super.ensureValidConfig(e)
            }
        }
        return Object(s.a)(t, void 0, U),
        t.KIND = a.a.STRING,
        t.baseName = i.D,
        t.configDefaults = {
            ...e.Scalar.configDefaults,
            ...q
        },
        e.String = t,
        t
    }
    const U = {
        createName: function(e, t) {
            return this.configDefaults.name || e === this.configDefaults.min && t === this.configDefaults.max ? "".concat(this.baseName) : "".concat(this.baseName, "_").concat(e, "_").concat(t)
        },
        createDescription: function(e, t, n) {
            let r = "The `".concat(e, "` scalar type represents ");
            switch (this.baseName) {
            case i.a:
                return r += "a physical street address.",
                r;
            case i.c:
                return r += "a hex, hsl, hsla, rgb, or rgba color code.",
                r;
            case i.d:
                return r += "an ISO 3166-1 alpha-2 code, which is the 2 character code of a country.",
                r;
            case i.e:
                return r += "an ISO 3166-2 code without the ISO 3166-1 alpha-2 prefix. For example, US-FL would be FL. Can be 2-3 characters, depending on the country.",
                r;
            case i.z:
                return r += "a phone number.",
                r;
            case i.I:
                return r += "an absolute or relative url.",
                r;
            case i.o:
                return r += "an absolute or relative address to an image.",
                r;
            case i.H:
                return r += 'an official IANA TimeZone. For example, "America/New_York", "Europe/London", etc.',
                r;
            default:
                return r += "textual data, defined as UTF-8 character sequences of at least ".concat(t, " and no more than ").concat(n, " characters. The ").concat(this.baseName === i.D ? "String" : this.baseName, " type is most often used to represent free-form human-readable text."),
                r
            }
        },
        parseConfigString: function(e) {
            if (e === this.baseName)
                return {
                    name: this.baseName
                };
            let[t,n,r] = e.split("_");
            if (t !== this.baseName)
                throw new Error("Unable to create ".concat(this.baseName, " type from name. In order to do so, a string of format `").concat(this.baseName, "_<min_length>_<max_length>` must be provided. \n Example: `").concat(this.baseName, "_1_255` represents a string that contains at least 1 character and a maximum of 255 characters. Got: ").concat(Object(u.a)(e)));
            return n = n ? parseInt(n, 10) : this.configDefaults.min,
            r = r ? parseInt(r, 10) : this.configDefaults.max,
            {
                name: this.createName(n, r),
                min: n,
                max: r
            }
        },
        use: function(e, t) {
            "number" !== typeof e && (e = this.configDefaults.min),
            "number" !== typeof t && (t = this.configDefaults.max);
            const n = this.createName(e, t);
            return this.get(n) || this.define({
                name: n,
                min: e,
                max: t
            })
        }
    };
    const q = {
        ...L.b.toConfig(),
        name: void 0,
        baseName: i.D,
        description: null,
        min: 0,
        max: 255,
        JSDOC_TYPE: "string",
        serialize: function(e) {
            return e
        },
        parseValue: function(e) {
            if ("string" !== typeof e)
                if ("boolean" === typeof e)
                    e = e ? "true" : "false";
                else {
                    if (!Object(j.b)(e))
                        throw new TypeError("".concat(this.name, " cannot represent value: ").concat(Object(u.a)(e)));
                    e = e.toString()
                }
            return this.validateMinMax(e)
        },
        parseLiteral: function(e) {
            return e.kind === a.a.STRING ? e.value : void 0
        }
    };
    const Q = () => {}
    ;
    let B = Q;
    function G(e) {
        if (e.String) {
            if (e.RegExp)
                return e.RegExp
        } else
            V(e);
        class t extends e.String {
            static ensureValidConfig(e) {
                if (!e.regex)
                    throw new Error("A regular expression must be provided via config.regex, but got: ".concat(Object(u.a)(e.regex)));
                return e.description || (e.description = this.createDescription(e.name, e.regex)),
                e.regexErrorMsg || (e.regexErrorMsg = "The value does not satisfy the ".concat(e.name, " requirements.")),
                super.ensureValidConfig(e),
                e
            }
        }
        return t.createDescription = B,
        t.configDefaults = {
            ...e.String.configDefaults,
            ...z
        },
        e.RegExp = t,
        t
    }
    const z = {
        serialize: function(e) {
            return e && "string" !== typeof e ? "function" === typeof e.toString ? e.toString() : "".concat(e) : e
        },
        parseValue: function(e) {
            if ("string" !== typeof e)
                throw new TypeError("A ".concat(this.name, " value must be a string, but got: ").concat(Object(u.a)(e)));
            if (!this.regex.test(e))
                throw new TypeError(this.regexErrorMsg);
            return this.regex.lastIndex = 0,
            this.validateMinMax(e)
        },
        parseLiteral: function(e) {
            if (e.kind !== a.a.STRING)
                throw new TypeError("The ".concat(this.name, " must be a String, but got: ").concat(Object(u.a)(e.value)));
            return this.parseValue(e.value)
        },
        JSDOC_TYPE: "RegExp"
    }
      , H = /^(?:(?:#[A-Fa-f\d]{6}|#[A-Fa-f\d]{3})|rgb\(\d{1,3}, ?\d{1,3}, ?\d{1,3}\)|rgba\(\d{1,3}, ?\d{1,3}, ?\d{1,3}, ?0?\.?\d{1,5}\)|hsl\(\d+, ?[\d.]+%, ?[\d.]+%\))$/;
    var K = n(1002);
    function Y(e) {
        class t extends e.Scalar {
            static ensureValidConfig(e) {
                "number" !== typeof e.scale && (e.scale = this.configDefaults.scale);
                const {min: t, max: n, scale: r} = e;
                let i, o;
                return e.name || (e.name = this.createName(t, n, r)),
                e.description || (e.description = this.createDescription(e.name, t, n, r)),
                r > 0 ? (i = Object(j.g)(Object(j.a)(t, e.scale)),
                o = Object(j.g)(Object(j.a)(n, e.scale))) : (i = Object(j.h)(t),
                o = Object(j.h)(n)),
                e.digits = i > o ? i : o,
                super.ensureValidConfig(e)
            }
        }
        for (let n in W)
            t[n] = W[n];
        return e.NumberLike = t,
        t
    }
    const W = {
        createName: function(e, t, n) {
            const r = n ? "_".concat(n) : "";
            let o, s;
            if (this.baseName === i.p)
                o = Math.abs(e),
                s = Math.abs(t),
                n = 0;
            else {
                const r = Math.pow(10, n);
                o = Math.round(Math.abs(e) * r),
                s = Math.round(Math.abs(t) * r)
            }
            const {configDefaults: a} = this;
            if (e < 0 && t < 0) {
                const i = n ? -1 / Math.pow(10, n) : -1;
                return e === a.min && t === i && n === a.scale ? "".concat(this.baseName, "Negative") : "".concat(this.baseName, "Negative_").concat(o, "_").concat(s).concat(r)
            }
            return e >= 0 && t >= 0 ? t === a.max && 0 === e && n === a.scale ? "".concat(this.baseName, "Positive") : "".concat(this.baseName, "Positive_").concat(o, "_").concat(s).concat(r) : e === a.min && t === a.max && n === a.scale ? this.baseName : "".concat(this.baseName, "Signed_").concat(o, "_").concat(s).concat(r)
        },
        createDescription: function(e, t, n, r) {
            let o = "The `".concat(e, "` scalar type represents ");
            if (this.baseName === i.p)
                return o += "non-fractional whole numeric values between ".concat(t, " and ").concat(n, "."),
                o;
            const s = Object(j.a)(t, r)
              , a = Object(j.a)(n, r);
            switch (this.baseName) {
            case i.k:
            case i.i:
            case i.f:
                return o += "fractional values ",
                this.baseName === i.f && (o += "of a monetary type "),
                o += "between ".concat(s, " and ").concat(a),
                o;
            case i.y:
                return o += "".concat(0 === r ? "" : "non-", "fractional literal percentage between ").concat(s, " and ").concat(a, ", rather than as a fractional value. A generic example of the difference between this type and the ").concat(i.x, " type is for this type, a percentage of 10.15, for example, is represented as 10.15, rather than 0.1015."),
                o;
            case i.x:
                return o += "fractional percentages between ".concat(s, " and ").concat(a, ", rather than as a literal value. A generic example of the difference between this type and the ").concat(i.y, " type is for this type, a percentage of 10.15, for example, is represented as 0.1015, rather than 10.15."),
                o;
            case i.r:
            case i.s:
                return o += "fractional values between ".concat(s, " and ").concat(a, " representing the ").concat(this.baseName === i.r ? "latitudinal" : "longitudinal", " portion of a geo coordinate."),
                o;
            default:
                throw new Error("Unrecognized type ".concat(this.baseName, ". Unable to generate description."))
            }
        },
        parseConfigString: function(e) {
            const {configDefaults: t} = this
              , n = {
                name: e,
                min: t.min,
                max: t.max,
                scale: t.scale
            };
            switch (e) {
            case this.baseName:
            case "".concat(this.baseName, "Signed"):
                return n;
            case "".concat(this.baseName, "Positive"):
                return n.min = 0,
                n;
            case "".concat(this.baseName, "Negative"):
                return n.max = n.scale ? -1 / Math.pow(10, n.scale) : -1,
                n
            }
            const r = "".concat(this.baseName, "Positive")
              , o = "".concat(this.baseName, "Negative")
              , s = "".concat(this.baseName, "Signed");
            let[a,c,u,l] = e.split("_");
            if (a !== r && a !== o && a !== s || !c || !u || n.scale && !l) {
                let t;
                switch (this.baseName) {
                case i.p:
                    t = "integer";
                    break;
                case i.k:
                case i.i:
                    t = "float";
                    break;
                case i.f:
                    t = "currency";
                    break;
                case i.y:
                case i.x:
                    t = "percent";
                    break;
                case i.r:
                    t = "latitude";
                    break;
                case i.s:
                    t = "longitude";
                    break;
                default:
                    t = "number"
                }
                let a = "Unable to create ".concat(this.baseName, " type from name. In order to do so, a string of format ").concat(this.baseName, "<Positive|Negative|Signed>_<min>_<max>").concat(n.scale ? "_<scale>" : "", " must be provided.\n");
                throw n.scale ? (a += "Example 1: `".concat(r, "` represents a positive ").concat(t, " between 0 and ").concat(K.a, ".00 (scale of 2).\n"),
                a += "Example 2: `".concat(r, "_20001_520032_4` represents a positive ").concat(t, " between 2.0001 and 52.0032 (scale of 4).\n"),
                a += "Example 3: `".concat(o, "` represents a negative ").concat(t, " between ").concat(K.b, ".00 and -0.01 (scale of 2).\n"),
                a += "Example 4: `".concat(o, "_500240_44_3` represents a negative ").concat(t, " between -500.240 and -0.044 (scale of 3). Note that leading 0s are not included, but trailing 0s are included.\n"),
                a += "Example 5: `".concat(s, "_500_22_1` represents a ").concat(t, " that can be either positive or negative, and must be between -50.0000 and 2.2 (scale of 5).\n")) : (a += "Example 1: `".concat(r, "` represents a positive ").concat(t, " between 0 and ").concat(K.a, ".\n"),
                a += "Example 2: `".concat(r, "_2_52` represents a positive ").concat(t, " between 2 and 52.\n"),
                a += "Example 3: `".concat(o, "` represents a negative ").concat(t, " between ").concat(K.b, " and -1.\n"),
                a += "Example 4: `".concat(o, "_500_2` represents a negative ").concat(t, " between -500 and -2.\n"),
                a += "Example 5: `".concat(s, "_500_20` represents an ").concat(t, " that can be either positive or negative, and must be between -500 and 20.\n")),
                a += "Got: " + e,
                new Error(a)
            }
            if (n.min = parseInt(c, 10),
            n.max = parseInt(u, 10),
            n.scale) {
                n.scale = parseInt(l);
                const e = Math.pow(10, l);
                n.min = Object(j.i)(n.min / e, l),
                n.max = Object(j.i)(n.max / e, l)
            }
            return a === o ? (n.min = -Math.abs(n.min),
            n.max = -Math.abs(n.max)) : a === s && (n.min = -Math.abs(n.min)),
            n
        }
    };
    function $(e) {
        if (e.NumberLike) {
            if (e.Float)
                return e.Float
        } else
            Y(e);
        class t extends e.NumberLike {
        }
        return t.KIND = a.a.FLOAT,
        t.baseName = i.k,
        t.defaultScale = 2,
        t.configDefaults = {
            ...e.NumberLike.configDefaults,
            ...J
        },
        t.use = X,
        t.createName = e.NumberLike.createName,
        e.Float = t,
        t
    }
    function X(e, t, n) {
        "number" !== typeof e && (e = this.configDefaults.min),
        "number" !== typeof t && (t = this.configDefaults.max),
        "number" !== typeof n && (n = this.configDefaults.scale);
        const r = this.createName(e, t, n);
        return this.get(r) || this.define({
            name: r,
            min: e,
            max: t,
            scale: n
        })
    }
    const J = {
        min: K.b,
        max: K.a,
        digits: 12,
        scale: 2,
        KIND: a.a.FLOAT,
        baseName: i.k,
        JSDOC_TYPE: "number",
        isCurrency: !1,
        serialize: function(e) {
            if (null === e || "undefined" === typeof e)
                return e;
            if (e = Object(j.f)(e),
            !Object(j.b)(e))
                throw new TypeError("".concat(this.name, " cannot represent non numeric value: ").concat(Object(u.a)(e)));
            return e
        },
        parseValue: function(e) {
            if (e = Object(j.f)(e),
            !Object(j.b)(e))
                throw new TypeError("".concat(this.name, " cannot represent non numeric value: ").concat(Object(u.a)(e)));
            return e = Object(j.i)(e, this.scale),
            this.validateMinMax(e),
            e
        },
        parseLiteral: function(e) {
            return e.kind === a.a.FLOAT || e.kind === a.a.INT ? this.parseValue(e.value) : void 0
        }
    };
    function Z(e) {
        if (e.Float) {
            if (e.Decimal)
                return e.Decimal
        } else
            $(e);
        class t extends e.Float {
        }
        return t.KIND = a.a.FLOAT,
        t.baseName = i.i,
        t.configDefaults = {
            ...e.Float.configDefaults,
            baseName: i.i
        },
        e.Decimal = t,
        t
    }
    const ee = e => "number" !== typeof e && "number" !== typeof (e = Object(j.f)(e)) ? e : e < 10 ? "0".concat(e) : "".concat(e);
    var te = n(1021);
    function ne(e) {
        return Object(c.b)(this.serialize(e))
    }
    function re(e) {
        try {
            return this.parseValue(e.value)
        } catch (t) {
            return
        }
    }
    function ie(e) {
        return e instanceof Date ? e.getTime() : e
    }
    function oe(e) {
        const t = new Array(e.length);
        for (let n = 0; n < e.length; n++)
            t[n] = e[n]instanceof Date ? e[n].getTime() : e[n];
        return t
    }
    const se = /^\d{13}$/
      , ae = /^\d{10}$/
      , ce = /\d{4}-\d{1,2}-\d{1,2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-][\d.]+)$/
      , ue = e => se.test(e) ? new Date("string" === typeof e ? parseInt(e) : e) : !!ae.test(e) && new Date("string" === typeof e ? 1e3 * parseInt(e) : 1e3 * e)
      , le = e => !!ce.test(e) && new Date(e)
      , de = (e, t) => {
        throw new Error("String ".concat(e, " is not a valid ").concat(t.DATE_TIME_TYPE, " type."))
    }
    ;
    function he(e) {
        if (null === e || "undefined" === typeof e)
            return e;
        if (e instanceof Date) {
            const t = e.getTime();
            if (t === t)
                return e;
            throw new Error("Invalid date instance cannot represent ".concat(this.DATE_TIME_TYPE, " type."))
        }
        let t = ue(e);
        if (t)
            return t;
        if (t = le(e))
            return t;
        if (se.test(e))
            return new Date("string" === typeof e ? parseInt(e) : e);
        if (ae.test(e))
            return new Date("string" === typeof e ? 1e3 * parseInt(e) : 1e3 * e);
        if ("string" !== typeof e)
            throw new Error("".concat(typeof e, " type cannot represent ").concat(this.DATE_TIME_TYPE, " type."));
        try {
            const t = new Date(e)
              , n = t.getTime();
            if (n === n)
                return t;
            de(e, this)
        } catch (n) {
            de(e, this)
        }
        return e
    }
    var fe = n(389)
      , pe = n(137);
    function ge() {
        return this.baseName
    }
    function me(e) {
        return Object(fe.a)(e, "yyyy-MM-dd")
    }
    const ye = /^\d{4}-\d{2}-\d{2}$/;
    function ve(e) {
        return "string" !== typeof e ? e : Object(pe.b)("".concat(e, " 00:00:00.000"), "Etc/GMT")
    }
    function be(e) {
        if (null === e || "undefined" === typeof e)
            return e;
        if ("now()" === e)
            return me(new Date);
        if (e instanceof Date)
            return "".concat(e.getUTCFullYear(), "-").concat(ee(e.getUTCMonth() + 1), "-").concat(ee(e.getUTCDate()));
        if (ye.test(e)) {
            const t = e.substring(0, 4)
              , n = Number(e.substring(5, 2))
              , r = Number(e.substring(8, 2));
            if (Object(te.a)(n, t) < r)
                throw new Error("Invalid Date provided: Month ".concat(n, " does not have ").concat(r, " days."));
            return e
        }
        let t = le(e);
        if (t)
            return me(t);
        if (t = ue(e))
            return me(t);
        throw new Error("Value ".concat(Object(u.a)(e), " cannot represent ").concat(i.g, " type."))
    }
    function _e(e) {
        return null === e || "undefined" === typeof e ? e : me(e)
    }
    function Se(e) {
        return null === e || "undefined" === typeof e ? e : e.toISOString()
    }
    const Oe = /^[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/i;
    function Te(e) {
        if (e.String) {
            if (e.Url)
                return e.Url
        } else
            V(e);
        class t extends e.String {
        }
        t.baseName = i.I,
        t.configDefaults = {
            ...e.String.configDefaults,
            max: 65535,
            baseName: i.I
        },
        e.Url = t
    }
    function Ie(e, t) {
        "number" !== typeof e && (e = this.MIN_INT),
        "number" !== typeof t && (t = this.MAX_INT);
        const n = this.createName(e, t, 0);
        let r = this.get(n);
        return r || (r = this.define({
            name: n,
            min: e,
            max: t
        })),
        r
    }
    const xe = {
        baseName: i.p,
        min: K.b,
        max: K.a,
        digits: 10,
        scale: 0,
        serialize: function(e) {
            if (null === e)
                return e;
            const t = typeof e;
            if ("boolean" === t)
                return e ? 1 : 0;
            if ("undefined" === t)
                return e;
            if ("string" === t) {
                if ("" === e)
                    throw new TypeError("".concat(this.name, " cannot represent non-integer value: (empty string)"));
                if ("number" !== typeof (e = Object(j.e)(e)))
                    throw new TypeError("".concat(this.name, " cannot represent non-integer value: ").concat(Object(u.a)(e)))
            } else if ("number" !== t)
                throw new TypeError("".concat(this.name, " cannot represent non-integer value: ").concat(Object(u.a)(e)));
            return e
        },
        parseValue: function(e) {
            if ("number" !== typeof e && (e = Object(j.e)(e)),
            !Object(j.d)(e))
                throw new TypeError("".concat(this.name, " cannot represent non-integer value: ").concat(Object(u.a)(e)));
            return this.validateMinMax(e),
            e
        },
        parseLiteral: function(e) {
            if (e.kind === a.a.INT) {
                const t = parseInt(e.value, 10);
                if (t <= this.max && t >= this.min)
                    return t
            }
        },
        KIND: a.a.INT,
        JSDOC_TYPE: "number"
    };
    var we = n(97)
      , Me = n(188)
      , Ae = n(875);
    let Ee = Q;
    function Ce(e) {
        if (e.ID)
            return e.ID;
        class t extends e.Scalar {
            static ensureValidConfig(e) {
                return super.ensureValidConfig(e),
                e.description || (e.description = Ee(e.name)),
                e
            }
        }
        return t.KIND = a.a.STRING,
        t.PERSISTENT_KIND = a.a.STRING,
        t.baseName = i.n,
        t.configDefaults = {
            ...e.Scalar.configDefaults,
            canAutoGenerate: !0,
            parseValue: je,
            serialize: ke,
            parseLiteral: Le,
            PERSISTENT_KIND: a.a.STRING,
            JSDOC_TYPE: "string",
            baseName: i.n,
            toPersistent: De,
            fromPersistent: Fe,
            toGlobalId: Re,
            fromGlobalId: Pe
        },
        t.use = Ne,
        e.ID = t,
        t
    }
    function Ne() {
        let e = this.get(i.n);
        return e || (e = this.define({
            toGlobalId: Me.a,
            fromGlobalId: Me.a
        })),
        e
    }
    function Re(e) {
        return "string" !== typeof e ? Object(Ae.b)() : e
    }
    function Pe(e) {
        return e
    }
    function De(e) {
        return null === e || "undefined" === typeof e ? e : this.fromGlobalId(e)
    }
    function Fe(e) {
        return null === e || "undefined" === typeof e ? e : this.toGlobalId(e)
    }
    function ke(e) {
        return e
    }
    function je(e) {
        try {
            return this.toGlobalId(e)
        } catch (t) {
            throw new TypeError(t.message)
        }
    }
    function Le(e) {
        return e.kind === a.a.STRING || e.kind === a.a.INT ? this.toGlobalId(e.value) : void 0
    }
    const Ve = /.+/;
    function Ue(e) {
        return "string" === typeof e && 21 === e.length
    }
    function qe(e) {
        return "string" !== typeof e ? Object(Ae.b)() : e
    }
    const Qe = {
        use: function() {
            return this.get(i.b) || this.define({
                name: i.b
            })
        },
        parseValue: L.a.parseValue,
        createName: ge
    }
      , Be = {
        ...L.a.toConfig(),
        name: void 0,
        KIND: a.a.BOOLEAN,
        baseName: i.b,
        JSDOC_TYPE: "boolean",
        parseValue: function(e) {
            if ("boolean" === typeof e)
                return e;
            if (1 === e || "1" === e || "true" === e)
                return !0;
            if (0 === e || "0" === e || "false" === e)
                return !1;
            throw new TypeError("".concat(this.name, " cannot represent a non boolean value: ").concat(Object(u.a)(e)))
        },
        serialize: function(e) {
            return null === e || "undefined" === typeof e ? e : this.parseValue(e)
        },
        fromPersistent: function(e) {
            return null === e ? e : this.parseValue(e)
        },
        toPersistent: function(e) {
            return null === e || "undefined" === typeof e ? e : this.parseValue(e)
        }
    };
    var Ge = n(107);
    let ze = Q;
    function He(e) {
        if (null === e)
            return null;
        switch (typeof e) {
        case "undefined":
            return e;
        case "string":
            try {
                if (JSON.parse(e))
                    return e
            } catch (t) {
                try {
                    return JSON.stringify(e)
                } catch (t) {
                    throw new TypeError("The string ".concat(Object(u.a)(e), " cannot be represented as valid JSON."))
                }
            }
            break;
        case "object":
            try {
                return JSON.stringify(e)
            } catch (t) {
                throw new TypeError("The object ".concat(Object(u.a)(e), " cannot be converted to a valid string representation."))
            }
        case "boolean":
        case "number":
        case "bigint":
            return JSON.stringify(e);
        default:
            throw new TypeError("A ".concat(typeof e, " cannot be represented as valid JSON."))
        }
    }
    const Ke = /^\s*[{\[](?:.|\r?\n)+[}\]]\s*$/;
    function Ye(e) {
        if ("string" !== typeof e)
            return e;
        try {
            return JSON.parse(e)
        } catch (t) {
            if (!Ke.test(e))
                return e;
            try {
                return JSON.parse(e.trim())
            } catch (t) {
                throw new Error("The string ".concat(Object(u.a)(e), " is not valid JSON."))
            }
        }
    }
    function We(e) {
        if (e.JSON)
            return e.JSON;
        class t extends e.Scalar {
            static ensureValidConfig(e) {
                return super.ensureValidConfig(e),
                e.min || (e.min = 0),
                "number" !== typeof e.max ? e.max = 255 : 0 === e.max && (e.isSerializable = !1),
                e.description || (e.description = this.createDescription(e.name, e.isSerializable, e.max)),
                e
            }
        }
        return t.KIND = a.a.OBJECT,
        t.PERSISTENT_KIND = a.a.OBJECT,
        t.configDefaults = {
            ...e.Scalar.configDefaults,
            ...tt,
            baseName: i.q
        },
        t.baseName = i.q,
        t.createName = Xe,
        t.use = $e,
        t.parseConfigString = et,
        t.createDescription = ze,
        e.JSON = t,
        t
    }
    function $e(e) {
        const t = this.createName(0, e);
        let n = this.get(t);
        return n || (n = this.define({
            name: t,
            max: "number" === typeof e ? e : 255
        })),
        n
    }
    function Xe(e, t) {
        return 0 === t ? "".concat(i.q, "_0") : i.q
    }
    function Je(e, t, n) {
        switch (t.kind) {
        case a.a.STRING:
        case a.a.BOOLEAN:
            return t.value;
        case a.a.INT:
        case a.a.FLOAT:
            return parseFloat(t.value);
        case a.a.OBJECT:
            return function(e, t, n) {
                const r = Object.create(null)
                  , {fields: i} = t;
                for (let o of i)
                    r[o.name.value] = Je(e, o.value, n);
                return r
            }(e, t, n);
        case a.a.LIST:
            return t.values.map(t => Je(e, t, n));
        case a.a.NULL:
            return null;
        case a.a.VARIABLE:
            return n ? n[t.name.value] : void 0;
        default:
            throw new TypeError("".concat(e, " cannot represent value: ").concat(Object(Ge.a)(t)))
        }
    }
    function Ze(e) {
        return Je(this.name, e)
    }
    function et(e) {
        if (e === i.q)
            return {
                ...this.configDefaults,
                name: i.q
            };
        let[t,n] = e.split("_");
        if (t !== i.q)
            throw new Error("Unable to create ".concat(i.q, " type from name. In order to do so, a string of format `").concat(i.q, "_<max_length>` must be provided. \n Example: `").concat(i.q, "_2000` represents a JSON value that when serialized contains at most 2000 characters. Got: ").concat(Object(u.a)(e)));
        return "number" !== typeof (n = Object(j.e)(n)) && (n = tt.max),
        {
            name: e,
            max: n,
            isSerializable: 0 !== n
        }
    }
    const tt = {
        toPersistent: function(e) {
            return this.isSerializable ? He(e) : null
        },
        fromPersistent: function(e) {
            return Ye(e)
        },
        serialize: function(e) {
            return He(e)
        },
        parseValue: function(e) {
            return this.isSerializable ? Ye(e) : e
        },
        parseLiteral: Ze,
        min: 0,
        max: 255,
        PERSISTENT_KIND: a.a.OBJECT,
        JSDOC_TYPE: "Object",
        isSerializable: !0
    };
    var nt = n(3)
      , rt = n(998);
    function it(e) {
        if (null === e)
            return this.canAutoGenerate ? Object(Ae.b)() : ft(this);
        switch (typeof e) {
        case "string":
            if ("number" !== typeof (e = Object(j.e)(e)))
                return e;
        case "number":
            if (e <= 0)
                throw new TypeError("An ID for Model ".concat(this.modelName, " must be greater than 0. Got: ").concat(e));
            return e;
        case "undefined":
            return this.canAutoGenerate ? Object(Ae.b)() : ft(this);
        default:
            return pt(this, typeof e, "number")
        }
    }
    function ot(e) {
        return e
    }
    const st = {
        toGlobalId: it,
        fromGlobalId: it,
        isValidGlobalId: function(e) {
            return "number" === typeof e && e > 0 && e < 4294967295
        },
        parseValue: it,
        fromPersistent: ot
    };
    function at(e) {
        if (null === e)
            return this.canAutoGenerate ? Object(Ae.b)() : ft(this);
        switch (typeof e) {
        case "string":
            return e;
        case "number":
            return "".concat(e);
        case "undefined":
            return this.canAutoGenerate ? Object(Ae.b)() : ft(this);
        default:
            return pt(this, typeof e, "string")
        }
    }
    const ct = {
        toGlobalId: at,
        fromGlobalId: at,
        isValidGlobalId: function(e) {
            return "string" === typeof e
        },
        parseValue: at,
        fromPersistent: ot
    }
      , ut = e => ( (e, t) => {
        for (const n in t)
            e[n] = t[n];
        return e
    }
    )(e, e.PERSISTENT_KIND === a.a.STRING ? ct : st);
    function lt(e) {
        return e && Object(rt.b)(e) && this.regex.test(Object(rt.a)(e))
    }
    const dt = nt.c.length;
    function ht(e) {
        return Object(rt.b)(e) && (e = (e = Object(rt.a)(e)).substring(e.lastIndexOf(nt.c) + dt)),
        Object(j.e)(e)
    }
    const ft = e => {
        throw new TypeError("The ID for Model ".concat(e.modelName, " must be provided."))
    }
      , pt = (e, t, n) => {
        throw n || (n = "string or number"),
        new Error("Expected ".concat(n, " for ").concat(e.modelName, " model global ID, got ").concat(t, "."))
    }
    ;
    function gt(e) {
        switch (typeof e) {
        case "number":
        case "bigint":
            break;
        case "string":
            if (Object(rt.b)(e)) {
                if (this.regex.test(Object(rt.a)(e)))
                    return e;
                throw this.regexErrorMsg ? new TypeError(this.regexErrorMsg) : new TypeError("A globalId was provided for Model ".concat(this.modelName, ", but the globalId is not valid for the model."))
            }
            break;
        case "undefined":
            if (!this.canAutoGenerate)
                return ft(this);
            e = Object(Ae.b)();
            break;
        case "object":
            if (null !== e)
                return pt(this, "object");
            if (!this.canAutoGenerate)
                return ft(this);
            e = Object(Ae.b)();
            break;
        default:
            return pt(this, typeof e)
        }
        return Object(rt.c)("".concat(this.pluginSlug).concat(nt.c).concat(this.modelName).concat(nt.c).concat(e))
    }
    var mt = n(36);
    const yt = function() {
        const e = {};
        for (let t in o.r)
            e[o.r[t]] = !0;
        return e
    }();
    function vt(e, t) {
        return "The provided OBJECT_TYPE for the ".concat(e, " scalar (").concat(Object(u.a)(t), ") is not a recognized instance type. Valid instance types include: ").concat(Object.keys(yt).join(", "), ".")
    }
    function bt(e) {
        return "".concat(e, "InstanceScalar")
    }
    const _t = {
        use: function(e) {
            if (!yt[e])
                throw new Error(vt("ObjectInstance", e));
            const t = bt(e);
            let n = this.get(t);
            return n || (n = this.define({
                name: t,
                OBJECT_TYPE: e
            })),
            n
        },
        parseConfigString: function(e) {
            const [t] = e.split("InstanceScalar");
            if (!yt[t])
                throw new Error(vt(e, t));
            return {
                name: e,
                OBJECT_TYPE: t
            }
        }
    };
    function St(e) {
        throw new Error("An ObjectInstance cannot be saved to persistent storage. Scalar type: " + this.name)
    }
    const Ot = {
        toPersistent: St,
        fromPersistent: St,
        isSerializable: !1,
        serialize: function(e) {
            throw new Error("Cannot serialize an ObjectInstance. Scalar type: " + this.name)
        },
        parseValue: function(e) {
            if ("string" === typeof e)
                throw new Error("Parsing an ObjectInstance from a string is not possible.");
            if (!Object(o.y)(e, this.OBJECT_TYPE))
                throw new TypeError("The value of the scalar ".concat(this.name, " must be an instance of ").concat(this.OBJECT_TYPE, ", but got: ").concat(Object(u.a)(e)));
            return e
        },
        parseLiteral: function(e) {
            if (e.kind !== a.a.STRING)
                throw new mt.a("The ".concat(this.name, " type can only be represented by a string, but got: ").concat(e.kind));
            return this.parseValue(e.value)
        }
    }
      , Tt = /^[a-z][a-z0-9_]*$/;
    function It(e) {
        return null === e || "undefined" === typeof e ? e : e instanceof Date ? e.getTime() : "number" === typeof e ? Math.trunc(e) : Date.parse(e)
    }
    function xt() {
        return this.get(i.G) || this.define({
            name: i.G
        })
    }
    function wt(e) {
        if ("now()" === e)
            return Math.floor(Date.now() / 1e3);
        if (null === e || "undefined" === typeof e)
            return e;
        if (e instanceof Date)
            return Math.floor(e.getTime() / 1e3);
        if ("number" !== typeof (e = Object(j.e)(e))) {
            if (e.endsWith("Z"))
                return Math.floor(new Date(e).getTime() / 1e3);
            throw new Error("The value ".concat(Object(u.a)(e), " cannot represent the number of seconds since the Unix Epoch."))
        }
        return Math.abs(e) > 9999999999 ? Math.floor(e / 1e3) : e
    }
    const Mt = {
        baseName: i.r,
        min: -90,
        max: 90,
        scale: 5,
        digits: 7
    };
    const At = {
        baseName: i.s,
        min: -180,
        max: 180,
        scale: 5,
        digits: 8
    };
    var Et = n(1010);
    function Ct(e) {
        return e
    }
    function Nt() {
        return this.get(i.m) || this.define({
            name: i.m
        })
    }
    const Rt = {
        JSDOC_TYPE: "string",
        baseName: i.m,
        toPersistent: function(e) {
            return e
        },
        fromPersistent: function(e) {
            return null === e || "string" === typeof e ? e : e.toString()
        },
        parseAst: Je,
        parseLiteral: Ze,
        parseValue: function(e) {
            return e ? "string" === typeof e ? e : "GeoPoint" : e
        },
        serialize: function(e) {
            return null === e || "object" !== typeof e ? e : Object(Et.b)(e)
        }
    };
    function Pt(e) {
        return e
    }
    function Dt() {
        return this.get(i.l) || this.define({
            name: i.l
        })
    }
    const Ft = {
        JSDOC_TYPE: "string",
        baseName: i.l,
        toPersistent: function(e) {
            return e
        },
        fromPersistent: function(e) {
            return null === e || "string" === typeof e ? e : e.toString()
        },
        parseAst: Je,
        parseLiteral: Ze,
        parseValue: function(e) {
            return e && "string" !== typeof e ? "GEOMETRY" : e
        },
        serialize: function(e) {
            return null === e || "object" !== typeof e ? e : Object(Et.b)(e)
        }
    };
    function kt(e) {
        const t = g(e, S.c);
        class n extends t {
        }
        return e.Scalar = n,
        n.configDefaults = {
            ...t.configDefaults,
            ...jt
        },
        function(e) {
            class t extends e.Scalar {
            }
            t.KIND = a.a.BOOLEAN,
            t.baseName = i.b,
            t.configDefaults = {
                ...e.Scalar.configDefaults,
                ...Be,
                name: i.b
            },
            Object(s.a)(t, void 0, Qe),
            e.Boolean = t
        }(e),
        $(e),
        V(e),
        We(e),
        function(e) {
            if (e.RegExp) {
                if (e.Color)
                    return e.Color
            } else
                G(e);
            class t extends e.RegExp {
                static ensureValidConfig(e) {
                    return e.regex = H,
                    e.name = i.c,
                    e.regexErrorMsg = "The color must be a valid color value. Examples: #ccc, hsl(0, 100%, 50%), rgb(0, 0, 0), rgba(0, 0, 0, 0.25).",
                    super.ensureValidConfig(e)
                }
            }
            e.Color = t,
            t.baseName = i.c,
            t.configDefaults = {
                ...e.RegExp.configDefaults,
                JSDOC_TYPE: "string",
                name: i.c,
                min: 0,
                max: 50,
                regex: H,
                regexErrorMsg: "The color must be a valid color value. Examples: #ccc, hsl(0, 100%, 50%), rgb(0, 0, 0), rgba(0, 0, 0, 0.25).",
                baseName: i.c
            }
        }(e),
        function(e) {
            if (e.String) {
                if (e.Country)
                    return e.Country
            } else
                V(e);
            class t extends e.String {
            }
            t.use = function() {
                return this.get(i.d) || this.define({
                    name: i.d
                })
            }
            ,
            t.baseName = i.d,
            t.configDefaults = {
                ...e.String.configDefaults,
                baseName: i.d,
                name: i.d,
                parseValue: function(e) {
                    if ("undefined" === typeof e || null === e)
                        return e;
                    if ("string" !== typeof e)
                        throw new TypeError("The value ".concat(Object(u.a)(e), " cannot represent a Country ISO 3166-1 alpha-2 code."));
                    return this.validateMinMax(e.toUpperCase())
                },
                min: 2,
                max: 2
            },
            e.Country = t
        }(e),
        function(e) {
            if (e.String) {
                if (e.CountryState)
                    return e.CountryState
            } else
                V(e);
            class t extends e.String {
            }
            t.use = function() {
                return this.get(i.e) || this.define({
                    name: i.e
                })
            }
            ;
            const n = /^[A-Z]{2}-/;
            t.baseName = i.e,
            t.configDefaults = {
                ...e.String.configDefaults,
                baseName: i.e,
                name: i.e,
                min: 1,
                max: 3,
                parseValue: function(e) {
                    if ("undefined" === typeof e || null === e)
                        return e;
                    if ("string" !== typeof e)
                        throw new TypeError("The value ".concat(Object(u.a)(e), " does not represent a valid ISO 3166-2 code."));
                    if (e = e.trim().toUpperCase(),
                    n.test(e)) {
                        const t = e.indexOf("-");
                        e = e.substring(t + 1)
                    }
                    return this.validateMinMax(e)
                }
            },
            e.CountryState = t
        }(e),
        Z(e),
        function(e) {
            if (e.Decimal) {
                if (e.Currency)
                    return e.Currency
            } else
                Z(e);
            class t extends e.Decimal {
            }
            t.KIND = a.a.FLOAT,
            t.baseName = i.f,
            t.configDefaults = {
                ...e.Decimal.configDefaults,
                baseName: i.f,
                isCurrency: !0
            },
            e.Currency = t
        }(e),
        Ce(e),
        function(e) {
            e.NumberLike || Y(e);
            class t extends e.NumberLike {
            }
            t.KIND = a.a.INT,
            t.baseName = i.p,
            t.configDefaults = {
                ...e.NumberLike.configDefaults,
                ...xe
            },
            t.use = Ie,
            t.createName = e.NumberLike.createName,
            t.MIN_INT = K.b,
            t.MAX_INT = K.a,
            e.Int = t
        }(e),
        function(e) {
            if (e.Float) {
                if (e.Latitude)
                    return e.Latitude
            } else
                $(e);
            class t extends e.Float {
            }
            t.KIND = a.a.FLOAT,
            t.baseName = i.r,
            t.createName = ge,
            t.configDefaults = {
                ...e.Float.configDefaults,
                ...Mt
            },
            e.Latitude = t
        }(e),
        function(e) {
            if (e.Float) {
                if (e.Longitude)
                    return e.Longitude
            } else
                $(e);
            class t extends e.Float {
            }
            t.KIND = a.a.FLOAT,
            t.baseName = i.s,
            t.createName = ge,
            t.configDefaults = {
                ...e.Float.configDefaults,
                ...At
            },
            e.Longitude = t
        }(e),
        function(e) {
            if (e.String) {
                if (e.Longtext)
                    return e.Longtext
            } else
                V(e);
            class t extends e.String {
            }
            t.baseName = i.t,
            t.configDefaults = {
                ...e.String.configDefaults,
                baseName: i.t,
                min: 0,
                max: 4294967295
            },
            e.Longtext = t
        }(e),
        function(e) {
            if (e.String) {
                if (e.Mediumtext)
                    return e.Mediumtext
            } else
                V(e);
            class t extends e.String {
            }
            t.baseName = i.u,
            t.configDefaults = {
                ...e.String.configDefaults,
                baseName: i.u,
                min: 0,
                max: 16777215
            },
            e.Mediumtext = t
        }(e),
        function(e) {
            if (e.ModelID)
                return e.ModelID;
            e.ID || Ce(e);
            class t extends e.ID {
                static ensureValidConfig(e) {
                    if (!e.modelName)
                        throw new Error("The name of the model must be included on `config.modelName` when defining a Model".concat(this.nameSuffix, " scalar type. Got ").concat(e.modelName));
                    return e.fieldName || (e.fieldName = this.defaultFieldName),
                    e.name || (e.name = this.createName(e.modelName)),
                    e.description || (e.description = this.createDescription(e.name)),
                    e.encodingDisabled ? ut(e) : e.regex || (e.regex = this.createRegex(e.modelName)),
                    super.ensureValidConfig(e)
                }
                static getByModelName(t) {
                    return e.get(this.createName(t))
                }
                static decodeGlobalId(e) {
                    if (!e || !Object(rt.b)(e))
                        return;
                    const t = Object(rt.a)(e).split(nt.c);
                    return 4 === t.length ? {
                        routing: t[0],
                        pluginSlug: t[1],
                        modelName: t[2],
                        id: t[3]
                    } : {
                        pluginSlug: t[0],
                        modelName: t[1],
                        id: t[2]
                    }
                }
                static createRegex(t, n) {
                    return n || (n = "\\S+"),
                    new RegExp("".concat(e.pluginSlug).concat(nt.d).concat(t).concat(nt.d).concat(n))
                }
                static use(e) {
                    let t = this.get(this.createName(e));
                    return t || (t = this.define({
                        modelName: e
                    })),
                    t
                }
                static useDecoded(e) {
                    let t = this.get(this.createName(e));
                    return t ? t.disableEncoding() : this.define({
                        modelName: e,
                        encodingDisabled: !0
                    })
                }
                static useString(e) {
                    if (!e || !e.modelName)
                        throw new Error("The config for the ID must be provided to the ModelID type, and at a minimum must include `modelName`.");
                    return e.fieldName || (e.fieldName = this.defaultFieldName),
                    e.isAutoIncrement = !1,
                    e.KIND = a.a.STRING,
                    e.PERSISTENT_KIND = a.a.STRING,
                    this.define(e)
                }
                static createName(e) {
                    return "".concat(e).concat(this.nameSuffix)
                }
                static modelNameFromName(e) {
                    return e.replace(this.nameSuffix, "")
                }
                static createDescription(e) {
                    return "The `".concat(e, "` scalar represents a unique ID of a `").concat(this.modelNameFromName(e), "` record.")
                }
                static parseConfigString(e) {
                    return {
                        name: e,
                        modelName: this.modelNameFromName(e)
                    }
                }
                static definitionExisted(e, t) {
                    if ("string" !== typeof e && t.toGlobalId === gt)
                        throw new Error("The ".concat(t.name, " scalar has already been defined. A Model").concat(this.nameSuffix, " can only be defined once, merging a definition is not supported due to how many things rely on the ").concat(this.nameSuffix, " of a record. To use a custom Model").concat(this.nameSuffix, " implementation for the ").concat(t.modelName, " Model, ensure it is defined before any fields use is."));
                    return t
                }
                disableEncoding() {
                    return this.encodingDisabled || (this.encodingDisabled = !0,
                    ut(this)),
                    this
                }
                hasFromPersistent() {
                    return this.toGlobalId !== it
                }
                updateFromField(e) {
                    return this.canAutoGenerate = e.canAutoGenerate,
                    this.fieldName = e.name,
                    this.PERSISTENT_KIND = e.decodedKind,
                    this.isAutoIncrement = e.isAutoIncrement,
                    this.isBigIncrement = !0 === e.isBigIncrement,
                    e.encodingDisabled && (this.KIND = e.decodedKind,
                    ut(this)),
                    this
                }
                convertPersistentKindToString() {
                    return this.PERSISTENT_KIND === a.a.STRING || (this.PERSISTENT_KIND = a.a.STRING,
                    this.encodingDisabled && ut(this)),
                    this
                }
            }
            const n = e.ID.configDefaults.getFieldValidator;
            t.nameSuffix = "ID",
            t.defaultFieldName = "id",
            t.baseName = i.v,
            t.KIND = a.a.STRING,
            t.PERSISTENT_KIND = a.a.INT,
            t.configDefaults = {
                ...e.ID.configDefaults,
                isAutoIncrement: !0,
                baseName: i.v,
                canAutoGenerate: !0,
                KIND: a.a.STRING,
                PERSISTENT_KIND: a.a.INT,
                JSDOC_TYPE: "string",
                encodingDisabled: !1,
                parseValue: gt,
                isValidGlobalId: lt,
                fromGlobalId: ht,
                toGlobalId: gt,
                getFieldValidator: function(e) {
                    return this.isAutoIncrement && e.primary ? this.getFieldValidatorMethod() : n.call(this, e)
                }
            },
            e.ModelID = t
        }(e),
        function(e) {
            if (e.ModelUID)
                return e.ModelUID;
            e.ID || Ce(e);
            class t extends e.ModelID {
                static createRegex(e, t) {
                    return Ve
                }
            }
            const n = e.Scalar.configDefaults.getFieldValidator;
            t.nameSuffix = "UID",
            t.defaultFieldName = we.d,
            t.baseName = i.w,
            t.configDefaults = {
                ...e.ModelID.configDefaults,
                baseName: i.w,
                isAutoIncrement: !1,
                isBigIncrement: !1,
                canAutoGenerate: !0,
                KIND: a.a.STRING,
                PERSISTENT_KIND: a.a.STRING,
                getFieldValidator: function(e) {
                    return e.name === we.d ? this.getFieldValidatorMethod() : n.call(this, e)
                },
                isValidGlobalId: Ue,
                parseValue: qe,
                fromGlobalId: Me.a,
                toPersistentMany: Me.a,
                toGlobalIdMany: Me.a,
                fromGlobalIdMany: Me.a,
                toGlobalId: qe,
                max: 30
            },
            e.ModelUID = t
        }(e),
        function(e) {
            if (e.String) {
                if (e.Address)
                    return e.Address
            } else
                V(e);
            class t extends e.String {
            }
            t.baseName = i.a,
            t.configDefaults = {
                ...e.String.configDefaults,
                max: 65535,
                baseName: i.a
            },
            e.Address = t
        }(e),
        G(e),
        function(e) {
            if (e.RegExp) {
                if (e.Email)
                    return e.Email
            } else
                G(e);
            class t extends e.RegExp {
            }
            const n = e.RegExp.configDefaults.parseValue;
            e.Email = t,
            t.baseName = i.j,
            t.configDefaults = {
                ...e.RegExp.configDefaults,
                baseName: i.j,
                name: i.j,
                regex: Oe,
                regexErrorMsg: "The value does not represent an email address.",
                min: 0,
                max: 120,
                JSDOC_TYPE: "string",
                parseValue: function(e) {
                    return "string" === typeof e && (e = e.toLowerCase()),
                    n.call(this, e)
                }
            }
        }(e),
        function(e) {
            if (e.RegExp) {
                if (e.Slug)
                    return e.Slug
            } else
                G(e);
            class t extends e.RegExp {
                static ensureValidConfig(e) {
                    var t;
                    return e.regex = Tt,
                    e.name || (e.name = this.createName(e.min, e.max)),
                    e.description || (e.description = (t = e.name,
                    "The ".concat(t, " represents a lowercase string that begins with a letter followed by only letters, numbers, and underscores."))),
                    e.regexErrorMsg || (e.regexErrorMsg = "Only lowercase letters, numbers, and underscores are allowed, and it must begin with a letter."),
                    super.ensureValidConfig(e)
                }
            }
            e.Slug = t,
            t.baseName = i.C,
            t.configDefaults = {
                ...e.RegExp.configDefaults,
                baseName: i.C,
                JSDOC_TYPE: "string"
            }
        }(e),
        function(e) {
            e.JSON || We(e);
            class t extends e.JSON {
                static ensureValidConfig(e) {
                    if (!e.OBJECT_TYPE)
                        throw new Error("The instance type for the " + e.name + " scalar must be provided via `config.OBJECT_TYPE`, but got: " + Object(u.a)(e.OBJECT_TYPE));
                    if (!yt[e.OBJECT_TYPE])
                        throw new Error(vt(e.name || "ObjectInstance", e.OBJECT_TYPE));
                    return e.name || (e.name = bt(e.OBJECT_TYPE)),
                    e
                }
            }
            Object(s.a)(t, void 0, _t),
            t.configDefaults = {
                ...e.JSON.configDefaults,
                ...Ot
            },
            e.ObjectInstance = t
        }(e),
        function(e) {
            if (e.Date)
                return e.Date;
            class t extends e.Scalar {
            }
            t.use = function() {
                return this.get(i.g) || this.define({
                    name: i.g
                })
            }
            ,
            t.createName = ge,
            e.Date = t,
            t.baseName = i.g,
            t.KIND = a.a.STRING,
            t.configDefaults = {
                ...e.Scalar.configDefaults,
                name: i.g,
                baseName: i.g,
                KIND: a.a.STRING,
                JSDOC_TYPE: "string",
                DATE_TIME_TYPE: i.g,
                serialize: _e,
                toPersistent: ve,
                fromPersistent: be,
                parseValue: be,
                toASTValue: ne,
                parseLiteral: re
            }
        }(e),
        function(e) {
            if (e.DateTime)
                return e.DateTime;
            class t extends e.Scalar {
            }
            t.use = function() {
                return this.get(i.h) || this.define({
                    name: i.h
                })
            }
            ,
            t.createName = ge,
            t.KIND = a.a.STRING,
            t.baseName = i.h,
            e.DateTime = t,
            t.configDefaults = {
                ...e.Scalar.configDefaults,
                name: i.h,
                description: "A date-time string at UTC, such as 2024-05-03T19:04:27Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representing dates and times using the Gregorian calendar.",
                KIND: a.a.STRING,
                JSDOC_TYPE: "Date",
                DATE_TIME_TYPE: i.h,
                baseName: i.h,
                serialize: Se,
                parseValue: he,
                fromPersistent: he,
                parseLiteral: re,
                toASTValue: ne,
                getComparisonValue: ie,
                getComparisonValueMany: oe
            }
        }(e),
        function(e) {
            if (e.Timestamp)
                return e.Timestamp;
            class t extends e.Scalar {
            }
            t.use = function() {
                return this.get(i.F) || this.define({
                    name: i.F
                })
            }
            ,
            t.createName = ge,
            e.Timestamp = t,
            t.baseName = i.F,
            t.KIND = a.a.STRING,
            t.configDefaults = {
                ...e.Scalar.configDefaults,
                name: i.F,
                description: "A date and time represented as the number of milliseconds from the start of the UNIX epoch.",
                KIND: a.a.STRING,
                JSDOC_TYPE: "Date",
                DATE_TIME_TYPE: i.F,
                baseName: i.F,
                serialize: It,
                parseValue: he,
                fromPersistent: he,
                parseLiteral: re,
                toASTValue: ne,
                getComparisonValue: ie,
                getComparisonValueMany: oe
            }
        }(e),
        function(e) {
            if (e.TimestampSeconds)
                return e.TimestampSeconds;
            class t extends e.Scalar {
                static ensureValidConfig(e) {
                    if (e.scale = 0,
                    e.digits = 10,
                    !e.name)
                        throw new Error("A name is required to define a custom type that extends the ".concat(i.G, " type."));
                    return e.description || (e.description = "The ".concat(e.name, " is an integer that represents a moment in time as the number of seconds since the Unix Epoch.")),
                    super.ensureValidConfig(e)
                }
            }
            t.use = xt,
            t.createName = ge,
            t.KIND = a.a.INT,
            t.baseName = i.G,
            e.TimestampSeconds = t,
            t.configDefaults = {
                ...t.configDefaults,
                name: i.G,
                baseName: i.G,
                min: -9999999999,
                max: 9999999999,
                digits: 10,
                scale: 0,
                KIND: a.a.INT,
                JSDOC_TYPE: "number",
                DATE_TIME_TYPE: i.G,
                parseValue: wt,
                parseLiteral: re,
                serialize: wt,
                toASTValue: ne
            }
        }(e),
        function(e) {
            if (e.String) {
                if (e.TimeZone)
                    return e.TimeZone
            } else
                V(e);
            class t extends e.String {
            }
            t.use = function() {
                return this.get(i.H) || this.define({
                    name: i.H
                })
            }
            ,
            t.baseName = i.H,
            t.configDefaults = {
                ...e.String.configDefaults,
                baseName: i.H,
                name: i.H,
                min: 3,
                max: 100
            },
            e.TimeZone = t
        }(e),
        Te(e),
        function(e) {
            if (e.Url) {
                if (e.Image)
                    return e.Image
            } else
                Te(e);
            class t extends e.Url {
            }
            t.baseName = i.o,
            t.configDefaults = {
                ...e.Url.configDefaults,
                baseName: i.o
            },
            e.Image = t
        }(e),
        function(e) {
            if (e.Float) {
                if (e.PercentFraction)
                    return e.PercentFraction
            } else
                $(e);
            class t extends e.Float {
            }
            t.KIND = a.a.FLOAT,
            t.baseName = i.x,
            t.configDefaults = {
                ...e.Float.configDefaults,
                baseName: i.x
            },
            e.PercentFraction = t
        }(e),
        function(e) {
            if (e.Float) {
                if (e.PercentLiteral)
                    return e.PercentLiteral
            } else
                $(e);
            class t extends e.Float {
            }
            t.KIND = a.a.FLOAT,
            t.baseName = i.y,
            t.configDefaults = {
                ...e.Float.configDefaults,
                baseName: i.y
            },
            e.PercentLiteral = t
        }(e),
        function(e) {
            if (e.GeoPoint)
                return e.GeoPoint;
            class t extends e.Scalar {
                static ensureValidConfig(e) {
                    return e.name || (e.name = i.m),
                    e.description || (e.description = void 0),
                    super.ensureValidConfig(e)
                }
            }
            const n = {
                ...e.Scalar.configDefaults,
                ...Rt
            }
              , r = n.getFieldValidator;
            n.getFieldValidator = function(e) {
                return e.props && e.props.latitudeFieldName ? Ct : r.call(this, e)
            }
            ,
            t.KIND = a.a.STRING,
            t.baseName = i.m,
            t.configDefaults = n,
            t.use = Nt,
            t.createName = ge,
            e.GeoPoint = t
        }(e),
        function(e) {
            if (e.Geometry)
                return e.Geometry;
            class t extends e.Scalar {
                static ensureValidConfig(e) {
                    return e.name || (e.name = i.l),
                    e.description || (e.description = void 0),
                    super.ensureValidConfig(e)
                }
            }
            const n = {
                ...e.Scalar.configDefaults,
                ...Ft
            };
            n.getFieldValidator = function(e) {
                return Pt
            }
            ,
            t.KIND = a.a.STRING,
            t.baseName = i.l,
            t.configDefaults = n,
            t.use = Dt,
            t.createName = ge,
            e.Geometry = t
        }(e),
        function(e) {
            if (e.String) {
                if (e.PostalCode)
                    return e.PostalCode
            } else
                V(e);
            class t extends e.String {
            }
            t.use = function() {
                return this.get(i.A) || this.define({
                    name: i.A
                })
            }
            ,
            t.baseName = i.A,
            t.configDefaults = {
                ...e.String.configDefaults,
                baseName: i.A,
                name: i.A,
                min: 0,
                max: 12
            },
            e.PostalCode = t
        }(e),
        function(e) {
            if (e.String) {
                if (e.Phone)
                    return e.Phone
            } else
                V(e);
            class t extends e.String {
            }
            t.use = function() {
                return this.get(i.z) || this.define({
                    name: i.z
                })
            }
            ,
            t.baseName = i.z,
            t.configDefaults = {
                ...e.String.configDefaults,
                name: i.z,
                baseName: i.z,
                min: 0,
                max: 20
            },
            e.Phone = t
        }(e),
        function(e) {
            if (e.String) {
                if (e.Text)
                    return e.Text
            } else
                V(e);
            class t extends e.String {
            }
            t.baseName = i.E,
            t.configDefaults = {
                ...e.String.configDefaults,
                baseName: i.E,
                min: 0,
                max: 65535
            },
            e.Text = t
        }(e),
        n
    }
    const jt = {
        serialize: function(e) {
            return e
        },
        parseValue: function(e) {
            return e
        },
        parseLiteral: function(e) {
            return e.value
        }
    };
    class Lt {
        constructor(e) {
            this.names = new Map,
            this.pluginSlug = e,
            kt(this),
            C(this),
            this.TypesEnum = function(e) {
                e.Enum || C(e);
                const {configDefaults: t} = e.Enum
                  , n = e.Enum.define({
                    name: "TypesEnum",
                    description: "The `TypesEnum` represents all possible types.",
                    values: {
                        TypesEnum: {
                            name: "TypesEnum"
                        }
                    },
                    parseValue(n) {
                        return "function" === typeof n ? n.use() : "string" === typeof n ? t.parseValue.call(this, e.fromString(n)) : t.parseValue.call(this, n)
                    },
                    JSDOC_TYPE: ["Object.<module:graphql/types.Scalar>", "Object.<module:graphql/types.Enum>"]
                });
                return e.TypesEnum = n,
                n.addValue({
                    name: "TypesEnum",
                    value: n
                }, !0),
                n
            }(this),
            this.customFactories = void 0
        }
        setFetchInfoFn(e) {
            return this.fetchInfoFn = e,
            this
        }
        fetchInfo(e) {
            return this.fetchInfoFn ? this.fetchInfoFn(e) : Object(r.a)(null)
        }
        destroy() {
            const {names: e} = this;
            if (e) {
                this.names = void 0,
                this.TypesEnum = void 0,
                this.fetchInfoFn = void 0;
                for (let[,t] of e)
                    t.destroy();
                e.clear()
            }
        }
    }
    const Vt = "(?:Positive|Negative|Signed)?".concat("(?:$|_[\\d_]+$)")
      , Ut = /(?:Positive|Negative|Signed)?_[\d_]+$/
      , qt = (Qt = i.B,
    {
        String: new RegExp("^".concat(Qt.STRING).concat("(?:$|_[\\d_]+$)")),
        Decimal: new RegExp("^".concat(Qt.DECIMAL).concat(Vt)),
        Float: new RegExp("^".concat(Qt.FLOAT).concat(Vt)),
        Int: new RegExp("^".concat(Qt.INT).concat(Vt)),
        Currency: new RegExp("^".concat(Qt.CURRENCY).concat(Vt)),
        Slug: new RegExp("^".concat(Qt.SLUG).concat("(?:$|_[\\d_]+$)")),
        Text: new RegExp("^".concat(Qt.TEXT).concat("(?:$|_[\\d_]+$)")),
        Mediumtext: new RegExp("^".concat(Qt.MEDIUMTEXT).concat("(?:$|_[\\d_]+$)")),
        Longtext: new RegExp("^".concat(Qt.LONGTEXT).concat("(?:$|_[\\d_]+$)")),
        Latitude: new RegExp("^".concat(Qt.LATITUDE).concat("(?:$|_[\\d_]+$)")),
        Longitude: new RegExp("^".concat(Qt.LONGITUDE).concat("(?:$|_[\\d_]+$)")),
        Address: new RegExp("^".concat(Qt.ADDRESS).concat("(?:$|_[\\d_]+$)")),
        Image: new RegExp("^".concat(Qt.IMAGE).concat("(?:$|_[\\d_]+$)")),
        JSON: new RegExp("^".concat(Qt.JSON).concat("(?:$|_[\\d_]+$)")),
        ObjectInstance: new RegExp("InstanceScalar$"),
        PercentLiteral: new RegExp("^".concat(Qt.PERCENT_LITERAL).concat(Vt)),
        PercentFraction: new RegExp("^".concat(Qt.PERCENT_FRACTION).concat(Vt)),
        Url: new RegExp("^".concat(Qt.URL).concat("(?:$|_[\\d_]+$)")),
        ModelUID: new RegExp("UID(?:Scalar)?$")
    });
    var Qt;
    const Bt = (e => ({
        [e.ADDRESS]: "Address",
        [e.BOOLEAN]: "Boolean",
        [e.COLOR]: "Color",
        [e.COUNTRY]: "Country",
        [e.COUNTRY_STATE]: "CountryState",
        [e.CURRENCY]: "Currency",
        [e.DATE]: "Date",
        [e.DATE_TIME]: "DateTime",
        [e.DECIMAL]: "Decimal",
        [e.EMAIL]: "Email",
        [e.FLOAT]: "Float",
        [e.GEOMETRY]: "Geometry",
        [e.GEO_POINT]: "GeoPoint",
        [e.ID]: "ID",
        [e.IMAGE]: "Image",
        [e.INT]: "Int",
        [e.JSON]: "JSON",
        [e.LATITUDE]: "Latitude",
        [e.LONGITUDE]: "Longitude",
        [e.LONGTEXT]: "Longtext",
        [e.MEDIUMTEXT]: "Mediumtext",
        [e.MODEL_ID]: "ModelID",
        [e.MODEL_UID]: "ModelUID",
        [e.PERCENT_FRACTION]: "PercentFraction",
        [e.PERCENT_LITERAL]: "PercentLiteral",
        [e.PHONE]: "Phone",
        [e.POSTAL_CODE]: "PostalCode",
        [e.STRING]: "String",
        [e.SLUG]: "Slug",
        [e.TEXT]: "Text",
        [e.TIME]: "Time",
        [e.TIMESTAMP]: "Timestamp",
        [e.TIMESTAMP_SECONDS]: "TimestampSeconds",
        [e.TIME_ZONE]: "TimeZone",
        [e.URL]: "Url"
    }))(i.B)
      , Gt = /(?<!U)ID(?:Scalar)?$/;
    Object(s.a)(Lt, {
        add: function(e, t) {
            this.names.set(e, t),
            this.TypesEnum && this.TypesEnum.addValue({
                name: e,
                description: t.description,
                value: t
            }, !0)
        },
        remove: function(e) {
            this.names.delete(e.name),
            this.TypesEnum && this.TypesEnum.removeValue(e.name),
            e.destroy()
        },
        createName: function(e, t, n, r) {
            const i = this.getClassName(e);
            if (!i) {
                if (this.customFactories) {
                    const {customFactories: t} = this;
                    for (let n of t)
                        if (n.regExp.test(e))
                            return e
                }
                return null
            }
            if ("ModelID" === i || "ModelUID" === i)
                return this[i].createName(t);
            if (Ut.test(e))
                return e;
            const o = this[i];
            if (o.configDefaults.name)
                return o.configDefaults.name;
            if ("number" !== typeof t) {
                if ("number" !== typeof o.configDefaults.min)
                    return o.createName(t);
                t = o.configDefaults.min
            }
            return "number" !== typeof n && (n = o.configDefaults.max),
            "number" !== typeof r && (r = o.configDefaults.scale),
            o.createName(t, n, r)
        },
        get: function(e) {
            return this.names.get(e)
        },
        getClassName: function(e) {
            if (Bt[e])
                return Bt[e];
            if (Gt.test(e))
                return "ModelID";
            for (let t in qt)
                if (qt[t].test(e))
                    return t;
            return null
        },
        has: function(e) {
            return this.names.has(e)
        },
        fromString: function(e) {
            let t = this.names.get(e);
            if (t)
                return t;
            if (this.customFactories) {
                const {customFactories: t} = this;
                for (let n of t)
                    if (n.regExp.test(e))
                        return n.func(this, e)
            }
            const n = this.getClassName(e);
            if (n)
                return this[n].define(e);
            if ("TypesEnum" === e)
                return this.TypesEnum;
            throw new Error("Unknown type from string: ".concat(e))
        },
        registerCustomFactory: function(e, t) {
            return this.customFactories ? this.customFactories.push({
                regExp: e,
                func: t
            }) : this.customFactories = [{
                regExp: e,
                func: t
            }],
            this
        }
    }),
    Object(o.z)(Lt, o.r.PLUGIN_TYPES)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return se
    }
    )),
    n.d(t, "b", (function() {
        return oe
    }
    ));
    var r = n(876)
      , i = n(232)
      , o = n(1009)
      , s = n(58)
      , a = n(1013)
      , c = n(1014)
      , u = n(870)
      , l = n(385)
      , d = n.n(l)
      , h = n(0);
    let f = [];
    const p = (e, t) => Object(h.P)(t) ? t.switchTo(e.__typename).getMutableRecord(e) : e.getMutableRecord(t);
    function g(e, t) {
        const n = e.getState()
          , {route: r} = n.props;
        let i, o = n.localProps && n.localProps.route;
        if (r.disableMatching) {
            if (o && o.regexp) {
                let n;
                for (let e in o)
                    switch (e) {
                    case "regexp":
                    case "absPath":
                    case "exactOnly":
                    case "noTrailingSlash":
                    case "caseSensitive":
                        break;
                    default:
                        (n || (n = {})) && (n[e] = o[e])
                    }
                return (e = p(e, t)).getMutableLocalProps().route = n,
                e
            }
            return null
        }
        if (o)
            if (o.regexp && o.absPath === r.absPath && o.exactOnly === r.exactOnly && o.noTrailingSlash === !!r.noTrailingSlash && o.caseSensitive === !!r.caseSensitive) {
                if (!Object(a.d)(n))
                    return null;
                o = null
            } else
                o = {
                    ...o
                };
        else
            o = {};
        if (e = p(e, t),
        Object(a.d)(n)) {
            i = Object(u.a)(e, !0);
            const {routeCache: t} = i;
            if (t.pathname = void 0,
            t.search = void 0,
            t.hash = void 0,
            !o)
                return e
        } else
            i = e.getMutableLocalProps();
        return i.route = o,
        o.absPath = r.absPath,
        o.exactOnly = r.exactOnly,
        o.noTrailingSlash = !!r.noTrailingSlash,
        o.caseSensitive = !!r.caseSensitive,
        o.regexp = d()(o.absPath, f, {
            sensitive: o.caseSensitive,
            strict: o.noTrailingSlash,
            end: o.exactOnly
        }),
        f.length ? (o.paramKeys = f,
        f = []) : o.paramKeys = null,
        e
    }
    function m(e, t, n) {
        const r = e.getState()
          , i = y(r, t);
        return r.match === i ? e : (Object(h.P)(n) ? n.switchTo(e.__typename) : e.getModelMutation(n)).update(e, "match", null, i, !0)
    }
    function y(e, t) {
        const n = e.match;
        if (n && n.pathname === t.pathname)
            return n;
        if (!e.localProps)
            return null;
        const r = e.localProps.route
          , i = r.regexp.exec(t.pathname);
        if (!i)
            return null;
        const o = "/" === t.pathname && "" === i[0] ? "/" : i[0]
          , s = o === t.pathname;
        if (!s && r.exactOnly)
            return null;
        let a = null;
        if (r.paramKeys) {
            const e = r.paramKeys;
            if (n && (a = n.params))
                for (let t = 0; t < e.length; t++)
                    if (a[e[t].name] !== i[t + 1]) {
                        a = void 0;
                        break
                    }
            if (!a) {
                a = {};
                for (let t = 0; t < e.length; t++)
                    a[e[t].name] = i[t + 1]
            }
        }
        return n && n.path === o && n.params === a && n.isExact === s ? n : {
            path: o,
            isExact: s,
            params: a,
            pathParams: a
        }
    }
    var v = n(292)
      , b = n(31)
      , _ = n(394)
      , S = n(26)
      , O = n(52)
      , T = n(72)
      , I = n(74)
      , x = n(872)
      , w = n(234);
    function M(e, t, n) {
        if (Object(h.P)(t))
            return n ? t.switchTo(e.__typename).incrementExecuteCount() : t.switchTo(e.__typename);
        const r = e.getModel().mutation(t || e.__dispatchId);
        return n || r.execute(),
        r
    }
    function A(e, t) {
        return M(e, t).getMutableRecord(e)
    }
    const E = new Set;
    const C = (e, t, n) => function(e, t, n) {
        return n || (n = e.getModel().query()),
        n.selectAll("autoload").whereIn("loadWhenPath", t).andWhere("routerLogicId", e.__ID).includeFields("groupLogic", "autoload")
    }(e, t).fetchAllRecords({
        mutation: n
    });
    function N(e, t, n) {
        const r = e.getMainInstance()
          , i = r.getModel()
          , o = Object(h.P)(n) ? n : null;
        let a, c, u;
        o && o.isAcceptingFollowupQueries ? (a = o.ofConnectorComplete().pipe(Object(O.a)(e => e.isCancelling ? Object(b.a)(null) : C(r, t, o)), Object(T.a)(e => c = e)),
        o.addToFollowupQueries(a),
        a = o.ofComplete().pipe(Object(T.a)(e => (u = i.mutation(e.mainDispatchId).disableExecuteWhen(),
        c)))) : a = Object(_.a)( () => (u = i.mutation().disableExecuteWhen(),
        C(r, t, u)));
        const l = a.pipe(Object(O.a)(n => (e = function(e, t, n, r) {
            const {fetchPathsInFlight: i} = e.localProps;
            if (!i)
                return e;
            for (let s of t)
                i[s] === n && E.add(s);
            if (!E.size)
                return e;
            let o = null;
            for (let s in i)
                E.has(s) || (o || (o = {}),
                o[s] = i[s]);
            return E.clear(),
            (e = A(e, r)).setLocalProps({
                fetchPathsInFlight: o
            }),
            e
        }(r, t, l, u)).dispatchTo(n, s.m, {
            mutation: u
        }, u.mainDispatchId)), Object(O.a)(e => u.disableExecuteWhen(!1).execute(!0).pipe(Object(I.a)(e))), Object(x.a)());
        return function(e, t, n, r) {
            e = A(e, r);
            let {routeCache: {fetchedPaths: i}, fetchPathsInFlight: o} = e.localProps;
            o || (o = {});
            for (let s of t)
                i[s] = !0,
                o[s] = n;
            e.setLocalProps({
                fetchPathsInFlight: o
            })
        }(e, t, l, n),
        l
    }
    function R(e, t, n) {
        const r = M(e, n, !0).disableExecuteWhen();
        let i, o;
        return function(e, t) {
            const n = Object(h.U)(e) ? e.localProps.routeCache.fetchedPaths : e;
            if (n)
                for (let r of t)
                    n[r] = !0
        }(e, t),
        r.isExecuting && r.addToFollowupQueries(new S.a(e => {
            "undefined" !== typeof i ? (e.next(),
            e.complete()) : o = e
        }
        )),
        C(e, t, r).pipe(Object(O.a)(t => t ? e.dispatchTo(t, s.m, {
            mutation: r
        }, r.mainDispatchId) : Object(b.a)(null)), Object(O.a)(e => (i = e,
        o && (o.next(),
        o.complete()),
        r.disableExecuteWhen(!1).execute(),
        !r.isExecuting && r.controller.executeCount > 0 ? Object(b.a)(i) : r.ofComplete().pipe(Object(I.a)(i)))), Object(x.a)())
    }
    let P = N;
    const D = v.c.getMutation
      , F = v.c.setBestDispatchId
      , k = (e, t, n) => D(e, t).update(e, "match", null, n, !0)
      , j = (e, t) => {
        const n = e.getState();
        return !Object(a.e)(n.type) || !!n.match && (k(e, t, null),
        !0)
    }
      , L = (e, t) => {
        const n = e.getState();
        if (!Object(a.e)(n))
            return !0;
        const r = y(n, t._locState);
        return r !== n.match && (e = k(e, t, r)),
        r ? (!n.props.route.hasPathParams || t.pathnameToLoad && !n.loadWhenPath.startsWith(Object(w.b)(t.pathnameToLoad)) || (t.pathnameToLoad = n.loadWhenPath),
        n.props.route.hasChildRoute) : (e.walk(j, t, t.dispatchId),
        !1)
    }
    ;
    function V(e, t) {
        if (t || (t = {}),
        e = F(e, t),
        "undefined" === typeof t.location) {
            const n = e.getSession(t.dispatchId);
            t.location = n ? n.location : null
        }
        if (t.pathsToFetch = null,
        !t.location)
            return j(e, t) && e.walk(j, t, t.dispatchId),
            t;
        t._locState = Object(h.U)(t.location) ? t.location.getState() : t.location;
        const n = t.checkCache && e.localProps.routeCache;
        return n && t._locState.pathname === n.pathname ? (t.pathnameToLoad = null,
        t) : L(e, t) ? (t.pathnameToLoad || (t.pathnameToLoad = Object(w.a)(Object(w.d)(t._locState.pathname))),
        e.walk(L, t, t.dispatchId),
        n && (n.pathname = t._locState.pathname),
        null === t.fetchedPaths || (t.pathsToFetch = function(e, t, n) {
            const r = e.getState();
            if (!r.isMissingRouteLogic)
                return null;
            "undefined" === typeof n && r.localProps.routeCache && (n = r.localProps.routeCache.fetchedPaths);
            let i = Object(w.c)(r.props.route.absPath);
            if (!(t = Object(w.c)(Object(w.c)(t).replace(i, ""))))
                return null;
            const o = t.split("/");
            let s = null;
            for (let a of o)
                i += "".concat(Object(w.a)(a)),
                n && n[i] || (s ? s.push(i) : s = [i]);
            return s
        }(e, t._locState.pathname, t.fetchedPaths),
        t.pathsToFetch && (t.autoFetchPaths || t.autoFetchPathsNow) ? (t.fetchPaths$ = (!0 === t.autoFetchPathsNow ? R : !1 === t.autoFetchPathsNow ? N : P)(e, t.pathsToFetch, t.mutation || t.dispatchId),
        t.fetchPaths$.subscribe()) : t.fetchPaths$ = null),
        t) : (t.pathnameToLoad = null,
        t)
    }
    var U = n(166);
    const q = "@isomorix/router-matching"
      , Q = r.a.initModule("@isomorix/router-matching/router/logic").setPackageName(q)
      , B = r.a.initModule("@isomorix/router-matching/route/logic").setPackageName(q);
    var G = n(393)
      , z = n(268);
    const H = (e, t) => {
        var n;
        const {payload: r} = e;
        if (V(t.getBestStore(e).instance, {
            autoFetchPaths: !0,
            checkCache: !r.fromBuildRoutes,
            mutation: e.payload.mutation,
            location: e.meta.instance
        }),
        !r.fromBuildRoutes || null !== (n = t.get("match")) && void 0 !== n && n.isExact)
            return e;
        let i = e.meta.mainInstance;
        e.payload.mutation.ofComplete().subscribe(e => {
            if (e.isCancelling)
                return;
            if (t.parentInstance.query().whereExists("match").andWhere("routerLogicId", t.instance.__ID).getAllRecords({
                dispatchId: e.mainDispatchId
            }))
                return;
            const n = t.parentInstance.pluginMutation(e.mainDispatchId).switchTo(i.__typename);
            i = n.getMutableRecord(i);
            const r = i.getState();
            i.replace({
                pathname: t.get("props").route.absPath,
                search: r.search
            }, r.state ? {
                ...r.state
            } : void 0),
            n.execute()
        }
        )
    }
      , K = G.a.findByName("manageStateChanges", s.n);
    var Y = n(1020);
    const W = [s.d, s.m];
    let $ = e => e;
    function X(e) {
        const t = e.meta.instance;
        if (g(t, e),
        e.type === s.d)
            return $(e);
        t.getMutableRecord(e);
        const n = Object(u.a)(t)
          , r = t.getLocation(e);
        r && m(t, r.getState(), t.getModelMutation(e)),
        n.matchLocation = V;
        {
            const {localProps: n} = t
              , {routeCache: i} = n;
            if ("undefined" === typeof i.locationMutationLogic && (i.locationMutationLogic = (e => {
                e = e.mainStore;
                const t = z.a.LOCATION;
                function n(n) {
                    const r = n.payload.mutation;
                    return r.isUndoRedo || !n.meta.instance[t] ? n : (r.addToFollowupQueries(r.ofConnectorComplete().pipe(Object(T.a)( () => H(n, e)))),
                    n.payload.fromBuildRoutes ? n : H(n, e))
                }
                return U.a.useRelative(K, 100).setActionType(s.n).setName("manageRouterLocationChange").setId("".concat("manageRouterLocationChange", "_").concat(e.storeId)).setPure(!0).setModuleName("".concat("@isomorix/router-matching/router/logic", "/location")).setPackageName(q).done(n, !0),
                n
            }
            )(e.meta.store)),
            !i.locationMutationLogic)
                return e;
            if (r && (r.addOrReplacePendingLogic(i.locationMutationLogic, "all", "all"),
            window.isReload)) {
                const t = e.meta.store.mainStore;
                e.meta.mainActionMeta.pipe(Object(Y.a)(100)).subscribe( () => {
                    V(t.instance, {
                        autoFetchPaths: !0,
                        checkCache: !0,
                        location: t.instance.getLocation()
                    })
                }
                )
            }
        }
        return e
    }
    $ = e => {
        const t = e.meta.store.value
          , n = t.pChanges && t.get("match");
        let r = t.store.instance.getLocation(e);
        const i = t.mutation.switchTo(r.__typename);
        if (r = i.getMutableRecord(r),
        i.getRecordPayload(r, !0).fromBuildRoutes = !0,
        !n)
            return e;
        let o = t.state.props.route
          , s = t.pState.props.route;
        if (o.absPath === s.absPath)
            return e;
        const a = r.getMainInstance().pathname;
        let c;
        if (s.hasPathParams) {
            if (c = a.replace(t.state.loadWhenPath, t.pState.loadWhenPath),
            c === a)
                return e
        } else {
            if (!n.isExact && s.hasChildRoute)
                return e;
            c = s.absPath
        }
        const u = r.getState();
        return r.replace({
            pathname: c,
            search: u.search,
            title: u.title
        }, u.state ? {
            ...u.state
        } : u.state),
        e
    }
    ,
    U.a.use().setName("prepareRouteMatching").setActionType(W).setType(a.b).setId().setPure(!0).setOp(c.g).setPriority(c.h).setLogicMgr(Q, "./init").add(X, !0),
    U.a.useProps(X).setType(a.a).setLogicMgr(B, "./init").add((function(e) {
        const t = e.meta.instance;
        if (g(t, e),
        e.type === s.d)
            return $(e);
        const n = t.getLocation(e);
        if (!n)
            return e;
        const r = t.getParentByType(a.c);
        return r && !r.match || m(t, n.getState(), e),
        e
    }
    ), !0);
    var J = n(1015);
    const Z = r.a.initModule("@isomorix/router-perms/record/logic").setPackageName("@isomorix/router-perms")
      , ee = r.a.initModule("@isomorix/router-perms/router/logic").setPackageName("@isomorix/router-perms");
    const te = (e, t, n) => {
        let r, i, o = "prepare";
        n ? (o += "RouterPerms",
        r = c.e,
        i = c.f) : (o += "RecordPerms",
        r = c.c,
        i = c.d),
        U.a.use().setName(o).setOp(r).setPriority(i).setActionType(s.m).setId().setPure(!0).setType(n).setLogicMgr(t, "./init"),
        U.a.add(e, !0)
    }
    ;
    te((function(e) {
        const t = e.meta.instance.getMutableRecord(e)
          , n = Object(u.a)(t);
        {
            n.userRoleChangeListener = (r = (r = e.meta.store).mainStore,
            function(e) {
                const {meta: t, payload: n} = e
                  , i = r.getBestStore(t.dispatchId).instance;
                if (!Object(J.a)(i, {
                    mutation: n.mutation,
                    userRole: t.instance.userRole || null,
                    dispatchId: t.dispatchId
                }).userRole)
                    return;
                const {localProps: o} = i
                  , s = o.matchLocation ? i.getLocation(e) : null;
                s && (o.routeCache.fetchedPaths = {
                    [i.props.route.absPath]: !0
                },
                o.matchLocation(i, {
                    location: s,
                    mutation: n.mutation,
                    dispatchId: n.mutation.mainDispatchId,
                    autoFetchPaths: !0,
                    checkCache: !1
                }))
            }
            );
            const i = t.getSession(e.meta.dispatchId);
            i && i.addUserRoleChangeListener(n.userRoleChangeListener)
        }
        var r;
        return e
    }
    ), ee, a.b);
    te((function(e) {
        return Object(J.b)(e.meta.instance, e),
        e
    }
    ), Z, null);
    var ne = n(159);
    U.a.useRelative("trxOptimisticExecute", -50).setName("managePermUseChange").setActionType(s.n).setId().setPure(!0).setType(null).setLogicMgr(Z, "./mutation").add((function(e) {
        const t = e.meta.store.value;
        if (!t.pChanges || t.pChanges.permUse !== ne.a.UPDATED)
            return e;
        const n = e.meta.getSession();
        return n ? (Object(J.a)(e.meta.instance, {
            mutation: e.payload.mutation,
            userRole: n.userRole || null,
            onlyDescendOnChange: !0
        }),
        e) : e
    }
    ), !0),
    ee.add(Z);
    const re = r.a.initModule("@isomorix/ui-router/router/logic")
      , ie = r.a.initModule("@isomorix/ui-router/route/logic");
    function oe(e) {
        return e instanceof r.a ? e.add(re) : e.push(...re),
        function(e) {
            return e instanceof r.a ? e.add(o.a).add(Q).add(ee).add(i.a) : (e.push(o.a, ...Q, ...ee, ...i.a || []),
            e)
        }(e)
    }
    function se(e) {
        return e instanceof r.a ? e.add(ie) : e.push(...ie),
        function(e) {
            return e instanceof r.a ? e.add(o.a).add(B).add(Z) : (e.push(o.a, ...B, ...Z),
            e)
        }(e)
    }
}
, function(e, t, n) {
    "use strict";
    var r = function() {
        return (r = Object.assign || function(e) {
            for (var t, n = 1, r = arguments.length; n < r; n++)
                for (var i in t = arguments[n])
                    Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e
        }
        ).apply(this, arguments)
    };
    Object.create;
    Object.create;
    var i = n(36);
    function o(e, t, n) {
        return new i.a("Syntax Error: ".concat(n),void 0,e,[t])
    }
    var s = n(12)
      , a = n(35)
      , c = Object.freeze({
        SOF: "<SOF>",
        EOF: "<EOF>",
        BANG: "!",
        DOLLAR: "$",
        AMP: "&",
        PAREN_L: "(",
        PAREN_R: ")",
        SPREAD: "...",
        COLON: ":",
        EQUALS: "=",
        AT: "@",
        BRACKET_L: "[",
        BRACKET_R: "]",
        BRACE_L: "{",
        PIPE: "|",
        BRACE_R: "}",
        NAME: "Name",
        INT: "Int",
        FLOAT: "Float",
        STRING: "String",
        BLOCK_STRING: "BlockString",
        COMMENT: "Comment"
    })
      , u = n(61)
      , l = n(21)
      , d = n(30)
      , h = n(73);
    function f(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1,
            r.configurable = !0,
            "value"in r && (r.writable = !0),
            Object.defineProperty(e, r.key, r)
        }
    }
    var p = function() {
        function e(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "GraphQL request"
              , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                line: 1,
                column: 1
            };
            "string" === typeof e || Object(d.a)(0, "Body must be a string. Received: ".concat(Object(l.a)(e), ".")),
            this.body = e,
            this.name = t,
            this.locationOffset = n,
            this.locationOffset.line > 0 || Object(d.a)(0, "line in locationOffset is 1-indexed and must be positive."),
            this.locationOffset.column > 0 || Object(d.a)(0, "column in locationOffset is 1-indexed and must be positive.")
        }
        var t, n, r;
        return t = e,
        (n = [{
            key: u.a,
            get: function() {
                return "Source"
            }
        }]) && f(t.prototype, n),
        r && f(t, r),
        e
    }();
    var g = n(62)
      , m = n(230)
      , y = function() {
        function e(e) {
            var t = new a.b(c.SOF,0,0,0,0,null);
            this.source = e,
            this.lastToken = t,
            this.token = t,
            this.line = 1,
            this.lineStart = 0
        }
        var t = e.prototype;
        return t.advance = function() {
            return this.lastToken = this.token,
            this.token = this.lookahead()
        }
        ,
        t.lookahead = function() {
            var e = this.token;
            if (e.kind !== c.EOF)
                do {
                    var t;
                    e = null !== (t = e.next) && void 0 !== t ? t : e.next = b(this, e)
                } while (e.kind === c.COMMENT);
            return e
        }
        ,
        e
    }();
    function v(e) {
        return isNaN(e) ? c.EOF : e < 127 ? JSON.stringify(String.fromCharCode(e)) : '"\\u'.concat(("00" + e.toString(16).toUpperCase()).slice(-4), '"')
    }
    function b(e, t) {
        for (var n = e.source, r = n.body, i = r.length, s = t.end; s < i; ) {
            var u = r.charCodeAt(s)
              , l = e.line
              , d = 1 + s - e.lineStart;
            switch (u) {
            case 65279:
            case 9:
            case 32:
            case 44:
                ++s;
                continue;
            case 10:
                ++s,
                ++e.line,
                e.lineStart = s;
                continue;
            case 13:
                10 === r.charCodeAt(s + 1) ? s += 2 : ++s,
                ++e.line,
                e.lineStart = s;
                continue;
            case 33:
                return new a.b(c.BANG,s,s + 1,l,d,t);
            case 35:
                return S(n, s, l, d, t);
            case 36:
                return new a.b(c.DOLLAR,s,s + 1,l,d,t);
            case 38:
                return new a.b(c.AMP,s,s + 1,l,d,t);
            case 40:
                return new a.b(c.PAREN_L,s,s + 1,l,d,t);
            case 41:
                return new a.b(c.PAREN_R,s,s + 1,l,d,t);
            case 46:
                if (46 === r.charCodeAt(s + 1) && 46 === r.charCodeAt(s + 2))
                    return new a.b(c.SPREAD,s,s + 3,l,d,t);
                break;
            case 58:
                return new a.b(c.COLON,s,s + 1,l,d,t);
            case 61:
                return new a.b(c.EQUALS,s,s + 1,l,d,t);
            case 64:
                return new a.b(c.AT,s,s + 1,l,d,t);
            case 91:
                return new a.b(c.BRACKET_L,s,s + 1,l,d,t);
            case 93:
                return new a.b(c.BRACKET_R,s,s + 1,l,d,t);
            case 123:
                return new a.b(c.BRACE_L,s,s + 1,l,d,t);
            case 124:
                return new a.b(c.PIPE,s,s + 1,l,d,t);
            case 125:
                return new a.b(c.BRACE_R,s,s + 1,l,d,t);
            case 34:
                return 34 === r.charCodeAt(s + 1) && 34 === r.charCodeAt(s + 2) ? x(n, s, l, d, t, e) : I(n, s, l, d, t);
            case 45:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
                return O(n, s, u, l, d, t);
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 90:
            case 95:
            case 97:
            case 98:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 104:
            case 105:
            case 106:
            case 107:
            case 108:
            case 109:
            case 110:
            case 111:
            case 112:
            case 113:
            case 114:
            case 115:
            case 116:
            case 117:
            case 118:
            case 119:
            case 120:
            case 121:
            case 122:
                return M(n, s, l, d, t)
            }
            throw o(n, s, _(u))
        }
        var h = e.line
          , f = 1 + s - e.lineStart;
        return new a.b(c.EOF,i,i,h,f,t)
    }
    function _(e) {
        return e < 32 && 9 !== e && 10 !== e && 13 !== e ? "Cannot contain the invalid character ".concat(v(e), ".") : 39 === e ? "Unexpected single quote character ('), did you mean to use a double quote (\")?" : "Cannot parse the unexpected character ".concat(v(e), ".")
    }
    function S(e, t, n, r, i) {
        var o, s = e.body, u = t;
        do {
            o = s.charCodeAt(++u)
        } while (!isNaN(o) && (o > 31 || 9 === o));
        return new a.b(c.COMMENT,t,u,n,r,i,s.slice(t + 1, u))
    }
    function O(e, t, n, r, i, s) {
        var u = e.body
          , l = n
          , d = t
          , h = !1;
        if (45 === l && (l = u.charCodeAt(++d)),
        48 === l) {
            if ((l = u.charCodeAt(++d)) >= 48 && l <= 57)
                throw o(e, d, "Invalid number, unexpected digit after 0: ".concat(v(l), "."))
        } else
            d = T(e, d, l),
            l = u.charCodeAt(d);
        if (46 === l && (h = !0,
        l = u.charCodeAt(++d),
        d = T(e, d, l),
        l = u.charCodeAt(d)),
        69 !== l && 101 !== l || (h = !0,
        43 !== (l = u.charCodeAt(++d)) && 45 !== l || (l = u.charCodeAt(++d)),
        d = T(e, d, l),
        l = u.charCodeAt(d)),
        46 === l || function(e) {
            return 95 === e || e >= 65 && e <= 90 || e >= 97 && e <= 122
        }(l))
            throw o(e, d, "Invalid number, expected digit but got: ".concat(v(l), "."));
        return new a.b(h ? c.FLOAT : c.INT,t,d,r,i,s,u.slice(t, d))
    }
    function T(e, t, n) {
        var r = e.body
          , i = t
          , s = n;
        if (s >= 48 && s <= 57) {
            do {
                s = r.charCodeAt(++i)
            } while (s >= 48 && s <= 57);
            return i
        }
        throw o(e, i, "Invalid number, expected digit but got: ".concat(v(s), "."))
    }
    function I(e, t, n, r, i) {
        for (var s, u, l, d, h = e.body, f = t + 1, p = f, g = 0, m = ""; f < h.length && !isNaN(g = h.charCodeAt(f)) && 10 !== g && 13 !== g; ) {
            if (34 === g)
                return m += h.slice(p, f),
                new a.b(c.STRING,t,f + 1,n,r,i,m);
            if (g < 32 && 9 !== g)
                throw o(e, f, "Invalid character within String: ".concat(v(g), "."));
            if (++f,
            92 === g) {
                switch (m += h.slice(p, f - 1),
                g = h.charCodeAt(f)) {
                case 34:
                    m += '"';
                    break;
                case 47:
                    m += "/";
                    break;
                case 92:
                    m += "\\";
                    break;
                case 98:
                    m += "\b";
                    break;
                case 102:
                    m += "\f";
                    break;
                case 110:
                    m += "\n";
                    break;
                case 114:
                    m += "\r";
                    break;
                case 116:
                    m += "\t";
                    break;
                case 117:
                    var y = (s = h.charCodeAt(f + 1),
                    u = h.charCodeAt(f + 2),
                    l = h.charCodeAt(f + 3),
                    d = h.charCodeAt(f + 4),
                    w(s) << 12 | w(u) << 8 | w(l) << 4 | w(d));
                    if (y < 0) {
                        var b = h.slice(f + 1, f + 5);
                        throw o(e, f, "Invalid character escape sequence: \\u".concat(b, "."))
                    }
                    m += String.fromCharCode(y),
                    f += 4;
                    break;
                default:
                    throw o(e, f, "Invalid character escape sequence: \\".concat(String.fromCharCode(g), "."))
                }
                p = ++f
            }
        }
        throw o(e, f, "Unterminated string.")
    }
    function x(e, t, n, r, i, s) {
        for (var u = e.body, l = t + 3, d = l, h = 0, f = ""; l < u.length && !isNaN(h = u.charCodeAt(l)); ) {
            if (34 === h && 34 === u.charCodeAt(l + 1) && 34 === u.charCodeAt(l + 2))
                return f += u.slice(d, l),
                new a.b(c.BLOCK_STRING,t,l + 3,n,r,i,Object(m.a)(f));
            if (h < 32 && 9 !== h && 10 !== h && 13 !== h)
                throw o(e, l, "Invalid character within String: ".concat(v(h), "."));
            10 === h ? (++l,
            ++s.line,
            s.lineStart = l) : 13 === h ? (10 === u.charCodeAt(l + 1) ? l += 2 : ++l,
            ++s.line,
            s.lineStart = l) : 92 === h && 34 === u.charCodeAt(l + 1) && 34 === u.charCodeAt(l + 2) && 34 === u.charCodeAt(l + 3) ? (f += u.slice(d, l) + '"""',
            d = l += 4) : ++l
        }
        throw o(e, l, "Unterminated string.")
    }
    function w(e) {
        return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1
    }
    function M(e, t, n, r, i) {
        for (var o = e.body, s = o.length, u = t + 1, l = 0; u !== s && !isNaN(l = o.charCodeAt(u)) && (95 === l || l >= 48 && l <= 57 || l >= 65 && l <= 90 || l >= 97 && l <= 122); )
            ++u;
        return new a.b(c.NAME,t,u,n,r,i,o.slice(t, u))
    }
    var A = function() {
        function e(e, t) {
            var n = function(e) {
                return Object(h.a)(e, p)
            }(e) ? e : new p(e);
            this._lexer = new y(n),
            this._options = t
        }
        var t = e.prototype;
        return t.parseName = function() {
            var e = this.expectToken(c.NAME);
            return {
                kind: s.a.NAME,
                value: e.value,
                loc: this.loc(e)
            }
        }
        ,
        t.parseDocument = function() {
            var e = this._lexer.token;
            return {
                kind: s.a.DOCUMENT,
                definitions: this.many(c.SOF, this.parseDefinition, c.EOF),
                loc: this.loc(e)
            }
        }
        ,
        t.parseDefinition = function() {
            if (this.peek(c.NAME))
                switch (this._lexer.token.value) {
                case "query":
                case "mutation":
                case "subscription":
                    return this.parseOperationDefinition();
                case "fragment":
                    return this.parseFragmentDefinition();
                case "schema":
                case "scalar":
                case "type":
                case "interface":
                case "union":
                case "enum":
                case "input":
                case "directive":
                    return this.parseTypeSystemDefinition();
                case "extend":
                    return this.parseTypeSystemExtension()
                }
            else {
                if (this.peek(c.BRACE_L))
                    return this.parseOperationDefinition();
                if (this.peekDescription())
                    return this.parseTypeSystemDefinition()
            }
            throw this.unexpected()
        }
        ,
        t.parseOperationDefinition = function() {
            var e = this._lexer.token;
            if (this.peek(c.BRACE_L))
                return {
                    kind: s.a.OPERATION_DEFINITION,
                    operation: "query",
                    name: void 0,
                    variableDefinitions: [],
                    directives: [],
                    selectionSet: this.parseSelectionSet(),
                    loc: this.loc(e)
                };
            var t, n = this.parseOperationType();
            return this.peek(c.NAME) && (t = this.parseName()),
            {
                kind: s.a.OPERATION_DEFINITION,
                operation: n,
                name: t,
                variableDefinitions: this.parseVariableDefinitions(),
                directives: this.parseDirectives(!1),
                selectionSet: this.parseSelectionSet(),
                loc: this.loc(e)
            }
        }
        ,
        t.parseOperationType = function() {
            var e = this.expectToken(c.NAME);
            switch (e.value) {
            case "query":
                return "query";
            case "mutation":
                return "mutation";
            case "subscription":
                return "subscription"
            }
            throw this.unexpected(e)
        }
        ,
        t.parseVariableDefinitions = function() {
            return this.optionalMany(c.PAREN_L, this.parseVariableDefinition, c.PAREN_R)
        }
        ,
        t.parseVariableDefinition = function() {
            var e = this._lexer.token;
            return {
                kind: s.a.VARIABLE_DEFINITION,
                variable: this.parseVariable(),
                type: (this.expectToken(c.COLON),
                this.parseTypeReference()),
                defaultValue: this.expectOptionalToken(c.EQUALS) ? this.parseValueLiteral(!0) : void 0,
                directives: this.parseDirectives(!0),
                loc: this.loc(e)
            }
        }
        ,
        t.parseVariable = function() {
            var e = this._lexer.token;
            return this.expectToken(c.DOLLAR),
            {
                kind: s.a.VARIABLE,
                name: this.parseName(),
                loc: this.loc(e)
            }
        }
        ,
        t.parseSelectionSet = function() {
            var e = this._lexer.token;
            return {
                kind: s.a.SELECTION_SET,
                selections: this.many(c.BRACE_L, this.parseSelection, c.BRACE_R),
                loc: this.loc(e)
            }
        }
        ,
        t.parseSelection = function() {
            return this.peek(c.SPREAD) ? this.parseFragment() : this.parseField()
        }
        ,
        t.parseField = function() {
            var e, t, n = this._lexer.token, r = this.parseName();
            return this.expectOptionalToken(c.COLON) ? (e = r,
            t = this.parseName()) : t = r,
            {
                kind: s.a.FIELD,
                alias: e,
                name: t,
                arguments: this.parseArguments(!1),
                directives: this.parseDirectives(!1),
                selectionSet: this.peek(c.BRACE_L) ? this.parseSelectionSet() : void 0,
                loc: this.loc(n)
            }
        }
        ,
        t.parseArguments = function(e) {
            var t = e ? this.parseConstArgument : this.parseArgument;
            return this.optionalMany(c.PAREN_L, t, c.PAREN_R)
        }
        ,
        t.parseArgument = function() {
            var e = this._lexer.token
              , t = this.parseName();
            return this.expectToken(c.COLON),
            {
                kind: s.a.ARGUMENT,
                name: t,
                value: this.parseValueLiteral(!1),
                loc: this.loc(e)
            }
        }
        ,
        t.parseConstArgument = function() {
            var e = this._lexer.token;
            return {
                kind: s.a.ARGUMENT,
                name: this.parseName(),
                value: (this.expectToken(c.COLON),
                this.parseValueLiteral(!0)),
                loc: this.loc(e)
            }
        }
        ,
        t.parseFragment = function() {
            var e = this._lexer.token;
            this.expectToken(c.SPREAD);
            var t = this.expectOptionalKeyword("on");
            return !t && this.peek(c.NAME) ? {
                kind: s.a.FRAGMENT_SPREAD,
                name: this.parseFragmentName(),
                directives: this.parseDirectives(!1),
                loc: this.loc(e)
            } : {
                kind: s.a.INLINE_FRAGMENT,
                typeCondition: t ? this.parseNamedType() : void 0,
                directives: this.parseDirectives(!1),
                selectionSet: this.parseSelectionSet(),
                loc: this.loc(e)
            }
        }
        ,
        t.parseFragmentDefinition = function() {
            var e, t = this._lexer.token;
            return this.expectKeyword("fragment"),
            !0 === (null === (e = this._options) || void 0 === e ? void 0 : e.experimentalFragmentVariables) ? {
                kind: s.a.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                variableDefinitions: this.parseVariableDefinitions(),
                typeCondition: (this.expectKeyword("on"),
                this.parseNamedType()),
                directives: this.parseDirectives(!1),
                selectionSet: this.parseSelectionSet(),
                loc: this.loc(t)
            } : {
                kind: s.a.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                typeCondition: (this.expectKeyword("on"),
                this.parseNamedType()),
                directives: this.parseDirectives(!1),
                selectionSet: this.parseSelectionSet(),
                loc: this.loc(t)
            }
        }
        ,
        t.parseFragmentName = function() {
            if ("on" === this._lexer.token.value)
                throw this.unexpected();
            return this.parseName()
        }
        ,
        t.parseValueLiteral = function(e) {
            var t = this._lexer.token;
            switch (t.kind) {
            case c.BRACKET_L:
                return this.parseList(e);
            case c.BRACE_L:
                return this.parseObject(e);
            case c.INT:
                return this._lexer.advance(),
                {
                    kind: s.a.INT,
                    value: t.value,
                    loc: this.loc(t)
                };
            case c.FLOAT:
                return this._lexer.advance(),
                {
                    kind: s.a.FLOAT,
                    value: t.value,
                    loc: this.loc(t)
                };
            case c.STRING:
            case c.BLOCK_STRING:
                return this.parseStringLiteral();
            case c.NAME:
                switch (this._lexer.advance(),
                t.value) {
                case "true":
                    return {
                        kind: s.a.BOOLEAN,
                        value: !0,
                        loc: this.loc(t)
                    };
                case "false":
                    return {
                        kind: s.a.BOOLEAN,
                        value: !1,
                        loc: this.loc(t)
                    };
                case "null":
                    return {
                        kind: s.a.NULL,
                        loc: this.loc(t)
                    };
                default:
                    return {
                        kind: s.a.ENUM,
                        value: t.value,
                        loc: this.loc(t)
                    }
                }
            case c.DOLLAR:
                if (!e)
                    return this.parseVariable()
            }
            throw this.unexpected()
        }
        ,
        t.parseStringLiteral = function() {
            var e = this._lexer.token;
            return this._lexer.advance(),
            {
                kind: s.a.STRING,
                value: e.value,
                block: e.kind === c.BLOCK_STRING,
                loc: this.loc(e)
            }
        }
        ,
        t.parseList = function(e) {
            var t = this
              , n = this._lexer.token;
            return {
                kind: s.a.LIST,
                values: this.any(c.BRACKET_L, (function() {
                    return t.parseValueLiteral(e)
                }
                ), c.BRACKET_R),
                loc: this.loc(n)
            }
        }
        ,
        t.parseObject = function(e) {
            var t = this
              , n = this._lexer.token;
            return {
                kind: s.a.OBJECT,
                fields: this.any(c.BRACE_L, (function() {
                    return t.parseObjectField(e)
                }
                ), c.BRACE_R),
                loc: this.loc(n)
            }
        }
        ,
        t.parseObjectField = function(e) {
            var t = this._lexer.token
              , n = this.parseName();
            return this.expectToken(c.COLON),
            {
                kind: s.a.OBJECT_FIELD,
                name: n,
                value: this.parseValueLiteral(e),
                loc: this.loc(t)
            }
        }
        ,
        t.parseDirectives = function(e) {
            for (var t = []; this.peek(c.AT); )
                t.push(this.parseDirective(e));
            return t
        }
        ,
        t.parseDirective = function(e) {
            var t = this._lexer.token;
            return this.expectToken(c.AT),
            {
                kind: s.a.DIRECTIVE,
                name: this.parseName(),
                arguments: this.parseArguments(e),
                loc: this.loc(t)
            }
        }
        ,
        t.parseTypeReference = function() {
            var e, t = this._lexer.token;
            return this.expectOptionalToken(c.BRACKET_L) ? (e = this.parseTypeReference(),
            this.expectToken(c.BRACKET_R),
            e = {
                kind: s.a.LIST_TYPE,
                type: e,
                loc: this.loc(t)
            }) : e = this.parseNamedType(),
            this.expectOptionalToken(c.BANG) ? {
                kind: s.a.NON_NULL_TYPE,
                type: e,
                loc: this.loc(t)
            } : e
        }
        ,
        t.parseNamedType = function() {
            var e = this._lexer.token;
            return {
                kind: s.a.NAMED_TYPE,
                name: this.parseName(),
                loc: this.loc(e)
            }
        }
        ,
        t.parseTypeSystemDefinition = function() {
            var e = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
            if (e.kind === c.NAME)
                switch (e.value) {
                case "schema":
                    return this.parseSchemaDefinition();
                case "scalar":
                    return this.parseScalarTypeDefinition();
                case "type":
                    return this.parseObjectTypeDefinition();
                case "interface":
                    return this.parseInterfaceTypeDefinition();
                case "union":
                    return this.parseUnionTypeDefinition();
                case "enum":
                    return this.parseEnumTypeDefinition();
                case "input":
                    return this.parseInputObjectTypeDefinition();
                case "directive":
                    return this.parseDirectiveDefinition()
                }
            throw this.unexpected(e)
        }
        ,
        t.peekDescription = function() {
            return this.peek(c.STRING) || this.peek(c.BLOCK_STRING)
        }
        ,
        t.parseDescription = function() {
            if (this.peekDescription())
                return this.parseStringLiteral()
        }
        ,
        t.parseSchemaDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription();
            this.expectKeyword("schema");
            var n = this.parseDirectives(!0)
              , r = this.many(c.BRACE_L, this.parseOperationTypeDefinition, c.BRACE_R);
            return {
                kind: s.a.SCHEMA_DEFINITION,
                description: t,
                directives: n,
                operationTypes: r,
                loc: this.loc(e)
            }
        }
        ,
        t.parseOperationTypeDefinition = function() {
            var e = this._lexer.token
              , t = this.parseOperationType();
            this.expectToken(c.COLON);
            var n = this.parseNamedType();
            return {
                kind: s.a.OPERATION_TYPE_DEFINITION,
                operation: t,
                type: n,
                loc: this.loc(e)
            }
        }
        ,
        t.parseScalarTypeDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription();
            this.expectKeyword("scalar");
            var n = this.parseName()
              , r = this.parseDirectives(!0);
            return {
                kind: s.a.SCALAR_TYPE_DEFINITION,
                description: t,
                name: n,
                directives: r,
                loc: this.loc(e)
            }
        }
        ,
        t.parseObjectTypeDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription();
            this.expectKeyword("type");
            var n = this.parseName()
              , r = this.parseImplementsInterfaces()
              , i = this.parseDirectives(!0)
              , o = this.parseFieldsDefinition();
            return {
                kind: s.a.OBJECT_TYPE_DEFINITION,
                description: t,
                name: n,
                interfaces: r,
                directives: i,
                fields: o,
                loc: this.loc(e)
            }
        }
        ,
        t.parseImplementsInterfaces = function() {
            var e;
            if (!this.expectOptionalKeyword("implements"))
                return [];
            if (!0 === (null === (e = this._options) || void 0 === e ? void 0 : e.allowLegacySDLImplementsInterfaces)) {
                var t = [];
                this.expectOptionalToken(c.AMP);
                do {
                    t.push(this.parseNamedType())
                } while (this.expectOptionalToken(c.AMP) || this.peek(c.NAME));
                return t
            }
            return this.delimitedMany(c.AMP, this.parseNamedType)
        }
        ,
        t.parseFieldsDefinition = function() {
            var e;
            return !0 === (null === (e = this._options) || void 0 === e ? void 0 : e.allowLegacySDLEmptyFields) && this.peek(c.BRACE_L) && this._lexer.lookahead().kind === c.BRACE_R ? (this._lexer.advance(),
            this._lexer.advance(),
            []) : this.optionalMany(c.BRACE_L, this.parseFieldDefinition, c.BRACE_R)
        }
        ,
        t.parseFieldDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription()
              , n = this.parseName()
              , r = this.parseArgumentDefs();
            this.expectToken(c.COLON);
            var i = this.parseTypeReference()
              , o = this.parseDirectives(!0);
            return {
                kind: s.a.FIELD_DEFINITION,
                description: t,
                name: n,
                arguments: r,
                type: i,
                directives: o,
                loc: this.loc(e)
            }
        }
        ,
        t.parseArgumentDefs = function() {
            return this.optionalMany(c.PAREN_L, this.parseInputValueDef, c.PAREN_R)
        }
        ,
        t.parseInputValueDef = function() {
            var e = this._lexer.token
              , t = this.parseDescription()
              , n = this.parseName();
            this.expectToken(c.COLON);
            var r, i = this.parseTypeReference();
            this.expectOptionalToken(c.EQUALS) && (r = this.parseValueLiteral(!0));
            var o = this.parseDirectives(!0);
            return {
                kind: s.a.INPUT_VALUE_DEFINITION,
                description: t,
                name: n,
                type: i,
                defaultValue: r,
                directives: o,
                loc: this.loc(e)
            }
        }
        ,
        t.parseInterfaceTypeDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription();
            this.expectKeyword("interface");
            var n = this.parseName()
              , r = this.parseImplementsInterfaces()
              , i = this.parseDirectives(!0)
              , o = this.parseFieldsDefinition();
            return {
                kind: s.a.INTERFACE_TYPE_DEFINITION,
                description: t,
                name: n,
                interfaces: r,
                directives: i,
                fields: o,
                loc: this.loc(e)
            }
        }
        ,
        t.parseUnionTypeDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription();
            this.expectKeyword("union");
            var n = this.parseName()
              , r = this.parseDirectives(!0)
              , i = this.parseUnionMemberTypes();
            return {
                kind: s.a.UNION_TYPE_DEFINITION,
                description: t,
                name: n,
                directives: r,
                types: i,
                loc: this.loc(e)
            }
        }
        ,
        t.parseUnionMemberTypes = function() {
            return this.expectOptionalToken(c.EQUALS) ? this.delimitedMany(c.PIPE, this.parseNamedType) : []
        }
        ,
        t.parseEnumTypeDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription();
            this.expectKeyword("enum");
            var n = this.parseName()
              , r = this.parseDirectives(!0)
              , i = this.parseEnumValuesDefinition();
            return {
                kind: s.a.ENUM_TYPE_DEFINITION,
                description: t,
                name: n,
                directives: r,
                values: i,
                loc: this.loc(e)
            }
        }
        ,
        t.parseEnumValuesDefinition = function() {
            return this.optionalMany(c.BRACE_L, this.parseEnumValueDefinition, c.BRACE_R)
        }
        ,
        t.parseEnumValueDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription()
              , n = this.parseName()
              , r = this.parseDirectives(!0);
            return {
                kind: s.a.ENUM_VALUE_DEFINITION,
                description: t,
                name: n,
                directives: r,
                loc: this.loc(e)
            }
        }
        ,
        t.parseInputObjectTypeDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription();
            this.expectKeyword("input");
            var n = this.parseName()
              , r = this.parseDirectives(!0)
              , i = this.parseInputFieldsDefinition();
            return {
                kind: s.a.INPUT_OBJECT_TYPE_DEFINITION,
                description: t,
                name: n,
                directives: r,
                fields: i,
                loc: this.loc(e)
            }
        }
        ,
        t.parseInputFieldsDefinition = function() {
            return this.optionalMany(c.BRACE_L, this.parseInputValueDef, c.BRACE_R)
        }
        ,
        t.parseTypeSystemExtension = function() {
            var e = this._lexer.lookahead();
            if (e.kind === c.NAME)
                switch (e.value) {
                case "schema":
                    return this.parseSchemaExtension();
                case "scalar":
                    return this.parseScalarTypeExtension();
                case "type":
                    return this.parseObjectTypeExtension();
                case "interface":
                    return this.parseInterfaceTypeExtension();
                case "union":
                    return this.parseUnionTypeExtension();
                case "enum":
                    return this.parseEnumTypeExtension();
                case "input":
                    return this.parseInputObjectTypeExtension()
                }
            throw this.unexpected(e)
        }
        ,
        t.parseSchemaExtension = function() {
            var e = this._lexer.token;
            this.expectKeyword("extend"),
            this.expectKeyword("schema");
            var t = this.parseDirectives(!0)
              , n = this.optionalMany(c.BRACE_L, this.parseOperationTypeDefinition, c.BRACE_R);
            if (0 === t.length && 0 === n.length)
                throw this.unexpected();
            return {
                kind: s.a.SCHEMA_EXTENSION,
                directives: t,
                operationTypes: n,
                loc: this.loc(e)
            }
        }
        ,
        t.parseScalarTypeExtension = function() {
            var e = this._lexer.token;
            this.expectKeyword("extend"),
            this.expectKeyword("scalar");
            var t = this.parseName()
              , n = this.parseDirectives(!0);
            if (0 === n.length)
                throw this.unexpected();
            return {
                kind: s.a.SCALAR_TYPE_EXTENSION,
                name: t,
                directives: n,
                loc: this.loc(e)
            }
        }
        ,
        t.parseObjectTypeExtension = function() {
            var e = this._lexer.token;
            this.expectKeyword("extend"),
            this.expectKeyword("type");
            var t = this.parseName()
              , n = this.parseImplementsInterfaces()
              , r = this.parseDirectives(!0)
              , i = this.parseFieldsDefinition();
            if (0 === n.length && 0 === r.length && 0 === i.length)
                throw this.unexpected();
            return {
                kind: s.a.OBJECT_TYPE_EXTENSION,
                name: t,
                interfaces: n,
                directives: r,
                fields: i,
                loc: this.loc(e)
            }
        }
        ,
        t.parseInterfaceTypeExtension = function() {
            var e = this._lexer.token;
            this.expectKeyword("extend"),
            this.expectKeyword("interface");
            var t = this.parseName()
              , n = this.parseImplementsInterfaces()
              , r = this.parseDirectives(!0)
              , i = this.parseFieldsDefinition();
            if (0 === n.length && 0 === r.length && 0 === i.length)
                throw this.unexpected();
            return {
                kind: s.a.INTERFACE_TYPE_EXTENSION,
                name: t,
                interfaces: n,
                directives: r,
                fields: i,
                loc: this.loc(e)
            }
        }
        ,
        t.parseUnionTypeExtension = function() {
            var e = this._lexer.token;
            this.expectKeyword("extend"),
            this.expectKeyword("union");
            var t = this.parseName()
              , n = this.parseDirectives(!0)
              , r = this.parseUnionMemberTypes();
            if (0 === n.length && 0 === r.length)
                throw this.unexpected();
            return {
                kind: s.a.UNION_TYPE_EXTENSION,
                name: t,
                directives: n,
                types: r,
                loc: this.loc(e)
            }
        }
        ,
        t.parseEnumTypeExtension = function() {
            var e = this._lexer.token;
            this.expectKeyword("extend"),
            this.expectKeyword("enum");
            var t = this.parseName()
              , n = this.parseDirectives(!0)
              , r = this.parseEnumValuesDefinition();
            if (0 === n.length && 0 === r.length)
                throw this.unexpected();
            return {
                kind: s.a.ENUM_TYPE_EXTENSION,
                name: t,
                directives: n,
                values: r,
                loc: this.loc(e)
            }
        }
        ,
        t.parseInputObjectTypeExtension = function() {
            var e = this._lexer.token;
            this.expectKeyword("extend"),
            this.expectKeyword("input");
            var t = this.parseName()
              , n = this.parseDirectives(!0)
              , r = this.parseInputFieldsDefinition();
            if (0 === n.length && 0 === r.length)
                throw this.unexpected();
            return {
                kind: s.a.INPUT_OBJECT_TYPE_EXTENSION,
                name: t,
                directives: n,
                fields: r,
                loc: this.loc(e)
            }
        }
        ,
        t.parseDirectiveDefinition = function() {
            var e = this._lexer.token
              , t = this.parseDescription();
            this.expectKeyword("directive"),
            this.expectToken(c.AT);
            var n = this.parseName()
              , r = this.parseArgumentDefs()
              , i = this.expectOptionalKeyword("repeatable");
            this.expectKeyword("on");
            var o = this.parseDirectiveLocations();
            return {
                kind: s.a.DIRECTIVE_DEFINITION,
                description: t,
                name: n,
                arguments: r,
                repeatable: i,
                locations: o,
                loc: this.loc(e)
            }
        }
        ,
        t.parseDirectiveLocations = function() {
            return this.delimitedMany(c.PIPE, this.parseDirectiveLocation)
        }
        ,
        t.parseDirectiveLocation = function() {
            var e = this._lexer.token
              , t = this.parseName();
            if (void 0 !== g.a[t.value])
                return t;
            throw this.unexpected(e)
        }
        ,
        t.loc = function(e) {
            var t;
            if (!0 !== (null === (t = this._options) || void 0 === t ? void 0 : t.noLocation))
                return new a.a(e,this._lexer.lastToken,this._lexer.source)
        }
        ,
        t.peek = function(e) {
            return this._lexer.token.kind === e
        }
        ,
        t.expectToken = function(e) {
            var t = this._lexer.token;
            if (t.kind === e)
                return this._lexer.advance(),
                t;
            throw o(this._lexer.source, t.start, "Expected ".concat(C(e), ", found ").concat(E(t), "."))
        }
        ,
        t.expectOptionalToken = function(e) {
            var t = this._lexer.token;
            if (t.kind === e)
                return this._lexer.advance(),
                t
        }
        ,
        t.expectKeyword = function(e) {
            var t = this._lexer.token;
            if (t.kind !== c.NAME || t.value !== e)
                throw o(this._lexer.source, t.start, 'Expected "'.concat(e, '", found ').concat(E(t), "."));
            this._lexer.advance()
        }
        ,
        t.expectOptionalKeyword = function(e) {
            var t = this._lexer.token;
            return t.kind === c.NAME && t.value === e && (this._lexer.advance(),
            !0)
        }
        ,
        t.unexpected = function(e) {
            var t = null !== e && void 0 !== e ? e : this._lexer.token;
            return o(this._lexer.source, t.start, "Unexpected ".concat(E(t), "."))
        }
        ,
        t.any = function(e, t, n) {
            this.expectToken(e);
            for (var r = []; !this.expectOptionalToken(n); )
                r.push(t.call(this));
            return r
        }
        ,
        t.optionalMany = function(e, t, n) {
            if (this.expectOptionalToken(e)) {
                var r = [];
                do {
                    r.push(t.call(this))
                } while (!this.expectOptionalToken(n));
                return r
            }
            return []
        }
        ,
        t.many = function(e, t, n) {
            this.expectToken(e);
            var r = [];
            do {
                r.push(t.call(this))
            } while (!this.expectOptionalToken(n));
            return r
        }
        ,
        t.delimitedMany = function(e, t) {
            this.expectOptionalToken(e);
            var n = [];
            do {
                n.push(t.call(this))
            } while (this.expectOptionalToken(e));
            return n
        }
        ,
        e
    }();
    function E(e) {
        var t = e.value;
        return C(e.kind) + (null != t ? ' "'.concat(t, '"') : "")
    }
    function C(e) {
        return function(e) {
            return e === c.BANG || e === c.DOLLAR || e === c.AMP || e === c.PAREN_L || e === c.PAREN_R || e === c.SPREAD || e === c.COLON || e === c.EQUALS || e === c.AT || e === c.BRACKET_L || e === c.BRACKET_R || e === c.BRACE_L || e === c.PIPE || e === c.BRACE_R
        }(e) ? '"'.concat(e, '"') : e
    }
    var N = new Map
      , R = new Map
      , P = !0
      , D = !1;
    function F(e) {
        return e.replace(/[\s,]+/g, " ").trim()
    }
    function k(e) {
        var t = new Set
          , n = [];
        return e.definitions.forEach((function(e) {
            if ("FragmentDefinition" === e.kind) {
                var r = e.name.value
                  , i = F((s = e.loc).source.body.substring(s.start, s.end))
                  , o = R.get(r);
                o && !o.has(i) ? P && console.warn("Warning: fragment with name " + r + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names") : o || R.set(r, o = new Set),
                o.add(i),
                t.has(i) || (t.add(i),
                n.push(e))
            } else
                n.push(e);
            var s
        }
        )),
        r(r({}, e), {
            definitions: n
        })
    }
    function j(e) {
        var t = F(e);
        if (!N.has(t)) {
            var n = function(e, t) {
                return new A(e,t).parseDocument()
            }(e, {
                experimentalFragmentVariables: D,
                allowLegacyFragmentVariables: D
            });
            if (!n || "Document" !== n.kind)
                throw new Error("Not a valid GraphQL document.");
            N.set(t, function(e) {
                var t = new Set(e.definitions);
                t.forEach((function(e) {
                    e.loc && delete e.loc,
                    Object.keys(e).forEach((function(n) {
                        var r = e[n];
                        r && "object" === typeof r && t.add(r)
                    }
                    ))
                }
                ));
                var n = e.loc;
                return n && (delete n.startToken,
                delete n.endToken),
                e
            }(k(n)))
        }
        return N.get(t)
    }
    function L(e) {
        for (var t = [], n = 1; n < arguments.length; n++)
            t[n - 1] = arguments[n];
        "string" === typeof e && (e = [e]);
        var r = e[0];
        return t.forEach((function(t, n) {
            t && "Document" === t.kind ? r += t.loc.source.body : r += t,
            r += e[n + 1]
        }
        )),
        j(r)
    }
    var V, U = {
        gql: L,
        resetCaches: function() {
            N.clear(),
            R.clear()
        },
        disableFragmentWarnings: function() {
            P = !1
        },
        enableExperimentalFragmentVariables: function() {
            D = !0
        },
        disableExperimentalFragmentVariables: function() {
            D = !1
        }
    };
    (V = L || (L = {})).gql = U.gql,
    V.resetCaches = U.resetCaches,
    V.disableFragmentWarnings = U.disableFragmentWarnings,
    V.enableExperimentalFragmentVariables = U.enableExperimentalFragmentVariables,
    V.disableExperimentalFragmentVariables = U.disableExperimentalFragmentVariables,
    L.default = L;
    t.a = L
}
, function(e, t, n) {
    "use strict";
    n.d(t, "c", (function() {
        return N
    }
    )),
    n.d(t, "a", (function() {
        return P
    }
    )),
    n.d(t, "e", (function() {
        return D
    }
    )),
    n.d(t, "g", (function() {
        return F
    }
    )),
    n.d(t, "b", (function() {
        return k
    }
    )),
    n.d(t, "d", (function() {
        return j
    }
    )),
    n.d(t, "f", (function() {
        return L
    }
    ));
    var r = n(377)
      , i = n(161);
    i.a.CASCADE,
    i.a.RESTRICT,
    i.a.NO_ACTION,
    i.a.SET_NULL;
    function o(e, t, n) {
        for (let i in t)
            e[Object(r.c)("own", n[i])] = t[i];
        return e
    }
    function s(e, t, n) {
        for (let i in t)
            e[Object(r.c)("ownRef", n[i])] = t[i],
            e[Object(r.c)("other", n[i])] = t[i]
    }
    function a(e, t, n, r) {
        let i;
        n || (n = {});
        for (let o in e)
            (i = t[o]) ? n[i] = e[o] : r || (n[o] = e[o]);
        return n
    }
    function c(e, t, n) {
        const r = {
            ...n
        };
        for (let i in e)
            r[i] = e[i];
        for (let i in t)
            r[i] = t[i];
        return r
    }
    var u = n(268)
      , l = n(0);
    const d = e => function() {
        return this.foreignField[e]
    }
    ;
    function h() {}
    const f = {
        get: () => !0,
        set: h
    }
      , p = {
        get: () => !1,
        set: h
    };
    function g(e) {
        let t, n;
        e ? (t = "refModel",
        n = "refField") : (t = "model",
        n = "field");
        const r = function(e, t) {
            let n, r;
            return t ? (n = "manyToMany",
            r = "manyToMany") : e ? (n = "refModel",
            r = "refField") : (n = "model",
            r = "field"),
            {
                ["".concat(n, "VF")]: {
                    get: d("".concat(n, "VF")),
                    set(r) {
                        this.foreignField["".concat(n, "VF")] = r,
                        !t && e && this.manyToManyVF && (this.manyToManyVF.ownModelThroughVF = r)
                    }
                },
                ["".concat(n, "VFName")]: {
                    get: d("".concat(n, "VFName")),
                    set(r) {
                        this.foreignField["".concat(n, "VFName")] = r,
                        t ? this.manyToManyVF && (this.manyToManyVF.VFName = r) : e === this.isRefModel ? this.VFName = r : this.ownRefModelVF && (this.ownRefModelVF.VFName = r)
                    }
                },
                ["".concat(n, "VFApiRead")]: {
                    get: d("".concat(n, "VFApiRead")),
                    set(e) {
                        this.foreignField["".concat(n, "VFApiRead")] = !!e
                    }
                },
                ["".concat(n, "VFApiCreate")]: {
                    get: d("".concat(n, "VFApiCreate")),
                    set(e) {
                        this.foreignField["".concat(n, "VFApiCreate")] = !!e
                    }
                },
                ["".concat(n, "VFApiUpdate")]: {
                    get: d("".concat(n, "VFApiUpdate")),
                    set(e) {
                        this.foreignField["".concat(n, "VFApiUpdate")] = !!e
                    }
                },
                ["".concat(n, "VFResolver")]: {
                    get: d("".concat(n, "VFResolver")),
                    set(e) {
                        this.foreignField["".concat(n, "VFResolver")] = e
                    }
                },
                ["".concat(r, "Constraint")]: {
                    get: d("".concat(r, "Constraint")),
                    set(e) {
                        if (e) {
                            this.foreignField["".concat(r, "Constraint")] = e,
                            this["".concat(r, "ConstraintId")] = e[u.a.CONSTRAINT],
                            this["".concat(r, "IndexName")] = e.name,
                            this["".concat(r, "IndexPriority")] = e.indexStorePriority;
                            const i = e.indexStoreKeyByFieldName;
                            t ? this["".concat(r, "IndexKeyBy")] = i || this.refModelPk : (this["".concat(r, "IndexIsModelState")] = e.primary,
                            this["".concat(r, "IndexIncludeNull")] = e.includeNull,
                            this["".concat(r, "IndexKeyBy")] = i || this["".concat(n, "Pk")])
                        }
                    }
                },
                ["".concat(r, "IndexName")]: {
                    get: d("".concat(r, "IndexName")),
                    set(e) {
                        this.foreignField["".concat(r, "IndexName")] = e
                    }
                },
                ["".concat(r, "IndexPriority")]: {
                    get: d("".concat(r, "IndexPriority")),
                    set(e) {
                        this.foreignField["".concat(r, "IndexPriority")] = e
                    }
                },
                ["".concat(r, "IndexKeyBy")]: {
                    get: d("".concat(r, "IndexKeyBy")),
                    set(i) {
                        this.foreignField["".concat(r, "IndexKeyBy")] = i,
                        t ? i && i !== this.refModelPk && this.manyToManyVF && this.manyToManyVF.ownRefModelVF && (this.manyToManyVF.ownRefModelVF.keyBy = i) : i && i !== this["".concat(n, "Pk")] && (e !== this.isRefModel ? this.keyBy = i : this.ownRefModelVF && (this.ownRefModelVF.keyBy = i))
                    }
                },
                ["".concat(n, "Relationship")]: {
                    get: d("".concat(n, "Relationship")),
                    set(e) {
                        this.foreignField["".concat(n, "Relationship")] = e
                    }
                },
                ["".concat(n, "CacheMissingField")]: {
                    get: d("".concat(n, "CacheMissingField")),
                    set(e) {
                        this.foreignField["".concat(n, "CacheMissingField")] = e,
                        e && (this["".concat(n, "CacheMissingFieldName")] = e.name)
                    }
                },
                ["".concat(n, "CacheMissingFieldName")]: {
                    get: d("".concat(n, "CacheMissingFieldName")),
                    set(e) {
                        this.foreignField["".concat(n, "CacheMissingFieldName")] = e
                    }
                },
                ["".concat(n, "AutoloadOnClient")]: {
                    get: d("".concat(n, "AutoloadOnClient")),
                    set(e) {
                        e = !!e,
                        this.foreignField["".concat(n, "AutoloadOnClient")] = e,
                        this.isServer || !this["".concat(n, "Autoload")] === e || (this.foreignField["".concat(n, "Autoload")] = e)
                    }
                },
                ["".concat(n, "AutoloadOnServer")]: {
                    get: d("".concat(n, "AutoloadOnServer")),
                    set(e) {
                        e = !!e,
                        this.foreignField["".concat(n, "AutoloadOnServer")] = e,
                        this.isServer && this["".concat(n, "Autoload")] !== e && (this["".concat(n, "Autoload")] = e)
                    }
                },
                ["".concat(n, "Autoload")]: {
                    get: d("".concat(n, "Autoload")),
                    set(e) {
                        this.foreignField["".concat(n, "Autoload")] = !!e;
                        const t = this.isServer;
                        (!t && this["".concat(n, "AutoloadOnClient")] !== e || t && this["".concat(n, "AutoloadOnServer")] !== e) && (this["".concat(n, "AutoloadOnClient")] = e,
                        this["".concat(n, "AutoloadOnServer")] = e)
                    }
                }
            }
        }(e, !1);
        return r[t] = {
            get: d(t),
            set(e) {
                e && (e = Object(l.C)(e),
                this.foreignField[t] = e,
                this.foreignField["".concat(t, "Name")] = e.modelName)
            }
        },
        r["".concat(t, "Name")] = {
            get: d("".concat(t, "Name")),
            set(e) {
                this.foreignField["".concat(t, "Name")] = e
            }
        },
        r["".concat(t, "Pk")] = {
            get() {
                return this[t].primaryKey
            },
            set: void 0
        },
        r[n] = {
            get() {
                return this.foreignField[n]
            },
            set(e) {
                this.foreignField[n] = e,
                this["".concat(n, "Id")] = e[u.a.FIELD];
                const r = e.name;
                this["".concat(n, "Name")] = r,
                r === this["".concat(t, "Pk")] ? (this["".concat(n, "IsPk")] = !0,
                this["".concat(n, "IsAutoIncrement")] = e.type.isAutoIncrement) : (this["".concat(n, "IsPk")] = !1,
                this["".concat(n, "IsAutoIncrement")] = !1)
            }
        },
        r["".concat(n, "Name")] = {
            get: d("".concat(n, "Name")),
            set(e) {
                this.foreignField["".concat(n, "Name")] = e
            }
        },
        r["".concat(n, "IsPk")] = {
            get: d("".concat(n, "IsPk")),
            set(e) {
                this.foreignField["".concat(n, "IsPk")] = !!e
            }
        },
        r["".concat(n, "IsAutoIncrement")] = {
            get: d("".concat(n, "IsAutoIncrement")),
            set(e) {
                this.foreignField["".concat(n, "IsAutoIncrement")] = !!e
            }
        },
        r["".concat(n, "IndexIsModelState")] = {
            get: d("".concat(n, "IndexIsModelState")),
            set(e) {
                this.foreignField["".concat(n, "IndexIsModelState")] = !!e
            }
        },
        r["".concat(n, "IndexIncludeNull")] = {
            get: d("".concat(n, "IndexIncludeNull")),
            set(e) {
                this.foreignField["".concat(n, "IndexIncludeNull")] = !!e
            }
        },
        r["".concat(n, "IndexModel")] = {
            get() {
                return this[t]
            },
            set: void 0
        },
        r
    }
    const m = {
        bestVFName: {
            get() {
                return this.VFName || this.instanceId
            },
            set: void 0
        },
        isLocalOnly: {
            get() {
                return this.foreignField.isLocalOnly
            },
            set(e) {
                this.foreignField.isLocalOnly = !!e
            }
        },
        isComputed: p,
        isReciprocal: {
            get() {
                return this.foreignField.isReciprocal
            },
            set(e) {
                this.foreignField.isReciprocal = !0 === e
            }
        },
        isRecursive: {
            get() {
                return this.modelName === this.refModelName
            },
            set: void 0
        },
        isServer: {
            get() {
                return this.model.isServer
            },
            set: void 0
        },
        onUpdate: {
            get() {
                return this.foreignField.onUpdate
            },
            set(e) {
                this.foreignField.onUpdate = e
            }
        },
        onDelete: {
            get() {
                return this.foreignField.onDelete
            },
            set(e) {
                this.foreignField.onDelete = e
            }
        },
        manyToManyIndexModel: {
            get() {
                return this.refModel
            },
            set: void 0
        },
        manyToManyUniqueConstraint: {
            get() {
                return this.foreignField.manyToManyUniqueConstraint
            },
            set(e) {
                e ? (this.foreignField.manyToManyUniqueConstraint = e,
                this.manyToManyUniqueConstraintId = e[u.a.CONSTRAINT],
                this.manyToManyUniqueIndexName = e.name,
                this.manyToManyUniqueIndexPriority = e.indexStorePriority) : (this.foreignField.manyToManyUniqueConstraint = null,
                this.manyToManyUniqueConstraintId = null,
                this.manyToManyUniqueIndexName = null,
                this.manyToManyUniqueIndexPriority = null)
            }
        },
        manyToManyUniqueIndexName: {
            get() {
                return this.foreignField.manyToManyUniqueIndexName
            },
            set(e) {
                this.foreignField.manyToManyUniqueIndexName = e
            }
        },
        manyToManyUniqueIndexPriority: {
            get() {
                return this.foreignField.manyToManyUniqueIndexPriority
            },
            set(e) {
                this.foreignField.manyToManyUniqueIndexPriority = e
            }
        },
        manyToManyUniqueIndexModel: {
            get() {
                return this.model
            },
            set: void 0
        },
        manyToManyUniqueIndexIsModelState: p
    };
    m.inDatabase = m.isLocalOnly;
    const y = g(!1)
      , v = g(!0);
    function b(e) {
        let t, n, r, i;
        e ? (t = "refModelThroughVF",
        n = "refModel",
        r = "refField",
        i = v) : (t = "modelThroughVF",
        n = "model",
        r = "field",
        i = y);
        const o = "_".concat(t);
        return {
            ...i,
            ["".concat(r, "IsPk")]: f,
            ["".concat(r, "IndexIsModelState")]: p,
            ["".concat(r, "IndexIncludeNull")]: p,
            ["".concat(n, "ThroughVF")]: {
                get() {
                    return this[o]
                },
                set(e) {
                    e ? (this[o] = e,
                    e.manyToManyVF = this) : this[o] && (this[o].manyToManyVF = void 0,
                    this[o] = void 0)
                }
            },
            ["".concat(n, "ThroughVFName")]: {
                get() {
                    return this[t].modelVFName
                },
                set(e) {
                    this[t].modelVFName = e
                }
            },
            ["".concat(n, "ThroughRefVFName")]: {
                get() {
                    return this[t].refModelVFName
                },
                set(e) {
                    this[t].refModelVFName = e
                }
            },
            ["".concat(n, "ThroughField")]: {
                get() {
                    return this[t].field
                },
                set(e) {
                    this[t].field = e
                }
            },
            ["".concat(n, "ThroughFieldName")]: {
                get() {
                    return this[t].fieldName
                },
                set(e) {
                    this[t].fieldName = e
                }
            },
            ["".concat(n, "ThroughRefField")]: {
                get() {
                    return this[t].refField
                },
                set(e) {
                    this[t].refField = e
                }
            },
            ["".concat(n, "ThroughRefFieldName")]: {
                get() {
                    return this[t].refFieldName
                },
                set(e) {
                    this[t].refFieldName = e
                }
            },
            ["".concat(n, "ThroughAutoload")]: {
                get() {
                    return this[t].refModelAutoload
                },
                set(e) {
                    this[t].refModelAutoload = e
                }
            }
        }
    }
    const _ = e => function(t) {
        this.modelThroughVF[e] = t,
        this.refModelThroughVF[e] = t
    }
      , S = {
        bestVFName: m.bestVFName,
        inDatabase: m.inDatabase,
        isLocalOnly: m.isLocalOnly,
        isServer: m.isServer,
        onUpdate: m.onUpdate,
        onDelete: m.onDelete,
        throughModel: {
            get() {
                return this.modelThroughVF.model
            },
            set: _("model")
        },
        throughModelName: {
            get() {
                return this.modelThroughVF.modelName
            },
            set: _("modelName")
        },
        isComputed: p,
        isRecursive: p,
        throughModelUniqueConstraint: {
            get() {
                return this.modelThroughVF.manyToManyUniqueConstraint
            },
            set: _("manyToManyUniqueConstraint")
        },
        throughModelUniqueIndexName: {
            get() {
                return this.modelThroughVF.manyToManyUniqueIndexName
            },
            set: _("manyToManyUniqueIndexName")
        },
        throughModelUniqueIndexPriority: {
            get() {
                return this.modelThroughVF.manyToManyUniqueIndexPriority
            },
            set: _("manyToManyUniqueIndexPriority")
        }
    }
      , O = b(!1)
      , T = b(!0)
      , I = new Set
      , x = new Set
      , w = {}
      , M = {}
      , A = {}
      , E = {};
    !function() {
        const e = (e, t) => {
            for (let n in t)
                e.add(n)
        }
        ;
        let t, n, i, o;
        e(I, y),
        e(I, O);
        for (let s of I)
            t = Object(r.c)("ref", s),
            n = Object(r.c)("own", s),
            i = Object(r.c)("own", t),
            o = Object(r.c)("other", s),
            w[s] = t,
            w[t] = s,
            w[n] = t,
            w[i] = s,
            w[o] = s,
            M[s] = t,
            M[t] = s,
            M[n] = s,
            M[i] = t,
            M[o] = t,
            A[s] = s,
            A[t] = t,
            A[n] = s,
            A[i] = t,
            A[o] = t,
            E[s] = s,
            E[t] = t,
            E[n] = t,
            E[i] = s,
            E[o] = s;
        e(x, m),
        e(x, S);
        for (let r of x)
            w[r] = r,
            M[r] = r,
            A[r] = r,
            E[r] = r
    }();
    const C = (e, t) => {
        let n = y
          , r = v;
        t && (n = O,
        r = T);
        const i = {};
        return e ? (s(i, n, A),
        o(i, r, M)) : (o(i, n, A),
        s(i, r, M)),
        i
    }
    ;
    function N(e, t, n, r) {
        return a(e, t ? E : A, n, r)
    }
    function R(e) {
        return e ? c(O, T, S) : c(y, v, m)
    }
    const P = R()
      , D = C(!1, !1)
      , F = C(!0, !1)
      , k = R(!0)
      , j = C(!1, !0)
      , L = C(!0, !0)
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return a
    }
    ));
    var r = n(14)
      , i = n(82);
    var o = n(22)
      , s = n(138);
    function a(e, t) {
        void 0 === t && (t = i.a);
        var n, r = (n = e)instanceof Date && !isNaN(+n) ? +e - t.now() : Math.abs(e);
        return function(e) {
            return e.lift(new c(r,t))
        }
    }
    var c = function() {
        function e(e, t) {
            this.delay = e,
            this.scheduler = t
        }
        return e.prototype.call = function(e, t) {
            return t.subscribe(new u(e,this.delay,this.scheduler))
        }
        ,
        e
    }()
      , u = function(e) {
        function t(t, n, r) {
            var i = e.call(this, t) || this;
            return i.delay = n,
            i.scheduler = r,
            i.queue = [],
            i.active = !1,
            i.errored = !1,
            i
        }
        return r.a(t, e),
        t.dispatch = function(e) {
            for (var t = e.source, n = t.queue, r = e.scheduler, i = e.destination; n.length > 0 && n[0].time - r.now() <= 0; )
                n.shift().notification.observe(i);
            if (n.length > 0) {
                var o = Math.max(0, n[0].time - r.now());
                this.schedule(e, o)
            } else
                this.unsubscribe(),
                t.active = !1
        }
        ,
        t.prototype._schedule = function(e) {
            this.active = !0,
            this.destination.add(e.schedule(t.dispatch, this.delay, {
                source: this,
                destination: this.destination,
                scheduler: e
            }))
        }
        ,
        t.prototype.scheduleNotification = function(e) {
            if (!0 !== this.errored) {
                var t = this.scheduler
                  , n = new l(t.now() + this.delay,e);
                this.queue.push(n),
                !1 === this.active && this._schedule(t)
            }
        }
        ,
        t.prototype._next = function(e) {
            this.scheduleNotification(s.a.createNext(e))
        }
        ,
        t.prototype._error = function(e) {
            this.errored = !0,
            this.queue = [],
            this.destination.error(e),
            this.unsubscribe()
        }
        ,
        t.prototype._complete = function() {
            this.scheduleNotification(s.a.createComplete()),
            this.unsubscribe()
        }
        ,
        t
    }(o.a)
      , l = function() {
        return function(e, t) {
            this.time = e,
            this.notification = t
        }
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "a", (function() {
        return i
    }
    ));
    var r = n(83);
    function i(e, t) {
        let n;
        if (e instanceof Date)
            n = e.getMonth() + 1,
            t = e.getFullYear();
        else if (n = "string" === typeof e ? Number(e) : e,
        !t)
            throw new Error("A year is required for getMaxMonthDays() when a string or number is provided for the month.");
        switch (n) {
        case 2:
            return (r = t)instanceof Date ? r = r.getFullYear() : "string" === typeof r && (r = Number(r)),
            r % 4 === 0 && r % 100 !== 0 || r % 400 === 0 ? 29 : 28;
        case 4:
        case 6:
        case 9:
        case 11:
            return 30;
        default:
            return 31
        }
        var r
    }
    !function() {
        const e = (e, t, n) => (n && (t = Object(r.b)(t)),
        e > 1 && (t += "s"),
        "".concat(e, " ").concat(t))
    }()
}
, function(e, t, n) {
    "use strict";
    n.d(t, "e", (function() {
        return a
    }
    )),
    n.d(t, "c", (function() {
        return c
    }
    )),
    n.d(t, "g", (function() {
        return u
    }
    )),
    n.d(t, "d", (function() {
        return l
    }
    )),
    n.d(t, "f", (function() {
        return d
    }
    )),
    n.d(t, "a", (function() {
        return h
    }
    )),
    n.d(t, "b", (function() {
        return f
    }
    ));
    var r = n(237)
      , i = n(1001)
      , o = n(0);
    function s(e, t) {
        return e.id || e.externalId || t || e.name
    }
    let a = (e, t) => e;
    const c = (e, t) => {
        "undefined" === typeof e.refModelVFName && (e.refModelVFName = Object(r.a)(e.modelName) + "s");
        let n = i.g;
        t ? ("undefined" === typeof e.modelVFName && (e.modelVFName = Object(r.a)(e.refModelName) + "s"),
        e.modelThroughVFName || (e.modelThroughVFName = "".concat(e.modelVFName, "Data")),
        e.refModelThroughVFName || (e.refModelThroughVFName = "".concat(e.refModelVFName, "Data")),
        n = i.h,
        e.refFieldIndexName || (e.refFieldIndexName = "c_".concat(e.refFieldName || n.refFieldName))) : "undefined" === typeof e.modelVFName && (e.modelVFName = Object(r.a)(e.refModelName)),
        e.fieldIndexName || (e.fieldIndexName = "c_".concat(e.fieldName || n.fieldName));
        for (let r in n)
            e[r] || !1 === e[r] || (e[r] = n[r]);
        return e
    }
    ;
    function u(e, t, n) {
        const r = e.modelVF
          , i = e.refModelVF;
        r.refModelVF = i,
        i.modelVF = r,
        r.model = t.modelInstance,
        r.refModel = n.modelInstance,
        r.field = t.fields[e.fieldName],
        r.refField = n.fields[e.refFieldName],
        r.fieldConstraint = t.constraints[e.fieldIndexName],
        r.refFieldConstraint = n.constraints[e.refFieldIndexName]
    }
    function l(e, t) {
        const n = t.getInternalValue(e.modelRelationship).init(e);
        let r;
        n.isManyToMany ? (n.modelThroughVF = e.modelThroughVF,
        n.refModelThroughVF = e.refModelThroughVF,
        n.throughModelUniqueConstraint = e.throughModelUniqueIndexName ? e.modelThroughVF.model.schema.constraints[e.throughModelUniqueIndexName] : null,
        r = t.getInternalValue(e.refModelRelationship).init(e),
        r.modelThroughVF = e.modelThroughVF,
        r.refModelThroughVF = e.refModelThroughVF) : r = t.getInternalValue(e.refModelRelationship).init(e),
        n.refModelVF = r,
        r.modelVF = n
    }
    function d(e) {
        var t, n, r, i, o, a;
        return e.instanceId = e.isManyToMany ? (r = e.model.schema,
        i = e.modelThroughVF.field,
        o = e.refModel.schema,
        a = e.refModelThroughVF.field,
        "vf".concat(s(r), "__").concat(s(i), "__").concat(s(o), "__").concat(s(a))) : (t = e.model.schema,
        n = e.field,
        "vf".concat(s(t), "__").concat(s(n))),
        e.instanceId += "__".concat(e.isRefModel ? "refModel" : "model"),
        e
    }
    function h(e, t, n, r) {
        return "vf".concat(e, "__").concat(t, "__").concat(n, "__").concat(r)
    }
    function f(e) {
        if (!e)
            return null;
        let t = null;
        if (Object(o.Z)(e[0])) {
            t = {};
            for (const n of e)
                t[n.instanceId] = n
        } else
            for (const n of e)
                n.id && (t || (t = {})) && (t[n.id] = n);
        return t
    }
}
]);
