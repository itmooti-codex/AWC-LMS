<!-- External Libraries -->
<script src="https://cdn.jsdelivr.net/npm/jsrender@1.0.11/jsrender.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tributejs@5.1.3/dist/tribute.min.js"></script>
<script src="https://itmooti.github.io/Ontraport---AWC/globalSelectPopover.js"></script>

<script>
  function getScrollableParent(el) {
    let p = el.parentElement;
    while (p && p !== document.body) {
      const style = getComputedStyle(p);
      const canScrollY = /(auto|scroll|overlay)/.test(style.overflowY);
      if (canScrollY && p.scrollHeight > p.clientHeight) return p;
      p = p.parentElement;
    }
    return window;
  }

  function centerScroll({ scroller, target, offset = 0, smooth = true }) {
    if (scroller === window) {
      const rect = target.getBoundingClientRect();
      const viewportH = window.innerHeight;
      const y =
        window.pageYOffset + rect.top - offset - (viewportH - rect.height) / 2;
      window.scrollTo({
        top: Math.max(0, y),
        behavior: smooth ? "smooth" : "auto",
      });
    } else {
      const parentRect = scroller.getBoundingClientRect();
      const targetRect = target.getBoundingClientRect();
      const delta =
        targetRect.top -
        parentRect.top -
        (scroller.clientHeight - target.offsetHeight) / 2 -
        offset;
      scroller.scrollTo({
        top: scroller.scrollTop + delta,
        behavior: smooth ? "smooth" : "auto",
      });
    }
  }

  function highlightAndScrollToCommentOrReply() {
    const url = window.location.href;
    const match = url.match(/[?&]commentScrollId=(\d+)/);
    const commentScrollId = match ? match[1] : null;
    if (!commentScrollId) return;

    // If you have a fixed header, set its height here or compute it:
    const headerOffset =
      document.querySelector(".site-header, header.sticky, .fixed-header")
        ?.offsetHeight || 0;

    let attempts = 0;
    const maxAttempts = 8; // retry while layout settles
    const intervalMs = 250;

    const tryFindAndScroll = () => {
      attempts++;
      const target =
        document.querySelector(`[data-commentid="${commentScrollId}"]`) ||
        document.querySelector(`[data-replyid="${commentScrollId}"]`);

      if (target) {
        target.classList.add("highlightedSubmission");

        // choose scroller and center the target
        const scroller = getScrollableParent(target);
        centerScroll({
          scroller,
          target,
          offset: scroller === window ? headerOffset : 0,
          smooth: true,
        });

        // one extra pass after a short delay to correct for late layout shifts
        setTimeout(() => {
          centerScroll({
            scroller,
            target,
            offset: scroller === window ? headerOffset : 0,
            smooth: true,
          });
        }, 300);

        clearInterval(poll);
      } else if (attempts >= maxAttempts) {
        clearInterval(poll);
      }
    };

    const poll = setInterval(tryFindAndScroll, intervalMs);
    setTimeout(() => clearInterval(poll), maxAttempts * intervalMs + 500);
  }

  document.addEventListener(
    "DOMContentLoaded",
    highlightAndScrollToCommentOrReply
  );
</script>

<script>
  const awsParam = "ee037b98f52d6f86c4d3a4cc4522de1e";
  const awsParamUrl = "https://courses.writerscentre.com.au/s/aws";
  const GRAPHQL_ENDPOINT = "https://awc.vitalstats.app/api/v1/graphql";
  const API_KEY = "mMzQezxyIwbtSc85rFPs3";
  let submissionID = "[Page//ID]";
  let classId = "[Page//Student//Class//ID]";
  let firstName = "[Visitor//First Name]";
  let lastName = "[Visitor//Last Name]";
  let displayName = "[Visitor//Display Name]";
  let authorID = "[Visitor//Contact ID]";
  let authorProfileImage = "[Visitor//Profile Image ##link]";
  let filePreview = document.querySelector(".filePreviewWrapper");
  const commentForm = document.getElementById("submissionComment");
  const commentsContainer = document.getElementById("commentsContainer");
  const commentCountElement = document.getElementById("commentCount");
  let comments = [];
  let replies = {};
  const submissionVoteButton = document.querySelector(".submissionVoteButton");
  const submissionVoteCountElement = document.querySelector(".voteCount");
  let submissionVoters = [];
  let hasVotedForSubmission = false;
  let voteCountForSubmissions = 0;
  let commentVoters = [];
  let hasVotedForComment = false;
  let voteCountForComments = 0;
  window.lessonUIDFromPage = "[Page//Assessment//Lesson//Unique ID]";

  function gatherMentionsFromElement(el) {
    if (!el) return [];
    const nodes = el.querySelectorAll(".mention[data-mention-id]");
    return Array.from(nodes)
      .map((m) => m.getAttribute("data-mention-id"))
      .filter(Boolean);
  }

  // Ensure Tribute/@mention is attached to any dynamic editors (comments/replies)
  function initMentionableEditor(editor) {
    if (!editor || editor.nodeType !== 1) return;
    try {
      // Attach Tribute via NewMentionManager (preferred) or fallback
      if (!editor.hasAttribute("data-tribute-attached")) {
        if (
          window.NewMentionManager &&
          typeof window.NewMentionManager.initEditor === "function"
        ) {
          window.NewMentionManager.initEditor(editor);
          editor.setAttribute("data-tribute-attached", "true");
        } else if (window.Tribute) {
          try {
            const t = new Tribute({ trigger: "@", allowSpaces: true });
            t.attach(editor);
            editor.setAttribute("data-tribute-attached", "true");
          } catch (_) {}
        }
      }

      // Lightweight placeholder handling; guard against re-binding.
      if (!editor.hasAttribute("data-placeholder-initialized")) {
        const setPlaceholder = () => {
          if (
            !editor.textContent.trim() &&
            !editor.querySelector(".placeholder")
          ) {
            editor.innerHTML =
              '<span class="placeholder extra-small-text text-light text-[#586a80] text-base font-normal leading-normal"><i>Type @ to mention someone...</i></span>';
          }
        };
        editor.addEventListener("focus", () => {
          const ph = editor.querySelector(".placeholder");
          if (ph) editor.innerHTML = "";
        });
        editor.addEventListener("blur", () => setPlaceholder());
        setPlaceholder();
        editor.setAttribute("data-placeholder-initialized", "true");
      }
    } catch (_) {}
  }

  function reInitMentionEditors(rootEl) {
    try {
      const root = rootEl && rootEl.querySelectorAll ? rootEl : document;
      // No contact reload here â€” it's cached and loaded once.
      const editors = root.querySelectorAll(".mentionable");
      editors.forEach((ed) => initMentionableEditor(ed));
    } catch (_) {}
  }

  function normalizeForumFile(rawFile, rawFileName) {
    if (!rawFile || rawFile === "{}") return null;

    const fallbackName =
      typeof rawFileName === "string" && rawFileName.trim()
        ? rawFileName.trim()
        : "";

    const cleanString = (value) =>
      typeof value === "string" ? value.trim() : "";

    const stripQuotes = (value) =>
      typeof value === "string" ? value.replace(/^"|"$/g, "") : value;

    const deriveNameFromLink = (linkValue) => {
      const link = cleanString(linkValue);
      if (!link) return "";
      const parts = link.split("/");
      if (!parts.length) return "";
      const last = parts[parts.length - 1] || "";
      try {
        return decodeURIComponent(last);
      } catch (_) {
        return last;
      }
    };

    const buildResult = (linkValue, providedName) => {
      const cleanedLink = stripQuotes(cleanString(linkValue));
      if (!cleanedLink) return null;
      const hasProtocol =
        /^https?:\/\//i.test(cleanedLink) || cleanedLink.startsWith("//");
      if (!hasProtocol) return null;
      const candidateName =
        (typeof providedName === "string" && providedName.trim()) ||
        fallbackName ||
        deriveNameFromLink(cleanedLink) ||
        "Download attachment";
      return {
        link: cleanedLink,
        name: candidateName,
      };
    };

    let parsedValue = rawFile;
    if (typeof rawFile === "string") {
      const trimmed = cleanString(rawFile);
      if (!trimmed) return null;
      try {
        parsedValue = JSON.parse(trimmed);
      } catch (_) {
        return buildResult(trimmed, null);
      }
    }

    if (typeof parsedValue === "string") {
      return buildResult(parsedValue, null);
    }

    if (parsedValue && typeof parsedValue === "object") {
      const linkValue =
        parsedValue.link ||
        parsedValue.url ||
        parsedValue.href ||
        parsedValue.Location ||
        parsedValue.location ||
        parsedValue.download_url ||
        parsedValue.downloadUrl ||
        "";
      const builtFromObject = buildResult(linkValue, parsedValue.name);
      if (builtFromObject) {
        return builtFromObject;
      }

      if (parsedValue.s3_id) {
        return buildResult(parsedValue.s3_id, parsedValue.name);
      }
    }

    return null;
  }
</script>

<script>
  const API = {
    endpoint: GRAPHQL_ENDPOINT,
    apiKey: API_KEY,

    async fetchGraphQL(query, variables = {}) {
      try {
        const response = await fetch(this.endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Api-Key": this.apiKey,
          },
          body: JSON.stringify({ query, variables }),
        });

        const result = await response.json();
        if (result.errors) {
          throw new Error("GraphQL Error");
        }
        return result.data;
      } catch (error) {
        throw error;
      }
    },
  };
</script>

<script>
  const SubmissionService = {
    async fetchComments(submissionID) {
      const data = await API.fetchGraphQL(FETCH_SUBMISSIONS_COMMENTS_QUERY, {
        id: submissionID,
      });
      const normalized = (data?.calcForumComments || []).map((comment) => {
        const file = normalizeForumFile(
          comment.File,
          comment.Comment_File_Name
        );

        return {
          Comment: comment.Comment,
          Author_ID: comment.Author_ID,
          Author_First_Name: comment.Author_First_Name,
          Author_Last_Name: comment.Author_Last_Name,
          Author_Display_Name: comment.Author_Display_Name,
          Author_Profile_Image: comment.Author_Profile_Image,
          Date_Added: formatDateTimeFromUnix(comment.Date_Added),
          File: file,
          Comment_File_Name:
            typeof comment.Comment_File_Name === "string"
              ? comment.Comment_File_Name
              : null,
          ID: comment.ID,
          Reply_to_Comment_ID: comment.Reply_to_Comment_ID,
        };
      });

      return normalized.filter((comment) => {
        const parentKey =
          comment?.Reply_to_Comment_ID !== null &&
          comment.Reply_to_Comment_ID !== undefined
            ? String(comment.Reply_to_Comment_ID).trim()
            : "";
        return !parentKey || parentKey === "0";
      });
    },
    async fetchVotersForSubmission(submissionID) {
      const data = await API.fetchGraphQL(FETCH_SUBMISSION_VOTERS_QUERY, {
        id: submissionID,
      });
      const submissions = data.calcSubmissions || [];
      return submissions
        .filter(
          (submission) =>
            submission.Voters_DataID !== null &&
            submission.Voters_Contact_ID !== null
        )
        .map((submission) => ({
          voteID: submission.Voters_DataID,
          voterID: submission.Voters_Contact_ID,
        }));
    },

    async createVoteForSubmission(voterId, submissionID) {
      const variables = {
        payload: { voter_id: voterId, voted_submission_id: submissionID },
      };
      return API.fetchGraphQL(
        CREATE_VOTE_ON_SUBMISSION_MUTATION_QUERY,
        variables
      );
    },
    async deleteVoteForSubmission(voteId) {
      return API.fetchGraphQL(DELETE_VOTE_ON_SUBMISSION_MUTATION_QUERY, {
        id: voteId,
      });
    },
    async createComment(
      authorID,
      submissionID,
      commentContentHTML,
      mentionArrays = [],
      fileData,
      commentFileName
    ) {
      const variables = {
        payload: {
          author_id: authorID,
          submissions_id: submissionID,
          comment: commentContentHTML,
          Mentions: mentionArrays.map((id) => ({ unique_id: id })),
          file: fileData,
        },
      };

      if (commentFileName) {
        variables.payload.comment_file_name = commentFileName;
      }

      return API.fetchGraphQL(CREATE_COMMENT_MUTATION_QUERY, variables);
    },
    async deleteComment(commentId) {
      return API.fetchGraphQL(DELETE_COMMENT_MUTATION_QUERY, { id: commentId });
    },
    async deleteReply(replyId) {
      return API.fetchGraphQL(DELETE_COMMENT_MUTATION_QUERY, { id: replyId });
    },
  };
</script>

<script>
  const CommentsService = {
    async fetchReplies(parentCommentID) {
      const data = await API.fetchGraphQL(FETCH_REPLIES_QUERY, {
        id: parentCommentID,
      });
      return data.calcForumComments.map((reply) => ({
        Comment: reply.Comment,
        Author_First_Name: reply.Author_First_Name,
        Author_ID: reply.Author_ID,
        Reply_to_Comment_ID: reply.Reply_to_Comment_ID,
        Author_Last_Name: reply.Author_Last_Name,
        Author_Display_Name: reply.Author_Display_Name,
        Author_Profile_Image: reply.Author_Profile_Image,
        Date_Added: formatDateTimeFromUnix(reply.Date_Added),
        ID: reply.ID,
      }));
    },
    async createCommentOnReply(
      replyToCommentId,
      replyContentHTML,
      mentions = [],
      replyFileName
    ) {
      const variables = {
        payload: {
          author_id: authorID,
          reply_to_comment_id: replyToCommentId,
          comment: replyContentHTML,
          Mentions: mentions.map((id) => ({ unique_id: id })),
        },
      };

      if (replyFileName) {
        variables.payload.comment_file_name = replyFileName;
      }

      return API.fetchGraphQL(
        CREATE_REPLY_ON_COMMENT_MUTATION_QUERY,
        variables
      );
    },
  };
</script>

<script>
  const UI = {
    updateComments(comments) {
      const commentTemplate = $.templates("#submissionsCommentTemplate");
      if (commentsContainer) {
        commentsContainer.innerHTML = comments
          .map((comment) => commentTemplate.render(comment))
          .join("");
        comments.forEach((comment) => {
          const commentId = comment && comment.ID;
          if (commentId == null) return;
          const key = String(commentId);
          const cachedReplies = replies && (replies[key] || replies[commentId]);
          if (Array.isArray(cachedReplies)) {
            UI.updateReplies(commentId, cachedReplies);
          }
        });
      }
      // Re-attach Tribute/@mention for newly rendered reply editors (next frame)
      try {
        requestAnimationFrame(() => reInitMentionEditors(commentsContainer));
      } catch (_) {
        try {
          setTimeout(() => reInitMentionEditors(commentsContainer), 0);
        } catch (_) {}
      }
      UI.updateCommentCount(comments.length);
    },
    updateCommentCount(count) {
      if (commentCountElement) {
        commentCountElement.textContent = `${count}`;
      }
    },
    updateReplies(replyToCommentId, repliesForComment) {
      const safeReplies = Array.isArray(repliesForComment)
        ? repliesForComment
        : [];
      const repliesContainer = document.querySelector(
        `.replies-container[data-parentcommentid="${replyToCommentId}"]`
      );
      const repliesTemplate = $.templates("#repliesTemplate");

      if (repliesContainer) {
        repliesContainer.innerHTML = safeReplies
          .map((reply) => repliesTemplate.render(reply))
          .join("");
      }
      // Re-attach Tribute/@mention for newly rendered reply editor(s) (next frame)
      try {
        requestAnimationFrame(() => reInitMentionEditors(repliesContainer));
      } catch (_) {
        try {
          setTimeout(() => reInitMentionEditors(repliesContainer), 0);
        } catch (_) {}
      }
      UI.updateReplyCount(replyToCommentId, safeReplies.length);
    },
    updateReplyCount(replyToCommentId, count) {
      const replyCountElement = document.querySelector(
        `[data-replycount="replyCount-${replyToCommentId}"]`
      );
      if (replyCountElement) {
        replyCountElement.textContent = count;
      }
    },
    updateSubmissionVoteButton() {
      if (hasVotedForSubmission) {
        submissionVoteButton.classList.add("voted");
      } else {
        submissionVoteButton.classList.remove("voted");
      }
      submissionVoteCountElement.textContent = voteCountForSubmissions;
    },
  };
</script>

<script>
  const handleVotesForSubmission = {
    async createVoteForSubmission() {
      hasVotedForSubmission = true;
      voteCountForSubmissions += 1;
      UI.updateSubmissionVoteButton();

      try {
        const result = await SubmissionService.createVoteForSubmission(
          authorID,
          submissionID
        );
        submissionVoters.push({
          voteID: result.createOVoterVotedSubmission.voted_submission_id,
          voterID: result.createOVoterVotedSubmission.voter_id,
        });
      } catch (error) {
        hasVotedForSubmission = false;
        voteCountForSubmissions -= 1;
        UI.updateSubmissionVoteButton();
      }
    },
    async deleteVoteForSubmission() {
      const voteToDelete = submissionVoters.find(
        (voter) => voter.voterID === parseInt(authorID)
      );
      if (!voteToDelete) {
        return;
      }

      hasVotedForSubmission = false;
      voteCountForSubmissions -= 1;
      UI.updateSubmissionVoteButton();

      try {
        await SubmissionService.deleteVoteForSubmission(voteToDelete.voteID);
        // Corrected variable name here:
        submissionVoters = submissionVoters.filter(
          (voter) => voter.voteID !== voteToDelete.voteID
        );
      } catch (error) {
        hasVotedForSubmission = true;
        voteCountForSubmissions += 1;
        UI.updateSubmissionVoteButton();
      }
    },
  };

  submissionVoteButton.addEventListener("click", () => {
    if (hasVotedForSubmission) {
      handleVotesForSubmission.deleteVoteForSubmission();
    } else {
      handleVotesForSubmission.createVoteForSubmission();
    }
  });

  const handleVotesForComments = {
    async fetchVotersForComments(commentID) {
      try {
        const data = await API.fetchGraphQL(FETCH_COMMENTS_VOTERS_QUERY, {
          id: commentID,
        });
        const voters = data.calcForumComments || [];
        return voters
          .filter(
            (voter) =>
              voter.Member_Comment_Upvotes_Contact_ID !== null &&
              voter.Member_Comment_Upvotes_DataID !== null
          )
          .map((voter) => ({
            voterID: voter.Member_Comment_Upvotes_Contact_ID,
            voteID: voter.Member_Comment_Upvotes_DataID,
          }));
      } catch (error) {
        return [];
      }
    },
    async createVoteForComment(commentID) {
      const voteButton = document.querySelector(
        `[data-commentvoteid="${commentID}"]`
      );
      const voteCountElement = document.querySelector(
        `[data-commentvotecountelement="${commentID}"]`
      );
      const currentVotes = parseInt(voteCountElement.textContent, 10) || 0;
      voteButton.classList.add("voted");
      voteCountElement.textContent = currentVotes + 1;

      try {
        const result = await API.fetchGraphQL(
          CREATE_VOTE_ON_COMMENT_MUTATION_QUERY,
          {
            payload: {
              member_comment_upvote_id: authorID,
              forum_comment_upvote_id: commentID,
            },
          }
        );
      } catch (error) {
        voteButton.classList.remove("voted");
        voteCountElement.textContent = currentVotes;
      }
    },
    async deleteVoteForComment(commentID) {
      const voteButton = document.querySelector(
        `[data-commentvoteid="${commentID}"]`
      );
      const voteCountElement = document.querySelector(
        `[data-commentvotecountelement="${commentID}"]`
      );
      const currentVotes = parseInt(voteCountElement.textContent, 10) || 0;
      voteButton.classList.remove("voted");
      voteCountElement.textContent = Math.max(currentVotes - 1, 0);
      try {
        const voters = await this.fetchVotersForComments(commentID);
        const voteToDelete = voters.find(
          (voter) => voter.voterID === parseInt(authorID)
        );
        if (!voteToDelete) {
          throw new Error("No vote found to delete.");
        }
        await API.fetchGraphQL(DELETE_VOTE_ON_COMMENT_MUTATION_QUERY, {
          id: voteToDelete.voteID,
        });
      } catch (error) {
        voteButton.classList.add("voted");
        voteCountElement.textContent = currentVotes;
      }
    },
  };

  const handleComments = {
    async createComment() {
      const tempId = Date.now();
      // Target the main comment editor explicitly (avoid picking a reply editor)
      const commentContentEl =
        document.getElementById("tributeEditor") ||
        document.querySelector("#submissionComment .mentionable") ||
        document.querySelector(".mentionable");
      const textContent = commentContentEl.innerText.trim();

      // Validate non-empty input using innerText
      if (!textContent) {
        return;
      }

      let fileData = "";
      let commentFileName = "";
      const fileInput = document.getElementById("attachment-file-input");
      const file = fileInput.files[0];
      commentForm.style.opacity = "50%";
      commentForm.style.pointerEvents = "none";

      // Use innerHTML as the comment payload to preserve mention markup
      const newComment = {
        tempId,
        Comment: commentContentEl.innerHTML,
        Author_First_Name: firstName,
        Author_Last_Name: lastName,
        Author_Display_Name: displayName,
        Author_Profile_Image: authorProfileImage,
        Author_ID: Number(authorID) || authorID,
        Date_Added: "Just Now",
        Reply_to_Comment_ID: null,
      };
      comments = [newComment, ...comments];
      UI.updateComments(comments);
      // Re-attach Tribute/@mention editors for any reply forms after re-render
      try {
        reInitMentionEditors(commentsContainer);
        setTimeout(() => reInitMentionEditors(commentsContainer), 50);
        setTimeout(() => reInitMentionEditors(commentsContainer), 200);
      } catch (_) {}
      try {
        if (file) {
          const fileFields = [{ fieldName: "attachment", file: file }];
          const toSubmitFields = {};
          try {
            await processFileFields(
              toSubmitFields,
              fileFields,
              awsParam,
              awsParamUrl
            );
            fileData = toSubmitFields.attachment || "";
            if (file && file.name) commentFileName = file.name;
          } catch (err) {
            return;
          }
        }

        const mentionsFromDom = gatherMentionsFromElement(commentContentEl);
        const result = await SubmissionService.createComment(
          authorID,
          submissionID,
          commentContentEl.innerHTML, // send HTML payload
          mentionsFromDom,
          fileData,
          commentFileName
        );
        if (result && result.createForumComment) {
          const serverComment = {
            ID: result.createForumComment.id,
            Comment: result.createForumComment.comment,
            Author_First_Name: firstName,
            Author_Last_Name: lastName,
            Author_Display_Name: displayName,
            Author_Profile_Image: authorProfileImage,
            Author_ID: Number(authorID) || authorID,
            Date_Added: "Just Now",
            Reply_to_Comment_ID:
              result.createForumComment.reply_to_comment_id || null,
          };

          const normalizedFile =
            normalizeForumFile(
              result.createForumComment.file,
              result.createForumComment.comment_file_name || commentFileName
            ) || normalizeForumFile(fileData, commentFileName);
          if (normalizedFile) {
            serverComment.File = normalizedFile;
            serverComment.Comment_File_Name = normalizedFile.name;
          }

          comments = comments.map((comment) =>
            comment.tempId === newComment.tempId ? serverComment : comment
          );
          UI.updateComments(comments);
          // Re-attach again after server-synced render
          try {
            reInitMentionEditors(commentsContainer);
            setTimeout(() => reInitMentionEditors(commentsContainer), 50);
            setTimeout(() => reInitMentionEditors(commentsContainer), 200);
          } catch (_) {}

          // Create alerts for submission comment on newFileSubmission page
          (async () => {
            try {
              const created = result?.createForumComment;
              if (!created || !created.id) return;
              const endpoint =
                API.endpoint ||
                window.graphqlApiEndpoint ||
                window.GRAPHQL_ENDPOINT;
              const apiKey =
                API.apiKey || window.apiAccessKey || window.API_KEY;
              if (!endpoint || !apiKey) return;

              // Alert content
              const tmp = document.createElement("div");
              tmp.innerHTML = String(created.comment || "");
              const contentText = (tmp.textContent || "").trim();
              const createdAt = new Date().toISOString();

              // Resolve class id (from page or via eid)
              let clsId = Number(classId || 0) || null;
              if (!clsId) {
                const params = new URL(window.location.href).searchParams;
                const eidFromUrl = Number(params.get("eid") || 0) || null;
                if (eidFromUrl) {
                  try {
                    const q = `query eidToClass($id: AwcEnrolmentID) { calcEnrolments(query: [{ where: { id: $id } }]) { Class_ID: field(arg: ["class_id"]) } }`;
                    const rs = await fetch(endpoint, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "Api-Key": apiKey,
                      },
                      body: JSON.stringify({
                        query: q,
                        variables: { id: eidFromUrl },
                      }),
                    }).then((r) => (r.ok ? r.json() : null));
                    clsId =
                      Number(rs?.data?.calcEnrolments?.[0]?.Class_ID || 0) ||
                      null;
                  } catch (_) {}
                }
              }
              if (!clsId) return;

              // Fetch roster + class metadata
              const qTeacher = `query teacherByClass($id: AwcClassID) { calcClasses(query: [{ where: { id: $id } }]) { Teacher_Contact_ID: field(arg: [\"Teacher\",\"id\"]) } }`;
              const qClasses = `query getClass($id: AwcClassID) { getClasses(query: [{ where: { id: $id } }]) { id unique_id class_name Course { unique_id } Enrolments { Student { id } } } }`;
              const qEnrol = `query enrolStudents($id: AwcClassID) { calcEnrolments(query: [{ where: { class_id: $id } }]) { Student_ID: field(arg: [\"Student\",\"id\"]) } }`;
              const [resTeacher, resClasses, resEnrol] = await Promise.all([
                fetch(endpoint, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "Api-Key": apiKey,
                  },
                  body: JSON.stringify({
                    query: qTeacher,
                    variables: { id: clsId },
                  }),
                }).then((r) => (r.ok ? r.json() : null)),
                fetch(endpoint, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "Api-Key": apiKey,
                  },
                  body: JSON.stringify({
                    query: qClasses,
                    variables: { id: clsId },
                  }),
                }).then((r) => (r.ok ? r.json() : null)),
                fetch(endpoint, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "Api-Key": apiKey,
                  },
                  body: JSON.stringify({
                    query: qEnrol,
                    variables: { id: clsId },
                  }),
                }).then((r) => (r.ok ? r.json() : null)),
              ]);
              const norm = (list) =>
                (Array.isArray(list) ? list : [list])
                  .map((v) => Number(v))
                  .filter((n) => Number.isFinite(n) && n > 0);
              let teacherIds = [];
              const tRaw =
                resTeacher?.data?.calcClasses?.[0]?.Teacher_Contact_ID;
              if (tRaw != null) teacherIds = norm(tRaw);
              const classes = Array.isArray(resClasses?.data?.getClasses)
                ? resClasses.data.getClasses
                : [];
              let classUid, className, courseUid;
              const idsFromClasses = classes.flatMap((c) => {
                if (!classUid && c?.unique_id) classUid = c.unique_id;
                if (!className && c?.class_name) className = c.class_name;
                if (!courseUid && c?.Course?.unique_id)
                  courseUid = c.Course.unique_id;
                return (Array.isArray(c?.Enrolments) ? c.Enrolments : [])
                  .map((e) => e?.Student?.id)
                  .filter(Boolean);
              });
              const enrolRows = Array.isArray(resEnrol?.data?.calcEnrolments)
                ? resEnrol.data.calcEnrolments
                : [];
              const idsFromEnrol = enrolRows.flatMap((row) =>
                norm(row?.Student_ID)
              );
              const adminIds = [10435];

              const author = Number(authorID || 0);
              const seen = new Set();
              const audience = norm([
                ...idsFromClasses,
                ...idsFromEnrol,
                ...teacherIds,
                ...adminIds,
              ])
                .filter((id) => (seen.has(id) ? false : (seen.add(id), true)))
                .filter((id) => id !== author);
              if (!audience.length) return;

              // Mentions: convert unique_id -> contact id (use server-returned Mentions first)
              let mentionUIDs = [];
              try {
                if (Array.isArray(created?.Mentions)) {
                  mentionUIDs = created.Mentions.map((m) =>
                    String(m.unique_id)
                  ).filter(Boolean);
                }
              } catch (_) {}
              if (!mentionUIDs.length) {
                try {
                  mentionUIDs = gatherMentionsFromElement(commentContentEl)
                    .map(String)
                    .filter(Boolean);
                } catch (_) {}
              }
              let mentionContactIds = [];
              if (mentionUIDs.length) {
                try {
                  const perUidFetch = async (uid) => {
                    const q = `query getContactByUid($uid: StringScalar_0_8) { getContact(query: [{ where: { unique_id: $uid } }]) { id } }`;
                    const rs = await fetch(endpoint, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "Api-Key": apiKey,
                      },
                      body: JSON.stringify({ query: q, variables: { uid } }),
                    }).then((r) => (r.ok ? r.json() : null));
                    const id = Number(rs?.data?.getContact?.id || 0);
                    return Number.isFinite(id) && id > 0 ? id : null;
                  };
                  const resolved = await Promise.all(
                    mentionUIDs.map(perUidFetch)
                  );
                  mentionContactIds = resolved.filter((n) =>
                    Number.isFinite(n)
                  );
                } catch (_) {}
              }
              const mentionSet = new Set(mentionContactIds);

              // Resolve per-student eid for canonical URL
              async function resolveStudentEid(studentId, classIdLocal) {
                try {
                  const cache = (window.__awcEidCache ||= new Map());
                  const k = String(classIdLocal);
                  let byClass = cache.get(k);
                  if (!byClass) {
                    byClass = new Map();
                    cache.set(k, byClass);
                  }
                  if (byClass.has(Number(studentId)))
                    return byClass.get(Number(studentId));
                  const q = `query getEnrolment($id: AwcContactID, $class_id: AwcClassID) { getEnrolment(query: [{ where: { student_id: $id } }, { andWhere: { class_id: $class_id } }]) { ID: id } }`;
                  const rs = await fetch(endpoint, {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      "Api-Key": apiKey,
                    },
                    body: JSON.stringify({
                      query: q,
                      variables: {
                        id: Number(studentId),
                        class_id: Number(classIdLocal),
                      },
                    }),
                  }).then((r) => (r.ok ? r.json() : null));
                  const eid = Number(rs?.data?.getEnrolment?.ID || 0);
                  if (Number.isFinite(eid) && eid > 0) {
                    byClass.set(Number(studentId), eid);
                    return eid;
                  }
                } catch (_) {}
                return undefined;
              }

              function buildSubmissionAlertUrl(role, p) {
                const BASE = "https://courses.writerscentre.com.au";
                const r = String(role || "").toLowerCase();
                const lessonUid = String(p.lessonUid || "");
                const base = `${BASE}/course-details/content/${encodeURIComponent(
                  lessonUid
                )}`;
                const qs = new URLSearchParams();
                const idForSubmission = p.isComment
                  ? p.commentId || ""
                  : p.submissionId || p.commentId || "";
                if (r === "students" || r === "student") {
                  if (p.eid != null) qs.set("eid", String(p.eid));
                }
                if (p.classId != null)
                  qs.set("classIdFromUrl", String(p.classId));
                if (p.className) qs.set("className", String(p.className));
                if (p.classUid) qs.set("classUid", String(p.classUid));
                if (p.classId != null)
                  qs.set("currentClassID", String(p.classId));
                if (p.className)
                  qs.set("currentClassName", String(p.className));
                if (r === "students" || r === "student") {
                  if (p.classUid)
                    qs.set("currentClassUniqueID", String(p.classUid));
                }
                qs.set("submissionPostIs", String(idForSubmission || ""));
                qs.set("subUID", String(p.subUID));
                qs.set("commentScrollId", String(p.commentScrollID));
                if (p.notType) qs.set("notType", String(p.notType));
                return `${base}?${qs.toString()}`;
              }

              // Resolve parent submission unique_id for subUID
              let parentSubUID = window.subUIDFromPage || "";
              if (!parentSubUID) {
                try {
                  const qSubUid = `query getSubmissionUID($id: AwcSubmissionID) { getSubmission(query: [{ where: { id: $id } }]) { unique_id } }`;
                  const rsSub = await fetch(endpoint, {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      "Api-Key": apiKey,
                    },
                    body: JSON.stringify({
                      query: qSubUid,
                      variables: { id: Number(submissionID) },
                    }),
                  }).then((r) => (r.ok ? r.json() : null));
                  parentSubUID = String(
                    rsSub?.data?.getSubmission?.unique_id || ""
                  );
                } catch (_) {}
              }

              // Build payloads
              const alerts = [];
              for (const contactId of audience) {
                const isMentioned = mentionSet.has(Number(contactId));
                const isTeacher = teacherIds.includes(Number(contactId));
                const isAdmin = adminIds.includes(Number(contactId));
                const role = isAdmin
                  ? "admin"
                  : isTeacher
                  ? "teacher"
                  : "students";
                let eId;
                if (role === "students")
                  eId = await resolveStudentEid(contactId, clsId);
                const params = {
                  classId: Number(clsId),
                  classUid,
                  className,
                  courseUid,
                  eid: eId,
                  submissionId: Number(submissionID),
                  commentId: Number(created.id),
                  isComment: true,
                  lessonUid: window.lessonUIDFromPage || window.lessonUid || "",
                  assessmentType:
                    window.assessmentTypeFromPage ||
                    window.assessmentType ||
                    "",
                  subUID: parentSubUID,
                  commentScrollID: Number(created.id),
                  notType: "Submission Comments",
                };
                try {
                  console.log(
                    "[newFileSubmission Alerts] computed subUID",
                    parentSubUID
                  );
                } catch (_) {}
                const originCanonical =
                  window.AWC && typeof window.AWC.buildAlertUrl === "function"
                    ? window.AWC.buildAlertUrl(role, "submission", params)
                    : buildSubmissionAlertUrl(role, params);
                const teacherCanonical =
                  window.AWC && typeof window.AWC.buildAlertUrl === "function"
                    ? window.AWC.buildAlertUrl("teacher", "submission", params)
                    : buildSubmissionAlertUrl("teacher", params);
                const adminCanonical =
                  window.AWC && typeof window.AWC.buildAlertUrl === "function"
                    ? window.AWC.buildAlertUrl("admin", "submission", params)
                    : buildSubmissionAlertUrl("admin", params);
                const alertType = isMentioned
                  ? "Submission Comment Mention"
                  : "Submission Comment";
                let title;
                try {
                  // Personalize comments: submission owner gets direct title
                  let submissionOwnerId;
                  try {
                    const qOwner = `query getSubmissionOwner($id: AwcSubmissionID) { getSubmission(query: [{ where: { id: $id } }]) { Student { Student { id } } } }`;
                    const rsOwner = await fetch(endpoint, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "Api-Key": apiKey,
                      },
                      body: JSON.stringify({
                        query: qOwner,
                        variables: { id: Number(submissionID) },
                      }),
                    }).then((r) => (r.ok ? r.json() : null));
                    submissionOwnerId =
                      Number(
                        rsOwner?.data?.getSubmission?.Student?.Student?.id || 0
                      ) || undefined;
                  } catch (_) {}
                  const actorName =
                    displayName ||
                    `${firstName || ""} ${lastName || ""}`.trim() ||
                    "Someone";
                  if (isMentioned) {
                    title = `You have been mentioned in the comment`;
                  } else if (
                    submissionOwnerId &&
                    Number(contactId) === Number(submissionOwnerId)
                  ) {
                    title = `${actorName} commented on your submission`;
                  } else {
                    title = "A comment has been added to the submission";
                  }
                } catch (_) {
                  title = "A comment has been added to the submission";
                }
                try {
                  console.log("[newFileSubmission Alerts] recipient", {
                    contactId,
                    isMentioned,
                    title,
                    alertType,
                  });
                } catch (_) {}
                alerts.push({
                  alert_type: alertType,
                  title,
                  content: contentText,
                  created_at: createdAt,
                  is_mentioned: !!isMentioned,
                  is_read: false,
                  notified_contact_id: Number(contactId),
                  origin_url: originCanonical,
                  origin_url_teacher: teacherCanonical,
                  origin_url_admin: adminCanonical,
                  parent_class_id: Number(clsId),
                  parent_submission_id: Number(submissionID),
                  parent_comment_id: Number(created.id),
                });
                try {
                  console.log("[newFileSubmission Alerts] URL", {
                    contactId,
                    role,
                    eid: eId,
                    url: originCanonical,
                  });
                } catch (_) {}
              }

              if (alerts.length) {
                if (
                  window.AWC &&
                  typeof window.AWC.createAlerts === "function"
                ) {
                  try {
                    await window.AWC.createAlerts(alerts, { concurrency: 4 });
                  } catch (e) {
                    console.error(
                      "Failed to create alerts (newFileSubmission comment)",
                      e
                    );
                  }
                } else {
                  try {
                    const createAlertsMutation = `mutation createAlerts($payload: [AlertCreateInput] = null) { createAlerts(payload: $payload) { is_mentioned } }`;
                    await fetch(endpoint, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "Api-Key": apiKey,
                      },
                      body: JSON.stringify({
                        query: createAlertsMutation,
                        variables: { payload: alerts },
                      }),
                    });
                  } catch (e) {
                    console.error(
                      "createAlerts GraphQL failed (newFileSubmission comment)",
                      e
                    );
                  }
                }
              }

              if (mentionContactIds.length) {
                const updateMutation = `mutation updateContact($id: AwcContactID!, $payload: ContactUpdateInput!) { updateContact(query: [{ where: { id: $id } }], payload: $payload) { has__new__notification } }`;
                for (const mid of mentionContactIds) {
                  try {
                    await fetch(endpoint, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "Api-Key": apiKey,
                      },
                      body: JSON.stringify({
                        query: updateMutation,
                        variables: {
                          id: Number(mid),
                          payload: { has__new__notification: true },
                        },
                      }),
                    });
                  } catch (_) {}
                }
              }
            } catch (e) {
              console.error("newFileSubmission comment alert error", e);
            }
          })();
        }
      } catch (error) {
        comments = comments.filter(
          (comment) => comment.tempId !== newComment.tempId
        );
        UI.updateComments(comments);
      } finally {
        commentForm.style.opacity = "100%";
        commentForm.style.pointerEvents = "";
        // Hide any visible preview
        if (filePreview) filePreview.classList.add("hidden");
        // Clear the contenteditable div manually instead of form.reset()
        commentContentEl.innerHTML = "";

        // Also clear the file input if needed
        if (fileInput) fileInput.value = "";
        // Reset attachment UI controls back to initial state
        if (typeof resetSubmissionAttachmentUI === "function") {
          resetSubmissionAttachmentUI();
        } else {
          // Fallback inline reset if helper is not yet defined
          try {
            const attachBtn = document.querySelector(".attachBtn");
            const refreshBtn = document.querySelector(".refreshBtn");
            const deleteBtn = document.querySelector(".deleteBtn");
            const previewEl =
              document.querySelector(".filePreviewWrapper") || filePreview;
            if (previewEl) {
              previewEl.textContent = "";
              previewEl.classList.add("hidden");
            }
            if (refreshBtn) refreshBtn.classList.add("hidden");
            if (deleteBtn) deleteBtn.classList.add("hidden");
            if (attachBtn) attachBtn.classList.remove("hidden");
          } catch (_) {}
        }
      }
    },

    async deleteComment(commentId) {
      try {
        const commentElement = document.querySelector(
          `[data-commentid="${commentId}"]`
        );
        if (!commentElement) {
          return;
        }
        commentElement.style.opacity = "0.5";
        await SubmissionService.deleteComment(commentId);
        commentElement.remove();
        comments = comments.filter(
          (comment) => String(comment.ID) !== String(commentId)
        );
      } catch (error) {
        const commentElement = document.querySelector(
          `[data-commentid="${commentId}"]`
        );
        if (commentElement) {
          commentElement.style.opacity = "1";
        }
      }
    },

    async createReply(replyToCommentId, replyContentHTML, replyMentions = []) {
      const tempId = Date.now();
      if (!replyContentHTML.trim()) {
        return;
      }
      const newReply = {
        tempId,
        Comment: replyContentHTML,
        Author_First_Name: firstName,
        Author_Last_Name: lastName,
        Author_Display_Name: displayName,
        Author_Profile_Image: authorProfileImage,
        Author_ID: Number(authorID) || authorID,
        Date_Added: "Just Now",
        Reply_to_Comment_ID: replyToCommentId,
      };
      const replyKey = String(replyToCommentId);
      if (!replies[replyKey]) {
        replies[replyKey] = [];
      }
      replies[replyKey].push(newReply);
      UI.updateReplies(replyToCommentId, replies[replyKey]);

      try {
        const result = await CommentsService.createCommentOnReply(
          replyToCommentId,
          replyContentHTML,
          replyMentions
        );
        if (result && result.createForumComment) {
          const serverReply = {
            ID: result.createForumComment.id,
            Comment: result.createForumComment.comment,
            Author_First_Name: firstName,
            Author_Last_Name: lastName,
            Author_Display_Name: displayName,
            Author_Profile_Image: authorProfileImage,
            Author_ID: Number(authorID) || authorID,
            Reply_to_Comment_ID: result.createForumComment.reply_to_comment_id,
            Date_Added: "Just Now",
          };
          replies[replyKey] = replies[replyKey].map((reply) =>
            reply.tempId === newReply.tempId ? serverReply : reply
          );
          UI.updateReplies(replyToCommentId, replies[replyKey]);
          // Create alerts for submission reply on newFileSubmission page
          (async () => {
            try {
              const created = result?.createForumComment;
              if (!created || !created.id) return;
              const endpoint =
                API.endpoint ||
                window.graphqlApiEndpoint ||
                window.GRAPHQL_ENDPOINT;
              const apiKey =
                API.apiKey || window.apiAccessKey || window.API_KEY;
              if (!endpoint || !apiKey) return;

              // Alert content
              const tmp = document.createElement("div");
              tmp.innerHTML = String(created.comment || "");
              const contentText = (tmp.textContent || "").trim();
              const createdAt = new Date().toISOString();

              // Resolve class id (from page or via eid)
              let clsId = Number(classId || 0) || null;
              if (!clsId) {
                const params = new URL(window.location.href).searchParams;
                const eidFromUrl = Number(params.get("eid") || 0) || null;
                if (eidFromUrl) {
                  try {
                    const q = `query eidToClass($id: AwcEnrolmentID) { calcEnrolments(query: [{ where: { id: $id } }]) { Class_ID: field(arg: ["class_id"]) } }`;
                    const rs = await fetch(endpoint, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "Api-Key": apiKey,
                      },
                      body: JSON.stringify({
                        query: q,
                        variables: { id: eidFromUrl },
                      }),
                    }).then((r) => (r.ok ? r.json() : null));
                    clsId =
                      Number(rs?.data?.calcEnrolments?.[0]?.Class_ID || 0) ||
                      null;
                  } catch (_) {}
                }
              }
              if (!clsId) return;

              // Mentions: convert unique_id -> contact id (use server-returned Mentions first)
              let mentionUIDs = [];
              try {
                if (Array.isArray(created?.Mentions)) {
                  mentionUIDs = created.Mentions.map((m) =>
                    String(m.unique_id)
                  ).filter(Boolean);
                }
              } catch (_) {}
              if (!mentionUIDs.length && Array.isArray(replyMentions)) {
                mentionUIDs = replyMentions.map(String).filter(Boolean);
              }
              let mentionContactIds = [];
              if (mentionUIDs.length) {
                try {
                  const perUidFetch = async (uid) => {
                    const q = `query getContactByUid($uid: StringScalar_0_8) { getContact(query: [{ where: { unique_id: $uid } }]) { id } }`;
                    const rs = await fetch(endpoint, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "Api-Key": apiKey,
                      },
                      body: JSON.stringify({ query: q, variables: { uid } }),
                    }).then((r) => (r.ok ? r.json() : null));
                    const id = Number(rs?.data?.getContact?.id || 0);
                    return Number.isFinite(id) && id > 0 ? id : null;
                  };
                  const resolved = await Promise.all(
                    mentionUIDs.map(perUidFetch)
                  );
                  mentionContactIds = resolved.filter((n) =>
                    Number.isFinite(n)
                  );
                } catch (_) {}
              }
              const mentionSet = new Set(mentionContactIds);

              // Resolve per-student eid for canonical URL
              async function resolveStudentEid(studentId, classIdLocal) {
                try {
                  const cache = (window.__awcEidCache ||= new Map());
                  const k = String(classIdLocal);
                  let byClass = cache.get(k);
                  if (!byClass) {
                    byClass = new Map();
                    cache.set(k, byClass);
                  }
                  if (byClass.has(Number(studentId)))
                    return byClass.get(Number(studentId));
                  const q = `query getEnrolment($id: AwcContactID, $class_id: AwcClassID) { getEnrolment(query: [{ where: { student_id: $id } }, { andWhere: { class_id: $class_id } }]) { ID: id } }`;
                  const rs = await fetch(endpoint, {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      "Api-Key": apiKey,
                    },
                    body: JSON.stringify({
                      query: q,
                      variables: {
                        id: Number(studentId),
                        class_id: Number(classIdLocal),
                      },
                    }),
                  }).then((r) => (r.ok ? r.json() : null));
                  const eid = Number(rs?.data?.getEnrolment?.ID || 0);
                  if (Number.isFinite(eid) && eid > 0) {
                    byClass.set(Number(studentId), eid);
                    return eid;
                  }
                } catch (_) {}
                return undefined;
              }

              function buildSubmissionAlertUrl(role, p) {
                const BASE = "https://courses.writerscentre.com.au";
                const r = String(role || "").toLowerCase();
                const lessonUid = String(p.lessonUid || "");
                const base = `${BASE}/course-details/content/${encodeURIComponent(
                  lessonUid
                )}`;
                const qs = new URLSearchParams();
                const idForSubmission = p.isComment
                  ? p.commentId || ""
                  : p.submissionId || p.commentId || "";
                if (r === "students" || r === "student") {
                  if (p.eid != null) qs.set("eid", String(p.eid));
                }
                if (p.classId != null)
                  qs.set("classIdFromUrl", String(p.classId));
                if (p.className) qs.set("className", String(p.className));
                if (p.classUid) qs.set("classUid", String(p.classUid));
                if (p.classId != null)
                  qs.set("currentClassID", String(p.classId));
                if (p.className)
                  qs.set("currentClassName", String(p.className));
                if (r === "students" || r === "student") {
                  if (p.classUid)
                    qs.set("currentClassUniqueID", String(p.classUid));
                }
                qs.set("submissionPostIs", String(idForSubmission || ""));
                qs.set("subUID", String(p.subUID));
                qs.set("commentScrollId", String(p.commentScrollID));
                if (p.notType) qs.set("notType", String(p.notType));
                return `${base}?${qs.toString()}`;
              }

              // Resolve parent submission unique_id for subUID
              let parentSubUID = window.subUIDFromPage || "";
              if (!parentSubUID) {
                try {
                  const qSubUid = `query getSubmissionUID($id: AwcSubmissionID) { getSubmission(query: [{ where: { id: $id } }]) { unique_id } }`;
                  const rsSub = await fetch(endpoint, {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      "Api-Key": apiKey,
                    },
                    body: JSON.stringify({
                      query: qSubUid,
                      variables: { id: Number(submissionID) },
                    }),
                  }).then((r) => (r.ok ? r.json() : null));
                  parentSubUID = String(
                    rsSub?.data?.getSubmission?.unique_id || ""
                  );
                } catch (_) {}
              }

              // Build payloads
              const alerts = [];
              // Fetch roster + class metadata for role resolution
              const qTeacher = `query teacherByClass($id: AwcClassID) { calcClasses(query: [{ where: { id: $id } }]) { Teacher_Contact_ID: field(arg: [\"Teacher\",\"id\"]) } }`;
              const qClasses = `query getClass($id: AwcClassID) { getClasses(query: [{ where: { id: $id } }]) { id unique_id class_name Course { unique_id } Enrolments { Student { id } } } }`;
              const qEnrol = `query enrolStudents($id: AwcClassID) { calcEnrolments(query: [{ where: { class_id: $id } }]) { Student_ID: field(arg: [\"Student\",\"id\"]) } }`;
              const [resTeacher, resClasses, resEnrol] = await Promise.all([
                fetch(endpoint, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "Api-Key": apiKey,
                  },
                  body: JSON.stringify({
                    query: qTeacher,
                    variables: { id: clsId },
                  }),
                }).then((r) => (r.ok ? r.json() : null)),
                fetch(endpoint, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "Api-Key": apiKey,
                  },
                  body: JSON.stringify({
                    query: qClasses,
                    variables: { id: clsId },
                  }),
                }).then((r) => (r.ok ? r.json() : null)),
                fetch(endpoint, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "Api-Key": apiKey,
                  },
                  body: JSON.stringify({
                    query: qEnrol,
                    variables: { id: clsId },
                  }),
                }).then((r) => (r.ok ? r.json() : null)),
              ]);
              const norm = (list) =>
                (Array.isArray(list) ? list : [list])
                  .map((v) => Number(v))
                  .filter((n) => Number.isFinite(n) && n > 0);
              let teacherIds = [];
              const tRaw =
                resTeacher?.data?.calcClasses?.[0]?.Teacher_Contact_ID;
              if (tRaw != null) teacherIds = norm(tRaw);
              const classes = Array.isArray(resClasses?.data?.getClasses)
                ? resClasses.data.getClasses
                : [];
              let classUid, className, courseUid;
              const idsFromClasses = classes.flatMap((c) => {
                if (!classUid && c?.unique_id) classUid = c.unique_id;
                if (!className && c?.class_name) className = c.class_name;
                if (!courseUid && c?.Course?.unique_id)
                  courseUid = c.Course.unique_id;
                return (Array.isArray(c?.Enrolments) ? c.Enrolments : [])
                  .map((e) => e?.Student?.id)
                  .filter(Boolean);
              });
              const enrolRows = Array.isArray(resEnrol?.data?.calcEnrolments)
                ? resEnrol.data.calcEnrolments
                : [];
              const idsFromEnrol = enrolRows.flatMap((row) =>
                norm(row?.Student_ID)
              );
              const adminIds = [10435];

              const author = Number(authorID || 0);
              const seen = new Set();
              const audience = norm([
                ...idsFromClasses,
                ...idsFromEnrol,
                ...teacherIds,
                ...adminIds,
              ])
                .filter((id) => (seen.has(id) ? false : (seen.add(id), true)))
                .filter((id) => id !== author);

              for (const contactId of audience) {
                const isMentioned = mentionSet.has(Number(contactId));
                const isTeacher = teacherIds.includes(Number(contactId));
                const isAdmin = adminIds.includes(Number(contactId));
                const role = isAdmin
                  ? "admin"
                  : isTeacher
                  ? "teacher"
                  : "students";
                let eId;
                if (role === "students")
                  eId = await resolveStudentEid(contactId, clsId);
                const params = {
                  classId: Number(clsId),
                  classUid,
                  className,
                  courseUid,
                  eid: eId,
                  submissionId: Number(submissionID),
                  commentId: Number(created.id),
                  isComment: true,
                  lessonUid: window.lessonUIDFromPage || window.lessonUid || "",
                  assessmentType:
                    window.assessmentTypeFromPage ||
                    window.assessmentType ||
                    "",
                  subUID: parentSubUID,
                  commentScrollID: Number(created.id),
                  notType: "Submission Comments",
                };
                const originCanonical =
                  window.AWC && typeof window.AWC.buildAlertUrl === "function"
                    ? window.AWC.buildAlertUrl(role, "submission", params)
                    : buildSubmissionAlertUrl(role, params);
                const teacherCanonical =
                  window.AWC && typeof window.AWC.buildAlertUrl === "function"
                    ? window.AWC.buildAlertUrl("teacher", "submission", params)
                    : buildSubmissionAlertUrl("teacher", params);
                const adminCanonical =
                  window.AWC && typeof window.AWC.buildAlertUrl === "function"
                    ? window.AWC.buildAlertUrl("admin", "submission", params)
                    : buildSubmissionAlertUrl("admin", params);
                const alertType = isMentioned
                  ? "Submission Comment Mention"
                  : "Submission Comment";
                const isReplyNow =
                  Number(created?.reply_to_comment_id || 0) > 0;
                let title;
                try {
                  // Personalize replies: notify parent comment's author
                  let parentCommentAuthorId;
                  try {
                    const parentLocal = (
                      Array.isArray(comments) ? comments : []
                    ).find(
                      (c) =>
                        Number(c?.ID) === Number(created?.reply_to_comment_id)
                    );
                    if (parentLocal && parentLocal.Author_ID != null) {
                      parentCommentAuthorId = Number(parentLocal.Author_ID);
                    }
                  } catch (_) {}
                  if (
                    !parentCommentAuthorId &&
                    Number(created?.reply_to_comment_id || 0) > 0
                  ) {
                    try {
                      const qParent = `query parentAuthor($id: AwcForumCommentID) { calcForumComments(query: [{ where: { id: $id } }]) { Author_ID: field(arg: [\"author_id\"]) } }`;
                      const rsParent = await fetch(endpoint, {
                        method: "POST",
                        headers: {
                          "Content-Type": "application/json",
                          "Api-Key": apiKey,
                        },
                        body: JSON.stringify({
                          query: qParent,
                          variables: {
                            id: Number(created.reply_to_comment_id),
                          },
                        }),
                      }).then((r) => (r.ok ? r.json() : null));
                      const row = Array.isArray(
                        rsParent?.data?.calcForumComments
                      )
                        ? rsParent.data.calcForumComments[0]
                        : null;
                      const aid = Number(row?.Author_ID || 0);
                      if (Number.isFinite(aid) && aid > 0)
                        parentCommentAuthorId = aid;
                    } catch (_) {}
                  }
                  const actorName =
                    displayName ||
                    `${firstName || ""} ${lastName || ""}`.trim() ||
                    "Someone";
                  if (isMentioned) {
                    title = `You have been mentioned in the reply`;
                  } else if (
                    Number(created?.reply_to_comment_id || 0) > 0 &&
                    parentCommentAuthorId &&
                    Number(contactId) === Number(parentCommentAuthorId)
                  ) {
                    title = `${actorName} replied on your comment`;
                  } else {
                    title = "A reply has been added to a comment";
                  }
                } catch (_) {
                  title = "A reply has been added to a comment";
                }
                alerts.push({
                  alert_type: alertType,
                  title,
                  content: contentText,
                  created_at: createdAt,
                  is_mentioned: !!isMentioned,
                  is_read: false,
                  notified_contact_id: Number(contactId),
                  origin_url: originCanonical,
                  origin_url_teacher: teacherCanonical,
                  origin_url_admin: adminCanonical,
                  parent_class_id: Number(clsId),
                  parent_submission_id: Number(submissionID),
                  parent_comment_id: Number(created.id),
                });
              }

              if (alerts.length) {
                if (
                  window.AWC &&
                  typeof window.AWC.createAlerts === "function"
                ) {
                  try {
                    await window.AWC.createAlerts(alerts, { concurrency: 4 });
                  } catch (e) {
                    console.error(
                      "Failed to create alerts (newFileSubmission comment)",
                      e
                    );
                  }
                } else {
                  try {
                    const createAlertsMutation = `mutation createAlerts($payload: [AlertCreateInput] = null) { createAlerts(payload: $payload) { is_mentioned } }`;
                    await fetch(endpoint, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "Api-Key": apiKey,
                      },
                      body: JSON.stringify({
                        query: createAlertsMutation,
                        variables: { payload: alerts },
                      }),
                    });
                  } catch (e) {
                    console.error(
                      "createAlerts GraphQL failed (newFileSubmission comment)",
                      e
                    );
                  }
                }
              }

              if (mentionContactIds.length) {
                const updateMutation = `mutation updateContact($id: AwcContactID!, $payload: ContactUpdateInput!) { updateContact(query: [{ where: { id: $id } }], payload: $payload) { has__new__notification } }`;
                for (const mid of mentionContactIds) {
                  try {
                    await fetch(endpoint, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        "Api-Key": apiKey,
                      },
                      body: JSON.stringify({
                        query: updateMutation,
                        variables: {
                          id: Number(mid),
                          payload: { has__new__notification: true },
                        },
                      }),
                    });
                  } catch (_) {}
                }
              }
            } catch (e) {
              console.error("newFileSubmission reply alert error", e);
            }
          })();
        }
      } catch (error) {
        replies[replyKey] = replies[replyKey].filter(
          (reply) => reply.tempId !== newReply.tempId
        );
        UI.updateReplies(replyToCommentId, replies[replyKey]);
      }
    },

    async deleteReply(replyId) {
      try {
        const replyElement = document.querySelector(
          `[data-replyid="${replyId}"]`
        );
        if (!replyElement) {
          return;
        }
        replyElement.style.opacity = "0.5";
        // Assuming the reply element has a data attribute for its parent comment:
        const parentCommentId = replyElement.getAttribute(
          "data-parentcommentid"
        );
        await SubmissionService.deleteReply(replyId);
        // Remove the reply element from the DOM
        replyElement.remove();
        // Also update the replies array for the parent comment
        if (parentCommentId) {
          const parentKey = String(parentCommentId);
          if (replies[parentKey]) {
            replies[parentKey] = replies[parentKey].filter(
              (reply) => reply.ID != replyId
            );
          }
          UI.updateReplies(parentCommentId, replies[parentKey] || []);
        }
      } catch (error) {
        const replyElement = document.querySelector(
          `[data-replyid="${replyId}"]`
        );
        if (replyElement) {
          replyElement.style.opacity = "1";
        }
      }
    },
  };

  commentForm.addEventListener("submit", (e) => {
    e.preventDefault();
    handleComments.createComment();
  });

  commentsContainer.addEventListener("submit", (e) => {
    const replyForm = e.target.closest("[data-replyform]");
    if (replyForm) {
      e.preventDefault();
      const replyToCommentId = replyForm.getAttribute("data-replyform");
      const replyContentField = replyForm.querySelector(
        `[data-reply-textarea="${replyToCommentId}"]`
      );
      if (!replyContentField) return;

      // Capture the HTML content (preserves mentions/markup)
      const replyContentHTML = replyContentField.innerHTML.trim();
      // Validate by also checking the text content if needed
      const replyContentText = replyContentField.innerText.trim();

      if (replyContentText) {
        const replyMentions = gatherMentionsFromElement(replyContentField);

        handleComments.createReply(
          replyToCommentId,
          replyContentHTML,
          replyMentions
        );
        // Clear the contenteditable field appropriately
        replyContentField.innerHTML = "";
        // Ensure the cleared editor keeps Tribute + placeholder
        try {
          initMentionableEditor(replyContentField);
        } catch (_) {}
      }
    }
  });

  commentsContainer.addEventListener("click", (e) => {
    if (e.target && e.target.classList.contains("deleteComment")) {
      const commentId = e.target
        .closest("[data-commentid]")
        .getAttribute("data-commentid");
      handleComments.deleteComment(commentId);
    }
  });

  commentsContainer.addEventListener("click", (e) => {
    if (e.target && e.target.classList.contains("deleteReply")) {
      const replyId = e.target
        .closest("[data-replyid]")
        .getAttribute("data-replyid");
      handleComments.deleteReply(replyId);
    }
  });

  commentsContainer.addEventListener("click", async (e) => {
    const voteButton = e.target.closest(".commentVoteButton");
    if (voteButton) {
      const commentID = voteButton.getAttribute("data-commentvoteid");
      const isVoted = voteButton.classList.contains("voted");

      if (isVoted) {
        await handleVotesForComments.deleteVoteForComment(commentID);
      } else {
        await handleVotesForComments.createVoteForComment(commentID);
      }
    }
  });
</script>

<script>
  document.addEventListener("DOMContentLoaded", async () => {
    try {
      const defaultImageUrl =
        "https://files.ontraport.com/media/b0456fe87439430680b173369cc54cea.php03bzcx?Expires=4895186056&Signature=fw-mkSjms67rj5eIsiDF9QfHb4EAe29jfz~yn3XT0--8jLdK4OGkxWBZR9YHSh26ZAp5EHj~6g5CUUncgjztHHKU9c9ymvZYfSbPO9JGht~ZJnr2Gwmp6vsvIpYvE1pEywTeoigeyClFm1dHrS7VakQk9uYac4Sw0suU4MpRGYQPFB6w3HUw-eO5TvaOLabtuSlgdyGRie6Ve0R7kzU76uXDvlhhWGMZ7alNCTdS7txSgUOT8oL9pJP832UsasK4~M~Na0ku1oY-8a7GcvvVv6j7yE0V0COB9OP0FbC8z7eSdZ8r7avFK~f9Wl0SEfS6MkPQR2YwWjr55bbJJhZnZA__&Key-Pair-Id=APKAJVAAMVW6XQYWSTNA";

      const fetchedComments = await SubmissionService.fetchComments(
        submissionID
      );
      comments = fetchedComments || [];
      replies = {};
      UI.updateComments(comments);
      // Mentions are handled by external NewMentionManager (if present on page).
      if (
        window.NewMentionManager &&
        typeof window.NewMentionManager.initContacts === "function"
      ) {
        try {
          window.NewMentionManager.initContacts();
        } catch (_) {}
      }
      // Initialize/reattach Tribute on all current editors
      try {
        reInitMentionEditors(document);
      } catch (_) {}

      for (const comment of comments) {
        const commentIdKey = String(comment.ID);
        let repliesForComment = [];
        try {
          const fetchedReplies = await CommentsService.fetchReplies(comment.ID);
          repliesForComment = Array.isArray(fetchedReplies)
            ? fetchedReplies
            : [];
        } catch (err) {
          repliesForComment = replies[commentIdKey] || [];
        }
        replies[commentIdKey] = repliesForComment;
        UI.updateReplies(comment.ID, repliesForComment);

        for (const reply of repliesForComment) {
          const replyVoters =
            (await handleVotesForComments.fetchVotersForComments(reply.ID)) ||
            [];
          const isReplyVoted = replyVoters.some(
            (voter) => voter.voterID === parseInt(authorID)
          );
          const replyVoteCount = replyVoters.length;
          const replyVoteButton = document.querySelector(
            `[data-commentvoteid="${reply.ID}"]`
          );
          const replyVoteCountElement = document.querySelector(
            `[data-commentvotecountelement="${reply.ID}"]`
          );
          if (replyVoteButton) {
            if (isReplyVoted) {
              replyVoteButton.classList.add("voted");
            } else {
              replyVoteButton.classList.remove("voted");
            }
          }
          if (replyVoteCountElement) {
            replyVoteCountElement.textContent = replyVoteCount;
          }
        }
      }

      for (const comment of comments) {
        const voters =
          (await handleVotesForComments.fetchVotersForComments(comment.ID)) ||
          [];
        const isVoted = voters.some(
          (voter) => voter.voterID === parseInt(authorID)
        );
        const voteCount = voters.length;

        const commentVoteButton = document.querySelector(
          `[data-commentvoteid="${comment.ID}"]`
        );
        const commentVoteCountElement = document.querySelector(
          `[data-commentvotecountelement="${comment.ID}"]`
        );

        if (commentVoteButton) {
          if (isVoted) {
            commentVoteButton.classList.add("voted");
          } else {
            commentVoteButton.classList.remove("voted");
          }
        }
        if (commentVoteCountElement) {
          commentVoteCountElement.textContent = voteCount;
        }
      }
      const fetchedVotersForSubmission =
        await SubmissionService.fetchVotersForSubmission(submissionID);
      submissionVoters = fetchedVotersForSubmission;
      hasVotedForSubmission = submissionVoters.some(
        (voter) => voter.voterID === parseInt(authorID)
      );
      voteCountForSubmissions = submissionVoters.length;
      UI.updateSubmissionVoteButton();
    } catch (error) {
      // Handle errors appropriately
    }
  });

  // Observe DOM changes under commentsContainer to auto-init new editors
  try {
    const observer = new MutationObserver((mutations) => {
      for (const m of mutations) {
        m.addedNodes.forEach((node) => {
          if (node && node.nodeType === 1) {
            if (node.classList && node.classList.contains("mentionable")) {
              try {
                initMentionableEditor(node);
              } catch (_) {}
            }
            node.querySelectorAll?.(".mentionable")?.forEach((inner) => {
              try {
                initMentionableEditor(inner);
              } catch (_) {}
            });
          }
        });
      }
    });
    if (commentsContainer) {
      observer.observe(commentsContainer, { childList: true, subtree: true });
    }
  } catch (_) {}

  // Safety net: lazily init Tribute on focus if needed
  try {
    document.addEventListener("focusin", (e) => {
      const el = e.target;
      if (el && el.classList && el.classList.contains("mentionable")) {
        if (!el.hasAttribute("data-tribute-attached")) {
          try {
            initMentionableEditor(el);
          } catch (_) {}
        }
      }
    });
    document.addEventListener(
      "keydown",
      (e) => {
        const el = e.target;
        if (!el || !el.classList || !el.classList.contains("mentionable"))
          return;
        if (el.hasAttribute("data-tribute-attached")) return;
        if (e.key === "@") {
          try {
            initMentionableEditor(el);
          } catch (_) {}
        }
      },
      true
    );
  } catch (_) {}

  // If user toggles a reply form open, ensure its editor is initialized
  commentsContainer.addEventListener("click", (e) => {
    const toggle = e.target.closest("[data-replyformtoggle]");
    if (!toggle) return;
    const commentId = toggle.getAttribute("data-replyformtoggle");
    const replyForm = document.querySelector(`[data-replyform="${commentId}"]`);
    if (replyForm) {
      // Defer slightly to allow any CSS class toggles/DOM changes
      setTimeout(() => {
        try {
          reInitMentionEditors(replyForm);
        } catch (_) {}
      }, 0);
    }
  });

  // Mentions editor is injected by NewMentionManager; no local focus handlers needed.

  document.addEventListener("DOMContentLoaded", () => {
    const fileInput = document.getElementById("attachment-file-input");
    const attachBtn = document.querySelector(".attachBtn");
    const refreshBtn = document.querySelector(".refreshBtn");
    const deleteBtn = document.querySelector(".deleteBtn");
    if (!filePreview) {
      filePreview = document.createElement("span");
      attachBtn.appendChild(filePreview);
    }

    fileInput.addEventListener("change", () => {
      if (fileInput.files && fileInput.files.length > 0) {
        filePreview.classList.remove("hidden");
        const file = fileInput.files[0];
        filePreview.textContent = file.name;
        attachBtn.classList.add("hidden");
        refreshBtn.classList.remove("hidden");
        deleteBtn.classList.remove("hidden");
      }
    });

    // Replace: simulate clicking the file input to repick a file.
    refreshBtn.addEventListener("click", () => {
      fileInput.click();
    });

    // Delete: clear the selected file and reset the UI.
    deleteBtn.addEventListener("click", () => {
      filePreview.classList.add("hidden");
      fileInput.value = "";
      filePreview.textContent = "";
      refreshBtn.classList.add("hidden");
      deleteBtn.classList.add("hidden");
      attachBtn.classList.remove("hidden");
    });
  });

  // Helper: reset the attachment UI back to initial state
  function resetSubmissionAttachmentUI() {
    try {
      const fileInput = document.getElementById("attachment-file-input");
      const attachBtn = document.querySelector(".attachBtn");
      const refreshBtn = document.querySelector(".refreshBtn");
      const deleteBtn = document.querySelector(".deleteBtn");
      const previewEl =
        document.querySelector(".filePreviewWrapper") || filePreview;
      if (fileInput) fileInput.value = "";
      if (previewEl) {
        previewEl.textContent = "";
        previewEl.classList.add("hidden");
      }
      if (refreshBtn) refreshBtn.classList.add("hidden");
      if (deleteBtn) deleteBtn.classList.add("hidden");
      if (attachBtn) attachBtn.classList.remove("hidden");
    } catch (_) {}
  }
</script>

<script>
  let isAdminVisitor = "[Visitor//Is Admin]";
  let isTeacherVisitor = "[Visitor//Is Instructor?]";
  console.log("isAdminVisitor", isAdminVisitor);
  console.log("isTeacherVisitor", isTeacherVisitor);

  // ========= NewMentionManager (clean, cached, self-initializing) =========
  class NewMentionManager {
    static allContacts = [];
    static _contactsPromise = null;
    static _contactsLoaded = false;

    // 1) Load contacts ONCE (cached)
    static initContacts() {
      if (NewMentionManager._contactsLoaded) {
        return NewMentionManager._contactsPromise || Promise.resolve();
      }
      if (NewMentionManager._contactsPromise) {
        return NewMentionManager._contactsPromise;
      }

      NewMentionManager._contactsPromise = (async () => {
        try {
          const norm = (v) =>
            String(v ?? "")
              .trim()
              .toLowerCase();
          const isPrivate = norm(isAssessmentPrivateToCheckMentions) === "yes";
          const isAdmin = norm(isAdminVisitor) === "yes";
          const isInstructor = norm(isTeacherVisitor) === "yes";
          const isStudent = !isAdmin && !isInstructor;

          // Who is allowed to see (and thus fetch) students?
          // - If private: only admins/instructors see students
          // - If not private: everyone sees students
          const includeStudents = isAdmin || isInstructor || !isPrivate;

          const classQueryFields = `
            Teacher { first_name last_name display_name profile_image unique_id id }
            ${
              includeStudents
                ? `
            Enrolments { Student { first_name last_name display_name profile_image unique_id id } }`
                : ""
            }
          `;

          const getClassQuery = `
            query {
              getClasses(query: [{ where: { id: ${currentClassID} } }]) { ${classQueryFields} }
            }
          `;

          const getAdminQuery = `
            query {
              getContact(query: [{ where: { email: "courses@writerscentre.com.au" } }]) {
                Display_Name: display_name
                Contact_ID: id
                Unique_ID: unique_id
                Profile_Image: profile_image
                Is_Instructor: is_instructor
                Is_Admin: is_admin
                Email: email
              }
            }
          `;

          const [classData, adminData] = await Promise.all([
            fetch(useGloballyAPIEndPointURLGraphQL, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Api-Key": useGloballyAPIKeyGraphQL,
              },
              body: JSON.stringify({ query: getClassQuery }),
            }).then((res) =>
              res.ok ? res.json() : Promise.reject("getClasses query failed")
            ),
            fetch(useGloballyAPIEndPointURLGraphQL, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Api-Key": useGloballyAPIKeyGraphQL,
              },
              body: JSON.stringify({ query: getAdminQuery }),
            }).then((res) =>
              res.ok ? res.json() : Promise.reject("getContact query failed")
            ),
          ]);

          const contacts = [];
          const result = classData?.data?.getClasses?.[0];

          if (result?.Teacher?.display_name?.trim()) {
            contacts.push({
              key: result.Teacher.display_name,
              value: result.Teacher.display_name,
              name: result.Teacher.display_name,
              id: result.Teacher.id,
              uniqueId: result.Teacher.unique_id,
              profileImage: result.Teacher.profile_image,
              isAdmin: false,
              isInstructor: true,
            });
          }

          // Only push students if the visitor is admin or instructor
          if (includeStudents) {
            (result?.Enrolments || []).forEach(({ Student }) => {
              if (Student?.display_name?.trim()) {
                contacts.push({
                  key: Student.display_name,
                  value: Student.display_name,
                  name: Student.display_name,
                  id: Student.id,
                  uniqueId: Student.unique_id,
                  profileImage: Student.profile_image,
                  isAdmin: false,
                  isInstructor: false,
                });
              }
            });
          }

          const admin = adminData?.data?.getContact;
          if (admin?.Display_Name?.trim()) {
            contacts.push({
              key: admin.Display_Name,
              value: admin.Display_Name,
              name: admin.Display_Name,
              id: admin.Contact_ID,
              uniqueId: admin.Unique_ID,
              profileImage: admin.Profile_Image,
              isAdmin: true,
              isInstructor: admin.Is_Instructor,
            });
          }

          NewMentionManager.allContacts = contacts;
          NewMentionManager._contactsLoaded = true;
        } catch (e) {
          console.error("NewMentionManager.initContacts failed", e);
        }
      })();

      return NewMentionManager._contactsPromise;
    }

    // 2) Tribute values provider â€” waits for contacts if needed (prevents empty menus)
    static fetchMentionContacts(text, cb) {
      const run = () => {
        const searchText = (text || "").toLowerCase();
        const filtered = NewMentionManager.allContacts.filter((c) =>
          (c.value || "").toLowerCase().includes(searchText)
        );
        cb(filtered);
      };

      if (NewMentionManager._contactsLoaded) return run();

      NewMentionManager.initContacts()
        .then(() => run())
        .catch(() => run()); // fallback: use whatever we have
    }

    // 3) Attach Tribute to a single editor (idempotent via data-tribute-attached)
    static initEditor(editor) {
      if (!editor || editor.nodeType !== 1) return;
      if (editor.hasAttribute("data-tribute-attached")) return;

      try {
        const tribute = new Tribute({
          trigger: "@",
          allowSpaces: true,
          lookup: "name",
          values:
            NewMentionManager.fetchMentionContacts.bind(NewMentionManager),
          menuItemTemplate: NewMentionManager.mentionTemplate,
          selectTemplate: NewMentionManager.selectTemplate,
          menuContainer: document.body,
        });
        tribute.attach(editor);
        editor.setAttribute("data-tribute-attached", "true");

        // Lightweight placeholder UX (optional, matches your previous behavior)
        NewMentionManager._initPlaceholder(editor);
      } catch (e) {
        console.error("initEditor failed", e);
      }
    }

    // 4) Initialize all current editors within a root
    static ensureEditors(root = document) {
      try {
        const editors = root.querySelectorAll?.(".mentionable");
        editors?.forEach((ed) => NewMentionManager.initEditor(ed));
      } catch (e) {
        console.error("ensureEditors failed", e);
      }
    }

    // 5) Auto-init future editors via MutationObserver
    static observe(root = document) {
      try {
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((m) => {
            m.addedNodes.forEach((node) => {
              if (node?.nodeType !== 1) return;
              if (node.matches?.(".mentionable")) {
                NewMentionManager.initEditor(node);
              }
              node
                .querySelectorAll?.(".mentionable")
                ?.forEach((ed) => NewMentionManager.initEditor(ed));
            });
          });
        });
        observer.observe(root, { childList: true, subtree: true });
      } catch (e) {
        console.error("observe failed", e);
      }
    }

    // --- Templates kept from your version ---
    static mentionTemplate(item) {
      const fallback =
        "https://files.ontraport.com/media/b0456fe87439430680b173369cc54cea.php03bzcx?Expires=4895186056&Signature=fw-mkSjms67rj5eIsiDF9QfHb4EAe29jfz~yn3XT0--8jLdK4OGkxWBZR9YHSh26ZAp5EHj~6g5CUUncgjztHHKU9c9ymvZYfSbPO9JGht~ZJnr2Gwmp6vsvIpYvE1pEywTeoigeyClFm1dHrS7VakQk9uYac4Sw0suU4MpRGYQPFB6w3HUw-eO5TvaOLabtuSlgdyGRie6Ve0R7kzU76uXDvlhhWGMZ7alNCTdS7txSgUOT8oL9pJP832UsasK4~M~Na0ku1oY-8a7GcvvVv6j7yE0V0COB9OP0FbC8z7eSdZ8r7avFK~f9Wl0SEfS6MkPQR2YwWjr55bbJJhZnZA__&Key-Pair-Id=APKAJVAAMVW6XQYWSTNA";
      const src =
        item.original.profileImage &&
        item.original.profileImage !== "https://i.ontraport.com/abc.jpg"
          ? item.original.profileImage
          : fallback;

      const role = item.original.isAdmin
        ? " (Admin)"
        : item.original.isInstructor
        ? " (Teacher)"
        : "";

      return `
        <div class="flex items-center gap-3 px-3 py-2">
          <img class="w-6 h-6 rounded-full border border-[#d3d3d3]" src="${src}" alt="${item.original.name}'s Profile Image" />
          <div class="text-primary">${item.original.name}${role}</div>
        </div>`;
    }

    static selectTemplate(item) {
      return `<span class="mention" data-mention-id="${item.original.uniqueId}" data-contact-id="${item.original.id}">@${item.original.value}</span>`;
    }

    // --- Small helper: placeholder behavior for empty editors ---
    static _initPlaceholder(editor) {
      if (editor.hasAttribute("data-placeholder-initialized")) return;

      const setPlaceholder = () => {
        if (
          !editor.textContent.trim() &&
          !editor.querySelector(".mention-placeholder")
        ) {
          const span = document.createElement("span");
          span.className =
            "mention-placeholder text-[#586a80] text-base font-normal leading-normal pointer-events-none select-none";
          span.innerHTML = "Type @ to mention members";
          editor.appendChild(span);
        }
      };

      editor.addEventListener("focus", () => {
        const ph = editor.querySelector(".mention-placeholder");
        if (ph) ph.remove();
      });

      editor.addEventListener("blur", () => {
        setTimeout(setPlaceholder, 10);
      });

      setPlaceholder();
      editor.setAttribute("data-placeholder-initialized", "true");
    }
  }

  // ---- Single, simple bootstrapping (replaces your jQuery & setTimeout init) ----
  document.addEventListener("DOMContentLoaded", () => {
    try {
      NewMentionManager.initContacts();
    } catch (_) {}
    NewMentionManager.ensureEditors(document);
    NewMentionManager.observe(document);
  });
</script>
